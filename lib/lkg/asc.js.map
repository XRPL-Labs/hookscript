
{
  "version": 3,
  "sources": ["../util/browser/fs.js", "../util/browser/module.js", "../util/browser/process.js", "../util/browser/path.js", "../util/browser/url.js", "../cli/index.js", "../util/node.js", "../util/terminal.js", "../node_modules/diff/lib/index.mjs", "../util/text.js", "../util/options.js", "../cli/index.generated.js", "../lib/binaryen.js", "../src/index-js.ts", "../std/portable/index.js", "../lib/binaryen.js", "../src/glue/binaryen.js", "../src/glue/js/float.js", "../src/glue/js/i64.js", "../src/glue/js/collections.js", "../std/assembly/shared/feature.ts", "../std/assembly/shared/target.ts", "../std/assembly/shared/runtime.ts", "../std/assembly/shared/typeinfo.ts", "../src/common.ts", "../src/diagnosticMessages.generated", "../src/util.ts", "../src/util/binary.ts", "../src/util/collections.ts", "../src/util/math.ts", "../src/util/text.ts", "../src/util/path.ts", "../src/util/terminal.ts", "../src/util/vector.ts", "../src/diagnostics.ts", "../src/ast.ts", "../src/tokenizer.ts", "../src/module.ts", "../src/flow.ts", "../src/resolver.ts", "../src/parser.ts", "../src/program.ts", "../src/types.ts", "../src/builtins.ts", "../src/passes/pass.ts", "../src/passes/rtrace.ts", "../src/passes/shadowstack.ts", "../src/bindings/util.ts", "../src/bindings/js.ts", "../src/compiler.ts", "../src/bindings/tsd.ts", "../src/index-wasm.ts", "../src/extra/ast.ts", "../src/index.ts"],
  "sourcesContent": ["export const promises = {};\n", "export function createRequire() {\n  return function require(path) {\n    throw new Error(`Cannot find module: '${path}'`);\n  };\n}\n", "export const platform = \"linux\";\n\nexport function cwd() {\n  return \".\";\n}\n\nexport function umask() {\n  return 0;\n}\n\nexport const argv = [];\n\nexport function exit(code = 0) {\n  throw Error(`exit ${code}`);\n}\n\n// https://github.com/kumavis/browser-process-hrtime v1.0.0\n//\n// Copyright 2014 kumavis\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n// this list of conditions and the following disclaimer in the documentation\n// and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nvar performance = globalThis.performance || {};\nvar performanceNow = performance.now || function() { return new Date().getTime(); };\n\nexport function hrtime(previousTimestamp) {\n  var clocktime = performanceNow.call(performance);\n  var seconds = Math.floor(clocktime * 1e-3);\n  var nanoseconds = Math.floor(clocktime * 1e6 - seconds * 1e9);\n  if (previousTimestamp) {\n    seconds -= previousTimestamp[0];\n    nanoseconds -= previousTimestamp[1];\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [ seconds, nanoseconds ];\n}\n", "import * as process from \"./process.js\";\n\n// https://github.com/browserify/path-browserify v1.0.1\n//\n// Copyright (c) 2013 James Halliday\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\n// path.resolve([from ...], to)\nexport function resolve() {\n  var resolvedPath = '';\n  var resolvedAbsolute = false;\n  var cwd;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path;\n    if (i >= 0)\n      path = arguments[i];\n    else {\n      if (cwd === undefined)\n        cwd = process.cwd();\n      path = cwd;\n    }\n\n    assertPath(path);\n\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0)\n      return '/' + resolvedPath;\n    else\n      return '/';\n  } else if (resolvedPath.length > 0) {\n    return resolvedPath;\n  } else {\n    return '.';\n  }\n}\n\nexport function normalize(path) {\n  assertPath(path);\n\n  if (path.length === 0) return '.';\n\n  var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n  var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n  // Normalize the path\n  path = normalizeStringPosix(path, !isAbsolute);\n\n  if (path.length === 0 && !isAbsolute) path = '.';\n  if (path.length > 0 && trailingSeparator) path += '/';\n\n  if (isAbsolute) return '/' + path;\n  return path;\n}\n\nexport function isAbsolute(path) {\n  assertPath(path);\n  return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n}\n\nexport function join() {\n  if (arguments.length === 0)\n    return '.';\n  var joined;\n  for (var i = 0; i < arguments.length; ++i) {\n    var arg = arguments[i];\n    assertPath(arg);\n    if (arg.length > 0) {\n      if (joined === undefined)\n        joined = arg;\n      else\n        joined += '/' + arg;\n    }\n  }\n  if (joined === undefined)\n    return '.';\n  return normalize(joined);\n}\n\nexport function relative(from, to) {\n  assertPath(from);\n  assertPath(to);\n\n  if (from === to) return '';\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return '';\n\n  if (from === \".\") return to; // FIX for 'odule.ts' (see issue #1398)\n\n  // Trim any leading backslashes\n  var fromStart = 1;\n  for (; fromStart < from.length; ++fromStart) {\n    if (from.charCodeAt(fromStart) !== 47 /*/*/)\n      break;\n  }\n  var fromEnd = from.length;\n  var fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  var toStart = 1;\n  for (; toStart < to.length; ++toStart) {\n    if (to.charCodeAt(toStart) !== 47 /*/*/)\n      break;\n  }\n  var toEnd = to.length;\n  var toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  var length = fromLen < toLen ? fromLen : toLen;\n  var lastCommonSep = -1;\n  var i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        } else if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n      break;\n    }\n    var fromCode = from.charCodeAt(fromStart + i);\n    var toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode)\n      break;\n    else if (fromCode === 47 /*/*/)\n      lastCommonSep = i;\n  }\n\n  var out = '';\n  // Generate the relative path based on the path difference between `to`\n  // and `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n      if (out.length === 0)\n        out += '..';\n      else\n        out += '/..';\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0)\n    return out + to.slice(toStart + lastCommonSep);\n  else {\n    toStart += lastCommonSep;\n    if (to.charCodeAt(toStart) === 47 /*/*/)\n      ++toStart;\n    return to.slice(toStart);\n  }\n}\n\nexport function dirname(path) {\n  assertPath(path);\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) return '//';\n  return path.slice(0, end);\n}\n\nexport function basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n  assertPath(path);\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n    if (ext.length === path.length && ext === path) return '';\n    var extIdx = ext.length - 1;\n    var firstNonSlashEnd = -1;\n    for (i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          // We saw the first non-path separator, remember this index in case\n          // we need it if the extension ends up not matching\n          matchedSlash = false;\n          firstNonSlashEnd = i + 1;\n        }\n        if (extIdx >= 0) {\n          // Try to match the explicit extension\n          if (code === ext.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              // We matched the extension, so mark this as the end of our path\n              // component\n              end = i;\n            }\n          } else {\n            // Extension does not match, so our result is the entire path\n            // component\n            extIdx = -1;\n            end = firstNonSlashEnd;\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n    return path.slice(start, end);\n  } else {\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) return '';\n    return path.slice(start, end);\n  }\n}\n\nexport function extname(path) {\n  assertPath(path);\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1)\n        startDot = i;\n      else if (preDotState !== 1)\n        preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n}\n\nexport function format(pathObject) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n  }\n  return _format('/', pathObject);\n}\n\nexport function parse(path) {\n  assertPath(path);\n\n  var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n  if (path.length === 0) return ret;\n  var code = path.charCodeAt(0);\n  var isAbsolute = code === 47 /*/*/;\n  var start;\n  if (isAbsolute) {\n    ret.root = '/';\n    start = 1;\n  } else {\n    start = 0;\n  }\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= start; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n  // We saw a non-dot character immediately before the dot\n  preDotState === 0 ||\n  // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    if (end !== -1) {\n      if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n    }\n  } else {\n    if (startPart === 0 && isAbsolute) {\n      ret.name = path.slice(1, startDot);\n      ret.base = path.slice(1, end);\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n    }\n    ret.ext = path.slice(startDot, end);\n  }\n\n  if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n  return ret;\n}\n\nexport const sep = '/';\nexport const delimiter = ':';\nexport const win32 = null;\n", "import * as path from \"./path.js\";\n\nfunction encodePathChars(filepath) {\n  return filepath\n    .replace(/%/g, \"%25\")\n    .replace(/\\\\/g, \"%5C\")\n    .replace(/\\n/g, \"%0A\")\n    .replace(/\\r/g, \"%0D\")\n    .replace(/\\t/g, \"%09\");\n}\n\nexport function pathToFileURL(filepath) {\n  let resolved = path.resolve(filepath);\n  if (\n    filepath.charCodeAt(filepath.length - 1) === /* SLASH */ 47 &&\n    resolved[resolved.length - 1] !== path.sep\n  ) {\n    resolved += \"/\";\n  }\n  const url = new URL(\"file://\");\n  url.pathname = encodePathChars(resolved);\n  return url;\n}\n", "/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Compiler frontend for node.js\n *\n * Uses the low-level API exported from src/index.ts so it works with the compiler compiled to\n * JavaScript as well as the compiler compiled to WebAssembly (eventually).\n *\n * Can also be packaged as a bundle suitable for in-browser use with the standard library injected\n * in the build step. See dist/asc.js for the bundle.\n */\n\nimport { fs, module, path, process, url } from \"../util/node.js\";\nimport { Colors } from \"../util/terminal.js\";\nimport { utf8 } from \"../util/text.js\";\nimport * as optionsUtil from \"../util/options.js\";\nimport * as generated from \"./index.generated.js\";\n\nimport binaryen from \"../lib/binaryen.js\";\nimport * as assemblyscriptJS from \"../dist/assemblyscript.js\";\n\n// Use the TS->JS variant by default\nlet assemblyscript = assemblyscriptJS;\n\n// Use the AS->Wasm variant as an option (experimental)\nconst wasmPos = process.argv.indexOf(\"--wasm\");\nif (~wasmPos) {\n  const wasmPath = String(process.argv[wasmPos + 1]);\n  process.argv.splice(wasmPos, 2);\n  assemblyscript = await import(new URL(wasmPath, url.pathToFileURL(process.cwd() + \"/\")));\n}\n\nconst require = module.createRequire ? module.createRequire(import.meta.url): {};\n\nconst WIN = process.platform === \"win32\";\nconst EOL = WIN ? \"\\r\\n\" : \"\\n\";\nconst SEP = WIN ? \"\\\\\"   : \"/\";\n\nconst extension = \".ts\";\nconst extension_d = `.d${extension}`;\nconst extension_re = new RegExp(\"\\\\\" + extension + \"$\");\nconst extension_re_except_d = new RegExp(\"^(?!.*\\\\.d\\\\\" + extension + \"$).*\\\\\" + extension + \"$\");\n\nfunction toUpperSnakeCase(str) {\n  return str.replace(/-/g, \"_\").toUpperCase();\n}\n\nfunction isNonEmptyString(value) {\n  return typeof value === \"string\" && value !== \"\";\n}\n\n/** Ensures that an object is a wrapper class instead of just a pointer. */\n// function __wrap(ptrOrObj, wrapperClass) {\n//   if (typeof ptrOrObj === \"number\") {\n//     return ptrOrObj === 0 ? null : wrapperClass.wrap(ptrOrObj);\n//   }\n//   return ptrOrObj;\n// }\n\n/** AssemblyScript version. */\nexport const version = generated.version;\n\n/** Available CLI options. */\nexport const options = generated.options;\n\n/** Prefix used for library files. */\nexport const libraryPrefix = generated.libraryPrefix;\n\n/** Bundled library files. */\nexport const libraryFiles = generated.libraryFiles;\n\n/** Bundled definition files. */\nexport const definitionFiles = generated.definitionFiles;\n\n/** Default Binaryen optimization level. */\nexport const defaultOptimizeLevel = 3;\n\n/** Default Binaryen shrink level. */\nexport const defaultShrinkLevel = 0;\n\n/** Converts a configuration object to an arguments array. */\nexport function configToArguments(options, argv = []) {\n  Object.keys(options || {}).forEach(key => {\n    const val = options[key];\n    const opt = generated.options[key];\n    if (opt && opt.type === \"b\") {\n      if (val) argv.push(`--${key}`);\n    } else {\n      if (Array.isArray(val)) {\n        val.forEach(val => { argv.push(`--${key}`, String(val)); });\n      }\n      else argv.push(`--${key}`, String(val));\n    }\n  });\n  return argv;\n}\n\n/** Convenience function that parses and compiles source strings directly. */\nexport async function compileString(sources, config = {}) {\n  if (typeof sources === \"string\") sources = { [`input${extension}`]: sources };\n  let argv = [\n    \"--outFile\", \"binary\",\n    \"--textFile\", \"text\",\n  ];\n  configToArguments(config, argv);\n  const output = {};\n  const result = await main(argv.concat(Object.keys(sources)), {\n    readFile: name => Object.prototype.hasOwnProperty.call(sources, name) ? sources[name] : null,\n    writeFile: (name, contents) => { output[name] = contents; },\n    listFiles: () => []\n  });\n  return Object.assign(result, output);\n}\n\n/** Runs the command line utility using the specified arguments array. */\nexport async function main(argv, options) {\n  if (!Array.isArray(argv)) argv = configToArguments(argv);\n  if (!options) options = {};\n\n  const stats = options.stats || new Stats();\n  const statsBegin = stats.begin();\n\n  // Bundle semantic version\n  let bundleMinorVersion = 0, bundleMajorVersion = 0, bundlePatchVersion = 0;\n  const versionParts = (version || \"\").split(\".\");\n  if (versionParts.length === 3) {\n    bundleMajorVersion = parseInt(versionParts[0]) | 0;\n    bundleMinorVersion = parseInt(versionParts[1]) | 0;\n    bundlePatchVersion = parseInt(versionParts[2]) | 0;\n  }\n\n  const stdout = options.stdout || createMemoryStream();\n  const stderr = options.stderr || createMemoryStream();\n  const readFile = options.readFile || readFileNode;\n  const writeFile = options.writeFile || writeFileNode;\n  const listFiles = options.listFiles || listFilesNode;\n\n  // Parse command line options but do not populate option defaults yet\n  const optionsResult = optionsUtil.parse(argv, generated.options, false);\n  let opts = optionsResult.options;\n  argv = optionsResult.arguments;\n\n  const stdoutColors = new Colors(stdout);\n  const stderrColors = new Colors(stderr);\n  if (opts.noColors) {\n    stdoutColors.enabled = false;\n    stderrColors.enabled = false;\n  }\n\n  // Check for unknown options\n  const unknownOpts = optionsResult.unknown;\n  if (unknownOpts.length) {\n    unknownOpts.forEach(arg => {\n      stderr.write(\n        `${stderrColors.yellow(\"WARNING \")}Unknown option '${arg}'${EOL}`\n      );\n    });\n  }\n\n  // Check for trailing arguments\n  const trailingArgv = optionsResult.trailing;\n  if (trailingArgv.length) {\n    stderr.write(\n      `${stderrColors.yellow(\"WARNING \")}Unsupported trailing arguments: ${trailingArgv.join(\" \")}${EOL}`\n    );\n  }\n\n  let module = null;\n  let binaryenModule = null;\n\n  // Prepares the result object\n  let prepareResult = (error, result = {}) => {\n    if (error) {\n      stderr.write(`${stderrColors.red(\"FAILURE \")}${error.stack.replace(/^ERROR: /i, \"\")}${EOL}`);\n    }\n    if (binaryenModule) binaryenModule.dispose();\n    if (!stats.total) stats.total = stats.end(statsBegin);\n    return Object.assign({ error, stdout, stderr, stats }, result);\n  };\n\n  // Just print the version if requested\n  if (opts.version) {\n    stdout.write(`Version ${version}${EOL}`);\n    return prepareResult(null);\n  }\n\n  // Set up base directory\n  const baseDir = path.normalize(opts.baseDir || \".\");\n\n  // Check if a config file is present\n  let configPath = optionsUtil.resolvePath(opts.config || \"asconfig.json\", baseDir);\n  let configFile = path.basename(configPath);\n  let configDir = path.dirname(configPath);\n  let config = await getConfig(configFile, configDir, readFile);\n  let configHasEntries = config != null && Array.isArray(config.entries) && config.entries.length;\n\n  // Print the help message if requested or no source files are provided\n  if (opts.help || (!argv.length && !configHasEntries)) {\n    let out = opts.help ? stdout : stderr;\n    let colors = opts.help ? stdoutColors : stderrColors;\n    out.write([\n      colors.white(\"SYNTAX\"),\n      \"  \" + colors.cyan(\"asc\") + \" [entryFile ...] [options]\",\n      \"\",\n      colors.white(\"EXAMPLES\"),\n      \"  \" + colors.cyan(\"asc\") + \" hello\" + extension,\n      \"  \" + colors.cyan(\"asc\") + \" hello\" + extension + \" -o hello.wasm -t hello.wat\",\n      \"  \" + colors.cyan(\"asc\") + \" hello1\" + extension + \" hello2\" + extension + \" -o -O > hello.wasm\",\n      \"  \" + colors.cyan(\"asc\") + \" --config asconfig.json --target release\",\n      \"\",\n      colors.white(\"OPTIONS\"),\n    ].concat(\n      optionsUtil.help(generated.options, 24, EOL)\n    ).join(EOL) + EOL);\n    return prepareResult(null);\n  }\n\n  // I/O must be specified if not present in the environment\n  if (!(fs.promises && fs.promises.readFile)) {\n    if (readFile === readFileNode)   throw Error(\"'options.readFile' must be specified\");\n    if (writeFile === writeFileNode) throw Error(\"'options.writeFile' must be specified\");\n    if (listFiles === listFilesNode) throw Error(\"'options.listFiles' must be specified\");\n  }\n\n  // Load additional options from asconfig.json\n  const seenAsconfig = new Set();\n  seenAsconfig.add(configPath);\n  const target = opts.target || \"release\";\n  while (config) {\n    // Merge target first\n    if (config.targets) {\n      const targetOptions = config.targets[target];\n      if (targetOptions) {\n        opts = optionsUtil.merge(generated.options, opts, targetOptions, configDir);\n      }\n    }\n    // Merge general options\n    const generalOptions = config.options;\n    if (generalOptions) {\n      opts = optionsUtil.merge(generated.options, opts, generalOptions, configDir);\n    }\n\n    // Append entries\n    if (config.entries) {\n      for (let entry of config.entries) {\n        argv.push(optionsUtil.resolvePath(entry, configDir));\n      }\n    }\n\n    // Look up extended asconfig and repeat\n    if (config.extends) {\n      configPath = optionsUtil.resolvePath(config.extends, configDir, true);\n      configFile = path.basename(configPath);\n      configDir = path.dirname(configPath);\n      if (seenAsconfig.has(configPath)) break;\n      seenAsconfig.add(configPath);\n      config = await getConfig(configFile, configDir, readFile);\n    } else {\n      break;\n    }\n  }\n\n  // Populate option defaults once user-defined options are set\n  optionsUtil.addDefaults(generated.options, opts);\n\n  // If showConfig print options and exit\n  if (opts.showConfig) {\n    stderr.write(JSON.stringify({\n      options: opts,\n      entries: argv\n    }, null, 2));\n    return prepareResult(null);\n  }\n\n  // create a unique set of values\n  function unique(values) {\n    return [...new Set(values)];\n  }\n\n  // Set up options\n  let program, runtime;\n  const compilerOptions = assemblyscript.newOptions();\n  switch (opts.runtime) {\n    case \"stub\": runtime = 0; break;\n    case \"minimal\": runtime = 1; break;\n    /* incremental */\n    default: runtime = 2; break;\n  }\n  assemblyscript.setTarget(compilerOptions, 0);\n  assemblyscript.setDebugInfo(compilerOptions, !!opts.debug);\n  assemblyscript.setRuntime(compilerOptions, runtime);\n  assemblyscript.setNoAssert(compilerOptions, opts.noAssert);\n  assemblyscript.setExportMemory(compilerOptions, !opts.noExportMemory);\n  assemblyscript.setImportMemory(compilerOptions, opts.importMemory);\n  assemblyscript.setInitialMemory(compilerOptions, opts.initialMemory >>> 0);\n  assemblyscript.setMaximumMemory(compilerOptions, opts.maximumMemory >>> 0);\n  assemblyscript.setSharedMemory(compilerOptions, opts.sharedMemory);\n  assemblyscript.setImportTable(compilerOptions, opts.importTable);\n  assemblyscript.setExportTable(compilerOptions, opts.exportTable);\n  if (opts.exportStart != null) {\n    assemblyscript.setExportStart(compilerOptions, isNonEmptyString(opts.exportStart) ? opts.exportStart : \"_start\");\n  }\n  assemblyscript.setMemoryBase(compilerOptions, opts.memoryBase >>> 0);\n  assemblyscript.setTableBase(compilerOptions, opts.tableBase >>> 0);\n  assemblyscript.setSourceMap(compilerOptions, opts.sourceMap != null);\n  assemblyscript.setNoUnsafe(compilerOptions, opts.noUnsafe);\n  assemblyscript.setPedantic(compilerOptions, opts.pedantic);\n  assemblyscript.setLowMemoryLimit(compilerOptions, opts.lowMemoryLimit >>> 0);\n  assemblyscript.setExportRuntime(compilerOptions, opts.exportRuntime);\n  assemblyscript.setBundleVersion(compilerOptions, bundleMajorVersion, bundleMinorVersion, bundlePatchVersion);\n  if (!opts.stackSize && runtime === 2 /* incremental */) {\n    opts.stackSize = assemblyscript.DEFAULT_STACK_SIZE;\n  }\n  assemblyscript.setStackSize(compilerOptions, opts.stackSize);\n  assemblyscript.setBindingsHint(compilerOptions, opts.bindings && opts.bindings.length > 0);\n\n  // Instrument callback to perform GC\n  // prepareResult = (original => {\n  //   return function gcBeforePrepareResult(err) {\n  //     __unpin(compilerOptions);\n  //     if (program) __unpin(program);\n  //     __collect();\n  //     return original(err);\n  //   };\n  // })(prepareResult);\n\n  // Add or override aliases if specified\n  if (opts.use) {\n    let aliases = opts.use;\n    for (let i = 0, k = aliases.length; i < k; ++i) {\n      let part = aliases[i];\n      let p = part.indexOf(\"=\");\n      if (p < 0) return prepareResult(Error(`Global alias '${part}' is invalid.`));\n      let alias = part.substring(0, p).trim();\n      let name = part.substring(p + 1).trim();\n      if (!alias.length) {\n        return prepareResult(Error(`Global alias '${part}' is invalid.`));\n      }\n      assemblyscript.addGlobalAlias(compilerOptions, alias, name);\n    }\n  }\n\n  // Disable default features if specified\n  let features;\n  if ((features = opts.disable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[`FEATURE_${toUpperSnakeCase(name)}`];\n      if (!flag) return prepareResult(Error(`Feature '${name}' is unknown.`));\n      assemblyscript.disableFeature(compilerOptions, flag);\n    }\n  }\n\n  // Enable experimental features if specified\n  if ((features = opts.enable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[`FEATURE_${toUpperSnakeCase(name)}`];\n      if (!flag) return prepareResult(Error(`Feature '${name}' is unknown.`));\n      assemblyscript.enableFeature(compilerOptions, flag);\n    }\n  }\n\n  // Set up optimization levels\n  let optimizeLevel = 0;\n  let shrinkLevel = 0;\n  if (opts.optimize) {\n    optimizeLevel = defaultOptimizeLevel;\n    shrinkLevel = defaultShrinkLevel;\n  }\n  if (typeof opts.optimizeLevel === \"number\") optimizeLevel = opts.optimizeLevel;\n  if (typeof opts.shrinkLevel === \"number\") shrinkLevel = opts.shrinkLevel;\n  optimizeLevel = Math.min(Math.max(optimizeLevel, 0), 3);\n  shrinkLevel = Math.min(Math.max(shrinkLevel, 0), 2);\n  assemblyscript.setOptimizeLevelHints(compilerOptions, optimizeLevel, shrinkLevel);\n\n  // Initialize the program\n  program = assemblyscript.newProgram(compilerOptions);\n\n  // Collect transforms *constructors* from the `--transform` CLI flag as well\n  // as the `transform` option into the `transforms` array.\n  let transforms = [];\n  // `transform` option from `main()`\n  if (Array.isArray(options.transforms)) {\n    transforms.push(...options.transforms);\n  }\n  // `--transform` CLI flag\n  if (opts.transform) {\n    let transformArgs = unique(opts.transform);\n    for (let i = 0, k = transformArgs.length; i < k; ++i) {\n      let filename = transformArgs[i].trim();\n      let resolved;\n      let transform;\n      if (require.resolve) {\n        try {\n          resolved = require.resolve(filename, { paths: [process.cwd(), baseDir] });\n          transform = await import(url.pathToFileURL(resolved));\n          if (transform.default) transform = transform.default;\n        } catch (e1) {\n          try {\n            transform = require(resolved);\n          } catch (e2) {\n            return prepareResult(e1);\n          }\n        }\n      } else {\n        try {\n          transform = await import(new URL(filename, import.meta.url));\n          if (transform.default) transform = transform.default;\n        } catch (e) {\n          return prepareResult(e);\n        }\n      }\n      if (!transform || (typeof transform !== \"function\" && typeof transform !== \"object\")) {\n        return prepareResult(Error(\"not a transform: \" + transformArgs[i]));\n      }\n      transforms.push(transform);\n    }\n  }\n\n  // Fix up the prototype of the transforms\u2019 constructors and instantiate them.\n  try {\n    transforms = transforms.map(transform => {\n      if (typeof transform === \"function\") {\n        Object.assign(transform.prototype, {\n          program,\n          baseDir,\n          stdout,\n          stderr,\n          log: console.error,\n          readFile,\n          writeFile,\n          listFiles\n        });\n        transform = new transform();\n      }\n      return transform;\n    });\n  } catch (e) {\n    return prepareResult(e);\n  }\n\n  async function applyTransform(name, ...args) {\n    for (let i = 0, k = transforms.length; i < k; ++i) {\n      let transform = transforms[i];\n      if (typeof transform[name] === \"function\") {\n        try {\n          let start = stats.begin();\n          stats.transformCount++;\n          await transform[name](...args);\n          stats.transformTime += stats.end(start);\n        } catch (e) {\n          return e;\n        }\n      }\n    }\n  }\n\n  // Parse library files\n  Object.keys(libraryFiles).forEach(libPath => {\n    if (libPath.includes(\"/\")) return; // in sub-directory: imported on demand\n    let begin = stats.begin();\n    stats.parseCount++;\n    assemblyscript.parse(program, libraryFiles[libPath], libraryPrefix + libPath + extension, false);\n    stats.parseTime += stats.end(begin);\n  });\n  let customLibDirs = [];\n  if (opts.lib) {\n    let lib = opts.lib;\n    if (typeof lib === \"string\") lib = lib.split(\",\");\n    customLibDirs.push(...lib.map(p => p.trim()));\n    customLibDirs = unique(customLibDirs); // `lib` and `customLibDirs` may include duplicates\n    for (let i = 0, k = customLibDirs.length; i < k; ++i) { // custom\n      let libDir = customLibDirs[i];\n      let libFiles;\n      if (libDir.endsWith(extension)) {\n        libFiles = [ path.basename(libDir) ];\n        libDir = path.dirname(libDir);\n      } else {\n        libFiles = await listFiles(libDir, baseDir) || [];\n      }\n      for (let libPath of libFiles) {\n        let libText = await readFile(libPath, libDir);\n        if (libText == null) {\n          return prepareResult(Error(`Library file '${libPath}' not found.`));\n        }\n        libraryFiles[libPath.replace(extension_re, \"\")] = libText;\n        let begin = stats.begin();\n        stats.parseCount++;\n        assemblyscript.parse(program, libText, libraryPrefix + libPath, false);\n        stats.parseTime += stats.end(begin);\n      }\n    }\n  }\n  opts.path = opts.path || [];\n\n  // Maps package names to parent directory\n  const packageBases = new Map();\n\n  // Gets the file matching the specified source path, imported at the given dependee path\n  async function getFile(internalPath, dependeePath) {\n    let sourceText = null; // text reported back to the compiler\n    let sourcePath = null; // path reported back to the compiler\n\n    // Try file.ext, file/index.ext, file.d.ext\n    if (!internalPath.startsWith(libraryPrefix)) {\n      if ((sourceText = await readFile(sourcePath = internalPath + extension, baseDir)) == null) {\n        if ((sourceText = await readFile(sourcePath = internalPath + \"/index\" + extension, baseDir)) == null) {\n          // portable d.ext: uses the .js file next to it in JS or becomes an import in Wasm\n          sourcePath = internalPath + extension;\n          sourceText = await readFile(internalPath + extension_d, baseDir);\n        }\n      }\n\n    // Search library in this order: stdlib, custom lib dirs, paths\n    } else {\n      const plainName = internalPath.substring(libraryPrefix.length);\n      const indexName = `${plainName}/index`;\n      if (Object.prototype.hasOwnProperty.call(libraryFiles, plainName)) {\n        sourceText = libraryFiles[plainName];\n        sourcePath = libraryPrefix + plainName + extension;\n      } else if (Object.prototype.hasOwnProperty.call(libraryFiles, indexName)) {\n        sourceText = libraryFiles[indexName];\n        sourcePath = libraryPrefix + indexName + extension;\n      } else { // custom lib dirs\n        for (const libDir of customLibDirs) {\n          if ((sourceText = await readFile(plainName + extension, libDir)) != null) {\n            sourcePath = libraryPrefix + plainName + extension;\n            break;\n          } else {\n            if ((sourceText = await readFile(indexName + extension, libDir)) != null) {\n              sourcePath = libraryPrefix + indexName + extension;\n              break;\n            }\n          }\n        }\n        if (sourceText == null) { // paths\n          const match = internalPath.match(/^~lib\\/((?:@[^/]+\\/)?[^/]+)(?:\\/(.+))?/); // ~lib/(pkg)/(path), ~lib/(@org/pkg)/(path)\n          if (match) {\n            const packageName = match[1];\n            const filePath = match[2] || \"index\";\n            const basePath = packageBases.has(dependeePath) ? packageBases.get(dependeePath) : \".\";\n            const paths = [];\n            const parts = path.resolve(baseDir, basePath).split(SEP);\n            for (let i = parts.length, k = WIN ? 1 : 0; i >= k; --i) {\n              if (parts[i - 1] !== \"node_modules\") {\n                paths.push(`${parts.slice(0, i).join(SEP)}${SEP}node_modules`);\n              }\n            }\n            paths.push(...opts.path);\n            for (const currentDir of paths.map(p => path.relative(baseDir, p))) {\n              const plainName = filePath;\n              if ((sourceText = await readFile(path.join(currentDir, packageName, plainName + extension), baseDir)) != null) {\n                sourcePath = `${libraryPrefix}${packageName}/${plainName}${extension}`;\n                packageBases.set(sourcePath.replace(extension_re, \"\"), path.join(currentDir, packageName));\n                break;\n              }\n              const indexName = `${filePath}/index`;\n              if ((sourceText = await readFile(path.join(currentDir, packageName, indexName + extension), baseDir)) != null) {\n                sourcePath = `${libraryPrefix}${packageName}/${indexName}${extension}`;\n                packageBases.set(sourcePath.replace(extension_re, \"\"), path.join(currentDir, packageName));\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    // No such file\n    if (sourceText == null) return null;\n    return { sourceText, sourcePath };\n  }\n\n  // Gets all pending imported files from the the backlog\n  function getBacklog(paths = []) {\n    do {\n      let internalPath = assemblyscript.nextFile(program);\n      if (internalPath == null) break;\n      paths.push(internalPath);\n    } while (true);\n    return paths;\n  }\n\n  // Parses the backlog of imported files after including entry files\n  async function parseBacklog() {\n    let backlog;\n    while ((backlog = getBacklog()).length) {\n      let files = [];\n      for (let internalPath of backlog) {\n        const dependee = assemblyscript.getDependee(program, internalPath);\n        files.push(getFile(internalPath, dependee)); // queue\n      }\n      files = await Promise.all(files); // parallel\n      for (let i = 0, k = backlog.length; i < k; ++i) {\n        const internalPath = backlog[i];\n        const file = files[i];\n        const begin = stats.begin();\n        stats.parseCount++;\n        if (file) {\n          assemblyscript.parse(program, file.sourceText, file.sourcePath, false);\n        } else {\n          assemblyscript.parse(program, null, internalPath + extension, false);\n        }\n        stats.parseTime += stats.end(begin);\n      }\n    }\n    const numErrors = checkDiagnostics(program, stderr, opts.disableWarning, options.reportDiagnostic, stderrColors.enabled);\n    if (numErrors) {\n      const err = Error(`${numErrors} parse error(s)`);\n      err.stack = err.message; // omit stack\n      return prepareResult(err);\n    }\n  }\n\n  // Include runtime before entry files so its setup runs first\n  {\n    let runtimeName = String(opts.runtime);\n    let runtimePath = `rt/index-${runtimeName}`;\n    let runtimeText = libraryFiles[runtimePath];\n    if (runtimeText == null) {\n      runtimePath = runtimeName;\n      runtimeText = await readFile(runtimePath + extension, baseDir);\n      if (runtimeText == null) return prepareResult(Error(`Runtime '${path.resolve(baseDir, runtimePath + extension)}' is not found.`));\n    } else {\n      runtimePath = `~lib/${runtimePath}`;\n    }\n    let begin = stats.begin();\n    stats.parseCount++;\n    assemblyscript.parse(program, runtimeText, runtimePath + extension, true);\n    stats.parseTime += stats.end(begin);\n  }\n\n  // Include entry files\n  for (let i = 0, k = argv.length; i < k; ++i) {\n    const filename = String(argv[i]);\n\n    // Setting the path to relative path\n    let sourcePath = path.isAbsolute(filename)\n      ? path.relative(baseDir, filename)\n      : path.normalize(filename);\n\n    sourcePath = sourcePath\n      .replace(/\\\\/g, \"/\")\n      .replace(extension_re, \"\")\n      .replace(/\\/$/, \"\");\n    \n    // Try entryPath.ext, then entryPath/index.ext\n    let sourceText = await readFile(sourcePath + extension, baseDir);\n    if (sourceText == null) {\n      const path = `${sourcePath}/index${extension}`;\n      sourceText = await readFile(path, baseDir);\n      if (sourceText != null) sourcePath = path;\n      else sourcePath += extension;\n    } else {\n      sourcePath += extension;\n    }\n\n    let begin = stats.begin();\n    stats.parseCount++;\n    assemblyscript.parse(program, sourceText, sourcePath, true);\n    stats.parseTime += stats.end(begin);\n  }\n\n  // Parse entry files\n  {\n    let code = await parseBacklog();\n    if (code) return code;\n  }\n\n  // Call afterParse transform hook\n  {\n    let error = await applyTransform(\"afterParse\", program.parser);\n    if (error) return prepareResult(error);\n  }\n\n  // Parse additional files, if any\n  {\n    let code = await parseBacklog();\n    if (code) return code;\n  }\n\n  // Pre-emptively initialize the program\n  {\n    let begin = stats.begin();\n    stats.initializeCount++;\n    try {\n      assemblyscript.initializeProgram(program);\n    } catch (e) {\n      crash(\"initialize\", e);\n    }\n    stats.initializeTime += stats.end(begin);\n  }\n\n  // Call afterInitialize transform hook\n  {\n    let error = await applyTransform(\"afterInitialize\", program);\n    if (error) return prepareResult(error);\n  }\n\n  // Compile the program\n  {\n    let begin = stats.begin();\n    stats.compileCount++;\n    try {\n      module = assemblyscript.compile(program);\n    } catch (e) {\n      crash(\"compile\", e);\n    }\n    stats.compileTime += stats.end(begin);\n  }\n  // From here on we are going to use Binaryen.js\n  binaryenModule = binaryen.wrapModule(\n    typeof module === \"number\" || module instanceof Number\n      ? assemblyscript.getBinaryenModuleRef(module)\n      : module.ref\n  );\n  let numErrors = checkDiagnostics(program, stderr, opts.disableWarning, options.reportDiagnostic, stderrColors.enabled);\n  if (numErrors) {\n    const err = Error(`${numErrors} compile error(s)`);\n    err.stack = err.message; // omit stack\n    return prepareResult(err);\n  }\n\n  // Call afterCompile transform hook\n  {\n    let error = await applyTransform(\"afterCompile\", binaryenModule);\n    if (error) return prepareResult(error);\n  }\n\n  numErrors = checkDiagnostics(program, stderr, opts.disableWarning, options.reportDiagnostic, stderrColors.enabled);\n  if (numErrors) {\n    const err = Error(`${numErrors} afterCompile error(s)`);\n    err.stack = err.message; // omit stack\n    return prepareResult(err);\n  }\n\n  // Validate the module if requested\n  if (!opts.noValidate) {\n    let begin = stats.begin();\n    stats.validateCount++;\n    let isValid = assemblyscript.validate(module);\n    stats.validateTime += stats.end(begin);\n    if (!isValid) {\n      return prepareResult(Error(\"validate error\"));\n    }\n  }\n\n  // Set Binaryen-specific options\n  if (opts.trapMode === \"clamp\" || opts.trapMode === \"js\") {\n    let begin = stats.begin();\n    try {\n      binaryenModule.runPasses([`trap-mode-${opts.trapMode}`]);\n    } catch (e) {\n      crash(\"runPasses\", e);\n    }\n    stats.compileTime += stats.end(begin);\n  } else if (opts.trapMode !== \"allow\") {\n    return prepareResult(Error(\"Unsupported trap mode\"));\n  }\n\n  // Optimize the module\n  const debugInfo = opts.debug;\n  const converge = opts.converge;\n  const zeroFilledMemory = opts.importMemory\n    ? opts.zeroFilledMemory\n    : false;\n\n  const runPasses = [];\n  if (opts.runPasses) {\n    if (typeof opts.runPasses === \"string\") {\n      opts.runPasses = opts.runPasses.split(\",\");\n    }\n    if (opts.runPasses.length) {\n      opts.runPasses.forEach(pass => {\n        if (!runPasses.includes(pass = pass.trim())) {\n          runPasses.push(pass);\n        }\n      });\n    }\n  }\n\n  {\n    let begin = stats.begin();\n    try {\n      stats.optimizeCount++;\n      assemblyscript.optimize(module, optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n    } catch (e) {\n      crash(\"optimize\", e);\n    }\n    try {\n      binaryenModule.runPasses(runPasses);\n    } catch (e) {\n      crash(\"runPasses\", e);\n    }\n    if (converge) {\n      let last;\n      try {\n        let begin = stats.begin();\n        stats.emitCount++;\n        last = binaryenModule.emitBinary();\n        stats.emitTime += stats.end(begin);\n      } catch (e) {\n        crash(\"emitBinary (converge)\", e);\n      }\n      do {\n        try {\n          stats.optimizeCount++;\n          assemblyscript.optimize(module, optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n        } catch (e) {\n          crash(\"optimize (converge)\", e);\n        }\n        try {\n          binaryenModule.runPasses(runPasses);\n        } catch (e) {\n          crash(\"runPasses (converge)\", e);\n        }\n        let next;\n        try {\n          let begin = stats.begin();\n          stats.emitCount++;\n          next = binaryenModule.emitBinary();\n          stats.emitTime += stats.end(begin);\n        } catch (e) {\n          crash(\"emitBinary (converge)\", e);\n        }\n        if (next.length >= last.length) {\n          if (next.length > last.length) {\n            stderr.write(`Last converge was suboptimal.${EOL}`);\n          }\n          break;\n        }\n        last = next;\n      } while (true);\n    }\n    stats.optimizeTime += stats.end(begin);\n  }\n\n  const pending = [];\n\n  // Prepare output\n  if (!opts.noEmit) {\n    if (opts.binaryFile) {\n      // We catched lagacy field for binary output (before 0.20)\n      return prepareResult(Error(\"Usage of the --binaryFile compiler option is no longer supported. Use --outFile instead.\"));\n    }\n    let bindings = opts.bindings || [];\n    let hasStdout = false;\n    let hasOutFile = opts.outFile != null;\n    let hasTextFile = opts.textFile != null;\n    let hasOutput = hasOutFile || hasTextFile;\n    let hasFileOutput = (hasOutFile && opts.outFile.length > 0) || (hasTextFile && opts.textFile.length > 0);\n    let basepath = hasFileOutput\n      ? (opts.outFile || opts.textFile).replace(/\\.\\w+$/, \"\")\n      : null;\n    let basename = hasFileOutput\n      ? path.basename(basepath)\n      : \"output\";\n\n    assemblyscript.setBasenameHint(compilerOptions, basename);\n\n    // Write binary\n    if (opts.outFile != null) {\n      let sourceMapURL = opts.sourceMap != null\n        ? opts.sourceMap.length\n          ? opts.sourceMap\n          : `./${basename}.wasm.map`\n        : null;\n\n      let begin = stats.begin();\n      stats.emitCount++;\n      let wasm;\n      try {\n        wasm = binaryenModule.emitBinary(sourceMapURL);\n      } catch (e) {\n        crash(\"emitBinary\", e);\n      }\n      stats.emitTime += stats.end(begin);\n\n      if (opts.outFile.length) {\n        pending.push(\n          writeFile(opts.outFile, wasm.binary, baseDir)\n        );\n      } else {\n        hasStdout = true;\n        writeStdout(wasm.binary);\n      }\n\n      // Post-process source map\n      if (wasm.sourceMap != \"\") {\n        if (opts.outFile.length) {\n          let map = JSON.parse(wasm.sourceMap);\n          map.sourceRoot = `./${basename}`;\n          let contents = [];\n          for (let i = 0, k = map.sources.length; i < k; ++i) {\n            let name = map.sources[i];\n            let text = assemblyscript.getSource(program, name.replace(extension_re, \"\"));\n            if (text == null) return prepareResult(Error(`Source of file '${name}' not found.`));\n            contents[i] = text;\n          }\n          map.sourcesContent = contents;\n          pending.push(\n            writeFile(path.join(\n              path.dirname(opts.outFile),\n              path.basename(sourceMapURL)\n            ).replace(/^\\.\\//, \"\"), JSON.stringify(map), baseDir)\n          );\n        } else {\n          stderr.write(`Skipped source map (no output path)${EOL}`);\n        }\n      }\n    }\n\n    // Write text (also fallback)\n    if (opts.textFile != null || !hasOutput) {\n      let begin = stats.begin();\n      stats.emitCount++;\n      let out;\n      try {\n        // use superset text format when extension is `.wast`.\n        // Otherwise use official stack IR format (wat).\n        out = opts.textFile?.endsWith(\".wast\")\n          ? binaryenModule.emitText()\n          : binaryenModule.emitStackIR(true);\n      } catch (e) {\n        crash(\"emitText\", e);\n      }\n      stats.emitTime += stats.end(begin);\n\n      if (opts.textFile != null && opts.textFile.length) {\n        pending.push(\n          writeFile(opts.textFile, out, baseDir)\n        );\n      } else if (!hasStdout) {\n        hasStdout = true;\n        writeStdout(out);\n      }\n    }\n\n    // Write TypeScript definition\n    const bindingsEsm = bindings.includes(\"esm\");\n    const bindingsRaw = !bindingsEsm && bindings.includes(\"raw\");\n    if (bindingsEsm || bindingsRaw) {\n      if (basepath) {\n        let begin = stats.begin();\n        stats.emitCount++;\n        let source;\n        try {\n          source = assemblyscript.buildTSD(program, bindingsEsm);\n        } catch (e) {\n          crash(\"buildTSD\", e);\n        }\n        stats.emitTime += stats.end(begin);\n        pending.push(\n          writeFile(basepath + \".d.ts\", source, baseDir)\n        );\n      } else {\n        stderr.write(`Skipped TypeScript binding (no output path)${EOL}`);\n      }\n    }\n\n    // Write JavaScript bindings\n    if (bindingsEsm || bindingsRaw) {\n      if (basepath) {\n        let begin = stats.begin();\n        stats.emitCount++;\n        let source;\n        try {\n          source = assemblyscript.buildJS(program, bindingsEsm);\n        } catch (e) {\n          crash(\"buildJS\", e);\n        }\n        stats.emitTime += stats.end(begin);\n        pending.push(\n          writeFile(basepath + \".js\", source, baseDir)\n        );\n      } else {\n        stderr.write(`Skipped JavaScript binding (no output path)${EOL}`);\n      }\n    }\n  }\n\n  try {\n    await Promise.all(pending);\n  } catch (err) {\n    return prepareResult(err);\n  }\n\n  stats.total = stats.end(statsBegin);\n  if (opts.stats) stderr.write(stats.toString());\n\n  return prepareResult(null);\n\n  // Default implementation to read files on node\n  async function readFileNode(filename, baseDir) {\n    let name = path.resolve(baseDir, filename);\n    try {\n      stats.readCount++;\n      return await fs.promises.readFile(name, \"utf8\");\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Default implementation to write files on node\n  async function writeFileNode(filename, contents, baseDir) {\n    try {\n      stats.writeCount++;\n      const dirPath = path.resolve(baseDir, path.dirname(filename));\n      const filePath = path.join(dirPath, path.basename(filename));\n      await fs.promises.mkdir(dirPath, { recursive: true });\n      await fs.promises.writeFile(filePath, contents);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Default implementation to list files on node\n  async function listFilesNode(dirname, baseDir) {\n    try {\n      stats.readCount++;\n      return (await fs.promises.readdir(path.join(baseDir, dirname)))\n        .filter(file => extension_re_except_d.test(file));\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Writes to stdout\n  function writeStdout(contents) {\n    if (!writeStdout.used) {\n      writeStdout.used = true;\n      stats.writeCount++;\n    }\n    stdout.write(contents);\n  }\n\n  // Crash handler\n  function crash(stage, e) {\n    const BAR = stdoutColors.red(\"\u258C \");\n    console.error([\n      EOL,\n      BAR, \"Whoops, the AssemblyScript compiler has crashed during \", stage, \" :-(\", EOL,\n      BAR, EOL,\n      (typeof e.stack === \"string\"\n        ? [\n            BAR, \"Here is the stack trace hinting at the problem, perhaps it's useful?\", EOL,\n            BAR, EOL,\n            e.stack.replace(/^/mg, BAR), EOL\n          ]\n        : [\n            BAR, \"There is no stack trace. Perhaps a Binaryen exception above / in console?\", EOL,\n            BAR, EOL,\n            BAR, \"> \" + e.stack, EOL\n          ]\n      ).join(\"\"),\n      BAR, EOL,\n      BAR, \"If you see where the error is, feel free to send us a pull request. If not,\", EOL,\n      BAR, \"please let us know: https://github.com/AssemblyScript/assemblyscript/issues\", EOL,\n      BAR, EOL,\n      BAR, \"Thank you!\", EOL\n    ].join(\"\"));\n    process.exit(1);\n  }\n}\n\nfunction isObject(arg) {\n  return Object.prototype.toString.call(arg) === \"[object Object]\";\n}\n\nasync function getConfig(file, baseDir, readFile) {\n  const contents = await readFile(file, baseDir);\n  const location = path.join(baseDir, file);\n  if (!contents) return null;\n\n  // obtain the configuration\n  let config;\n  try {\n    config = JSON.parse(contents);\n  } catch(ex) {\n    throw new Error(`Asconfig is not valid json: ${location}`);\n  }\n\n  // validate asconfig shape\n  if (config.options && !isObject(config.options)) {\n    throw new Error(`Asconfig.options is not an object: ${location}`);\n  }\n\n  if (config.include && !Array.isArray(config.include)) {\n    throw new Error(`Asconfig.include is not an array: ${location}`);\n  }\n\n  if (config.targets) {\n    if (!isObject(config.targets)) {\n      throw new Error(`Asconfig.targets is not an object: ${location}`);\n    }\n    const targets = Object.keys(config.targets);\n    for (let i = 0; i < targets.length; i++) {\n      const target = targets[i];\n      if (!isObject(config.targets[target])) {\n        throw new Error(`Asconfig.targets.${target} is not an object: ${location}`);\n      }\n    }\n  }\n\n  if (config.extends && typeof config.extends !== \"string\") {\n    throw new Error(`Asconfig.extends is not a string: ${location}`);\n  }\n\n  return config;\n}\n\n/** Checks diagnostics emitted so far for errors. */\nexport function checkDiagnostics(program, stderr, disableWarning, reportDiagnostic, useColors) {\n  if (typeof useColors === \"undefined\" && stderr) useColors = stderr.isTTY;\n  let numErrors = 0;\n  do {\n    let diagnostic = assemblyscript.nextDiagnostic(program);\n    if (!diagnostic) break;\n    if (stderr) {\n      const isDisabledWarning = (diagnostic) => {\n        if (disableWarning == null) return false;\n        if (!disableWarning.length) return true;\n        const code = assemblyscript.getDiagnosticCode(diagnostic);\n        return disableWarning.includes(code);\n      };\n      if (assemblyscript.isError(diagnostic) || !isDisabledWarning(diagnostic)) {\n        stderr.write(assemblyscript.formatDiagnostic(diagnostic, useColors, true) + EOL + EOL);\n      }\n    }\n    if (reportDiagnostic) {\n      function wrapRange(range) {\n        return range && {\n          start: assemblyscript.getRangeStart(range),\n          end: assemblyscript.getRangeEnd(range),\n          source: wrapSource(assemblyscript.getRangeSource(range))\n        } || null;\n      }\n      function wrapSource(source) {\n        return source && {\n          normalizedPath: assemblyscript.getSourceNormalizedPath(source)\n        } || null;\n      }\n      reportDiagnostic({\n        message: assemblyscript.getDiagnosticMessage(diagnostic),\n        code: assemblyscript.getDiagnosticCode(diagnostic),\n        category: assemblyscript.getDiagnosticCategory(diagnostic),\n        range: wrapRange(assemblyscript.getDiagnosticRange(diagnostic)),\n        relatedRange: wrapRange(assemblyscript.getDiagnosticRelatedRange(diagnostic))\n      });\n    }\n    if (assemblyscript.isError(diagnostic)) ++numErrors;\n  } while (true);\n  return numErrors;\n}\n\nexport class Stats {\n  readCount = 0;\n  writeCount = 0;\n  parseTime = 0;\n  parseCount = 0;\n  initializeTime = 0;\n  initializeCount = 0;\n  compileTime = 0;\n  compileCount = 0;\n  emitTime = 0;\n  emitCount = 0;\n  validateTime = 0;\n  validateCount = 0;\n  optimizeTime = 0;\n  optimizeCount = 0;\n  transformTime = 0;\n  transformCount = 0;\n  begin() {\n    return process.hrtime();\n  }\n  end(begin) {\n    const hrtime = process.hrtime(begin);\n    return hrtime[0] * 1e9 + hrtime[1];\n  }\n  toString() {\n    const formatTime = time => time ? `${(time / 1e6).toFixed(3)} ms` : \"n/a\";\n    const keys = Object.keys(this).filter(key => key.endsWith(\"Time\")).map(key => key.substring(0, key.length - 4));\n    const times = keys.map(key => formatTime(this[`${key}Time`]));\n    const counts = keys.map(key => this[`${key}Count`].toString());\n    const keysLen = keys.reduce((current, key) => Math.max(key.length, current), 0);\n    const timesLen = times.reduce((current, time) => Math.max(time.length, current), 0);\n    const countsLen = counts.reduce((current, count) => Math.max(count.length, current), 0);\n    const totalLen = keysLen + timesLen + countsLen + 6;\n    const out = [];\n    out.push(`\u256D\u2500${\"\u2500\".repeat(totalLen)}\u2500\u256E${EOL}`);\n    const header = `Stats`;\n    out.push(`\u2502 ${header}${\" \".repeat(totalLen - header.length)} \u2502${EOL}`);\n    out.push(`\u255E\u2550${\"\u2550\".repeat(keysLen)}\u2550\u2564\u2550${\"\u2550\".repeat(timesLen)}\u2550\u2564\u2550${\"\u2550\".repeat(countsLen)}\u2550\u2561${EOL}`);\n    for (let i = 0, k = keys.length; i < k; ++i) {\n      out.push(`\u2502 ${keys[i].padEnd(keysLen)} \u2502 ${times[i].padStart(timesLen)} \u2502 ${counts[i].padStart(countsLen)} \u2502${EOL}`);\n    }\n    out.push(`\u251C\u2500${\"\u2500\".repeat(keysLen)}\u2500\u2534\u2500${\"\u2500\".repeat(timesLen)}\u2500\u2534\u2500${\"\u2500\".repeat(countsLen)}\u2500\u2524${EOL}`);\n    const totalTime = `Took ${formatTime(this.total)}`;\n    out.push(`\u2502 ${totalTime}${\" \".repeat(totalLen - totalTime.length)} \u2502${EOL}`);\n    const readsWrites = `${this.readCount} reads, ${this.writeCount} writes`;\n    out.push(`\u2502 ${readsWrites}${\" \".repeat(totalLen - readsWrites.length)} \u2502${EOL}`);\n    out.push(`\u2570\u2500${\"\u2500\".repeat(totalLen)}\u2500\u256F${EOL}`);\n    return out.join(\"\");\n  }\n}\n\nlet allocBuffer = typeof global !== \"undefined\" && global.Buffer\n  ? global.Buffer.allocUnsafe || (len => new global.Buffer(len))\n  : len => new Uint8Array(len);\n\n/** Creates a memory stream that can be used in place of stdout/stderr. */\nexport function createMemoryStream(fn) {\n  let stream = [];\n  stream.write = function(chunk) {\n    if (fn) fn(chunk);\n    if (typeof chunk === \"string\") {\n      let buffer = allocBuffer(utf8.length(chunk));\n      utf8.write(chunk, buffer, 0);\n      chunk = buffer;\n    }\n    this.push(chunk);\n  };\n  stream.reset = function() {\n    stream.length = 0;\n  };\n  stream.toBuffer = function() {\n    let offset = 0, i = 0, k = this.length;\n    while (i < k) offset += this[i++].length;\n    let buffer = allocBuffer(offset);\n    offset = i = 0;\n    while (i < k) {\n      buffer.set(this[i], offset);\n      offset += this[i].length;\n      ++i;\n    }\n    return buffer;\n  };\n  stream.toString = function() {\n    let buffer = this.toBuffer();\n    return utf8.read(buffer, 0, buffer.length);\n  };\n  return stream;\n}\n\n/** Compatible TypeScript compiler options for syntax highlighting etc. */\nexport const tscOptions = {\n  alwaysStrict: true,\n  strictNullChecks: true,\n  noImplicitAny: true,\n  noImplicitReturns: true,\n  noImplicitThis: true,\n  noEmitOnError: true,\n  noPropertyAccessFromIndexSignature: true,\n  experimentalDecorators: true,\n  target: \"esnext\",\n  noLib: true,\n  types: [],\n  allowJs: false\n};\n\nexport * as default from \"./index.js\";\n", "/**\n * @fileoverview Node.js polyfills.\n * @license Apache-2.0\n */\n\nexport const isNode = Object.prototype.toString.call(typeof globalThis.process !== 'undefined' ? globalThis.process : 0) === '[object process]';\n\nvar fs;\nvar module;\nvar path;\nvar process;\nvar url;\n\nif (isNode) {\n  fs = await import(\"fs\");\n  module = await import(\"module\");\n  path = await import(\"path\");\n  process = globalThis.process;\n  url = await import(\"url\");\n} else {\n  fs = await import(\"./browser/fs.js\");\n  module = await import(\"./browser/module.js\");\n  path = await import(\"./browser/path.js\");\n  process = await import(\"./browser/process.js\");\n  url = await import(\"./browser/url.js\");\n}\n\nexport {\n  fs,\n  module,\n  path,\n  process,\n  url\n};\n", "/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\nvar proc = typeof process !== \"undefined\" && process || {};\nvar isCI = proc.env && \"CI\" in proc.env;\n\nexport const GRAY = \"\\u001b[90m\";\nexport const RED = \"\\u001b[91m\";\nexport const GREEN = \"\\u001b[92m\";\nexport const YELLOW = \"\\u001b[93m\";\nexport const BLUE = \"\\u001b[94m\";\nexport const MAGENTA = \"\\u001b[95m\";\nexport const CYAN = \"\\u001b[96m\";\nexport const WHITE = \"\\u001b[97m\";\nexport const RESET = \"\\u001b[0m\";\n\nexport class Colors {\n  constructor(stream) {\n    this.stream = stream;\n    this.enabled = Boolean((this.stream && this.stream.isTTY) || isCI);\n  }\n  gray(text) { return this.enabled ? GRAY + text + RESET : text; }\n  red(text) { return this.enabled ? RED + text + RESET : text; }\n  green(text) { return this.enabled ? GREEN + text + RESET : text; }\n  yellow(text) { return this.enabled ? YELLOW + text + RESET : text; }\n  blue(text) { return this.enabled ? BLUE + text + RESET : text; }\n  magenta(text) { return this.enabled ? MAGENTA + text + RESET : text; }\n  cyan(text) { return this.enabled ? CYAN + text + RESET : text; }\n  white(text) { return this.enabled ? WHITE + text + RESET : text; }\n}\n\nexport const stdoutColors = new Colors(proc.stdout);\nexport const stderrColors = new Colors(proc.stderr);\n", "function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080\u201300FF\n//  - U+00D7  \u00D7 Multiplication sign\n//  - U+00F7  \u00F7 Division sign\n// Latin Extended-A, 0100\u2013017F\n// Latin Extended-B, 0180\u2013024F\n// IPA Extensions, 0250\u201302AF\n// Spacing Modifier Letters, 02B0\u201302FF\n//  - U+02C7  \u02C7 &#711;  Caron\n//  - U+02D8  \u02D8 &#728;  Breve\n//  - U+02D9  \u02D9 &#729;  Dot Above\n//  - U+02DA  \u02DA &#730;  Ring Above\n//  - U+02DB  \u02DB &#731;  Ogonek\n//  - U+02DC  \u02DC &#732;  Small Tilde\n//  - U+02DD  \u02DD &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00\u20131EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\n", "/**\n * @fileoverview Text utility.\n * @license Apache-2.0\n */\n\nimport * as Diff from \"diff\";\nimport { stdoutColors } from \"./terminal.js\";\n\nexport function utf8Length(string) {\n  var len = 0;\n  for (var i = 0, k = string.length; i < k; ++i) {\n    let c = string.charCodeAt(i);\n    if (c < 128) {\n      len += 1;\n    } else if (c < 2048) {\n      len += 2;\n    } else if ((c & 0xFC00) === 0xD800 && i + 1 < k && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nexport function utf8Read(buffer, start, end) {\n  var len = end - start;\n  if (len < 1) return \"\";\n  var parts = null,\n      chunk = [],\n      i = 0, // char offset\n      t;     // temporary\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128) {\n      chunk[i++] = t;\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n      chunk[i++] = 0xD800 + (t >> 10);\n      chunk[i++] = 0xDC00 + (t & 1023);\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n    }\n    if (i >= 8192) {\n      (parts || (parts = [])).push(String.fromCharCode(...chunk));\n      i = 0;\n    }\n  }\n  if (parts) {\n    if (i) parts.push(String.fromCharCode(...chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode(...chunk.slice(0, i));\n}\n\nexport function utf8Write(string, buffer, offset) {\n  var start = offset;\n  for (var i = 0, k = string.length; i < k; ++i) {\n    let c1 = string.charCodeAt(i), c2;\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192;\n      buffer[offset++] = c1 & 63 | 128;\n    } else if ((c1 & 0xFC00) === 0xD800 && i + 1 < k && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n      ++i;\n      buffer[offset++] = c1 >> 18 | 240;\n      buffer[offset++] = c1 >> 12 & 63 | 128;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    } else {\n      buffer[offset++] = c1 >> 12 | 224;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    }\n  }\n  return offset - start;\n}\n\nexport const utf8 = {\n  length: utf8Length,\n  read: utf8Read,\n  write: utf8Write\n};\n\nexport function diff(filename, expected, actual) {\n  const diff = Diff.structuredPatch(filename, filename, expected, actual, \"expected\", \"actual\", { context: 5 });\n  if (!diff.hunks.length) return null;\n\n  const out = [\n    '--- ' + diff.oldHeader,\n    '+++ ' + diff.newHeader\n  ];\n  for (const hunk of diff.hunks) {\n    out.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    out.push(...hunk.lines.map(line =>\n      line.charAt(0) === \"+\"\n        ? stdoutColors.green(line)\n        : line.charAt(0) === \"-\"\n        ? line = stdoutColors.red(line)\n        : line\n    ));\n  }\n\n  return out.join('\\n') + '\\n';\n}\n", "/**\n * @fileoverview Command line options utility.\n * @license Apache-2.0\n */\n\nimport { path, module } from \"./node.js\";\nimport { stdoutColors } from \"./terminal.js\";\n\nconst require = module.createRequire ? module.createRequire(import.meta.url): {};\n\n// type | meaning\n// -----|---------------\n// b    | boolean\n// i    | integer\n// f    | float\n// s    | string\n// I    | integer array\n// F    | float array\n// S    | string array\n\n/** Parses the specified command line arguments according to the given configuration. */\nexport function parse(argv, config, propagateDefaults = true) {\n  var options = {};\n  var unknown = [];\n  var args = [];\n  var trailing = [];\n\n  // make an alias map and initialize defaults\n  var aliases = {};\n  Object.keys(config).forEach(key => {\n    if (key.startsWith(\" \")) return;\n    var option = config[key];\n    if (option.alias != null) {\n      if (typeof option.alias === \"string\") aliases[option.alias] = key;\n      else if (Array.isArray(option.alias)) option.alias.forEach(alias => aliases[alias] = key);\n    }\n    if (propagateDefaults && option.default != null) options[key] = option.default;\n  });\n\n  // iterate over argv\n  for (var i = 0, k = (argv = argv.slice()).length; i < k; ++i) {\n    let arg = argv[i];\n    if (arg == \"--\") { ++i; break; }\n    let match = /^(?:(-\\w)(?:=(.*))?|(--\\w{2,})(?:=(.*))?)$/.exec(arg), option, key;\n    if (match) {\n      if (config[arg]) option = config[key = arg]; // exact\n      else if (match[1] != null) { // alias\n        option = config[key = aliases[match[1].substring(1)]];\n        if (option && match[2] != null) argv[i--] = match[2];\n      } else if (match[3] != null) { // full\n        option = config[key = match[3].substring(2)];\n        if (option && match[4] != null) argv[i--] = match[4];\n      }\n    } else {\n      if (arg.charCodeAt(0) == 45) option = config[key = arg]; // exact\n      else { args.push(arg); continue; } // argument\n    }\n    if (option) {\n      if (option.value) {\n        // alias setting fixed values\n        Object.keys(option.value).forEach(k => options[k] = option.value[k]);\n      } else if (option.type == null || option.type === \"b\") {\n        // boolean flag not taking a value\n        options[key] = true;\n      } else {\n        if (i + 1 < argv.length && argv[i + 1].charCodeAt(0) != 45) {\n          // non-boolean with given value\n          switch (option.type) {\n            case \"i\": options[key] = parseInt(argv[++i], 10); break;\n            case \"I\": options[key] = (options[key] || []).concat(parseInt(argv[++i], 10)); break;\n            case \"f\": options[key] = parseFloat(argv[++i]); break;\n            case \"F\": options[key] = (options[key] || []).concat(parseFloat(argv[++i])); break;\n            case \"s\": options[key] = String(argv[++i]); break;\n            case \"S\": options[key] = (options[key] || []).concat(argv[++i].split(\",\")); break;\n            default: unknown.push(arg); --i;\n          }\n        } else {\n          // non-boolean with omitted value\n          switch (option.type) {\n            case \"i\":\n            case \"f\": options[key] = option.default || 0; break;\n            case \"s\": options[key] = option.default || \"\"; break;\n            case \"I\":\n            case \"F\":\n            case \"S\": options[key] = option.default || []; break;\n            default: unknown.push(arg);\n          }\n        }\n      }\n    } else unknown.push(arg);\n  }\n  while (i < k) trailing.push(argv[i++]); // trailing\n  if (propagateDefaults) addDefaults(config, options);\n\n  return { options, unknown, arguments: args, trailing };\n}\n\n/** Generates the help text for the specified configuration. */\nexport function help(config, options) {\n  if (!options) options = {};\n  var indent = options.indent || 2;\n  var padding = options.padding || 24;\n  var eol = options.eol || \"\\n\";\n  var sbCategories = {};\n  var sbOther = [];\n  Object.keys(config).forEach(key => {\n    var option = config[key];\n    if (option.description == null) return;\n    var text = \"\";\n    while (text.length < indent) text += \" \";\n    text += \"--\" + key;\n    if (option.alias) text += \", -\" + option.alias;\n    while (text.length < padding) text += \" \";\n    var sb;\n    if (!options.noCategories && option.category) {\n      if (!(sb = sbCategories[option.category])) {\n        sbCategories[option.category] = sb = [];\n      }\n    } else {\n      sb = sbOther;\n    }\n    if (Array.isArray(option.description)) {\n      sb.push(text + option.description[0] + option.description.slice(1).map(line => {\n        for (let i = 0; i < padding; ++i) line = \" \" + line;\n        return eol + line;\n      }).join(\"\"));\n    } else sb.push(text + option.description);\n  });\n  var sb = [];\n  var hasCategories = false;\n  Object.keys(sbCategories).forEach(category => {\n    hasCategories = true;\n    sb.push(eol + \" \" + stdoutColors.gray(category) + eol);\n    sb.push(sbCategories[category].join(eol));\n  });\n  if (hasCategories && sbOther.length) {\n    sb.push(eol + \" \" + stdoutColors.gray(\"Other\") + eol);\n  }\n  sb.push(sbOther.join(eol));\n  return sb.join(eol);\n}\n\n/** Sanitizes an option value to be a valid value of the option's type. */\nfunction sanitizeValue(value, type) {\n  if (value != null) {\n    switch (type) {\n      case undefined:\n      case \"b\": return Boolean(value);\n      case \"i\": return Math.trunc(value) || 0;\n      case \"f\": return Number(value) || 0;\n      case \"s\": {\n        if (value === true) return \"\";\n        return String(value);\n      }\n      case \"I\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(v => Math.trunc(v) || 0);\n      }\n      case \"F\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(v => Number(v) || 0);\n      }\n      case \"S\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(String);\n      }\n    }\n  }\n  return undefined;\n}\n\n/** Merges two sets of options into one, preferring the current over the parent set. */\nexport function merge(config, currentOptions, parentOptions, parentBaseDir) {\n  const mergedOptions = {};\n  for (const [key, { type, mutuallyExclusive, isPath, useNodeResolution, cliOnly }] of Object.entries(config)) {\n    let currentValue = sanitizeValue(currentOptions[key], type);\n    let parentValue = sanitizeValue(parentOptions[key], type);\n    if (currentValue == null) {\n      if (parentValue != null) {\n        // only parent value present\n        if (cliOnly) continue;\n        if (Array.isArray(parentValue)) {\n          let exclude;\n          if (isPath) {\n            parentValue = parentValue.map(value => resolvePath(value, parentBaseDir, useNodeResolution));\n          }\n          if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {\n            mergedOptions[key] = parentValue.filter(value => !exclude.includes(value));\n          } else {\n            mergedOptions[key] = parentValue.slice();\n          }\n        } else {\n          if (isPath) {\n            parentValue = resolvePath(parentValue, parentBaseDir, useNodeResolution);\n          }\n          mergedOptions[key] = parentValue;\n        }\n      }\n    } else if (parentValue == null) {\n      // only current value present\n      if (Array.isArray(currentValue)) {\n        mergedOptions[key] = currentValue.slice();\n      } else {\n        mergedOptions[key] = currentValue;\n      }\n    } else {\n      // both current and parent values present\n      if (Array.isArray(currentValue)) {\n        if (cliOnly) {\n          mergedOptions[key] = currentValue.slice();\n          continue;\n        }\n        let exclude;\n        if (isPath) {\n          parentValue = parentValue.map(value => resolvePath(value, parentBaseDir, useNodeResolution));\n        }\n        if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {\n          mergedOptions[key] = [\n            ...currentValue,\n            ...parentValue.filter(value => !currentValue.includes(value) && !exclude.includes(value))\n          ];\n        } else {\n          mergedOptions[key] = [\n            ...currentValue,\n            ...parentValue.filter(value => !currentValue.includes(value)) // dedup\n          ];\n        }\n      } else {\n        mergedOptions[key] = currentValue;\n      }\n    }\n  }\n  return mergedOptions;\n}\n\n/** Normalizes a path. */\nexport function normalizePath(p) {\n  const parsed = path.parse(p);\n  if (!parsed.root) {\n    parsed.root = \"./\";\n  }\n  return path.format(parsed);\n}\n\n/** Resolves a single possibly relative path. Keeps absolute paths, otherwise prepends baseDir. */\nexport function resolvePath(p, baseDir, useNodeResolution = false) {\n  if (path.isAbsolute(p)) return p;\n  if (useNodeResolution && !p.startsWith(\".\") && require.resolve) {\n    return require.resolve(p, { paths: [ baseDir ] });\n  }\n  return normalizePath(path.join(baseDir, p));\n}\n\n/** Populates default values on a parsed options result. */\nexport function addDefaults(config, options) {\n  for (const [key, { default: defaultValue }] of Object.entries(config)) {\n    if (options[key] == null && defaultValue != null) {\n      options[key] = defaultValue;\n    }\n  }\n}\n", "// GENERATED FILE. DO NOT EDIT.\n\nexport const version = \"0.0.5\";\nexport const options = {\n  \"version\": {\n    \"category\": \"General\",\n    \"description\": \"Prints just the compiler's version and exits.\",\n    \"type\": \"b\",\n    \"alias\": \"v\"\n  },\n  \"help\": {\n    \"category\": \"General\",\n    \"description\": \"Prints this message and exits.\",\n    \"type\": \"b\",\n    \"alias\": \"h\"\n  },\n  \"config\": {\n    \"category\": \"General\",\n    \"description\": \"Configuration file to apply. CLI arguments take precedence.\",\n    \"type\": \"s\",\n    \"cliOnly\": true\n  },\n  \"target\": {\n    \"category\": \"General\",\n    \"description\": \"Configuration file target to use. Defaults to 'release'.\",\n    \"type\": \"s\",\n    \"cliOnly\": true\n  },\n  \"optimize\": {\n    \"category\": \"Optimization\",\n    \"description\": [\n      \"Optimizes the module. Typical shorthands are:\",\n      \"\",\n      \" Default optimizations   -O\",\n      \" Make a release build    -O --noAssert\",\n      \" Make a debug build      --debug\",\n      \" Optimize for speed      -Ospeed\",\n      \" Optimize for size       -Osize\",\n      \"\"\n    ],\n    \"type\": \"b\",\n    \"alias\": \"O\"\n  },\n  \"optimizeLevel\": {\n    \"category\": \"Optimization\",\n    \"description\": \"How much to focus on optimizing code. [0-3]\",\n    \"type\": \"i\"\n  },\n  \"shrinkLevel\": {\n    \"category\": \"Optimization\",\n    \"description\": \"How much to focus on shrinking code size. [0-2, s=1, z=2]\",\n    \"type\": \"i\"\n  },\n  \"converge\": {\n    \"category\": \"Optimization\",\n    \"description\": \"Re-optimizes until no further improvements can be made.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"noAssert\": {\n    \"category\": \"Optimization\",\n    \"description\": \"Replaces assertions with just their value without trapping.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"outFile\": {\n    \"category\": \"Output\",\n    \"description\": \"Specifies the WebAssembly output file (.wasm).\",\n    \"type\": \"s\",\n    \"alias\": \"o\",\n    \"isPath\": true\n  },\n  \"textFile\": {\n    \"category\": \"Output\",\n    \"description\": \"Specifies the WebAssembly text output file (.wat).\",\n    \"type\": \"s\",\n    \"alias\": \"t\",\n    \"isPath\": true\n  },\n  \"bindings\": {\n    \"category\": \"Output\",\n    \"description\": [\n      \"Specifies the bindings to generate (.js + .d.ts).\",\n      \"\",\n      \"  esm  JavaScript bindings & typings for ESM integration.\",\n      \"  raw  Like esm, but exports just the instantiate function.\",\n      \"       Useful where modules are meant to be instantiated\",\n      \"       multiple times or non-ESM imports must be provided.\"\n    ],\n    \"type\": \"S\",\n    \"alias\": \"b\"\n  },\n  \"sourceMap\": {\n    \"category\": \"Debugging\",\n    \"description\": [\n      \"Enables source map generation. Optionally takes the URL\",\n      \"used to reference the source map from the binary file.\"\n    ],\n    \"type\": \"s\"\n  },\n  \"debug\": {\n    \"category\": \"Debugging\",\n    \"description\": \"Enables debug information in emitted binaries.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"importMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Imports the memory from 'env.memory'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"noExportMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Does not export the memory as 'memory'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"initialMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Sets the initial memory size in pages.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"maximumMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Sets the maximum memory size in pages.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"sharedMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Declare memory as shared. Requires maximumMemory.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"zeroFilledMemory\": {\n    \"category\": \"Features\",\n    \"description\": \"Assume imported memory is zeroed. Requires importMemory.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"importTable\": {\n    \"category\": \"Features\",\n    \"description\": \"Imports the function table from 'env.table'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"exportTable\": {\n    \"category\": \"Features\",\n    \"description\": \"Exports the function table as 'table'.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"exportStart\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Exports the start function using the specified name instead\",\n      \"of calling it implicitly. Useful to obtain the exported memory\",\n      \"before executing any code accessing it.\"\n    ],\n    \"type\": \"s\"\n  },\n  \"runtime\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Specifies the runtime variant to include in the program.\",\n      \"\",\n      \" incremental  TLSF + incremental GC (default)\",\n      \" minimal      TLSF + lightweight GC invoked externally\",\n      \" stub         Minimal runtime stub (never frees)\",\n      \" ...          Path to a custom runtime implementation\",\n      \"\"\n    ],\n    \"type\": \"s\",\n    \"default\": \"incremental\"\n  },\n  \"exportRuntime\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Always exports the runtime helpers (__new, __collect, __pin etc.).\",\n      \"Automatically determined when generation of --bindings is enabled.\"\n    ],\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"stackSize\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Overrides the stack size. Only relevant for incremental GC\",\n      \"or when using a custom runtime that requires stack space.\",\n      \"Defaults to 0 without and to 32768 with incremental GC.\"\n    ],\n    \"default\": 0,\n    \"type\": \"i\"\n  },\n  \"enable\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Enables WebAssembly features being disabled by default.\",\n      \"\",\n      \" threads             Threading and atomic operations.\",\n      \" simd                SIMD types and operations.\",\n      \" reference-types     Reference types and operations.\",\n      \" gc                  Garbage collection (WIP).\",\n      \" stringref           String reference types.\",\n      \"\"\n    ],\n    \"TODO_doesNothingYet\": [\n      \" exception-handling  Exception handling.\",\n      \" tail-calls          Tail call operations.\",\n      \" multi-value         Multi value types.\",\n      \" memory64            Memory64 operations.\",\n      \" relaxed-simd        Relaxed SIMD operations.\",\n      \" extended-const      Extended const expressions.\"\n    ],\n    \"type\": \"S\",\n    \"mutuallyExclusive\": \"disable\"\n  },\n  \"disable\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Disables WebAssembly features being enabled by default.\",\n      \"\",\n      \" mutable-globals     Mutable global imports and exports.\",\n      \" sign-extension      Sign-extension operations\",\n      \" nontrapping-f2i     Non-trapping float to integer ops.\",\n      \" bulk-memory         Bulk memory operations.\",\n      \"\"\n    ],\n    \"type\": \"S\",\n    \"mutuallyExclusive\": \"enable\"\n  },\n  \"use\": {\n    \"category\": \"Features\",\n    \"description\": [\n      \"Aliases a global object under another name, e.g., to switch\",\n      \"the default 'Math' implementation used: --use Math=JSMath\",\n      \"Can also be used to introduce an integer constant.\"\n    ],\n    \"type\": \"S\",\n    \"alias\": \"u\"\n  },\n  \"lowMemoryLimit\": {\n    \"category\": \"Features\",\n    \"description\": \"Enforces very low (<64k) memory constraints.\",\n    \"default\": 0,\n    \"type\": \"i\"\n  },\n  \"memoryBase\": {\n    \"category\": \"Linking\",\n    \"description\": \"Sets the start offset of emitted memory segments.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"tableBase\": {\n    \"category\": \"Linking\",\n    \"description\": \"Sets the start offset of emitted table elements.\",\n    \"type\": \"i\",\n    \"default\": 0\n  },\n  \"transform\": {\n    \"category\": \"API\",\n    \"description\": \"Specifies the path to a custom transform to load.\",\n    \"type\": \"S\",\n    \"isPath\": true,\n    \"useNodeResolution\": true\n  },\n  \"trapMode\": {\n    \"category\": \"Binaryen\",\n    \"description\": [\n      \"Sets the trap mode to use.\",\n      \"\",\n      \" allow  Allow trapping operations. This is the default.\",\n      \" clamp  Replace trapping operations with clamping semantics.\",\n      \" js     Replace trapping operations with JS semantics.\",\n      \"\"\n    ],\n    \"type\": \"s\",\n    \"default\": \"allow\"\n  },\n  \"runPasses\": {\n    \"category\": \"Binaryen\",\n    \"description\": [\n      \"Specifies additional Binaryen passes to run after other\",\n      \"optimizations, if any. See: Binaryen/src/passes/pass.cpp\"\n    ],\n    \"type\": \"s\"\n  },\n  \"noValidate\": {\n    \"category\": \"Binaryen\",\n    \"description\": \"Skips validating the module using Binaryen.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"baseDir\": {\n    \"description\": \"Specifies the base directory of input and output files.\",\n    \"type\": \"s\",\n    \"default\": \".\"\n  },\n  \"noColors\": {\n    \"description\": \"Disables terminal colors.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"noUnsafe\": {\n    \"description\": [\n      \"Disallows the use of unsafe features in user code.\",\n      \"Does not affect library files and external modules.\"\n    ],\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"disableWarning\": {\n    \"description\": [\n      \"Disables warnings matching the given diagnostic code.\",\n      \"If no diagnostic code is given, all warnings are disabled.\"\n    ],\n    \"type\": \"I\"\n  },\n  \"noEmit\": {\n    \"description\": \"Performs compilation as usual but does not emit code.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"showConfig\": {\n    \"description\": \"Print computed compiler options and exit.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"stats\": {\n    \"description\": \"Prints statistics on I/O and compile times.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"pedantic\": {\n    \"description\": \"Make yourself sad for no good reason.\",\n    \"type\": \"b\",\n    \"default\": false\n  },\n  \"lib\": {\n    \"description\": [\n      \"Adds one or multiple paths to custom library components and\",\n      \"uses exports of all top-level files at this path as globals.\"\n    ],\n    \"type\": \"S\",\n    \"isPath\": true\n  },\n  \"path\": {\n    \"description\": [\n      \"Adds one or multiple paths to package resolution, similar\",\n      \"to node_modules. Prefers an 'ascMain' entry in a package's\",\n      \"package.json and falls back to an inner 'assembly/' folder.\"\n    ],\n    \"type\": \"S\",\n    \"isPath\": true\n  },\n  \"wasm\": {\n    \"description\": \"Uses the specified Wasm binary of the compiler.\",\n    \"type\": \"s\"\n  },\n  \" ...\": {\n    \"description\": \"Specifies node.js options (CLI only). See: node --help\"\n  },\n  \"-Os\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-Oz\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O0\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O1\": {\n    \"value\": {\n      \"optimizeLevel\": 1,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O2\": {\n    \"value\": {\n      \"optimizeLevel\": 2,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O3\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-O0s\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O1s\": {\n    \"value\": {\n      \"optimizeLevel\": 1,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O2s\": {\n    \"value\": {\n      \"optimizeLevel\": 2,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O3s\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 1\n    }\n  },\n  \"-O0z\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O1z\": {\n    \"value\": {\n      \"optimizeLevel\": 1,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O2z\": {\n    \"value\": {\n      \"optimizeLevel\": 2,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-O3z\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 2\n    }\n  },\n  \"-Ospeed\": {\n    \"value\": {\n      \"optimizeLevel\": 3,\n      \"shrinkLevel\": 0\n    }\n  },\n  \"-Osize\": {\n    \"value\": {\n      \"optimizeLevel\": 0,\n      \"shrinkLevel\": 2,\n      \"converge\": true\n    }\n  },\n  \"--measure\": {\n    \"value\": {\n      \"stats\": true\n    }\n  }\n};\nexport const libraryPrefix = \"~lib/\";\nexport const libraryFiles = {\n  \"account\": \"export class Account {\\n  @inline\\n  constructor(public bytes: ByteArray) {\\n    if (bytes.length != 20)\\n      rollback(\\\"\\\", bytes.length);\\n  }\\n\\n  compare(right: ByteArray): i32 {\\n    let ptr1 = changetype<usize>(this.bytes);\\n    let ptr2 = changetype<usize>(right);\\n    if (ptr1 == ptr2) return 0;\\n\\n    for (let i = 0; max_iterations(20), i < 20; ++i) {\\n      let a = load<u8>(ptr1);\\n      let b = load<u8>(ptr2);\\n      if (a > b)\\n        return 1;\\n      else if (a < b)\\n        return -1;\\n\\n      ++ptr1;\\n      ++ptr2;\\n    }\\n\\n    return 0;\\n  }\\n\\n  @inline @operator(\\\"==\\\")\\n  private static __eq(left: Account, right: ByteArray): bool {\\n    if (right.length != 20)\\n      return false;\\n\\n    let ptr1 = changetype<usize>(left.bytes);\\n    let ptr2 = changetype<usize>(right);\\n    if (ptr1 == ptr2) return true;\\n\\n    // unrolled loop takes less space (and also can be called from a\\n    // loop)\\n    if (load<u64>(ptr1) != load<u64>(ptr2)) return false;\\n    ptr1 += 8;\\n    ptr2 += 8;\\n    if (load<u64>(ptr1) != load<u64>(ptr2)) return false;\\n    ptr1 += 8;\\n    ptr2 += 8;\\n\\n    if (load<u32>(ptr1) != load<u32>(ptr2)) return false;\\n    return true;\\n  }\\n\\n  @inline @operator(\\\"!=\\\")\\n  private static __ne(left: Account, right: ByteArray): bool {\\n    return !this.__eq(left, right);\\n  }\\n}\\n\",\n  \"amount\": \"export class Amount {\\n  @inline\\n  constructor(public bytes: ByteArray) {\\n    if ((bytes.length != 8) && (bytes.length != 48))\\n      rollback(\\\"\\\", bytes.length);\\n  }\\n\\n  @inline\\n  get length(): i32 {\\n    return this.bytes.length;\\n  }\\n\\n  @inline\\n  isXrp(): bool {\\n    return this.length == 8;\\n  }\\n\\n  @inline\\n  get drops(): u64 {\\n    if (!this.isXrp()) unreachable();\\n    if (<u64>(this.bytes[0]) >> 7) unreachable();\\n\\n    return ((<u64>(this.bytes[0]) & 0xb00111111) << 56) +\\n      (<u64>(this.bytes[1]) << 48) +\\n      (<u64>(this.bytes[2]) << 40) +\\n      (<u64>(this.bytes[3]) << 32) +\\n      (<u64>(this.bytes[4]) << 24) +\\n      (<u64>(this.bytes[5]) << 16) +\\n      (<u64>(this.bytes[6]) << 8) +\\n      <u64>(this.bytes[7]);\\n  }\\n\\n  @inline\\n  static fromDrops(drops: u64): Amount {\\n    let buf = new ByteArray(8);\\n    buf[0] = <u8>((drops >> 56) & 0x3F);\\n    buf[1] = <u8>((drops >> 48) & 0xFF);\\n    buf[2] = <u8>((drops >> 40) & 0xFF);\\n    buf[3] = <u8>((drops >> 32) & 0xFF);\\n    buf[4] = <u8>((drops >> 24) & 0xFF);\\n    buf[5] = <u8>((drops >> 16) & 0xFF);\\n    buf[6] = <u8>((drops >> 8) & 0xFF);\\n    buf[7] = <u8>(drops & 0xFF);\\n\\n    return new Amount(buf);\\n  }\\n};\\n\",\n  \"array\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { BLOCK_MAXSIZE } from \\\"./rt/common\\\";\\nimport { Runtime } from \\\"shared/runtime\\\";\\nimport { COMPARATOR, SORT } from \\\"./util/sort\\\";\\nimport { REVERSE, FILL } from \\\"./util/bytes\\\";\\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \\\"./util/string\\\";\\nimport { idof, isArray as builtin_isArray } from \\\"./builtins\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \\\"./util/error\\\";\\n\\n// @ts-ignore: decorator\\n@inline @lazy const MIN_SIZE: usize = 8;\\n\\n/** Ensures that the given array has _at least_ the specified backing size. */\\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\\n  // Depends on the fact that Arrays mimic ArrayBufferView\\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\\n  if (newSize > oldCapacity >>> alignLog2) {\\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\\n    // Grows old capacity by factor of two.\\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\\n    let newData = __renew(oldData, newCapacity);\\n    // __new / __renew already init memory range as zeros in Incremental runtime.\\n    // So try to avoid this.\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\\n    }\\n    if (newData != oldData) { // oldData has been free'd\\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\\\"buffer\\\"));\\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\\\"dataStart\\\"));\\n      __link(array, changetype<usize>(newData), false);\\n    }\\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\\\"byteLength\\\"));\\n  }\\n}\\n\\nexport class Array<T> {\\n  [key: number]: T;\\n\\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\\n\\n  private buffer: ArrayBuffer;\\n  @unsafe readonly dataStart: usize;\\n  private byteLength: i32; // Uses here as capacity\\n\\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\\n  // type-safety anymore. For lack of a better word, such an array is \\\"holey\\\".\\n\\n  private length_: i32;\\n\\n  static isArray<U>(value: U): bool {\\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\\n  }\\n\\n  static create<T>(capacity: i32 = 0): Array<T> {\\n    WARNING(\\\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\\\");\\n    let array = new Array<T>(capacity);\\n    array.length = 0;\\n    return array;\\n  }\\n\\n  constructor(length: i32 = 0) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\\n    // reserve capacity for at least MIN_SIZE elements\\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\\n    }\\n    this.buffer = buffer; // links\\n    this.dataStart = changetype<usize>(buffer);\\n    this.byteLength = <i32>bufferSize;\\n    this.length_ = length;\\n  }\\n\\n  get length(): i32 {\\n    return this.length_;\\n  }\\n\\n  set length(newLength: i32) {\\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\\n    this.length_ = newLength;\\n  }\\n\\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\\n    }\\n    return true;\\n  }\\n\\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\\n    for (let i = this.length_ - 1; i >= 0; --i) {\\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  @operator(\\\"[]\\\") private __get(index: i32): T {\\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\") private __uget(index: i32): T {\\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\\n  }\\n\\n  @operator(\\\"[]=\\\") private __set(index: i32, value: T): void {\\n    if (<u32>index >= <u32>this.length_) {\\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\\n      this.length_ = index + 1;\\n    }\\n    this.__uset(index, value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\") private __uset(index: i32, value: T): void {\\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\\n    if (isManaged<T>()) {\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    }\\n  }\\n\\n  at(index: i32): T {\\n    let len = this.length_;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\\n    if (isManaged<T>()) {\\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\\n      __link(changetype<usize>(this), changetype<usize>(value), false);\\n    } else {\\n      FILL<T>(this.dataStart, this.length_, value, start, end);\\n    }\\n    return this;\\n  }\\n\\n  includes(value: T, fromIndex: i32 = 0): bool {\\n    if (isFloat<T>()) {\\n      let len = this.length_;\\n      if (len == 0 || fromIndex >= len) return false;\\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\\n      let ptr = this.dataStart;\\n      while (fromIndex < len) {\\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\\n        // @ts-ignore\\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\\n        ++fromIndex;\\n      }\\n      return false;\\n    } else {\\n      return this.indexOf(value, fromIndex) >= 0;\\n    }\\n  }\\n\\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\\n    let len = this.length_;\\n    if (len == 0 || fromIndex >= len) return -1;\\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\\n    let ptr = this.dataStart;\\n    while (fromIndex < len) {\\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      ++fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\\n    let len = this.length_;\\n    if (len == 0) return -1;\\n    if (fromIndex < 0) fromIndex = len + fromIndex;\\n    else if (fromIndex >= len) fromIndex = len - 1;\\n    let ptr = this.dataStart;\\n    while (fromIndex >= 0) {\\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      --fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  push(value: T): i32 {\\n    let oldLen = this.length_;\\n    let len = oldLen + 1;\\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\\n    if (isManaged<T>()) {\\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    } else {\\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\\n    }\\n    this.length_ = len;\\n    return len;\\n  }\\n\\n  concat(other: Array<T>): Array<T> {\\n    let thisLen = this.length_;\\n    let otherLen = other.length_;\\n    let outLen = thisLen + otherLen;\\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\\n    let outStart = out.dataStart;\\n    let thisSize = <usize>thisLen << alignof<T>();\\n    if (isManaged<T>()) {\\n      let thisStart = this.dataStart;\\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\\n        let ref = load<usize>(thisStart + offset);\\n        store<usize>(outStart + offset, ref);\\n        __link(changetype<usize>(out), ref, true);\\n      }\\n      outStart += thisSize;\\n      let otherStart = other.dataStart;\\n      let otherSize = <usize>otherLen << alignof<T>();\\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\\n        let ref = load<usize>(otherStart + offset);\\n        store<usize>(outStart + offset, ref);\\n        __link(changetype<usize>(out), ref, true);\\n      }\\n    } else {\\n      memory.copy(outStart, this.dataStart, thisSize);\\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\\n    }\\n    return out;\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\\n    let ptr = this.dataStart;\\n    let len = this.length_;\\n\\n    end = min<i32>(end, len);\\n\\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\\n    let count = min(last - from, len - to);\\n\\n    memory.copy( // is memmove\\n      ptr + (<usize>to << alignof<T>()),\\n      ptr + (<usize>from << alignof<T>()),\\n      <usize>count << alignof<T>()\\n    );\\n    return this;\\n  }\\n\\n  pop(): T {\\n    let len = this.length_;\\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\\n    this.length_ = len;\\n    return val;\\n  }\\n\\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n    }\\n  }\\n\\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\\n    let len = this.length_;\\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\\n    let outStart = out.dataStart;\\n    for (let i = 0; i < min(len, this.length_); ++i) {\\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\\n      if (isManaged<U>()) {\\n        __link(changetype<usize>(out), changetype<usize>(result), true);\\n      }\\n    }\\n    return out;\\n  }\\n\\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\\n      if (fn(value, i, this)) result.push(value);\\n    }\\n    return result;\\n  }\\n\\n  reduce<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  reduceRight<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = this.length_ - 1; i >= 0; --i) {\\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  shift(): T {\\n    let len = this.length_;\\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\\n    let base = this.dataStart;\\n    let element = load<T>(base);\\n    let lastIndex = len - 1;\\n    memory.copy(\\n      base,\\n      base + sizeof<T>(),\\n      <usize>lastIndex << alignof<T>()\\n    );\\n    if (isReference<T>()) {\\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\\n    } else {\\n      // @ts-ignore\\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\\n    }\\n    this.length_ = lastIndex;\\n    return element;\\n  }\\n\\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\\n    }\\n    return false;\\n  }\\n\\n  unshift(value: T): i32 {\\n    let len = this.length_ + 1;\\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\\n    let ptr = this.dataStart;\\n    memory.copy(\\n      ptr + sizeof<T>(),\\n      ptr,\\n      <usize>(len - 1) << alignof<T>()\\n    );\\n    store<T>(ptr, value);\\n    if (isManaged<T>()) {\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    }\\n    this.length_ = len;\\n    return len;\\n  }\\n\\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\\n    let len = this.length_;\\n    start = start < 0 ? max(start + len, 0) : min(start, len);\\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\\n    len = max(end - start, 0);\\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\\n    let sliceBase = slice.dataStart;\\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\\n    if (isManaged<T>()) {\\n      let off = <usize>0;\\n      let end = <usize>len << alignof<usize>();\\n      while (off < end) {\\n        let ref = load<usize>(thisBase + off);\\n        store<usize>(sliceBase + off, ref);\\n        __link(changetype<usize>(slice), ref, true);\\n        off += sizeof<usize>();\\n      }\\n    } else {\\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\\n    }\\n    return slice;\\n  }\\n\\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\\n    let len = this.length_;\\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\\n    let resultStart = result.dataStart;\\n    let thisStart = this.dataStart;\\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\\n    memory.copy(\\n      resultStart,\\n      thisBase,\\n      <usize>deleteCount << alignof<T>()\\n    );\\n    let offset = start + deleteCount;\\n    if (len != offset) {\\n      memory.copy(\\n        thisBase,\\n        thisStart + (<usize>offset << alignof<T>()),\\n        <usize>(len - offset) << alignof<T>()\\n      );\\n    }\\n    this.length_ = len - deleteCount;\\n    return result;\\n  }\\n\\n  reverse(): Array<T> {\\n    REVERSE<T>(this.dataStart, this.length_);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\\n    SORT<T>(this.dataStart, this.length_, comparator);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    let ptr = this.dataStart;\\n    let len = this.length_;\\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\\n    }\\n    // For rest objects and arrays use general join routine\\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\\n    ERROR(\\\"unspported element type\\\");\\n    return <string>unreachable();\\n  }\\n\\n  flat(): T {\\n    if (!isArray<T>()) {\\n      ERROR(\\\"Cannot call flat() on Array<T> where T is not an Array.\\\");\\n    }\\n    // Get the length and data start values\\n    let ptr = this.dataStart;\\n    let len = this.length_;\\n\\n    // calculate the end size with an initial pass\\n    let size = 0;\\n    for (let i = 0; i < len; ++i) {\\n      let child = load<usize>(ptr + (i << alignof<T>()));\\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\\\"length_\\\"));\\n    }\\n\\n    // calculate the byteLength of the resulting backing ArrayBuffer\\n    const align = alignof<valueof<T>>();\\n    let byteLength = <usize>size << align;\\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\\n\\n    // create the return value and initialize it\\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\\\"length_\\\"));\\n\\n    // byteLength, dataStart, and buffer are all readonly\\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\\\"byteLength\\\"));\\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\\\"dataStart\\\"));\\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\\\"buffer\\\"));\\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\\n\\n    // set the elements\\n    let resultOffset: usize = 0;\\n    for (let i = 0; i < len; ++i) { // for each child\\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\\n\\n      // ignore null arrays\\n      if (!child) continue;\\n\\n      // copy the underlying buffer data to the result buffer\\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\\\"length_\\\")) << align;\\n      memory.copy(\\n        changetype<usize>(outBuffer) + resultOffset,\\n        load<usize>(child, offsetof<T>(\\\"dataStart\\\")),\\n        childDataLength\\n      );\\n\\n      // advance the result length\\n      resultOffset += childDataLength;\\n    }\\n\\n    // if the `valueof<T>` type is managed, we must link each reference\\n    if (isManaged<valueof<T>>()) {\\n      for (let i = 0; i < size; ++i) {\\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\\n        __link(changetype<usize>(outBuffer), ref, true);\\n      }\\n    }\\n\\n    return outArray;\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    if (isManaged<T>()) {\\n      let cur = this.dataStart;\\n      let end = cur + (<usize>this.length_ << alignof<T>());\\n      while (cur < end) {\\n        let val = load<usize>(cur);\\n        if (val) __visit(val, cookie);\\n        cur += sizeof<usize>();\\n      }\\n    }\\n    __visit(changetype<usize>(this.buffer), cookie);\\n  }\\n}\\n\",\n  \"arraybuffer\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \\\"./rt/common\\\";\\nimport { Runtime } from \\\"shared/runtime\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { E_INVALIDLENGTH } from \\\"./util/error\\\";\\n\\nexport abstract class ArrayBufferView {\\n\\n  readonly buffer: ArrayBuffer;\\n  @unsafe readonly dataStart: usize;\\n  readonly byteLength: i32;\\n\\n  get byteOffset(): i32 {\\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\\n  }\\n\\n  protected constructor(length: i32, alignLog2: i32) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\\n    }\\n    this.buffer = buffer; // links\\n    this.dataStart = changetype<usize>(buffer);\\n    this.byteLength = length;\\n  }\\n}\\n\\n@final export class ArrayBuffer {\\n\\n  static isView<T>(value: T): bool {\\n    if (isNullable<T>()) {\\n      if (changetype<usize>(value) == 0) return false;\\n    }\\n    if (value instanceof Int8Array) return true;\\n    if (value instanceof Uint8Array) return true;\\n    if (value instanceof Uint8ClampedArray) return true;\\n    if (value instanceof Int16Array) return true;\\n    if (value instanceof Uint16Array) return true;\\n    if (value instanceof Int32Array) return true;\\n    if (value instanceof Uint32Array) return true;\\n    if (value instanceof Int64Array) return true;\\n    if (value instanceof Uint64Array) return true;\\n    if (value instanceof Float32Array) return true;\\n    if (value instanceof Float64Array) return true;\\n    if (value instanceof DataView) return true;\\n    return false;\\n  }\\n\\n  constructor(length: i32) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\\n    }\\n    return buffer;\\n  }\\n\\n  get byteLength(): i32 {\\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\\n    let length = this.byteLength;\\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\\n    let outSize = <usize>max(end - begin, 0);\\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\\n    return out;\\n  }\\n\\n  toString(): string {\\n    return \\\"[object ArrayBuffer]\\\";\\n  }\\n}\\n\",\n  \"atomics\": \"import { ArrayBufferView } from \\\"./arraybuffer\\\";\\nimport { E_INDEXOUTOFRANGE } from \\\"./util/error\\\";\\n\\nexport namespace Atomics {\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function load<T extends ArrayBufferView>(array: T, index: i32): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.load<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function store<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): void {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    atomic.store<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function add<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.add<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function sub<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.sub<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function and<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.and<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function or<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.or<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function xor<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.xor<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function exchange<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.xchg<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      value\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function compareExchange<T extends ArrayBufferView>(\\n    array: T,\\n    index: i32,\\n    expectedValue: valueof<T>,\\n    replacementValue: valueof<T>\\n  ): valueof<T> {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.cmpxchg<valueof<T>>(\\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\\n      expectedValue,\\n      replacementValue\\n    );\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function wait<T extends ArrayBufferView>(array: T, value: valueof<T>, timeout: i64 = -1): AtomicWaitResult {\\n    return atomic.wait<valueof<T>>(changetype<usize>(array.buffer) + array.byteOffset, value, timeout);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function notify<T extends ArrayBufferView>(array: T, index: i32, count: i32 = -1): i32 {\\n    const align = alignof<valueof<T>>();\\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return atomic.notify(changetype<usize>(array.buffer) + (index << align) + array.byteOffset, count);\\n  }\\n\\n  export function isLockFree(size: usize): bool {\\n    return size == 1 || size == 2 || size == 4;\\n  }\\n}\\n\",\n  \"bindings/asyncify\": \"@unmanaged\\nexport class StackDescriptor {\\n  /** The index in linear memory of the start of the \u201Casyncify stack\u201D. */\\n  stackStart: usize;\\n  /** The index of the end of that stack region, which implies how big it is. */\\n  stackEnd: usize;\\n}\\n\\n/** Starts to unwind the call stack. */\\nexport declare function start_unwind(data: StackDescriptor): void;\\n/** Stops unwinding the call stack. */\\nexport declare function stop_unwind(): void;\\n/** Starts to rewind the call stack. */\\nexport declare function start_rewind(data: StackDescriptor): void;\\n/** Stops rewinding the call stack. */\\nexport declare function stop_rewind(): void;\\n\",\n  \"bindings/dom\": \"import {\\n  _01_02_ENCODE_TT,\\n  _02_02_ENCODE_FLAGS,\\n  _02_03_ENCODE_TAG_SRC,\\n  _02_04_ENCODE_SEQUENCE,\\n  _02_14_ENCODE_TAG_DST,\\n  _02_26_ENCODE_FLS,\\n  _02_27_ENCODE_LLS,\\n  _06_01_ENCODE_DROPS_AMOUNT,\\n  _06_01_ENCODE_TL_AMOUNT,\\n  _06_08_ENCODE_DROPS_FEE,\\n  _07_03_ENCODE_SIGNING_PUBKEY_NULL,\\n  _08_01_ENCODE_ACCOUNT_SRC,\\n  _08_03_ENCODE_ACCOUNT_DST,\\n  tfCANONICAL,\\n  ttPAYMENT\\n} from \\\"./encode\\\";\\n\\n@external(\\\"env\\\", \\\"globalThis\\\")\\nexport declare const globalThis: externref;\\n\\nexport declare namespace Math {\\n  @external(\\\"env\\\", \\\"Math.E\\\")\\n  export const E: f64;\\n  @external(\\\"env\\\", \\\"Math.LN2\\\")\\n  export const LN2: f64;\\n  @external(\\\"env\\\", \\\"Math.LN10\\\")\\n  export const LN10: f64;\\n  @external(\\\"env\\\", \\\"Math.LOG2E\\\")\\n  export const LOG2E: f64;\\n  @external(\\\"env\\\", \\\"Math.LOG10E\\\")\\n  export const LOG10E: f64;\\n  @external(\\\"env\\\", \\\"Math.PI\\\")\\n  export const PI: f64;\\n  @external(\\\"env\\\", \\\"Math.SQRT1_2\\\")\\n  export const SQRT1_2: f64;\\n  @external(\\\"env\\\", \\\"Math.SQRT2\\\")\\n  export const SQRT2: f64;\\n  @external(\\\"env\\\", \\\"Math.abs\\\")\\n  export function abs(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.acos\\\")\\n  export function acos(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.acosh\\\")\\n  export function acosh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.asin\\\")\\n  export function asin(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.asinh\\\")\\n  export function asinh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.atan\\\")\\n  export function atan(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.atan2\\\")\\n  export function atan2(y: f64, x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.atanh\\\")\\n  export function atanh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.cbrt\\\")\\n  export function cbrt(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.ceil\\\")\\n  export function ceil(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.clz32\\\")\\n  export function clz32(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.cos\\\")\\n  export function cos(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.cosh\\\")\\n  export function cosh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.exp\\\")\\n  export function exp(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.expm1\\\")\\n  export function expm1(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.floor\\\")\\n  export function floor(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.fround\\\")\\n  export function fround(x: f64): f32;\\n  @external(\\\"env\\\", \\\"Math.hypot\\\")\\n  export function hypot(value1: f64, value2: f64): f64; // TODO: rest\\n  @external(\\\"env\\\", \\\"Math.imul\\\")\\n  export function imul(a: f64, b: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log\\\")\\n  export function log(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log10\\\")\\n  export function log10(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log1p\\\")\\n  export function log1p(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.log2\\\")\\n  export function log2(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.max\\\")\\n  export function max(value1: f64, value2: f64): f64; // TODO: rest\\n  @external(\\\"env\\\", \\\"Math.min\\\")\\n  export function min(value1: f64, value2: f64): f64; // TODO: rest\\n  @external(\\\"env\\\", \\\"Math.pow\\\")\\n  export function pow(base: f64, exponent: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.random\\\")\\n  export function random(): f64;\\n  @external(\\\"env\\\", \\\"Math.round\\\")\\n  export function round(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sign\\\")\\n  export function sign(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sin\\\")\\n  export function sin(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sinh\\\")\\n  export function sinh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.sqrt\\\")\\n  export function sqrt(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.tan\\\")\\n  export function tan(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.tanh\\\")\\n  export function tanh(x: f64): f64;\\n  @external(\\\"env\\\", \\\"Math.trunc\\\")\\n  export function trunc(x: f64): f64;\\n}\\n\\nexport declare namespace Reflect {\\n  @external(\\\"env\\\", \\\"Reflect.get\\\")\\n  export function get(target: externref, propertyKey: string): externref;\\n  @external(\\\"env\\\", \\\"Reflect.getWithReceiver\\\")\\n  @external.js(\\\"return Reflect.get(target, propertyKey, receiver);\\\")\\n  export function getWithReceiver(target: externref, propertyKey: string, receiver: externref): externref;\\n  @external(\\\"env\\\", \\\"Reflect.has\\\")\\n  export function has(target: externref, propertyKey: string): bool;\\n  @external(\\\"env\\\", \\\"Reflect.set\\\")\\n  export function set(target: externref, propertyKey: string, value: externref): externref;\\n  @external(\\\"env\\\", \\\"Reflect.setWithReceiver\\\")\\n  @external.js(\\\"return Reflect.set(target, propertyKey, value, receiver);\\\")\\n  export function setWithReceiver(target: externref, propertyKey: string, value: externref , receiver: externref): externref;\\n  @external(\\\"env\\\", \\\"Reflect.apply\\\")\\n  export function apply(target: externref, thisArgument: externref, argumentsList: externref): externref;\\n}\\n\\nexport declare namespace String {\\n  @external(\\\"env\\\", \\\"String.fromCodePoint\\\")\\n  export function fromCodePoint(codepoint: i32): externref;\\n  @external(\\\"env\\\", \\\"String.fromCodePoints\\\")\\n  @external.js(\\\"return String.fromCodePoint(...codepoints);\\\")\\n  export function fromCodePoints(codepoints: i32[]): externref;\\n}\\n\\nexport declare namespace Object {\\n  @external(\\\"env\\\", \\\"Object.is\\\")\\n  export function is(a: externref, b: externref): bool;\\n  @external(\\\"env\\\", \\\"Object.hasOwn\\\")\\n  export function hasOwn(target: externref, propertyKey: string): bool;\\n  @external(\\\"env\\\", \\\"Object.assign\\\")\\n  export function assign(target: externref, source: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.keys\\\")\\n  export function keys(target: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.values\\\")\\n  export function values(target: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.entries\\\")\\n  export function entries(target: externref): externref;\\n  @external(\\\"env\\\", \\\"Object.getOwnPropertyNames\\\")\\n  export function getOwnPropertyNames(target: externref): externref;\\n}\\n\\nexport declare namespace Date {\\n  @external(\\\"env\\\", \\\"Date.now\\\")\\n  export function now(): f64;\\n}\\n\\nexport declare namespace console {\\n  @external(\\\"env\\\", \\\"console.assert\\\")\\n  export function assert(condition: bool, message: string): void;\\n  @external(\\\"env\\\", \\\"console.debug\\\")\\n  export function debug(text: string): void;\\n  @external(\\\"env\\\", \\\"console.info\\\")\\n  export function info(text: string): void;\\n  @external(\\\"env\\\", \\\"console.warn\\\")\\n  export function warn(text: string): void;\\n  @external(\\\"env\\\", \\\"console.error\\\")\\n  export function error(text: string): void;\\n  @external(\\\"env\\\", \\\"console.time\\\")\\n  export function time(label: string): void;\\n  @external(\\\"env\\\", \\\"console.timeLog\\\")\\n  export function timeLog(label: string): void;\\n  @external(\\\"env\\\", \\\"console.timeEnd\\\")\\n  export function timeEnd(label: string): void;\\n}\\n\\nexport namespace console {\\n  @inline\\n  function log(text: string): void {\\n    trace(text, text.length, 0, 0, 0);\\n  }\\n}\\n\\n@global @inline\\nexport function accept(msg: string = \\\"\\\", err: i64 = 0): void {\\n  $accept(msg, msg.length, err);\\n  // does not return\\n}\\n\\n@global @inline\\nexport function emit(tx: EmitSpec): Bytes32 {\\n  // 288 for non-XRP transactions is bigger than\\n  // PREPARE_PAYMENT_SIMPLE_TRUSTLINE_SIZE in macro.h (287) because\\n  // macro.h is incorrect\\n  let buf = new ByteArray(tx.amount.isXrp() ? 248 : 288); // FIXME: w/o cbak only, so far\\n  let cls = <u32>ledger_seq();\\n  let acc = hook_account();\\n\\n  let buf_out = changetype<u32>(buf);\\n  buf_out = _01_02_ENCODE_TT(buf_out, ttPAYMENT);\\n  buf_out = _02_02_ENCODE_FLAGS(buf_out, tfCANONICAL);\\n  buf_out = _02_03_ENCODE_TAG_SRC(buf_out, tx.sourceTag);\\n  buf_out = _02_04_ENCODE_SEQUENCE(buf_out, 0);\\n  buf_out = _02_14_ENCODE_TAG_DST(buf_out, tx.destinationTag);\\n  buf_out = _02_26_ENCODE_FLS(buf_out, cls + 1);\\n  buf_out = _02_27_ENCODE_LLS(buf_out, cls + 5);\\n  if (tx.amount.isXrp())\\n    buf_out = _06_01_ENCODE_DROPS_AMOUNT(buf_out, tx.amount.bytes);\\n  else\\n    buf_out = _06_01_ENCODE_TL_AMOUNT(buf_out, tx.amount.bytes);\\n  let fee_ptr = buf_out;\\n  buf_out = _06_08_ENCODE_DROPS_FEE(buf_out, 0);\\n  buf_out = _07_03_ENCODE_SIGNING_PUBKEY_NULL(buf_out);\\n  buf_out = _08_01_ENCODE_ACCOUNT_SRC(buf_out, changetype<u32>(acc));\\n  buf_out = _08_03_ENCODE_ACCOUNT_DST(buf_out, changetype<u32>(tx.account.bytes));\\n\\n  // doesn't check return value\\n  $etxn_details(buf_out, buf.length - (buf_out - changetype<u32>(buf)));\\n\\n  // ditto\\n  let fee = $etxn_fee_base(changetype<u32>(buf), buf.length);\\n  _06_08_ENCODE_DROPS_FEE(fee_ptr, fee);\\n\\n  let emit_hash = new Bytes32();\\n  let emit_result = $emit(changetype<u32>(emit_hash), 32, changetype<u32>(buf), buf.length);\\n  if (emit_result < 0)\\n    rollback(\\\"\\\", emit_result);\\n\\n  return emit_hash;\\n}\\n\\n@global @inline\\nexport function emit_sto(buffer: ByteArray): Bytes32 {\\n  let fee_to_pay = $etxn_fee_base(changetype<u32>(buffer), buffer.length);\\n  if (fee_to_pay < 0)\\n    rollback(\\\"\\\", fee_to_pay);\\n\\n  let fee_buf = new ByteArray(9);\\n  _06_08_ENCODE_DROPS_FEE(changetype<u32>(fee_buf), fee_to_pay);\\n  let buffer2 = new ByteArray(buffer.length + 13);\\n  let r = $sto_emplace(changetype<u32>(buffer2), buffer2.length, changetype<u32>(buffer), buffer.length, changetype<u32>(fee_buf), 9, sfFee);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  buffer2.length = <i32>r;\\n\\n  let emit_hash = new Bytes32();\\n  let emit_result = $emit(changetype<u32>(emit_hash), 32, changetype<u32>(buffer2), buffer2.length);\\n  if (emit_result < 0)\\n    rollback(\\\"\\\", emit_result);\\n\\n  return emit_hash;\\n}\\n\\n@global @inline\\nexport function etxn_reserve(count: u32): void {\\n  let r = $etxn_reserve(count);\\n  if (r != count)\\n    rollback(\\\"\\\", r);\\n}\\n\\n@global @inline\\nexport function float_compare(float1: i64, float2: i64, mode: u32): i32 {\\n  let r = $float_compare(float1, float2, mode);\\n  if ((r < 0) || (r > 1))\\n    rollback(\\\"\\\", r);\\n\\n  return <i32>r;\\n}\\n\\n@global @inline\\nexport function float_divide(float1: i64, float2: i64): i64 {\\n  let r = $float_divide(float1, float2);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function float_int(float1: i64, dec: u32, abs: u32): i64 {\\n  let r = $float_int(float1, dec, abs);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function float_mulratio(float1: i64, round_up: u32, numerator: u32, denominator: u32): i64 {\\n  let r = $float_mulratio(float1, round_up, numerator, denominator);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function float_multiply(float1: i64, float2: i64): i64 {\\n  let r = $float_multiply(float1, float2);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function float_negate(float1: i64): i64 {\\n  let r = $float_negate(float1);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function float_set(exponent: i32, mantissa: i64): i64 {\\n  let r = $float_set(exponent, mantissa);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function float_sto(currency: ByteView, issuer: ByteView, float1: i64, field: i32, el: i32 = 8): ByteArray {\\n  let a = new ByteArray(el);\\n  let r = $float_sto(\\n    changetype<u32>(a), el,\\n    changetype<u32>(currency.underlying) + currency.offset, currency.length,\\n    changetype<u32>(issuer.underlying) + issuer.offset, issuer.length,\\n    float1,\\n    field);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return a;\\n}\\n\\n@global @inline\\nexport function float_sto_set(data: ByteView): i64 {\\n  let r = $float_sto_set(changetype<u32>(data.underlying) + data.offset, data.length);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function float_sum(float1: i64, float2: i64): i64 {\\n  let r = $float_sum(float1, float2);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function hook_account(): ByteArray {\\n  let a = new ByteArray(20);\\n  let r = $hook_account(changetype<u32>(a), 20);\\n  if (r != 20)\\n    rollback(\\\"\\\", r);\\n\\n  return a;\\n}\\n\\n@global @inline\\nexport function hook_param(name: string): ByteArray {\\n  let a = new ByteArray(64);\\n  let r = $hook_param(changetype<u32>(a), 64, changetype<u32>(name), name.length);\\n  if (r < 0)\\n    r = 0;\\n\\n  a.length = <i32>r;\\n  return a;\\n}\\n\\n@global @inline\\nexport function otxn_slot(sn: i32): i32 {\\n  let r = $otxn_slot(sn);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return <i32>r;\\n}\\n\\n@global @inline\\nexport function rollback(msg: string = \\\"\\\", err: i64 = 0): void {\\n  $rollback(msg, msg.length, err);\\n  // does not return\\n}\\n\\n@global @inline\\nexport function slot(sn: i32, el: i32 = 64): ByteArray {\\n  let a = new ByteArray(el);\\n  let r = $slot(changetype<u32>(a), <u32>el, <u32>sn);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return a;\\n}\\n\\n@global @inline\\nexport function slot_count(sn: i32): i32 {\\n  let r = $slot_count(<u32>sn);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return <i32>r;\\n}\\n\\n@global @inline\\nexport function slot_float(sn: i32): i64 {\\n  let r = $slot_float(<u32>sn);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return r;\\n}\\n\\n@global @inline\\nexport function slot_set(keylet: ByteArray, sn: i32): i32 {\\n  let r = $slot_set(changetype<u32>(keylet), <u32>(keylet.length), <u32>sn);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return <i32>r;\\n}\\n\\n@global @inline\\nexport function slot_subarray(parent: i32, idx: i32, target: i32): i32 {\\n  let r = $slot_subarray(<u32>parent, <u32>idx, <u32>target);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return <i32>r;\\n}\\n\\n@global @inline\\nexport function slot_subfield(parent: i32, field: i32, target: i32): i32 {\\n  let r = $slot_subfield(<u32>parent, <u32>field, <u32>target);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return <i32>r;\\n}\\n\\n@global @inline\\nexport function slot_type(sn: u32, flags: u32): i32 {\\n  let r = $slot_type(sn, flags);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return <i32>r;\\n}\\n\\n@global @inline\\nexport function state(key: ByteArray, el: i32 = 64): ByteArray {\\n  let a = new ByteArray(el);\\n  let r = $state(changetype<u32>(a), <u32>el, changetype<u32>(key), key.length);\\n  if (r < 0)\\n    r = 0;\\n\\n  a.length = <i32>r;\\n  return a;\\n}\\n\\n@global @inline\\nexport function state_foreign(key: ByteArray, ns: ByteArray, acc: ByteArray, el: i32 = 64): ByteArray {\\n  let a = new ByteArray(el);\\n  let r = $state_foreign(changetype<u32>(a), <u32>el, changetype<u32>(key), key.length, changetype<u32>(ns), ns.length, changetype<u32>(acc), acc.length);\\n  if (r < 0)\\n    r = 0;\\n\\n  a.length = <i32>r;\\n  return a;\\n}\\n\\n@global @inline\\nexport function state_set(key: ByteArray, data: ByteView): void {\\n  let r = $state_set(changetype<u32>(data.underlying) + data.offset, data.length, changetype<u32>(key), key.length);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n}\\n\\n@global @inline\\nexport function sto_emplace(obj: ByteView, field: ByteView, fid: i32): ByteArray {\\n  let a = new ByteArray(obj.length + field.length + 4);\\n  let r = $sto_emplace(changetype<u32>(a), a.length, changetype<u32>(obj.underlying) + obj.offset, obj.length, changetype<u32>(field.underlying) + field.offset, field.length, fid);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  a.length = <i32>r;\\n  return a;\\n}\\n\\n@global @inline\\nexport function sto_erase(obj: ByteView, fid: i32): ByteView {\\n  let a = new ByteArray(obj.length);\\n  let r = $sto_erase(changetype<u32>(a), a.length, changetype<u32>(obj.underlying) + obj.offset, obj.length, fid);\\n  if (r == -5) { // DOESNT_EXIST\\n    return obj;\\n  }\\n\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  return new ByteView(a, 0, <i32>r);\\n}\\n\\n@global @inline\\nexport function sto_subarray(array: ByteView, index: i32): ByteView {\\n  let r = $sto_subarray(changetype<u32>(array.underlying) + array.offset, <u32>(array.length), <u32>index);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  let offset = <i32>(r >> 32);\\n  let length = <i32>(r & 0xFFFFFFFF);\\n  return new ByteView(array.underlying, array.offset + offset, length);\\n}\\n\\n@global @inline\\nexport function sto_subfield(obj: ByteView, fid: i32): ByteView {\\n  let r = $sto_subfield(changetype<u32>(obj.underlying) + obj.offset, <u32>(obj.length), <u32>fid);\\n  if (r < 0)\\n    rollback(\\\"\\\", r);\\n\\n  let offset = <i32>(r >> 32);\\n  let length = <i32>(r & 0xFFFFFFFF);\\n  return new ByteView(obj.underlying, obj.offset + offset, length);\\n}\\n\\n@global @inline\\nexport function trace_float(msg: string, fln: i64): void {\\n  $trace_float(msg, msg.length, fln);\\n}\\n\\n@global @inline\\nexport function trace_num(msg: string, num: i64): void {\\n  $trace_num(msg, msg.length, num);\\n  // could check return value here, but C macros don't do it either...\\n}\\n\\n@global @inline\\nexport function util_accid(raddr: string): ByteArray {\\n  let a = new ByteArray(20);\\n  let r = $util_accid(changetype<u32>(a), 20, changetype<u32>(raddr), raddr.length);\\n  if (r < 20)\\n    rollback(\\\"\\\", r);\\n\\n  return a;\\n}\\n\\n@global @inline\\nexport function util_sha512h(data: ByteView): ByteArray {\\n  let a = new ByteArray(32);\\n  let r = $util_sha512h(changetype<u32>(a), 32, changetype<u32>(data.underlying) + data.offset, data.length);\\n  if (r < 32)\\n    rollback(\\\"\\\", r);\\n\\n  return a;\\n}\\n\\nexport declare namespace document {\\n  /** Returns document's encoding. */\\n  @external(\\\"env\\\", \\\"document.characterSet\\\")\\n  export const characterSet: string;\\n  /** Returns a value that indicates whether standards-compliant mode is switched on for the object. */\\n  @external(\\\"env\\\", \\\"document.compatMode\\\")\\n  export const compatMode: string;\\n  /** Returns document's content type. */\\n  @external(\\\"env\\\", \\\"document.contentType\\\")\\n  export const contentType: string;\\n  /** Returns a reference to the root node of the document. */\\n  @external(\\\"env\\\", \\\"document.documentElement\\\")\\n  export const documentElement: externref;\\n  /** Returns document's URL. */\\n  @external(\\\"env\\\", \\\"document.documentURI\\\")\\n  export const documentURI: string;\\n  /** Returns the URL of the location that referred the user to the current page. */\\n  @external(\\\"env\\\", \\\"document.referrer\\\")\\n  export const referrer: string;\\n  /** Returns true if document has the ability of fullscreen mode, or false otherwise. */\\n  @external(\\\"env\\\", \\\"document.pictureInPictureEnabled\\\")\\n  export const fullscreenEnabled: bool;\\n  /** Returns true if document has the ability of picture-in-picture mode, or false otherwise. */\\n  @external(\\\"env\\\", \\\"document.pictureInPictureEnabled\\\")\\n  export const pictureInPictureEnabled: bool;\\n\\n  /** Returns the number of child elements. */\\n  @external(\\\"env\\\", \\\"document.childElementCount\\\")\\n  export const childElementCount: i32;\\n  /** Returns the child elements. */\\n  @external(\\\"env\\\", \\\"document.children\\\")\\n  export const children: externref;\\n  /** Returns the first child that is an element, and null otherwise. */\\n  @external(\\\"env\\\", \\\"document.firstElementChild\\\")\\n  export const firstElementChild: externref;\\n  /** Returns the last child that is an element, and null otherwise. */\\n  @external(\\\"env\\\", \\\"document.lastElementChild\\\")\\n  export const lastElementChild: externref;\\n\\n  /**\\n   * Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied\\n   * to this resource, the empty string will be returned.\\n   *\\n   * Can be set, to add a new cookie to the element's set of HTTP cookies.\\n   *\\n   * If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute),\\n   * a \\\"SecurityError\\\" DOMException will be thrown on getting and setting.\\n   */\\n  @external(\\\"env\\\", \\\"document.cookie\\\")\\n  export let cookie: string;\\n  /** Represents the <body> or <frameset> node of the current document, or null if no such element exists. */\\n  @external(\\\"env\\\", \\\"document.body\\\")\\n  export let body: externref;\\n  /** Sets or gets the security domain of the document. */\\n  @external(\\\"env\\\", \\\"document.domain\\\")\\n  export let domain: string;\\n  /** Sets or gets the title of the document. */\\n  @external(\\\"env\\\", \\\"document.title\\\")\\n  export let title: string;\\n  /** Sets or gets information about the current Location. */\\n  @external(\\\"env\\\", \\\"document.location\\\")\\n  export let location: externref;\\n  /** Sets or gets the URL for the current document. */\\n  @external(\\\"env\\\", \\\"document.URL\\\")\\n  export let URL: string;\\n\\n  /**\\n   * Creates an instance of the element for the specified tag.\\n   * @param tagName The name of an element.\\n   */\\n  @external(\\\"env\\\", \\\"document.createElement\\\")\\n  export function createElement(tagName: string /* , options?: ElementCreationOptions */): externref;\\n  /**\\n   * Returns a reference to the first HTMLElement object with the specified value of the ID attribute.\\n   * @param id String that specifies the ID value.\\n   */\\n  @external(\\\"env\\\", \\\"document.getElementById\\\")\\n  export function getElementById(id: string): externref;\\n  /**\\n   * Returns a HTMLCollection of the elements in the object on which the method was invoked that have all the classes\\n   * given by classNames. The classNames argument is interpreted as a space-separated list of classes.\\n   * @param classNames Gets a collection of objects based on the value of the CLASS attribute.\\n   */\\n  @external(\\\"env\\\", \\\"document.getElementsByClassName\\\")\\n  export function getElementsByClassName(classNames: string): externref;\\n  /**\\n   * Gets a collection of HTMLElement objects based on the value of the NAME or ID attribute.\\n   * @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.\\n   */\\n  @external(\\\"env\\\", \\\"document.getElementsByName\\\")\\n  export function getElementsByName(elementName: string): externref;\\n  /** Gets a value indicating whether the object currently has focus. */\\n  @external(\\\"env\\\", \\\"document.hasFocus\\\")\\n  export function hasFocus(): bool;\\n  /** Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes. */\\n  @external(\\\"env\\\", \\\"document.append\\\")\\n  export function append(node: externref): void;\\n  /** Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes. */\\n  @external(\\\"env\\\", \\\"document.prepend\\\")\\n  export function prepend(node: externref): void;\\n  /** Replace all children of node with nodes, while replacing strings in nodes with equivalent Text nodes. */\\n  @external(\\\"env\\\", \\\"document.replaceChildren\\\")\\n  export function replaceChildren(node: externref): void;\\n  /**\\n   * Writes one or more HTML expressions to a document in the specified window.\\n   * @param content Specifies the text and HTML tags to write.\\n   */\\n  @external(\\\"env\\\", \\\"document.write\\\")\\n  export function write(content: string): void;\\n  /**\\n   * Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window.\\n   * @param content Specifies the text and HTML tags to write.\\n   */\\n  @external(\\\"env\\\", \\\"document.writeln\\\")\\n  export function writeln(content: string): void;\\n}\\n\\nexport declare namespace performance {\\n  @external(\\\"env\\\", \\\"performance.now\\\")\\n  export function now(): f64;\\n}\\n\\nexport namespace crypto {\\n  export function getRandomValues(array: Uint8Array): void {\\n    let values = getRandomValuesN(array.length);\\n    array.set(values);\\n  }\\n  @external(\\\"env\\\", \\\"crypto.getRandomValuesN\\\")\\n  @external.js(\\\"let a = new Uint8Array(n); crypto.getRandomValues(a); return a;\\\")\\n  export declare function getRandomValuesN(n: u32): Uint8Array;\\n}\\n\",\n  \"bindings/encode\": \"// @ts-ignore: decorator\\n@lazy\\nexport const ttPAYMENT: u8 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const tfCANONICAL: u32 = 0x80000000;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const atACCOUNT: u8 = 1;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const atDESTINATION: u8 = 3;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const amAMOUNT: u8 = 1;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const amFEE: u8 = 8;\\n\\n@inline\\nexport function ENCODE_TL(buf: u32, tlamt: u32, uat: u8): u32 {\\n  store<u8>(buf, 0x60 + (uat & 0x0F));\\n  for (let i = 0; max_iterations(6), i < 48; i += 8)\\n    store<u64>(buf + i + 1, load<u64>(tlamt + i));\\n  return buf + 49;\\n}\\n\\n@inline\\nexport function ENCODE_TT(buf: u32, utt: u8): u32 {\\n  store<u8>(buf, 0x12);\\n  store<u8>(buf + 1, 0);\\n  store<u8>(buf + 2, utt);\\n  return buf + 3;\\n}\\n\\n@inline\\nexport function ENCODE_UINT32_COMMON(buf: u32, ui: u32, uf: u8): u32 {\\n  store<u8>(buf, 0x20 + (uf & 0x0F));\\n  store<u8>(buf + 1, (ui >> 24) & 0xFF);\\n  store<u8>(buf + 2, (ui >> 16) & 0xFF);\\n  store<u8>(buf + 3, (ui >> 8) & 0xFF);\\n  store<u8>(buf + 4, ui & 0xFF);\\n  return buf + 5;\\n}\\n\\n@inline\\nexport function ENCODE_UINT32_UNCOMMON(buf: u32, ui: u32, uf: u8): u32 {\\n  store<u8>(buf, 0x20);\\n  store<u8>(buf + 1, uf);\\n  // store<u32>?\\n  store<u8>(buf + 2, (ui >> 24) & 0xFF);\\n  store<u8>(buf + 3, (ui >> 16) & 0xFF);\\n  store<u8>(buf + 4, (ui >> 8) & 0xFF);\\n  store<u8>(buf + 5, ui & 0xFF);\\n  return buf + 6;\\n}\\n\\n@inline\\nexport function ENCODE_DROPS(buf: u32, udrops: u64, uat: u8): u32 {\\n  store<u8>(buf, 0x60 + (uat & 0x0F));\\n  // store<u64> (+ 1*store<u8>)?\\n  store<u8>(buf + 1, 0x40 + ((udrops >> 56) & 0x3F));\\n  store<u8>(buf + 2, (udrops >> 48) & 0xFF);\\n  store<u8>(buf + 3, (udrops >> 40) & 0xFF);\\n  store<u8>(buf + 4, (udrops >> 32) & 0xFF);\\n  store<u8>(buf + 5, (udrops >> 24) & 0xFF);\\n  store<u8>(buf + 6, (udrops >> 16) & 0xFF);\\n  store<u8>(buf + 7, (udrops >> 8) & 0xFF);\\n  store<u8>(buf + 8, udrops & 0xFF);\\n  return buf + 9;\\n}\\n\\n@inline\\nexport function ENCODE_DROPS_ARRAY(buf: u32, drops: ByteArray, uat: u8): u32 {\\n  store<u8>(buf, 0x60 + (uat & 0x0F));\\n  store<u8>(buf + 1, 0x40 + drops[0]);\\n  store<u8>(buf + 2, drops[1]);\\n  store<u8>(buf + 3, drops[2]);\\n  store<u8>(buf + 4, drops[3]);\\n  store<u8>(buf + 5, drops[4]);\\n  store<u8>(buf + 6, drops[5]);\\n  store<u8>(buf + 7, drops[6]);\\n  store<u8>(buf + 8, drops[7]);\\n  return buf + 9;\\n}\\n\\n@inline\\nexport function ENCODE_ACCOUNT(buf: u32, account_id: u32, uat: u8): u32 {\\n  store<u8>(buf, 0x80 + uat);\\n  store<u8>(buf + 1, 0x14);\\n  store<u64>(buf + 2, load<u64>(account_id));\\n  store<u64>(buf + 10, load<u64>(account_id + 8));\\n  store<u32>(buf + 18, load<u32>(account_id + 16));\\n  return buf + 22;\\n}\\n\\n@inline\\nexport function _01_02_ENCODE_TT(buf: u32, tt: u8): u32 {\\n  return ENCODE_TT(buf, tt);\\n}\\n\\n@inline\\nexport function _02_02_ENCODE_FLAGS(buf: u32, tag: u32): u32 {\\n  return ENCODE_UINT32_COMMON(buf, tag, 0x2);\\n}\\n\\n@inline\\nexport function _02_03_ENCODE_TAG_SRC(buf: u32, tag: u32): u32 {\\n  return ENCODE_UINT32_COMMON(buf, tag, 0x3);\\n}\\n\\n@inline\\nexport function _02_04_ENCODE_SEQUENCE(buf: u32, sequence: u32): u32 {\\n  return ENCODE_UINT32_COMMON(buf, sequence, 0x4);\\n}\\n\\n@inline\\nexport function _02_14_ENCODE_TAG_DST(buf: u32, tag: u32): u32 {\\n  return ENCODE_UINT32_COMMON(buf, tag, 0xE);\\n}\\n\\n@inline\\nexport function _02_26_ENCODE_FLS(buf: u32, fls: u32): u32 {\\n  return ENCODE_UINT32_UNCOMMON(buf, fls, 0x1A);\\n}\\n\\n@inline\\nexport function _02_27_ENCODE_LLS(buf: u32, lls: u32): u32 {\\n  return ENCODE_UINT32_UNCOMMON(buf, lls, 0x1B);\\n}\\n\\n@inline\\nexport function _06_01_ENCODE_DROPS_AMOUNT(buf: u32, drops: ByteArray): u32 {\\n  return ENCODE_DROPS_ARRAY(buf, drops, amAMOUNT);\\n}\\n\\n@inline\\nexport function _06_01_ENCODE_TL_AMOUNT(buf: u32, drops: ByteArray): u32 {\\n  return ENCODE_TL(buf, changetype<u32>(drops), amAMOUNT);\\n}\\n\\n@inline\\nexport function _06_08_ENCODE_DROPS_FEE(buf: u32, drops: u64): u32 {\\n  return ENCODE_DROPS(buf, drops, amFEE);\\n}\\n\\n@inline\\nexport function _07_03_ENCODE_SIGNING_PUBKEY_NULL(buf: u32): u32 {\\n  store<u8>(buf, 0x73);\\n  store<u8>(buf + 1, 0x21);\\n  store<u64>(buf + 2, 0);\\n  store<u64>(buf + 10, 0);\\n  store<u64>(buf + 18, 0);\\n  store<u64>(buf + 25, 0);\\n  return buf + 35;\\n}\\n\\n@inline\\nexport function _08_01_ENCODE_ACCOUNT_SRC(buf: u32, account_id: u32): u32 {\\n  return ENCODE_ACCOUNT(buf, account_id, atACCOUNT);\\n}\\n\\n@inline\\nexport function _08_03_ENCODE_ACCOUNT_DST(buf: u32, account_id: u32): u32 {\\n  return ENCODE_ACCOUNT(buf, account_id, atDESTINATION);\\n}\\n\",\n  \"bindings/node\": \"export declare namespace process {\\n  @external(\\\"env\\\", \\\"process.argv\\\")\\n  export const argv: string[];\\n  @external(\\\"env\\\", \\\"process.exit\\\")\\n  export function exit(code: i32): void;\\n}\\n\",\n  \"builtins\": \"import { strtol, strtod, strtob } from \\\"./util/string\\\";\\n\\ntype auto = i32;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isBoolean<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isInteger<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isSigned<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isFloat<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isVector<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isReference<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isString<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isArray<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isArrayLike<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isFunction<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isNullable<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isDefined(expression: auto): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isConstant(expression: auto): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isManaged<T>(value?: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isVoid<T>(): bool;\\n\\n// @ts-ignore\\n@builtin\\nexport declare function lengthof<T>(func?: T): i32;\\n\\n// @ts-ignore\\n@builtin\\nexport declare function bswap<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function clz<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function ctz<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function popcnt<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function rotl<T>(value: T, shift: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function rotr<T>(value: T, shift: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function abs<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function max<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function min<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function ceil<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function floor<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function copysign<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function nearest<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function reinterpret<T>(value: number): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function sqrt<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function trunc<T>(value: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function add<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function sub<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function mul<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function div<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function eq<T>(left: T, right: T): i32;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function ne<T>(left: T, right: T): i32;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function rem<T>(left: T, right: T): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function sizeof<T>(): usize; // | u32 / u64\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function alignof<T>(): usize; // | u32 / u64\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function idof<T>(): u32;\\n\\n// @ts-ignore\\n@builtin\\nexport declare function nameof<T>(): string;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function unreachable(): auto;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function changetype<T>(value: auto): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function assert<T>(isTrueish: T, message?: string): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function unchecked<T>(expr: T): T;\\n\\n// @ts-ignore: decorator\\n@unsafe @builtin\\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function instantiate<T>(...args: auto[]): T;\\n\\nexport namespace atomic {\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function notify(ptr: usize, count: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function fence(): void;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const enum AtomicWaitResult {\\n  OK = 0,\\n  NOT_EQUAL = 1,\\n  TIMED_OUT = 2\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i8(value: auto): i8;\\n\\nexport namespace i8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i8 = -128;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i8 =  127;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i8 {\\n    return <i8>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i16(value: auto): i16;\\n\\nexport namespace i16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i16 = -32768;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i16 =  32767;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i16 {\\n    return <i16>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i32(value: auto): i32;\\n\\nexport namespace i32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i32 = -2147483648;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i32 =  2147483647;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i32 {\\n    return strtol<i32>(value, radix);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function clz(value: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ctz(value: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt(value: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_s(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_u(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotl(value: i32, shift: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotr(value: i32, shift: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: i32, right:i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_s(left: i32, right: i32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_u(left: u32, right: u32): u32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_f32(value: f32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n\\n  export namespace atomic {\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load(ptr: usize, immOffset?: usize): i32;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\\n\\n    export namespace rmw8 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n\\n    export namespace rmw16 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n\\n    export namespace rmw {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i64(value: auto): i64;\\n\\nexport namespace i64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: i64 = -9223372036854775808;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: i64 =  9223372036854775807;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): i64 {\\n    return strtol<i64>(value, radix);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function clz(value: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ctz(value: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_s(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div_u(left: i64, right:i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt(value: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotl(value: i64, shift: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rotr(value: i64, shift: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: i64, right:i64): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: i64, right:i64): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_s(left: i64, right: i64): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function rem_u(left: u64, right: u64): u64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_f64(value: f64): i64;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n\\n  export namespace atomic {\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function load(ptr: usize, immOffset?: usize): i64;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @unsafe @builtin\\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\\n\\n    // @ts-ignore: decorator\\n    @builtin\\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\\n\\n    export namespace rmw8 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n\\n    export namespace rmw16 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n\\n    export namespace rmw32 {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n\\n    export namespace rmw {\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @builtin\\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\\n\\n      // @ts-ignore: decorator\\n      @unsafe @builtin\\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isize(value: auto): isize;\\n\\nexport namespace isize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\\n    ? -2147483648\\n    : <isize>-9223372036854775808;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\\n    ? 2147483647\\n    : <isize>9223372036854775807;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): isize {\\n    return <isize>strtol<i64>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u8(value: auto): u8;\\n\\nexport namespace u8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u8 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u8 = 255;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u8 {\\n    return <u8>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u16(value: auto): u16;\\n\\nexport namespace u16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u16 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u16 = 65535;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u16 {\\n    return <u16>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u32(value: auto): u32;\\n\\nexport namespace u32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u32 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u32 = 4294967295;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u32 {\\n    return <u32>strtol<i32>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function u64(value: auto): u64;\\n\\nexport namespace u64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: u64 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: u64 = 18446744073709551615;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): u64 {\\n    return <u64>strtol<i64>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function usize(value: auto): usize;\\n\\nexport namespace usize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: usize = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\\n    ? 4294967295\\n    : <usize>18446744073709551615;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string, radix: i32 = 0): usize {\\n    return <usize>strtol<i64>(value, radix);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function bool(value: auto): bool;\\n\\nexport namespace bool {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE: bool = false;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE: bool = true;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string): bool {\\n    return strtob(value);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f32(value: auto): f32;\\n\\nexport namespace f32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const POSITIVE_INFINITY: f32 =  Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NaN: f32 = 0.0 / 0.0;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string): f32 {\\n    return <f32>strtod(value);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function copysign(x: f32, y: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_i32(value: i32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(value: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(left: f32, right: f32): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: f32, right: f32): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: f32, right: f32): i32;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f64(value: auto): f64;\\n\\nexport namespace f64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const POSITIVE_INFINITY: f64 =  Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const NaN: f64 = 0.0 / 0.0;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function parse(value: string): f64 {\\n    return strtod(value);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function copysign(x: f64, y: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function reinterpret_i64(value: i64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(value: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(left: f64, right: f64): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(left: f64, right: f64): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(left: f64, right: f64): i32;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function v128(\\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\\n): v128;\\n\\nexport namespace v128 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat<T>(x: T): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\\n\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl<T>(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr<T>(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function and(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function or(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function xor(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function andnot(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function not(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function any_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true<T>(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask<T>(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmin<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmax<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_low<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_zero<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise<T>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function demote_zero<T = f64>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function promote_low<T = f32>(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i8x16(\\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\\n): v128;\\n\\nexport namespace i8x16 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function avgr_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function popcnt(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(\\n    a: v128, b: v128,\\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\\n  ): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\\n\\nexport namespace i16x8 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i16): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function avgr_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub_sat_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i8x16_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i8x16_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i8x16_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i8x16_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(\\n    a: v128, b: v128,\\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\\n  ): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\\n\\nexport namespace i32x4 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i16x8_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i16x8_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i16x8_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i16x8_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function i64x2(a: i64, b: i64): v128;\\n\\nexport namespace i64x2 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: i64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): i64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shl(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_s(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shr_u(a: v128, b: i32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function all_true(a: v128): bool;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function bitmask(a: v128): i32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_low_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extend_high_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\\n\\nexport namespace f32x4 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: f32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): f32;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmin(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmax(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function demote_f64x2_zero(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function f64x2(a: f64, b: f64): v128;\\n\\nexport namespace f64x2 {\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function splat(x: f64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function extract_lane(x: v128, idx: u8): f64;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function add(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sub(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function mul(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function div(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function neg(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function min(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function max(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmin(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function pmax(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function abs(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function sqrt(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ceil(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function floor(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function trunc(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function nearest(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function eq(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ne(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function lt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function le(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function gt(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function ge(a: v128, b: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_low_i32x4_s(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function convert_low_i32x4_u(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function promote_low_f32x4(a: v128): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function swizzle(a: v128, b: v128): v128;\\n}\\n\\n@final\\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\\n\\n  // @ts-ignore: decorator\\n  @builtin\\n  static get(i31expr: i31ref): i32 { return unreachable(); }\\n}\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"abort\\\")\\n@external.js(\\\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\\\")\\ndeclare function abort(\\n  message?: string | null,\\n  fileName?: string | null,\\n  lineNumber?: u32,\\n  columnNumber?: u32\\n): void;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"_g\\\")\\ndeclare function _g(\\n  id: i32,\\n  maxiter: i32\\n): i32\\n\\n@builtin\\nexport declare function max_iterations(maxiter: i32): i32;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"accept\\\")\\ndeclare function $accept(\\n  read_ptr: string,\\n  read_len: u32,\\n  err: i64\\n): i64\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"emit\\\")\\ndeclare function $emit(\\n  write_ptr: u32,\\n  write_len: u32,\\n  read_ptr: u32,\\n  read_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"etxn_details\\\")\\nexport declare function $etxn_details(\\n  write_ptr: u32,\\n  write_len: u32\\n): i64\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"etxn_fee_base\\\")\\nexport declare function $etxn_fee_base(\\n  read_ptr: u32,\\n  read_len: u32\\n): i64\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"etxn_reserve\\\")\\nexport declare function $etxn_reserve(\\n  count: u32\\n): i64\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_compare\\\")\\ndeclare function $float_compare(\\n  float1: i64,\\n  float2: i64,\\n  mode: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_divide\\\")\\ndeclare function $float_divide(\\n  float1: i64,\\n  float2: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_int\\\")\\ndeclare function $float_int(\\n  float1: i64,\\n  decimal_places: u32,\\n  abs: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_mulratio\\\")\\ndeclare function $float_mulratio(\\n  float1: i64,\\n  round_up: u32,\\n  numerator: u32,\\n  denominator: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_multiply\\\")\\ndeclare function $float_multiply(\\n  float1: i64,\\n  float2: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_negate\\\")\\ndeclare function $float_negate(\\n  float1: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_set\\\")\\ndeclare function $float_set(\\n  exponent: i32,\\n  mantissa: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_sto\\\")\\ndeclare function $float_sto(\\n  write_ptr: u32,\\n  write_len: u32,\\n  cread_ptr: u32,\\n  cread_len: u32,\\n  iread_ptr: u32,\\n  iread_len: u32,\\n  float1: i64,\\n  field_code: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_sto_set\\\")\\ndeclare function $float_sto_set(\\n  read_ptr: u32,\\n  read_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"float_sum\\\")\\ndeclare function $float_sum(\\n  float1: i64,\\n  float2: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"hook_account\\\")\\ndeclare function $hook_account(\\n  write_ptr: u32,\\n  write_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"hook_param\\\")\\ndeclare function $hook_param(\\n  write_ptr: u32,\\n  write_len: u32,\\n  read_ptr: u32,\\n  read_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"ledger_seq\\\")\\ndeclare function ledger_seq(\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"otxn_field\\\")\\ndeclare function otxn_field(\\n  write_ptr: u32,\\n  write_len: u32,\\n  field_id: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"otxn_slot\\\")\\ndeclare function $otxn_slot(\\n  slot_no: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"rollback\\\")\\ndeclare function $rollback(\\n  read_ptr: string,\\n  read_len: u32,\\n  error_code: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"slot\\\")\\ndeclare function $slot(\\n  write_ptr: u32,\\n  write_len: u32,\\n  slot_no: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"slot_count\\\")\\ndeclare function $slot_count(\\n  slot_no: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"slot_float\\\")\\ndeclare function $slot_float(\\n  slot_no: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"slot_set\\\")\\ndeclare function $slot_set(\\n  read_ptr: u32,\\n  read_len: u32,\\n  slot_no: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"slot_subarray\\\")\\ndeclare function $slot_subarray(\\n  parent_slot: u32,\\n  array_id: u32,\\n  new_slot: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"slot_subfield\\\")\\ndeclare function $slot_subfield(\\n  parent_slot: u32,\\n  field_id: u32,\\n  new_slot: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"slot_type\\\")\\ndeclare function $slot_type(\\n  slot_no: u32,\\n  flags: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"state\\\")\\ndeclare function $state(\\n  write_ptr: u32,\\n  write_len: u32,\\n  kread_ptr: u32,\\n  kread_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"state_foreign\\\")\\ndeclare function $state_foreign(\\n  write_ptr: u32,\\n  write_len: u32,\\n  kread_ptr: u32,\\n  kread_len: u32,\\n  nread_ptr: u32,\\n  nread_len: u32,\\n  aread_ptr: u32,\\n  aread_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"state_set\\\")\\ndeclare function $state_set(\\n  read_ptr: u32,\\n  read_len: u32,\\n  kread_ptr: u32,\\n  kread_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"sto_emplace\\\")\\ndeclare function $sto_emplace(\\n  write_ptr: u32,\\n  write_len: u32,\\n  sread_ptr: u32,\\n  sread_len: u32,\\n  fread_ptr: u32,\\n  fread_len: u32,\\n  field_id: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"sto_erase\\\")\\ndeclare function $sto_erase(\\n  write_ptr: u32,\\n  write_len: u32,\\n  read_ptr: u32,\\n  read_len: u32,\\n  field_id: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"sto_subarray\\\")\\ndeclare function $sto_subarray(\\n  read_ptr: u32,\\n  read_len: u32,\\n  array_id: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"sto_subfield\\\")\\ndeclare function $sto_subfield(\\n  read_ptr: u32,\\n  read_len: u32,\\n  field_id: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"trace\\\")\\ndeclare function trace(\\n  mread_ptr: string,\\n  mread_len: u32,\\n  dread_ptr: u32,\\n  dread_len: u32,\\n  as_hex: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"trace_float\\\")\\ndeclare function $trace_float(\\n  read_ptr: string,\\n  read_len: u32,\\n  float1: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"trace_num\\\")\\ndeclare function $trace_num(\\n  read_ptr: string,\\n  read_len: u32,\\n  num: i64\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"util_accid\\\")\\ndeclare function $util_accid(\\n  write_ptr: u32,\\n  write_len: u32,\\n  read_ptr: u32,\\n  read_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"util_keylet\\\")\\ndeclare function $util_keylet(\\n  write_ptr: u32,\\n  write_len: u32,\\n  keylet_type: u32,\\n  a: u32,\\n  b: u32,\\n  c: u32,\\n  d: u32,\\n  e: u32,\\n  f: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"util_sha512h\\\")\\ndeclare function $util_sha512h(\\n  write_ptr: u32,\\n  write_len: u32,\\n  read_ptr: u32,\\n  read_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"util_verify\\\")\\ndeclare function $util_verify(\\n  dread_ptr: u32,\\n  dread_len: u32,\\n  sread_ptr: u32,\\n  sread_len: u32,\\n  kread_ptr: u32,\\n  kread_len: u32\\n): i64;\\n\\n// @ts-ignore: decorator\\n@external(\\\"env\\\", \\\"seed\\\")\\n@external.js(\\\"return Date.now() * Math.random();\\\")\\ndeclare function seed(): f64;\\n\\n/* eslint-enable @typescript-eslint/no-unused-vars */\\n\",\n  \"compat\": \"export type ReturnType<T> = returnof<T>;\\nexport type NonNullable<T> = nonnull<T>;\\n\",\n  \"console\": \"import {\\n  console as binding\\n} from \\\"./bindings/dom\\\";\\n\\nexport namespace console {\\n\\n  export function assert<T>(condition: T, message: string = \\\"\\\"): void {\\n    binding.assert(!!condition, message);\\n  }\\n\\n  export function log(message: string = \\\"\\\"): void {\\n    binding.log(message);\\n  }\\n\\n  export function debug(message: string = \\\"\\\"): void {\\n    binding.debug(message);\\n  }\\n\\n  export function info(message: string = \\\"\\\"): void {\\n    binding.info(message);\\n  }\\n\\n  export function warn(message: string = \\\"\\\"): void {\\n    binding.warn(message);\\n  }\\n\\n  export function error(message: string = \\\"\\\"): void {\\n    binding.error(message);\\n  }\\n\\n  export function time(label: string = \\\"default\\\"): void {\\n    binding.time(label);\\n  }\\n\\n  export function timeLog(label: string = \\\"default\\\"): void {\\n    binding.timeLog(label);\\n  }\\n\\n  export function timeEnd(label: string = \\\"default\\\"): void {\\n    binding.timeEnd(label);\\n  }\\n}\\n\",\n  \"copyx\": \"@global @inline\\nexport function __copy1(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  store<u8>(dest, load<u8>(ptr));\\n  return dest + 1;\\n}\\n\\n@global @inline\\nexport function __copy2(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  store<u16>(dest, load<u16>(ptr));\\n  return dest + 2;\\n}\\n\\n@global @inline\\nexport function __copy3(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  store<u16>(dest, load<u16>(ptr));\\n  dest += 2;\\n  ptr += 2;\\n  store<u8>(dest, load<u8>(ptr));\\n  return dest + 1;\\n}\\n\\n@global @inline\\nexport function __copy4(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  store<u32>(dest, load<u32>(ptr));\\n  return dest + 4;\\n}\\n\\n@global @inline\\nexport function __copy5(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  store<u32>(dest, load<u32>(ptr));\\n  dest += 4;\\n  ptr += 4;\\n  store<u8>(dest, load<u8>(ptr));\\n  return dest + 1;\\n}\\n\\n@global @inline\\nexport function __copy6(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  store<u32>(dest, load<u32>(ptr));\\n  dest += 4;\\n  ptr += 4;\\n  store<u16>(dest, load<u16>(ptr));\\n  return dest + 2;\\n}\\n\\n@global @inline\\nexport function __copy21(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  store<u64>(dest, load<u64>(ptr));\\n  dest += 8;\\n  ptr += 8;\\n  store<u64>(dest, load<u64>(ptr));\\n  dest += 8;\\n  ptr += 8;\\n  store<u32>(dest, load<u32>(ptr));\\n  dest += 4;\\n  ptr += 4;\\n  store<u8>(dest, load<u8>(ptr));\\n  return dest + 1;\\n}\\n\\n@global @inline\\nexport function __copy47(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  for (let i = 0; max_iterations(5), i < 5; ++i) {\\n    store<u64>(dest, load<u64>(ptr));\\n    dest += 8;\\n    ptr += 8;\\n  }\\n\\n  store<u32>(dest, load<u32>(ptr));\\n  dest += 4;\\n  ptr += 4;\\n  store<u16>(dest, load<u16>(ptr));\\n  dest += 2;\\n  ptr += 2;\\n  store<u8>(dest, load<u8>(ptr));\\n  return dest + 1;\\n}\\n\\n@global @inline\\nexport function __copy64(dest: usize, src: string): usize {\\n  let ptr = changetype<usize>(src);\\n  for (let i = 0; max_iterations(8), i < 8; ++i) {\\n    store<u64>(dest, load<u64>(ptr));\\n    dest += 8;\\n    ptr += 8;\\n  }\\n\\n  return dest;\\n}\\n\",\n  \"crypto\": \"import {\\n  crypto as crypto_binding\\n} from \\\"bindings/dom\\\";\\n\\nexport namespace crypto {\\n  export function getRandomValues(array: Uint8Array): void {\\n    crypto_binding.getRandomValues(array);\\n  }\\n}\\n\",\n  \"dataview\": \"import { BLOCK_MAXSIZE } from \\\"./rt/common\\\";\\nimport { ArrayBuffer } from \\\"./arraybuffer\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \\\"./util/error\\\";\\n\\n// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte\\n\\nexport class DataView {\\n\\n  readonly buffer: ArrayBuffer;\\n  @unsafe readonly dataStart: usize;\\n  readonly byteLength: i32;\\n\\n  get byteOffset(): i32 {\\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\\n  }\\n\\n  constructor(\\n    buffer: ArrayBuffer,\\n    byteOffset: i32 = 0,\\n    byteLength: i32 = buffer.byteLength\\n  ) {\\n    if (\\n      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |\\n      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)\\n    ) throw new RangeError(E_INVALIDLENGTH);\\n    this.buffer = buffer; // links\\n    let dataStart = changetype<usize>(buffer) + <usize>byteOffset;\\n    this.dataStart = dataStart;\\n    this.byteLength = byteLength;\\n  }\\n\\n  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return littleEndian\\n      ? load<f32>(this.dataStart + <usize>byteOffset)\\n      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));\\n  }\\n\\n  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return littleEndian\\n      ? load<f64>(this.dataStart + <usize>byteOffset)\\n      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));\\n  }\\n\\n  getInt8(byteOffset: i32): i8 {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i8>(this.dataStart + <usize>byteOffset);\\n  }\\n\\n  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: i16 = load<i16>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u16>(result);\\n  }\\n\\n  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: i32 = load<i32>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u32>(result);\\n  }\\n\\n  getUint8(byteOffset: i32): u8 {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>byteOffset);\\n  }\\n\\n  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: u16 = load<u16>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u16>(result);\\n  }\\n\\n  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: u32 = load<u32>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u32>(result);\\n  }\\n\\n  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);\\n    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));\\n  }\\n\\n  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);\\n    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));\\n  }\\n\\n  setInt8(byteOffset: i32, value: i8): void {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i8>(this.dataStart + <usize>byteOffset, value);\\n  }\\n\\n  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\\n  }\\n\\n  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\\n  }\\n\\n  setUint8(byteOffset: i32, value: u8): void {\\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u8>(this.dataStart + <usize>byteOffset, value);\\n  }\\n\\n  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\\n  }\\n\\n  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\\n  }\\n\\n  // Non-standard additions that make sense in WebAssembly, but won't work in JS:\\n\\n  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result: i64 = load<i64>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u64>(result);\\n  }\\n\\n  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let result = load<u64>(this.dataStart + <usize>byteOffset);\\n    return littleEndian ? result : bswap<u64>(result);\\n  }\\n\\n  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\\n  }\\n\\n  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {\\n    if (\\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\\n  }\\n\\n  toString(): string {\\n    return \\\"[object DataView]\\\";\\n  }\\n}\\n\",\n  \"date\": \"import { E_INVALIDDATE } from \\\"util/error\\\";\\nimport { Date as Date_binding } from \\\"./bindings/dom\\\";\\n\\n// @ts-ignore: decorator\\n@inline const\\n  MILLIS_PER_DAY    = 1000 * 60 * 60 * 24,\\n  MILLIS_PER_HOUR   = 1000 * 60 * 60,\\n  MILLIS_PER_MINUTE = 1000 * 60,\\n  MILLIS_PER_SECOND = 1000,\\n\\n  YEARS_PER_EPOCH = 400,\\n  DAYS_PER_EPOCH = 146097,\\n  EPOCH_OFFSET = 719468, // Jan 1, 1970\\n  MILLIS_LIMIT = 8640000000000000;\\n\\n// ymdFromEpochDays returns values via globals to avoid allocations\\n// @ts-ignore: decorator\\n@lazy let _month: i32, _day: i32;\\n\\nexport class Date {\\n  private year: i32 = 0;\\n  private month: i32 = 0;\\n  private day: i32 = 0;\\n\\n  @inline static UTC(\\n    year: i32,\\n    month: i32 = 0,\\n    day: i32 = 1,\\n    hour: i32 = 0,\\n    minute: i32 = 0,\\n    second: i32 = 0,\\n    millisecond: i32 = 0\\n  ): i64 {\\n    if (year >= 0 && year <= 99) year += 1900;\\n    let ms = epochMillis(year, month + 1, day, hour, minute, second, millisecond);\\n    if (invalidDate(ms)) throw new RangeError(E_INVALIDDATE);\\n    return ms;\\n  }\\n\\n  @inline static now(): i64 {\\n    return <i64>Date_binding.now();\\n  }\\n\\n  // It can parse only ISO 8601 inputs like YYYY-MM-DDTHH:MM:SS.000Z\\n  @inline static parse(dateString: string): Date {\\n    return this.fromString(dateString);\\n  }\\n\\n  static fromString(dateTimeString: string): Date {\\n    if (!dateTimeString.length) throw new RangeError(E_INVALIDDATE);\\n    var\\n      hour: i32 = 0,\\n      min: i32 = 0,\\n      sec: i32 = 0,\\n      ms: i32 = 0;\\n\\n    let dateString = dateTimeString;\\n    let posT = dateTimeString.indexOf(\\\"T\\\");\\n    if (~posT) {\\n      // includes a time component\\n      let timeString: string;\\n      dateString = dateTimeString.substring(0, posT);\\n      timeString = dateTimeString.substring(posT + 1);\\n      // parse the HH-MM-SS component\\n      let timeParts = timeString.split(\\\":\\\");\\n      let len = timeParts.length;\\n      if (len <= 1) throw new RangeError(E_INVALIDDATE);\\n\\n      hour = I32.parseInt(timeParts[0]);\\n      min  = I32.parseInt(timeParts[1]);\\n      if (len >= 3) {\\n        let secAndMs = timeParts[2];\\n        let posDot = secAndMs.indexOf(\\\".\\\");\\n        if (~posDot) {\\n          // includes milliseconds\\n          sec = I32.parseInt(secAndMs.substring(0, posDot));\\n          ms  = I32.parseInt(secAndMs.substring(posDot + 1));\\n        } else {\\n          sec = I32.parseInt(secAndMs);\\n        }\\n      }\\n    }\\n    // parse the YYYY-MM-DD component\\n    let parts = dateString.split(\\\"-\\\");\\n    let year = I32.parseInt(parts[0]);\\n    let month = 1, day = 1;\\n    let len = parts.length;\\n    if (len >= 2) {\\n      month = I32.parseInt(parts[1]);\\n      if (len >= 3) {\\n        day = I32.parseInt(parts[2]);\\n      }\\n    }\\n    return new Date(epochMillis(year, month, day, hour, min, sec, ms));\\n  }\\n\\n  constructor(private epochMillis: i64) {\\n    // this differs from JavaScript which prefer return NaN or \\\"Invalid Date\\\" string\\n    // instead throwing exception.\\n    if (invalidDate(epochMillis)) throw new RangeError(E_INVALIDDATE);\\n\\n    this.year = dateFromEpoch(epochMillis);\\n    this.month = _month;\\n    this.day = _day;\\n  }\\n\\n  @inline getTime(): i64 {\\n    return this.epochMillis;\\n  }\\n\\n  setTime(time: i64): i64 {\\n    if (invalidDate(time)) throw new RangeError(E_INVALIDDATE);\\n\\n    this.epochMillis = time;\\n    this.year = dateFromEpoch(time);\\n    this.month = _month;\\n    this.day = _day;\\n\\n    return time;\\n  }\\n\\n  @inline getUTCFullYear(): i32 {\\n    return this.year;\\n  }\\n\\n  @inline getUTCMonth(): i32 {\\n    return this.month - 1;\\n  }\\n\\n  @inline getUTCDate(): i32 {\\n    return this.day;\\n  }\\n\\n  @inline getUTCDay(): i32 {\\n    return dayOfWeek(this.year, this.month, this.day);\\n  }\\n\\n  getUTCHours(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_DAY)) / MILLIS_PER_HOUR;\\n  }\\n\\n  getUTCMinutes(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_HOUR)) / MILLIS_PER_MINUTE;\\n  }\\n\\n  getUTCSeconds(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_MINUTE)) / MILLIS_PER_SECOND;\\n  }\\n\\n  getUTCMilliseconds(): i32 {\\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_SECOND));\\n  }\\n\\n  setUTCMilliseconds(millis: i32): void {\\n    this.setTime(this.epochMillis + (millis - this.getUTCMilliseconds()));\\n  }\\n\\n  setUTCSeconds(seconds: i32): void {\\n    this.setTime(this.epochMillis + (seconds - this.getUTCSeconds()) * MILLIS_PER_SECOND);\\n  }\\n\\n  setUTCMinutes(minutes: i32): void {\\n    this.setTime(this.epochMillis + (minutes - this.getUTCMinutes()) * MILLIS_PER_MINUTE);\\n  }\\n\\n  setUTCHours(hours: i32): void {\\n    this.setTime(this.epochMillis + (hours - this.getUTCHours()) * MILLIS_PER_HOUR);\\n  }\\n\\n  setUTCDate(day: i32): void {\\n    if (this.day == day) return;\\n    this.setTime(join(this.year, this.month, day, this.epochMillis));\\n  }\\n\\n  setUTCMonth(month: i32, day: i32 = this.day): void {\\n    if (this.month == month + 1) return;\\n    this.setTime(join(this.year, month + 1, day, this.epochMillis));\\n  }\\n\\n  setUTCFullYear(year: i32): void {\\n    if (this.year == year) return;\\n    this.setTime(join(year, this.month, this.day, this.epochMillis));\\n  }\\n}\\n\\nfunction epochMillis(\\n  year: i32,\\n  month: i32,\\n  day: i32,\\n  hour: i32,\\n  minute: i32,\\n  second: i32,\\n  milliseconds: i32\\n): i64 {\\n  return (\\n    daysSinceEpoch(year, month, day) * MILLIS_PER_DAY +\\n    hour * MILLIS_PER_HOUR +\\n    minute * MILLIS_PER_MINUTE +\\n    second * MILLIS_PER_SECOND +\\n    milliseconds\\n  );\\n}\\n\\n// @ts-ignore: decorator\\n@inline function floorDiv<T extends number>(a: T, b: T): T {\\n  return (a - (a < 0 ? b - 1 : 0)) / b as T;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function euclidRem<T extends number>(a: T, b: T): T {\\n  let m = a % b;\\n  return m + (m < 0 ? b : 0) as T;\\n}\\n\\nfunction invalidDate(millis: i64): bool {\\n  // @ts-ignore\\n  return (millis < -MILLIS_LIMIT) | (millis > MILLIS_LIMIT);\\n}\\n\\n// Based on \\\"Euclidean Affine Functions and Applications to Calendar Algorithms\\\"\\n// Paper: https://arxiv.org/pdf/2102.06959.pdf\\nfunction dateFromEpoch(ms: i64): i32 {\\n  let da = (<i32>floorDiv(ms, MILLIS_PER_DAY) * 4 + EPOCH_OFFSET * 4) | 3;\\n  let q0 = floorDiv(da, DAYS_PER_EPOCH); // [0, 146096]\\n  let r1 = <u32>da - q0 * DAYS_PER_EPOCH;\\n  let u1 = u64(r1 | 3) * 2939745;\\n  let dm1 = <u32>u1 / 11758980;\\n  let n1 = 2141 * dm1 + 197913;\\n  let year = 100 * q0 + i32(u1 >>> 32);\\n  let mo = n1 >>> 16;\\n  _day = (n1 & 0xFFFF) / 2141 + 1; // [1, 31]\\n  if (dm1 >= 306) { mo -= 12; ++year; }\\n  _month = mo; // [1, 12]\\n  return year;\\n}\\n\\n// http://howardhinnant.github.io/date_algorithms.html#days_from_civil\\nfunction daysSinceEpoch(y: i32, m: i32, d: i32): i64 {\\n  y -= i32(m <= 2);\\n  let era = <u32>floorDiv(y, YEARS_PER_EPOCH);\\n  let yoe = <u32>y - era * YEARS_PER_EPOCH; // [0, 399]\\n  let doy = <u32>(153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1; // [0, 365]\\n  let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy; // [0, 146096]\\n  return <i64><i32>(era * 146097 + doe - EPOCH_OFFSET);\\n}\\n\\n// TomohikoSakamoto algorithm from https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week\\nfunction dayOfWeek(year: i32, month: i32, day: i32): i32 {\\n  const tab = memory.data<u8>([0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]);\\n\\n  year -= i32(month < 3);\\n  year += floorDiv(year, 4) - floorDiv(year, 100) + floorDiv(year, YEARS_PER_EPOCH);\\n  month = <i32>load<u8>(tab + month - 1);\\n  return euclidRem(year + month + day, 7);\\n}\\n\\nfunction stringify(value: i32, padding: i32 = 2): string {\\n  return value.toString().padStart(padding, \\\"0\\\");\\n}\\n\\nfunction join(year: i32, month: i32, day: i32, ms: i64): i64 {\\n  return daysSinceEpoch(year, month, day) * MILLIS_PER_DAY + euclidRem(ms, MILLIS_PER_DAY);\\n}\\n\",\n  \"diagnostics\": \"// @ts-ignore: decorator\\n@builtin\\nexport declare function ERROR(message?: string): void;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function WARNING(message?: string): void;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function INFO(message?: string): void;\\n\",\n  \"eqx\": \"@global @inline\\nexport function __eq0(left: ByteView, right: string): bool {\\n  return left.length == 0;\\n}\\n\\n@global @inline\\nexport function __eq1(left: ByteView, right: string): bool {\\n  return (left.length == 1) && (left[0] == right[0]);\\n}\\n\\n@global @inline\\nexport function __eq2(left: ByteView, right: string): bool {\\n  if (left.length != 2) return false;\\n\\n  let ptr1 = changetype<usize>(left.underlying) + left.offset;\\n  let ptr2 = changetype<usize>(right);\\n  return load<u16>(ptr1) == load<u16>(ptr2);\\n}\\n\\n@global @inline\\nexport function __eq16(left: ByteView, right: string): bool {\\n  if (left.length != 16) return false;\\n\\n  let ptr1 = changetype<usize>(left.underlying) + left.offset;\\n  let ptr2 = changetype<usize>(right);\\n  if (load<u64>(ptr1) != load<u64>(ptr2)) return false;\\n  ptr1 += 8;\\n  ptr2 += 8;\\n  return load<u64>(ptr1) == load<u64>(ptr2);\\n}\\n\\n@global @inline\\nexport function __eq18(left: ByteView, right: string): bool {\\n  if (left.length != 18) return false;\\n\\n  let ptr1 = changetype<usize>(left.underlying) + left.offset;\\n  let ptr2 = changetype<usize>(right);\\n  if (load<u64>(ptr1) != load<u64>(ptr2)) return false;\\n  ptr1 += 8;\\n  ptr2 += 8;\\n  if (load<u64>(ptr1) != load<u64>(ptr2)) return false;\\n  ptr1 += 8;\\n  ptr2 += 8;\\n  return load<u16>(ptr1) == load<u16>(ptr2);\\n}\\n\",\n  \"error\": \"export class Error {\\n\\n  name: string  = \\\"Error\\\";\\n  stack: string = \\\"\\\"; // TODO\\n\\n  constructor(\\n    public message: string = \\\"\\\"\\n  ) {}\\n\\n  toString(): string {\\n    let message = this.message;\\n    return message.length\\n      ? this.name + \\\": \\\" + message\\n      : this.name;\\n  }\\n}\\n\\nexport class RangeError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"RangeError\\\";\\n  }\\n}\\n\\nexport class TypeError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"TypeError\\\";\\n  }\\n}\\n\\nexport class SyntaxError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"SyntaxError\\\";\\n  }\\n}\\n\\nexport class URIError extends Error {\\n  constructor(message: string = \\\"\\\") {\\n    super(message);\\n    this.name = \\\"URIError\\\";\\n  }\\n}\\n\",\n  \"function\": \"type auto = i32;\\n\\n@final export abstract class Function<T> {\\n  private _index: u32;\\n  private _env: usize;\\n\\n  // @ts-ignore: this on getter\\n  get index(this: T): u32 {\\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\\\"_index\\\"));\\n  }\\n\\n  // @ts-ignore: this on getter\\n  get name(this: T): string {\\n    return \\\"\\\";\\n  }\\n\\n  // @ts-ignore: this on getter\\n  get length(this: T): i32 {\\n    // @ts-ignore: T is function\\n    return lengthof<T>();\\n  }\\n\\n  // @ts-ignore: T is function\\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\\n    return unreachable();\\n  }\\n\\n  toString(this: T): string {\\n    return \\\"function() { [native code] }\\\";\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    // Env is either `null` (nop) or compiler-generated\\n    __visit(this._env, cookie);\\n  }\\n}\\n\",\n  \"invoice\": \"export class InvoiceID {\\n  @inline\\n  constructor(public bytes: ByteArray) {\\n    if (bytes.length != 32)\\n      rollback(\\\"\\\", bytes.length);\\n  }\\n\\n  @inline\\n  toHex(): string {\\n    let out = __new(64, idof<string>());\\n    for (let i = 0; max_iterations(32), i < 32; ++i) {\\n      let b = this.bytes[i];\\n      let hi = b >> 4;\\n      let lo = b & 0xF;\\n      hi += ((hi > 9) ? 55 : 48);\\n      lo += ((lo > 9) ? 55 : 48);\\n      store<u8>(out + 2 * i, hi);\\n      store<u8>(out + 2 * i + 1, lo);\\n    }\\n    return changetype<string>(out);\\n  }\\n}\\n\",\n  \"iterator\": \"export abstract class Iterable<T> {\\n  // ?\\n}\\n\\n@final\\nexport abstract class Iterator<T> {\\n\\n  // private constructor(iterable: Iterable<T>) {\\n  // }\\n\\n  // TODO: these need to evaluate the classId at the respective reference in order to obtain the\\n  // next value, i.e. arrays work differently than maps. we'd then have:\\n  //\\n  // \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Iterator layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n  //    3                   2                   1\\n  //  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n  // \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n  // \u2502                             index                             \u2502\\n  // \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2524\\n  // \u2502                           reference                     \u2502 0 \u2502D\u2502\\n  // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2518\\n  // D: Done flag\\n\\n  // get value(this: u64): T {\\n  //   ?\\n  // }\\n\\n  // next(this: u64): Iterator<T> {\\n  //   ?\\n  // }\\n\\n  done(this: u64): bool {\\n    return <bool>(this & 1);\\n  }\\n}\\n\",\n  \"keylet\": \"// @ts-ignore: decorator\\n@lazy\\nexport const KEYLET_LINE = 9;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const KEYLET_SIGNERS = 14;\\n\\nexport class Keylet {\\n  @inline\\n  static getSigners(acc: Account): ByteArray {\\n    let a = new ByteArray(34);\\n    let b = acc.bytes;\\n    let r = $util_keylet(changetype<u32>(a), 34, KEYLET_SIGNERS, changetype<u32>(b), 20, 0, 0, 0, 0);\\n    if (r != 34)\\n      rollback(\\\"\\\", r);\\n\\n    return a;\\n  }\\n\\n  @inline\\n  static getTrustLine(high: Account, low: Account, currency: ByteArray): ByteArray {\\n    let res = new ByteArray(34);\\n    let r = $util_keylet(changetype<u32>(res), 34, KEYLET_LINE, changetype<u32>(high.bytes), 20, changetype<u32>(low.bytes), 20, changetype<u32>(currency), currency.length);\\n    if (r != 34)\\n      rollback(\\\"\\\", r);\\n\\n    return res;\\n  }\\n}\\n\",\n  \"map\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { HASH } from \\\"./util/hash\\\";\\nimport { E_KEYNOTFOUND } from \\\"./util/error\\\";\\n\\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\\n\\n// @ts-ignore: decorator\\n@inline const INITIAL_CAPACITY = 4;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_N = 8;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_D = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_N = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_D = 4;\\n\\n/** Structure of a map entry. */\\n@unmanaged class MapEntry<K,V> {\\n  key: K;\\n  value: V;\\n  taggedNext: usize; // LSB=1 indicates EMPTY\\n}\\n\\n/** Empty bit. */\\n// @ts-ignore: decorator\\n@inline const EMPTY: usize = 1 << 0;\\n\\n/** Size of a bucket. */\\n// @ts-ignore: decorator\\n@inline const BUCKET_SIZE = sizeof<usize>();\\n\\n/** Computes the alignment of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_ALIGN<K,V>(): usize {\\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\\n  return align;\\n}\\n\\n/** Computes the aligned size of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_SIZE<K,V>(): usize {\\n  const align = ENTRY_ALIGN<K,V>();\\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\\n  return size;\\n}\\n\\nexport class Map<K,V> {\\n\\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\\n\\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\\n  private entriesOffset: i32 = 0;\\n  private entriesCount: i32 = 0;\\n\\n  constructor() {\\n    /* nop */\\n  }\\n\\n  get size(): i32 {\\n    return this.entriesCount;\\n  }\\n\\n  clear(): void {\\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n    this.bucketsMask = INITIAL_CAPACITY - 1;\\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\\n    this.entriesCapacity = INITIAL_CAPACITY;\\n    this.entriesOffset = 0;\\n    this.entriesCount = 0;\\n  }\\n\\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\\n    let entry = load<MapEntry<K,V>>( // unmanaged!\\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\\n    );\\n    while (entry) {\\n      let taggedNext = entry.taggedNext;\\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\\n    }\\n    return null;\\n  }\\n\\n  has(key: K): bool {\\n    return this.find(key, HASH<K>(key)) != null;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  get(key: K): V {\\n    let entry = this.find(key, HASH<K>(key));\\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\\n    return entry.value;\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  set(key: K, value: V): this {\\n    let hashCode = HASH<K>(key);\\n    let entry = this.find(key, hashCode); // unmanaged!\\n    if (entry) {\\n      entry.value = value;\\n      if (isManaged<V>()) {\\n        __link(changetype<usize>(this), changetype<usize>(value), true);\\n      }\\n    } else {\\n      // check if rehashing is necessary\\n      if (this.entriesOffset == this.entriesCapacity) {\\n        this.rehash(\\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\\n        );\\n      }\\n      // append new entry\\n      let entries = this.entries;\\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\\n      // link with the map\\n      entry.key = key;\\n      if (isManaged<K>()) {\\n        __link(changetype<usize>(this), changetype<usize>(key), true);\\n      }\\n      entry.value = value;\\n      if (isManaged<V>()) {\\n        __link(changetype<usize>(this), changetype<usize>(value), true);\\n      }\\n      ++this.entriesCount;\\n      // link with previous entry in bucket\\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\\n      entry.taggedNext = load<usize>(bucketPtrBase);\\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\\n    }\\n    return this;\\n  }\\n\\n  delete(key: K): bool {\\n    let entry = this.find(key, HASH<K>(key));\\n    if (!entry) return false;\\n    entry.taggedNext |= EMPTY;\\n    --this.entriesCount;\\n    // check if rehashing is appropriate\\n    let halfBucketsMask = this.bucketsMask >> 1;\\n    if (\\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n    ) this.rehash(halfBucketsMask);\\n    return true;\\n  }\\n\\n  private rehash(newBucketsMask: u32): void {\\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\\n\\n    // copy old entries to new entries\\n    let oldPtr = changetype<usize>(this.entries);\\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\\n    let newPtr = changetype<usize>(newEntries);\\n    while (oldPtr != oldEnd) {\\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\\n      if (!(oldEntry.taggedNext & EMPTY)) {\\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\\n        let oldEntryKey = oldEntry.key;\\n        newEntry.key = oldEntryKey;\\n        newEntry.value = oldEntry.value;\\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\\n        store<usize>(newBucketPtrBase, newPtr);\\n        newPtr += ENTRY_SIZE<K,V>();\\n      }\\n      oldPtr += ENTRY_SIZE<K,V>();\\n    }\\n\\n    this.buckets = newBuckets;\\n    this.bucketsMask = newBucketsMask;\\n    this.entries = newEntries;\\n    this.entriesCapacity = newEntriesCapacity;\\n    this.entriesOffset = this.entriesCount;\\n  }\\n\\n  keys(): K[] {\\n    // FIXME: this is preliminary, needs iterators/closures\\n    let start = changetype<usize>(this.entries);\\n    let size = this.entriesOffset;\\n    let keys = new Array<K>(size);\\n    let length = 0;\\n    for (let i = 0; i < size; ++i) {\\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\\n      if (!(entry.taggedNext & EMPTY)) {\\n        unchecked(keys[length++] = entry.key);\\n      }\\n    }\\n    keys.length = length;\\n    return keys;\\n  }\\n\\n  values(): V[] {\\n    // FIXME: this is preliminary, needs iterators/closures\\n    let start = changetype<usize>(this.entries);\\n    let size = this.entriesOffset;\\n    let values = new Array<V>(size);\\n    let length = 0;\\n    for (let i = 0; i < size; ++i) {\\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\\n      if (!(entry.taggedNext & EMPTY)) {\\n        unchecked(values[length++] = entry.value);\\n      }\\n    }\\n    values.length = length;\\n    return values;\\n  }\\n\\n  toString(): string {\\n    return \\\"[object Map]\\\";\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    __visit(changetype<usize>(this.buckets), cookie);\\n    let entries = changetype<usize>(this.entries);\\n    if (isManaged<K>() || isManaged<V>()) {\\n      let cur = entries;\\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\\n      while (cur < end) {\\n        let entry = changetype<MapEntry<K,V>>(cur);\\n        if (!(entry.taggedNext & EMPTY)) {\\n          if (isManaged<K>()) {\\n            let val = changetype<usize>(entry.key);\\n            if (isNullable<K>()) {\\n              if (val) __visit(val, cookie);\\n            } else __visit(val, cookie);\\n          }\\n          if (isManaged<V>()) {\\n            let val = changetype<usize>(entry.value);\\n            if (isNullable<V>()) {\\n              if (val) __visit(val, cookie);\\n            } else __visit(val, cookie);\\n          }\\n        }\\n        cur += ENTRY_SIZE<K,V>();\\n      }\\n    }\\n    __visit(entries, cookie);\\n  }\\n}\\n\",\n  \"math\": \"import { Math as JSMath } from \\\"./bindings/dom\\\";\\nexport { JSMath };\\n\\nimport {\\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\\n} from \\\"./util/math\\\";\\n\\nimport {\\n  abs as builtin_abs,\\n  ceil as builtin_ceil,\\n  clz as builtin_clz,\\n  copysign as builtin_copysign,\\n  floor as builtin_floor,\\n  max as builtin_max,\\n  min as builtin_min,\\n  sqrt as builtin_sqrt,\\n  trunc as builtin_trunc\\n} from \\\"./builtins\\\";\\n\\n// SUN COPYRIGHT NOTICE\\n//\\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\\n// Developed at SunPro, a Sun Microsystems, Inc. business.\\n// Permission to use, copy, modify, and distribute this software\\n// is freely granted, provided that this notice is preserved.\\n//\\n// Applies to all functions marked with a comment referring here.\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\\n]);\\n\\n/** @internal */\\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\\n\\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\\n  return p / q;\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\\n  const                       // see: musl/src/math/__expo2.c\\n    k    = <u32>2043,\\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\\n  // in directed rounding correct sign before rounding or overflow is important\\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\\n}\\n\\n/** @internal */\\n/* Helper function to eventually get bits of \u03C0/2 * |x|\\n *\\n * y = \u03C0/4 * (frac << clz(frac) >> 11)\\n * return clz(frac)\\n *\\n * Right shift 11 bits to make upper half fit in `double`\\n */\\n// @ts-ignore: decorator\\n@inline\\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\\n  // Bits of \u03C0/4\\n  const p0: u64 = 0xC4C6628B80DC1CD1;\\n  const p1: u64 = 0xC90FDAA22168C234;\\n\\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\\n\\n  let shift = clz(q1);\\n\\n  q1 = q1 << shift | q0 >> (64 - shift);\\n  q0 <<= shift;\\n\\n  let lo = umuldi(p1, q1);\\n  let hi = res128_hi;\\n\\n  let ahi = hi >> 11;\\n  let alo = lo >> 11 | hi << 53;\\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\\n\\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\\n\\n  return shift;\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction umuldi(u: u64, v: u64): u64 {\\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\\n\\n  u1 = u & 0xFFFFFFFF;\\n  v1 = v & 0xFFFFFFFF;\\n\\n  u >>= 32;\\n  v >>= 32;\\n\\n  t  = u1 * v1;\\n  w0 = t & 0xFFFFFFFF;\\n  t  = u * v1 + (t >> 32);\\n  w1 = t >> 32;\\n  t  = u1 * v + (t & 0xFFFFFFFF);\\n\\n  res128_hi = u * v + w1 + (t >> 32);\\n  return (t << 32) + w0;\\n}\\n\\n/** @internal */\\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\\n  let offset = (magnitude >> 52) - 1045;\\n  let shift  = offset & 63;\\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\\n  let s0: u64, s1: u64, s2: u64;\\n\\n  let b0 = load<u64>(tblPtr, 0 << 3);\\n  let b1 = load<u64>(tblPtr, 1 << 3);\\n  let b2 = load<u64>(tblPtr, 2 << 3);\\n\\n  // Get 192 bits of 0x1p-31 / \u03C0 with `offset` bits skipped\\n  if (shift) {\\n    let rshift = 64 - shift;\\n    let b3 = load<u64>(tblPtr, 3 << 3);\\n    s0 = b1 >> rshift | b0 << shift;\\n    s1 = b2 >> rshift | b1 << shift;\\n    s2 = b3 >> rshift | b2 << shift;\\n  } else {\\n    s0 = b0;\\n    s1 = b1;\\n    s2 = b2;\\n  }\\n\\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\\n\\n  // First 128 bits of fractional part of x/(2\u03C0)\\n  let blo = umuldi(s1, significand);\\n  let bhi = res128_hi;\\n\\n  let ahi = s0 * significand;\\n  let clo = (s2 >> 32) * (significand >> 32);\\n  let plo = blo + clo;\\n  let phi = ahi + bhi + u64(plo < clo);\\n\\n  // r: u128 = p << 2\\n  let rlo = plo << 2;\\n  let rhi = phi << 2 | plo >> 62;\\n\\n  // s: i128 = r >> 127\\n  let slo = <i64>rhi >> 63;\\n  let shi = slo >> 1;\\n  let q   = (<i64>phi >> 62) - slo;\\n\\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\\n  let signbit = (u ^ rhi) & 0x8000000000000000;\\n  let coeff   = reinterpret<f64>(shifter | signbit);\\n\\n  rempio2_y0 *= coeff;\\n  rempio2_y1 *= coeff;\\n\\n  return <i32>q;\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\\n  const\\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\\n\\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\\n\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\\n      let q = 1, z: f64, y0: f64, y1: f64;\\n      if (!sign) {\\n        z = x - pio2_1;\\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\\n          y0 = z - pio2_1t;\\n          y1 = (z - y0) - pio2_1t;\\n        } else { // near pi/2, use 33+33+53 bit pi\\n          z -= pio2_2;\\n          y0 = z - pio2_2t;\\n          y1 = (z - y0) - pio2_2t;\\n        }\\n      } else { // negative x\\n        z = x + pio2_1;\\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\\n          y0 = z + pio2_1t;\\n          y1 = (z - y0) + pio2_1t;\\n        } else { // near pi/2, use 33+33+53 bit pi\\n          z += pio2_2;\\n          y0 = z + pio2_2t;\\n          y1 = (z - y0) + pio2_2t;\\n        }\\n        q = -1;\\n      }\\n      rempio2_y0 = y0;\\n      rempio2_y1 = y1;\\n      return q;\\n    }\\n  }\\n\\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\\n    // Use precise Cody Waite scheme\\n    let q  = nearest(x * invpio2);\\n    let r  = x - q * pio2_1;\\n    let w  = q * pio2_1t; // 1st round good to 85 bit\\n    let j  = ix >> 20;\\n    let y0 = r - w;\\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\\n    let i  = j - ((hi >> 20) & 0x7FF);\\n\\n    if (i > 16) { // 2nd iteration needed, good to 118\\n      let t = r;\\n      w  = q * pio2_2;\\n      r  = t - w;\\n      w  = q * pio2_2t - ((t - r) - w);\\n      y0 = r - w;\\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\\n      i = j - ((hi >> 20) & 0x7FF);\\n      if (i > 49) { // 3rd iteration need, 151 bits acc\\n        let t = r;\\n        w  = q * pio2_3;\\n        r  = t - w;\\n        w  = q * pio2_3t - ((t - r) - w);\\n        y0 = r - w;\\n      }\\n    }\\n    let y1 = (r - y0) - w;\\n    rempio2_y0 = y0;\\n    rempio2_y1 = y1;\\n    return <i32>q;\\n  }\\n  let q = pio2_large_quot(x, u);\\n  return select(-q, q, sign);\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\\n  const\\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\\n  let v = z * x;\\n  if (!iy) {\\n    return x + v * (S1 + z * r);\\n  } else {\\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\\n  }\\n}\\n\\n/** @internal */\\n// @ts-ignore: decorator\\n@inline\\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\\n  const\\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\\n  let hz = 0.5 * z;\\n  w = 1.0 - hz;\\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\\n}\\n\\n/** @internal */\\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\\n  const\\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\\n\\n  const\\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\\n\\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\\n  let big = ix >= 0x3FE59428;\\n  if (big) { // |x| >= 0.6744\\n    if (hx < 0) { x = -x, y = -y; }\\n    z = pio4 - x;\\n    w = pio4lo - y;\\n    x = z + w;\\n    y = 0.0;\\n  }\\n  z = x * x;\\n  w = z * z;\\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\\n  s = z * x;\\n  r = y + z * (s * (r + v) + y);\\n  r += T0 * s;\\n  w = x + r;\\n  if (big) {\\n    v = iy;\\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\\n  }\\n  if (iy == 1) return w;\\n  let a: f64, t: f64;\\n  z = w;\\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\\n  v = r - (z - x);  // z + v = r + x\\n  t = a = -one / w; // a = -1.0 / w\\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\\n  s = one + t * z;\\n  return t + a * (s + t * v);\\n}\\n\\n/** @internal */\\nfunction dtoi32(x: f64): i32 {\\n  if (ASC_SHRINK_LEVEL > 0) {\\n    const inv32 = 1.0 / 4294967296;\\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\\n  } else {\\n    let result = 0;\\n    let u = reinterpret<u64>(x);\\n    let e = (u >> 52) & 0x7FF;\\n    if (e <= 1023 + 30) {\\n      result = <i32>x;\\n    } else if (e <= 1023 + 30 + 53) {\\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\\n      v = v << e - 1023 - 52 + 32;\\n      result = <i32>(v >> 32);\\n      result = select<i32>(-result, result, <i64>u < 0);\\n    }\\n    return result;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let random_seeded = false;\\n\\n// @ts-ignore: decorator\\n@lazy let random_state0_64: u64, random_state1_64: u64;\\n\\n// @ts-ignore: decorator\\n@lazy let random_state0_32: u32, random_state1_32: u32;\\n\\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\\n  h *= 0xFF51AFD7ED558CCD;\\n  h ^= h >> 33;\\n  h *= 0xC4CEB9FE1A85EC53;\\n  h ^= h >> 33;\\n  return h;\\n}\\n\\nfunction splitMix32(h: u32): u32 {\\n  h += 0x6D2B79F5;\\n  h  = (h ^ (h >> 15)) * (h | 1);\\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\\n  return h ^ (h >> 14);\\n}\\n\\nexport namespace NativeMath {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_sin: f64 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_cos: f64 = 0;\\n\\n  // @ts-ignore: decorator\\n  @inline export function abs(x: f64): f64 {\\n    return builtin_abs<f64>(x);\\n  }\\n\\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\\n      Ox1p_120f = reinterpret<f32>(0x03800000);\\n\\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\\n    let ix = hx & 0x7FFFFFFF;\\n    if (ix >= 0x3FF00000) {\\n      let lx = <u32>reinterpret<u64>(x);\\n      if ((ix - 0x3FF00000 | lx) == 0) {\\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\\n        return 0;\\n      }\\n      return 0 / (x - x);\\n    }\\n    if (ix < 0x3FE00000) {\\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\\n    }\\n    let s: f64, w: f64, z: f64;\\n    if (<i32>hx < 0) {\\n      // z = (1.0 + x) * 0.5;\\n      z = 0.5 + x * 0.5;\\n      s = builtin_sqrt<f64>(z);\\n      w = R(z) * s - pio2_lo;\\n      return 2 * (pio2_hi - (s + w));\\n    }\\n    // z = (1.0 - x) * 0.5;\\n    z = 0.5 - x * 0.5;\\n    s = builtin_sqrt<f64>(z);\\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\\n    let c = (z - df * df) / (s + df);\\n    w = R(z) * s + c;\\n    return 2 * (df + w);\\n  }\\n\\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\\n    let u = reinterpret<u64>(x);\\n    // Prevent propagation for all input values less than 1.0.\\n    // Note musl lib didn't fix this yet.\\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\\n    let e = u >> 52 & 0x7FF;\\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\\n    return log(x) + s;\\n  }\\n\\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\\n      Ox1p_120f = reinterpret<f32>(0x03800000);\\n\\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\\n    let ix = hx & 0x7FFFFFFF;\\n    if (ix >= 0x3FF00000) {\\n      let lx = <u32>reinterpret<u64>(x);\\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\\n      return 0 / (x - x);\\n    }\\n    if (ix < 0x3FE00000) {\\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\\n      return x + x * R(x * x);\\n    }\\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\\n    let s = builtin_sqrt<f64>(z);\\n    let r = R(z);\\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\\n    else {\\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\\n      let c = (z - f * f) / (s + f);\\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\\n    }\\n    return select(-x, x, <i32>hx < 0);\\n  }\\n\\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\\n    let u = reinterpret<u64>(x);\\n    let e = u >> 52 & 0x7FF;\\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\\n    if (e >= 0x3FF + 26) y = log(y) + c;\\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\\n    return builtin_copysign(y, x);\\n  }\\n\\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\\n    const\\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\\n      Ox1p_120f = reinterpret<f32>(0x03800000);\\n\\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\\n    let sx = x;\\n    ix &= 0x7FFFFFFF;\\n    let z: f64;\\n    if (ix >= 0x44100000) {\\n      if (isNaN(x)) return x;\\n      z = atanhi3 + Ox1p_120f;\\n      return builtin_copysign<f64>(z, sx);\\n    }\\n    let id: i32;\\n    if (ix < 0x3FDC0000) {\\n      if (ix < 0x3E400000) return x;\\n      id = -1;\\n    } else {\\n      x = builtin_abs<f64>(x);\\n      if (ix < 0x3FF30000) {\\n        if (ix < 0x3FE60000) {\\n          id = 0;\\n          x = (2.0 * x - 1.0) / (2.0 + x);\\n        } else {\\n          id = 1;\\n          x = (x - 1.0) / (x + 1.0);\\n        }\\n      } else {\\n        if (ix < 0x40038000) {\\n          id = 2;\\n          x = (x - 1.5) / (1.0 + 1.5 * x);\\n        } else {\\n          id = 3;\\n          x = -1.0 / x;\\n        }\\n      }\\n    }\\n    z = x * x;\\n    let w = z * z;\\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\\n    let s3 = x * (s1 + s2);\\n    if (id < 0) return x - s3;\\n    switch (id) {\\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\\n      default: unreachable();\\n    }\\n    return builtin_copysign<f64>(z, sx);\\n  }\\n\\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\\n    let u = reinterpret<u64>(x);\\n    let e = u >> 52 & 0x7FF;\\n    let y = builtin_abs(x);\\n    if (e < 0x3FF - 1) {\\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\\n    } else {\\n      y = 0.5 * log1p(2 * (y / (1 - y)));\\n    }\\n    return builtin_copysign<f64>(y, x);\\n  }\\n\\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\\n    if (isNaN(x) || isNaN(y)) return x + y;\\n    let u = reinterpret<u64>(x);\\n    let ix = <u32>(u >> 32);\\n    let lx = <u32>u;\\n    u = reinterpret<u64>(y);\\n    let iy = <u32>(u >> 32);\\n    let ly = <u32>u;\\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\\n    ix = ix & 0x7FFFFFFF;\\n    iy = iy & 0x7FFFFFFF;\\n    if ((iy | ly) == 0) {\\n      switch (m) {\\n        case 0:\\n        case 1: return  y;\\n        case 2: return  PI;\\n        case 3: return -PI;\\n      }\\n    }\\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\\n    if (ix == 0x7FF00000) {\\n      if (iy == 0x7FF00000) {\\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\\n        return m & 1 ? -t : t;\\n      } else {\\n        let t = m & 2 ? PI : 0;\\n        return m & 1 ? -t : t;\\n      }\\n    }\\n    let z: f64;\\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\\n    else z = atan(builtin_abs<f64>(y / x));\\n    switch (m) {\\n      case 0: return  z;\\n      case 1: return -z;\\n      case 2: return PI - (z - pi_lo);\\n      case 3: return (z - pi_lo) - PI;\\n    }\\n    unreachable();\\n    return 0;\\n  }\\n\\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\\n    const\\n      B1     = <u32>715094163,\\n      B2     = <u32>696219795,\\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\\n    if (hx >= 0x7FF00000) return x + x;\\n    if (hx < 0x00100000) {\\n      u = reinterpret<u64>(x * Ox1p54);\\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\\n      if (hx == 0) return x;\\n      hx = hx / 3 + B2;\\n    } else {\\n      hx = hx / 3 + B1;\\n    }\\n    u &= 1 << 63;\\n    u |= <u64>hx << 32;\\n    let t = reinterpret<f64>(u);\\n    let r = (t * t) * (t / x);\\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\\n    let s = t * t;\\n    r = x / s;\\n    r = (r - t) / (2 * t + r);\\n    t = t + t * r;\\n    return t;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function ceil(x: f64): f64 {\\n    return builtin_ceil<f64>(x);\\n  }\\n\\n  export function clz32(x: f64): f64 {\\n    if (!isFinite(x)) return 32;\\n    /*\\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\\n     *\\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\\n     * our float-point arguments before actual convertion to integers.\\n     */\\n    return builtin_clz(dtoi32(x));\\n  }\\n\\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\\n    let u  = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >> 31;\\n\\n    ux &= 0x7FFFFFFF;\\n\\n    // |x| ~< pi/4\\n    if (ux <= 0x3FE921FB) {\\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\\n        return 1.0;\\n      }\\n      return cos_kern(x, 0);\\n    }\\n\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7FF00000) return x - x;\\n\\n    // argument reduction needed\\n    let n  = rempio2(x, u, sign);\\n    let y0 = rempio2_y0;\\n    let y1 = rempio2_y1;\\n\\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\\n    return (n + 1) & 2 ? -x : x;\\n  }\\n\\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\\n    let u = reinterpret<u64>(x);\\n    u &= 0x7FFFFFFFFFFFFFFF;\\n    x = reinterpret<f64>(u);\\n    let w = <u32>(u >> 32);\\n    let t: f64;\\n    if (w < 0x3FE62E42) {\\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\\n      t = expm1(x);\\n      // return 1 + t * t / (2 * (1 + t));\\n      return 1 + t * t / (2 + 2 * t);\\n    }\\n    if (w < 0x40862E42) {\\n      t = exp(x);\\n      return 0.5 * (t + 1 / t);\\n    }\\n    t = expo2(x, 1);\\n    return t;\\n  }\\n\\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return exp_lut(x);\\n    } else {\\n      const\\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\\n\\n      let hx = u32(reinterpret<u64>(x) >> 32);\\n      let sign = hx >> 31;\\n      hx &= 0x7FFFFFFF;\\n      if (hx >= 0x4086232B) {\\n        if (isNaN(x)) return x;\\n        if (x > overflow)  return x * Ox1p1023;\\n        if (x < underflow) return 0;\\n      }\\n      let hi: f64, lo: f64 = 0;\\n      let k = 0;\\n      if (hx > 0x3FD62E42) {\\n        if (hx >= 0x3FF0A2B2) {\\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\\n        } else {\\n          k = 1 - (sign << 1);\\n        }\\n        hi = x - k * ln2hi;\\n        lo = k * ln2lo;\\n        x = hi - lo;\\n      } else if (hx > 0x3E300000) {\\n        hi = x;\\n      } else return 1.0 + x;\\n      let xs = x * x;\\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\\n      let xq = xs * xs;\\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\\n      return k == 0 ? y : scalbn(y, k);\\n    }\\n  }\\n\\n  export function exp2(x: f64): f64 {\\n    return exp2_lut(x);\\n  }\\n\\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\\n    const\\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\\n    let sign = u32(u >> 63);\\n    let k = 0;\\n    if (hx >= 0x4043687A) {\\n      if (isNaN(x)) return x;\\n      if (sign) return -1;\\n      if (x > o_threshold) return x * Ox1p1023;\\n    }\\n    let c = 0.0, t: f64;\\n    if (hx > 0x3FD62E42) {\\n      k = select<i32>(\\n        1 - (sign << 1),\\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\\n        hx < 0x3FF0A2B2\\n      );\\n      t = <f64>k;\\n      let hi = x - t * ln2_hi;\\n      let lo = t * ln2_lo;\\n      x = hi - lo;\\n      c = (hi - x) - lo;\\n    } else if (hx < 0x3C900000) return x;\\n    let hfx = 0.5 * x;\\n    let hxs = x * hfx;\\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\\n    let hxq = hxs * hxs;\\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\\n    t = 3.0 - r1 * hfx;\\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\\n    if (k == 0) return x - (x * e - hxs);\\n    e = x * (e - c) - c;\\n    e -= hxs;\\n    if (k == -1) return 0.5 * (x - e) - 0.5;\\n    if (k == 1) {\\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\\n      return 1.0 + 2.0 * (x - e);\\n    }\\n    u = (0x3FF + k) << 52;\\n    let twopk = reinterpret<f64>(u);\\n    let y: f64;\\n    if (k < 0 || k > 56) {\\n      y = x - e + 1.0;\\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\\n      else y = y * twopk;\\n      return y - 1.0;\\n    }\\n    u = (0x3FF - k) << 52;\\n    y = reinterpret<f64>(u);\\n    if (k < 20) y = (1 - y) - e;\\n    else y = 1 - (e + y);\\n    return (x + y) * twopk;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function floor(x: f64): f64 {\\n    return builtin_floor<f64>(x);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function fround(x: f64): f64 {\\n    return <f32>x;\\n  }\\n\\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\\n    const\\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\\n\\n    let ux = reinterpret<u64>(x);\\n    let uy = reinterpret<u64>(y);\\n    ux &= 0x7FFFFFFFFFFFFFFF;\\n    uy &= 0x7FFFFFFFFFFFFFFF;\\n    if (ux < uy) {\\n      let ut = ux;\\n      ux = uy;\\n      uy = ut;\\n    }\\n    let ex = i32(ux >> 52);\\n    let ey = i32(uy >> 52);\\n    y = reinterpret<f64>(uy);\\n    if (ey == 0x7FF) return y;\\n    x = reinterpret<f64>(ux);\\n    if (ex == 0x7FF || uy == 0) return x;\\n    if (ex - ey > 64) return x + y;\\n    let z = 1.0;\\n    if (ex > 0x3FF + 510) {\\n      z  = Ox1p700;\\n      x *= Ox1p_700;\\n      y *= Ox1p_700;\\n    } else if (ey < 0x3FF - 450) {\\n      z  = Ox1p_700;\\n      x *= Ox1p700;\\n      y *= Ox1p700;\\n    }\\n    let c = x * SPLIT;\\n    let h = x - c + c;\\n    let l = x - h;\\n    let hx = x * x;\\n    let lx = h * h - hx + (2 * h + l) * l;\\n    c = y * SPLIT;\\n    h = y - c + c;\\n    l = y - h;\\n    let hy = y * y;\\n    let ly = h * h - hy + (2 * h + l) * l;\\n    return z * builtin_sqrt(ly + lx + hy + hx);\\n  }\\n\\n  export function imul(x: f64, y: f64): f64 {\\n    /*\\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\\n     *\\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\\n     * our float-point arguments before actual convertion to integers.\\n     */\\n    if (!isFinite(x + y)) return 0;\\n    return dtoi32(x) * dtoi32(y);\\n  }\\n\\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return log_lut(x);\\n    } else {\\n      const\\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\\n\\n      let u = reinterpret<u64>(x);\\n      let hx = u32(u >> 32);\\n      let k = 0;\\n      let sign = hx >> 31;\\n      if (sign || hx < 0x00100000) {\\n        if (u << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0.0;\\n        k -= 54;\\n        x *= Ox1p54;\\n        u = reinterpret<u64>(x);\\n        hx = u32(u >> 32);\\n      } else if (hx >= 0x7FF00000) {\\n        return x;\\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\\n        return 0;\\n      }\\n      hx += 0x3FF00000 - 0x3FE6A09E;\\n      k += (<i32>hx >> 20) - 0x3FF;\\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\\n      x = reinterpret<f64>(u);\\n      let f = x - 1.0;\\n      let hfsq = 0.5 * f * f;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n      let r = t2 + t1;\\n      let dk = <f64>k;\\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\\n    }\\n  }\\n\\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = u32(u >> 32);\\n    let k = 0;\\n    let sign = hx >> 31;\\n    if (sign || hx < 0x00100000) {\\n      if (u << 1 == 0) return -1 / (x * x);\\n      if (sign) return (x - x) / 0.0;\\n      k -= 54;\\n      x *= Ox1p54;\\n      u = reinterpret<u64>(x);\\n      hx = u32(u >> 32);\\n    } else if (hx >= 0x7FF00000) {\\n      return x;\\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\\n      return 0;\\n    }\\n    hx += 0x3FF00000 - 0x3FE6A09E;\\n    k += i32(hx >> 20) - 0x3FF;\\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\\n    x = reinterpret<f64>(u);\\n    let f = x - 1.0;\\n    let hfsq = 0.5 * f * f;\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n    let r = t2 + t1;\\n    let hi = f - hfsq;\\n    u = reinterpret<u64>(hi);\\n    u &= 0xFFFFFFFF00000000;\\n    hi = reinterpret<f64>(u);\\n    let lo = f - hi - hfsq + s * (hfsq + r);\\n    let val_hi = hi * ivln10hi;\\n    let dk = <f64>k;\\n    let y = dk * log10_2hi;\\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\\n    w = y + val_hi;\\n    val_lo += (y - w) + val_hi;\\n    return val_lo + w;\\n  }\\n\\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\\n\\n    let u = reinterpret<u64>(x);\\n    let hx = u32(u >> 32);\\n    let k = 1;\\n    let c = 0.0, f = 0.0;\\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\\n      if (hx >= 0xBFF00000) {\\n        if (x == -1) return x / 0.0;\\n        return (x - x) / 0.0;\\n      }\\n      if (hx << 1 < 0x3CA00000 << 1) return x;\\n      if (hx <= 0xBFD2BEC4) {\\n        k = 0;\\n        c = 0;\\n        f = x;\\n      }\\n    } else if (hx >= 0x7FF00000) return x;\\n    if (k) {\\n      u = reinterpret<u64>(1 + x);\\n      let hu = u32(u >> 32);\\n      hu += 0x3FF00000 - 0x3FE6A09E;\\n      k = i32(hu >> 20) - 0x3FF;\\n      if (k < 54) {\\n        let uf = reinterpret<f64>(u);\\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\\n        c /= uf;\\n      } else c = 0;\\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\\n      f = reinterpret<f64>(u) - 1;\\n    }\\n    let hfsq = 0.5 * f * f;\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n    let r = t2 + t1;\\n    let dk = <f64>k;\\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\\n  }\\n\\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return log2_lut(x);\\n    } else {\\n      const\\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\\n\\n      let u = reinterpret<u64>(x);\\n      let hx = u32(u >> 32);\\n      let k = 0;\\n      let sign = hx >> 31;\\n      if (sign || hx < 0x00100000) {\\n        if (u << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0.0;\\n        k -= 54;\\n        x *= Ox1p54;\\n        u = reinterpret<u64>(x);\\n        hx = u32(u >> 32);\\n      } else if (hx >= 0x7FF00000) {\\n        return x;\\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\\n        return 0;\\n      }\\n      hx += 0x3FF00000 - 0x3FE6A09E;\\n      k += i32(hx >> 20) - 0x3FF;\\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\\n      x = reinterpret<f64>(u);\\n      let f = x - 1.0;\\n      let hfsq = 0.5 * f * f;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\\n      let r = t2 + t1;\\n      let hi = f - hfsq;\\n      u = reinterpret<u64>(hi);\\n      u &= 0xFFFFFFFF00000000;\\n      hi = reinterpret<f64>(u);\\n      let lo = f - hi - hfsq + s * (hfsq + r);\\n      let val_hi = hi * ivln2hi;\\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\\n      let y = <f64>k;\\n      w = y + val_hi;\\n      val_lo += (y - w) + val_hi;\\n      val_hi = w;\\n      return val_lo + val_hi;\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function max(value1: f64, value2: f64): f64 {\\n    return builtin_max<f64>(value1, value2);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function min(value1: f64, value2: f64): f64 {\\n    return builtin_min<f64>(value1, value2);\\n  }\\n\\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\\n    // TODO: remove this fast pathes after introduced own mid-end IR with \\\"stdlib call simplify\\\" transforms\\n    if (builtin_abs<f64>(y) <= 2) {\\n      if (y == 2.0) return x * x;\\n      if (y == 0.5) {\\n        return select<f64>(\\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\\n          Infinity,\\n          x != -Infinity\\n        );\\n      }\\n      if (y == -1.0) return 1 / x;\\n      if (y == 1.0) return x;\\n      if (y == 0.0) return 1.0;\\n    }\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return pow_lut(x, y);\\n    } else {\\n      const\\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\\n\\n      let u_ = reinterpret<u64>(x);\\n      let hx = i32(u_ >> 32);\\n      let lx = <u32>u_;\\n      u_ = reinterpret<u64>(y);\\n      let hy = i32(u_ >> 32);\\n      let ly = <u32>u_;\\n      let ix = hx & 0x7FFFFFFF;\\n      let iy = hy & 0x7FFFFFFF;\\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\\n      if ( // NaN if either arg is NaN\\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\\n      ) return x + y;\\n      let yisint = 0, k: i32;\\n      if (hx < 0) {\\n        if (iy >= 0x43400000) yisint = 2;\\n        else if (iy >= 0x3FF00000) {\\n          k = (iy >> 20) - 0x3FF;\\n          let offset = select<u32>(52, 20, k > 20) - k;\\n          let Ly = select<u32>(ly, iy, k > 20);\\n          let jj = Ly >> offset;\\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\\n        }\\n      }\\n      if (ly == 0) {\\n        if (iy == 0x7FF00000) { // y is +-inf\\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\\n        }\\n        if (iy == 0x3FF00000) {\\n          if (hy >= 0) return x;\\n          return 1 / x;\\n        }\\n        if (hy == 0x40000000) return x * x;\\n        if (hy == 0x3FE00000) {\\n          if (hx >= 0) return builtin_sqrt(x);\\n        }\\n      }\\n      let ax = builtin_abs<f64>(x), z: f64;\\n      if (lx == 0) {\\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\\n          z = ax;\\n          if (hy < 0) z = 1.0 / z;\\n          if (hx < 0) {\\n            if (((ix - 0x3FF00000) | yisint) == 0) {\\n              let d = z - z;\\n              z = d / d;\\n            } else if (yisint == 1) z = -z;\\n          }\\n          return z;\\n        }\\n      }\\n      let s = 1.0;\\n      if (hx < 0) {\\n        if (yisint == 0) {\\n          let d = x - x;\\n          return d / d;\\n        }\\n        if (yisint == 1) s = -1.0;\\n      }\\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\\n      let j: i32, n: i32;\\n      if (iy > 0x41E00000) {\\n        if (iy > 0x43F00000) {\\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\\n        }\\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\\n        t = ax - 1.0;\\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\\n        u = ivln2_h * t;\\n        v = t * ivln2_l - w * ivln2;\\n        t1 = u + v;\\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\\n        t2 = v - (t1 - u);\\n      } else {\\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\\n        n = 0;\\n        if (ix < 0x00100000) {\\n          ax *= two53;\\n          n -= 53;\\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\\n        }\\n        n += (ix >> 20) - 0x3FF;\\n        j = ix & 0x000FFFFF;\\n        ix = j | 0x3FF00000;\\n        if (j <= 0x3988E) k = 0;\\n        else if (j < 0xBB67A) k = 1;\\n        else {\\n          k = 0;\\n          n += 1;\\n          ix -= 0x00100000;\\n        }\\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\\n        u = ax - bp;\\n        v = 1.0 / (ax + bp);\\n        ss = u * v;\\n        s_h = ss;\\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\\n        t_l = ax - (t_h - bp);\\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\\n        s2 = ss * ss;\\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\\n        r += s_l * (s_h + ss);\\n        s2 = s_h * s_h;\\n        t_h = 3.0 + s2 + r;\\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\\n        t_l = r - ((t_h - 3.0) - s2);\\n        u = s_h * t_h;\\n        v = s_l * t_h + t_l * ss;\\n        p_h = u + v;\\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\\n        p_l = v - (p_h - u);\\n        let z_h = cp_h * p_h;\\n        let dp_l = select<f64>(dp_l1, 0.0, k);\\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\\n        t = <f64>n;\\n        let dp_h = select<f64>(dp_h1, 0.0, k);\\n        t1 = ((z_h + z_l) + dp_h) + t;\\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\\n      }\\n      let y1 = y;\\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\\n      p_l = (y - y1) * t1 + y * t2;\\n      p_h = y1 * t1;\\n      z = p_l + p_h;\\n      u_ = reinterpret<u64>(z);\\n      j = u32(u_ >> 32);\\n      let i = <i32>u_;\\n      if (j >= 0x40900000) {\\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\\n        if (p_l + ovt > z - p_h) return s * huge * huge;\\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\\n        if (p_l <= z - p_h) return s * tiny * tiny;\\n      }\\n      i = j & 0x7FFFFFFF;\\n      k = (i >> 20) - 0x3FF;\\n      n = 0;\\n      if (i > 0x3FE00000) {\\n        n = j + (0x00100000 >> (k + 1));\\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\\n        t = 0.0;\\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\\n        if (j < 0) n = -n;\\n        p_h -= t;\\n      }\\n      t = p_l + p_h;\\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\\n      u = t * lg2_h;\\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\\n      z = u + v;\\n      w = v - (z - u);\\n      t = z * z;\\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\\n      z = 1.0 - (r - z);\\n      j = u32(reinterpret<u64>(z) >> 32);\\n      j += n << 20;\\n      if ((j >> 20) <= 0) z = scalbn(z, n);\\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\\n      return s * z;\\n    }\\n  }\\n\\n  export function seedRandom(value: i64): void {\\n    // Instead zero seed use golden ratio:\\n    // phi = (1 + sqrt(5)) / 2\\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\\n    if (value == 0) value = 0x9e3779b97f4a7c15;\\n    random_state0_64 = murmurHash3(value);\\n    random_state1_64 = murmurHash3(~random_state0_64);\\n    random_state0_32 = splitMix32(<u32>value);\\n    random_state1_32 = splitMix32(random_state0_32);\\n    random_seeded = true;\\n  }\\n\\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\\n    let s1 = random_state0_64;\\n    let s0 = random_state1_64;\\n    random_state0_64 = s0;\\n    s1 ^= s1 << 23;\\n    s1 ^= s1 >> 17;\\n    s1 ^= s0;\\n    s1 ^= s0 >> 26;\\n    random_state1_64 = s1;\\n    let r = (s0 >> 12) | 0x3FF0000000000000;\\n    return reinterpret<f64>(r) - 1;\\n  }\\n\\n  export function round(x: f64): f64 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\\n    } else {\\n      let roundUp = builtin_ceil<f64>(x);\\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\\n    }\\n  }\\n\\n  export function sign(x: f64): f64 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\\n    } else {\\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function signbit(x: f64): bool {\\n    return bool(reinterpret<u64>(x) >>> 63);\\n  }\\n\\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\\n    let u  = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >> 31;\\n\\n    ux &= 0x7FFFFFFF;\\n\\n    // |x| ~< pi/4\\n    if (ux <= 0x3FE921FB) {\\n      if (ux < 0x3E500000) { // |x| < 2**-26\\n        return x;\\n      }\\n      return sin_kern(x, 0.0, 0);\\n    }\\n\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7FF00000) return x - x;\\n\\n    // argument reduction needed\\n    let n  = rempio2(x, u, sign);\\n    let y0 = rempio2_y0;\\n    let y1 = rempio2_y1;\\n\\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\\n    return n & 2 ? -x : x;\\n  }\\n\\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\\n    let a = reinterpret<f64>(u);\\n    let w = u32(u >> 32);\\n    let h = builtin_copysign(0.5, x);\\n    if (w < 0x40862E42) {\\n      let t = expm1(a);\\n      if (w < 0x3FF00000) {\\n        if (w < 0x3FF00000 - (26 << 20)) return x;\\n        return h * (2 * t - t * t / (t + 1));\\n      }\\n      return h * (t + t / (t + 1));\\n    }\\n    return expo2(a, 2 * h);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function sqrt(x: f64): f64 {\\n    return builtin_sqrt<f64>(x);\\n  }\\n\\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\\n    let u = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >>> 31;\\n\\n    ux &= 0x7FFFFFFF;\\n\\n    // |x| ~< pi/4\\n    if (ux <= 0x3FE921FB) {\\n      if (ux < 0x3E400000) { // |x| < 2**-27\\n        return x;\\n      }\\n      return tan_kern(x, 0.0, 1);\\n    }\\n\\n    // tan(Inf or NaN) is NaN\\n    if (ux >= 0x7FF00000) return x - x;\\n\\n    let n = rempio2(x, u, sign);\\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\\n  }\\n\\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\\n    let u = reinterpret<u64>(x);\\n    u &= 0x7FFFFFFFFFFFFFFF;\\n    let y = reinterpret<f64>(u);\\n    let w = u32(u >> 32);\\n    let t: f64;\\n    if (w > 0x3FE193EA) {\\n      if (w > 0x40340000) {\\n        t = 1 - 0 / y;\\n      } else {\\n        t = expm1(2 * y);\\n        t = 1 - 2 / (t + 2);\\n      }\\n    } else if (w > 0x3FD058AE) {\\n      t = expm1(2 * y);\\n      t = t / (t + 2);\\n    } else if (w >= 0x00100000) {\\n      t = expm1(-2 * y);\\n      t = -t / (t + 2);\\n    } else t = y;\\n    return builtin_copysign<f64>(t, x);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function trunc(x: f64): f64 {\\n    return builtin_trunc<f64>(x);\\n  }\\n\\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\\n    const\\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\\n\\n    let y = x;\\n    if (n > 1023) {\\n      y *= Ox1p1023;\\n      n -= 1023;\\n      if (n > 1023) {\\n        y *= Ox1p1023;\\n        n = builtin_min<i32>(n - 1023, 1023);\\n      }\\n    } else if (n < -1022) {\\n      // make sure final n < -53 to avoid double\\n      // rounding in the subnormal range\\n      y *= Ox1p_1022 * Ox1p53;\\n      n += 1022 - 53;\\n      if (n < -1022) {\\n        y *= Ox1p_1022 * Ox1p53;\\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\\n      }\\n    }\\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\\n  }\\n\\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\\n    if (builtin_abs<f64>(y) == 1.0) {\\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\\n      // TODO: move this rule to compiler's optimization pass.\\n      // It could be apply for any x % C_pot, where \\\"C_pot\\\" is pow of two const.\\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\\n    }\\n    let ux = reinterpret<u64>(x);\\n    let uy = reinterpret<u64>(y);\\n    let ex = i64(ux >> 52 & 0x7FF);\\n    let ey = i64(uy >> 52 & 0x7FF);\\n    let sx = ux >> 63;\\n    let uy1 = uy << 1;\\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\\n      let m = x * y;\\n      return m / m;\\n    }\\n    let ux1 = ux << 1;\\n    if (ux1 <= uy1) {\\n      return x * f64(ux1 != uy1);\\n    }\\n    if (!ex) {\\n      ex -= builtin_clz<i64>(ux << 12);\\n      ux <<= 1 - ex;\\n    } else {\\n      ux &= u64(-1) >> 12;\\n      ux |= 1 << 52;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<i64>(uy << 12);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u64(-1) >> 12;\\n      uy |= 1 << 52;\\n    }\\n    while (ex > ey) {\\n      if (ux >= uy) {\\n        if (ux == uy) return 0 * x;\\n        ux -= uy;\\n      }\\n      ux <<= 1;\\n      --ex;\\n    }\\n    if (ux >= uy) {\\n      if (ux == uy) return 0 * x;\\n      ux -= uy;\\n    }\\n    // for (; !(ux >> 52); ux <<= 1) --ex;\\n    let shift = builtin_clz<i64>(ux << 11);\\n    ex -= shift;\\n    ux <<= shift;\\n    if (ex > 0) {\\n      ux -= 1 << 52;\\n      ux |= ex << 52;\\n    } else {\\n      ux >>= -ex + 1;\\n    }\\n    return reinterpret<f64>(ux | (sx << 63));\\n  }\\n\\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\\n    let ux = reinterpret<u64>(x);\\n    let uy = reinterpret<u64>(y);\\n    let ex = i64(ux >> 52 & 0x7FF);\\n    let ey = i64(uy >> 52 & 0x7FF);\\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\\n      let m = x * y;\\n      return m / m;\\n    }\\n    if (ux << 1 == 0) return x;\\n    let uxi = ux;\\n    if (!ex) {\\n      ex -= builtin_clz<i64>(uxi << 12);\\n      uxi <<= 1 - ex;\\n    } else {\\n      uxi &= u64(-1) >> 12;\\n      uxi |= 1 << 52;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<i64>(uy << 12);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u64(-1) >> 12;\\n      uy |= 1 << 52;\\n    }\\n    let q: u32 = 0;\\n    do {\\n      if (ex < ey) {\\n        if (ex + 1 == ey) break; // goto end\\n        return x;\\n      }\\n      while (ex > ey) {\\n        if (uxi >= uy) {\\n          uxi -= uy;\\n          ++q;\\n        }\\n        uxi <<= 1;\\n        q <<= 1;\\n        --ex;\\n      }\\n      if (uxi >= uy) {\\n        uxi -= uy;\\n        ++q;\\n      }\\n      if (uxi == 0) ex = -60;\\n      else {\\n        let shift = builtin_clz<i64>(uxi << 11);\\n        ex -= shift;\\n        uxi <<= shift;\\n      }\\n      break;\\n    } while (false);\\n    // end:\\n    if (ex > 0) {\\n      uxi -= 1 << 52;\\n      uxi |= ex << 52;\\n    } else {\\n      uxi >>= -ex + 1;\\n    }\\n    x = reinterpret<f64>(uxi);\\n    y = builtin_abs<f64>(y);\\n    let x2 = x + x;\\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\\n      x -= y;\\n      // ++q;\\n    }\\n    return <i64>ux < 0 ? -x : x;\\n  }\\n\\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\\n    let u = reinterpret<u64>(x);\\n    let ux = u32(u >> 32);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3FE921FB) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\\n        sincos_sin = x;\\n        sincos_cos = 1;\\n        return;\\n      }\\n      sincos_sin = sin_kern(x, 0, 0);\\n      sincos_cos = cos_kern(x, 0);\\n      return;\\n    }\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) {\\n      let xx = x - x;\\n      sincos_sin = xx;\\n      sincos_cos = xx;\\n      return;\\n    }\\n    // general argument reduction needed\\n    let n = rempio2(x, u, sign);\\n    let y0 = rempio2_y0;\\n    let y1 = rempio2_y1;\\n    let s = sin_kern(y0, y1, 1);\\n    let c = cos_kern(y0, y1);\\n    let sin = s, cos = c;\\n    if (n & 1) {\\n      sin =  c;\\n      cos = -s;\\n    }\\n    if (n & 2) {\\n      sin = -sin;\\n      cos = -cos;\\n    }\\n    sincos_sin = sin;\\n    sincos_cos = cos;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let rempio2f_y: f64;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\\n  0xA2F9836E4E441529,\\n  0xFC2757D1F534DDC0,\\n  0xDB6295993C439041,\\n  0xFE5163ABDEBBC561\\n]);\\n\\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\\n\\n  let p = z * (pS0 + z * (pS1 + z * pS2));\\n  let q: f32 = 1 + z * qS1;\\n  return p / q;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\\n  const                                // see: musl/src/math/__expo2f.c\\n    k    = <u32>235,\\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\\n  // in directed rounding correct sign before rounding or overflow is important\\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // \u03C0 * 0x1p-65 = 8.51530395021638647334e-20\\n\\n  let offset = (u >> 23) - 152;\\n  let shift  = u64(offset & 63);\\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\\n\\n  let b0 = load<u64>(tblPtr, 0 << 3);\\n  let b1 = load<u64>(tblPtr, 1 << 3);\\n  let lo: u64;\\n\\n  if (shift > 32) {\\n    let b2 = load<u64>(tblPtr, 2 << 3);\\n    lo  = b2 >> (96 - shift);\\n    lo |= b1 << (shift - 32);\\n  } else {\\n    lo = b1 >> (32 - shift);\\n  }\\n\\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\\n  let product = mantissa * hi + (mantissa * lo >> 32);\\n  let r: i64 = product << 2;\\n  let q = i32((product >> 62) + (r >>> 63));\\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\\n  return q;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\\n  const\\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\\n\\n  if (u < 0x4DC90FDB) { // \u03C0 * 0x1p28\\n    let q = nearest(x * _2_pi);\\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\\n    return <i32>q;\\n  }\\n\\n  let q = pio2f_large_quot(x, u);\\n  return select(-q, q, sign);\\n}\\n\\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\\n// @ts-ignore: decorator\\n@inline\\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\\n  const\\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = S3 + z * S4;\\n  let s = z * x;\\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\\n}\\n\\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\\n// @ts-ignore: decorator\\n@inline\\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\\n  const\\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\\n\\n  let z = x * x;\\n  let w = z * z;\\n  let r = C2 + z * C3;\\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\\n}\\n\\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\\n// @ts-ignore: decorator\\n@inline\\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\\n  const\\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\\n\\n  let z = x * x;\\n  let r = T4 + z * T5;\\n  let t = T2 + z * T3;\\n  let w = z * z;\\n  let s = z * x;\\n  let u = T0 + z * T1;\\n\\n  r = (x + s * u) + (s * w) * (t + w * r);\\n  return f32(odd ? -1 / r : r);\\n}\\n\\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\\n// @ts-ignore: decorator\\n@inline\\nfunction log2f(x: f64): f64 {\\n  const\\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\\n\\n  let i = reinterpret<i64>(x);\\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\\n  x = reinterpret<f64>(i - (exponent << 52));\\n  x = (x - 1) / (x + 1);\\n  let xx = x * x;\\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\\n  return (2 * log2e) * y + <f64>exponent;\\n}\\n\\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\\n// @ts-ignore: decorator\\n@inline\\nfunction exp2f(x: f64): f64 {\\n  const\\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\\n\\n  if (x < -1022) return 0;\\n  if (x >= 1024) return Infinity;\\n\\n  let n = nearest(x);\\n  x -= n;\\n  let xx = x * x;\\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\\n}\\n\\nexport namespace NativeMathf {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const E       = <f32>NativeMath.E;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN2     = <f32>NativeMath.LN2;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LN10    = <f32>NativeMath.LN10;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG2E   = <f32>NativeMath.LOG2E;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const LOG10E  = <f32>NativeMath.LOG10E;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const PI      = <f32>NativeMath.PI;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export const SQRT2   = <f32>NativeMath.SQRT2;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_sin: f32 = 0;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  export let sincos_cos: f32 = 0;\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function abs(x: f32): f32 {\\n    return builtin_abs<f32>(x);\\n  }\\n\\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\\n\\n    let hx = reinterpret<u32>(x);\\n    let ix = hx & 0x7FFFFFFF;\\n    if (ix >= 0x3F800000) {\\n      if (ix == 0x3F800000) {\\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\\n      }\\n      return 0 / (x - x);\\n    }\\n    if (ix < 0x3F000000) {\\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\\n    }\\n    let z: f32, w: f32, s: f32;\\n    if (<i32>hx < 0) {\\n      // z = (1 + x) * 0.5;\\n      z = 0.5 + x * 0.5;\\n      s = builtin_sqrt<f32>(z);\\n      w = Rf(z) * s - pio2_lo;\\n      return 2 * (pio2_hi - (s + w));\\n    }\\n    // z = (1 - x) * 0.5;\\n    z = 0.5 - x * 0.5;\\n    s = builtin_sqrt<f32>(z);\\n    hx = reinterpret<u32>(s);\\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\\n    let c = (z - df * df) / (s + df);\\n    w = Rf(z) * s + c;\\n    return 2 * (df + w);\\n  }\\n\\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\\n    let u = reinterpret<u32>(x);\\n    let a = u & 0x7FFFFFFF;\\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\\n      let xm1 = x - 1;\\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\\n    }\\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\\n    }\\n    // x >= 0x1p12 or x <= -2 or NaN\\n    return log(x) + s;\\n  }\\n\\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\\n\\n    let sx = x;\\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\\n    if (hx >= 0x3F800000) {\\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\\n      return 0 / (x - x);\\n    }\\n    if (hx < 0x3F000000) {\\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\\n      return x + x * Rf(x * x);\\n    }\\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\\n    let s = builtin_sqrt<f64>(z); // sic\\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\\n    return builtin_copysign(x, sx);\\n  }\\n\\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\\n    let y = reinterpret<f32>(u);\\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\\n    return builtin_copysign(y, x);\\n  }\\n\\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\\n\\n    let ix = reinterpret<u32>(x);\\n    let sx = x;\\n    ix &= 0x7FFFFFFF;\\n    let z: f32;\\n    if (ix >= 0x4C800000) {\\n      if (isNaN(x)) return x;\\n      z = atanhi3 + Ox1p_120f;\\n      return builtin_copysign(z, sx);\\n    }\\n    let id: i32;\\n    if (ix < 0x3EE00000) {\\n      if (ix < 0x39800000) return x;\\n      id = -1;\\n    } else {\\n      x = builtin_abs<f32>(x);\\n      if (ix < 0x3F980000) {\\n        if (ix < 0x3F300000) {\\n          id = 0;\\n          x = (2.0 * x - 1.0) / (2.0 + x);\\n        } else {\\n          id = 1;\\n          x = (x - 1.0) / (x + 1.0);\\n        }\\n      } else {\\n        if (ix < 0x401C0000) {\\n          id = 2;\\n          x = (x - 1.5) / (1.0 + 1.5 * x);\\n        } else {\\n          id = 3;\\n          x = -1.0 / x;\\n        }\\n      }\\n    }\\n    z = x * x;\\n    let w = z * z;\\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\\n    let s2 = w * (aT1 + w * aT3);\\n    let s3 = x * (s1 + s2);\\n    if (id < 0) return x - s3;\\n    switch (id) {\\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\\n      default: unreachable();\\n    }\\n    return builtin_copysign(z, sx);\\n  }\\n\\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\\n    let u = reinterpret<u32>(x);\\n    let y = builtin_abs(x);\\n    if (u < 0x3F800000 - (1 << 23)) {\\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\\n    return builtin_copysign(y, x);\\n  }\\n\\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\\n    const\\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\\n\\n    if (isNaN(x) || isNaN(y)) return x + y;\\n    let ix = reinterpret<u32>(x);\\n    let iy = reinterpret<u32>(y);\\n    if (ix == 0x3F800000) return atan(y);\\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\\n    ix &= 0x7FFFFFFF;\\n    iy &= 0x7FFFFFFF;\\n    if (iy == 0) {\\n      switch (m) {\\n        case 0:\\n        case 1: return  y;\\n        case 2: return  pi;\\n        case 3: return -pi;\\n      }\\n    }\\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\\n    if (ix == 0x7F800000) {\\n      if (iy == 0x7F800000) {\\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\\n        return m & 1 ? -t : t;\\n      } else {\\n        let t: f32 = m & 2 ? pi : 0.0;\\n        return m & 1 ? -t : t;\\n      }\\n    }\\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\\n    let z: f32;\\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\\n    else z = atan(builtin_abs<f32>(y / x));\\n    switch (m) {\\n      case 0: return  z;\\n      case 1: return -z;\\n      case 2: return pi - (z - pi_lo);\\n      case 3: return (z - pi_lo) - pi;\\n    }\\n    unreachable();\\n    return 0;\\n  }\\n\\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      B1      = <u32>709958130,\\n      B2      = <u32>642849266,\\n      Ox1p24f = reinterpret<f32>(0x4B800000);\\n\\n    let u = reinterpret<u32>(x);\\n    let hx = u & 0x7FFFFFFF;\\n    if (hx >= 0x7F800000) return x + x;\\n    if (hx < 0x00800000) {\\n      if (hx == 0) return x;\\n      u = reinterpret<u32>(x * Ox1p24f);\\n      hx = u & 0x7FFFFFFF;\\n      hx = hx / 3 + B2;\\n    } else {\\n      hx = hx / 3 + B1;\\n    }\\n    u &= 0x80000000;\\n    u |= hx;\\n    let t = <f64>reinterpret<f32>(u);\\n    let r = t * t * t;\\n    t = t * (<f64>x + x + r) / (x + r + r);\\n    r = t * t * t;\\n    t = t * (<f64>x + x + r) / (x + r + r);\\n    return <f32>t;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function ceil(x: f32): f32 {\\n    return builtin_ceil<f32>(x);\\n  }\\n\\n  export function clz32(x: f32): f32 {\\n    if (!isFinite(x)) return 32;\\n    return <f32>builtin_clz(dtoi32(x));\\n  }\\n\\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\\n    const\\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        // raise inexact if x != 0\\n        return 1;\\n      }\\n      return cos_kernf(x);\\n    }\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5\u03C0/4\\n        if (ux > 0x4016CBE3) { // |x|  ~> 3\u03C0/4\\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\\n        } else {\\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\\n        }\\n      }\\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9\u03C0/4\\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7\u03C0/4\\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\\n        } else {\\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\\n        }\\n      }\\n    }\\n\\n    // cos(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) return x - x;\\n\\n    // general argument reduction needed\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n\\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\\n    return (n + 1) & 2 ? -t : t;\\n  }\\n\\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\\n    let u = reinterpret<u32>(x);\\n    u &= 0x7FFFFFFF;\\n    x = reinterpret<f32>(u);\\n    if (u < 0x3F317217) {\\n      if (u < 0x3F800000 - (12 << 23)) return 1;\\n      let t = expm1(x);\\n      // return 1 + t * t / (2 * (1 + t));\\n      return 1 + t * t / (2 + 2 * t);\\n    }\\n    if (u < 0x42B17217) {\\n      let t = exp(x);\\n      // return 0.5 * (t + 1 / t);\\n      return 0.5 * t + 0.5 / t;\\n    }\\n    return expo2f(x, 1);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function floor(x: f32): f32 {\\n    return builtin_floor<f32>(x);\\n  }\\n\\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return expf_lut(x);\\n    } else {\\n      const\\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\\n\\n      let hx = reinterpret<u32>(x);\\n      let sign = hx >> 31;\\n      hx &= 0x7FFFFFFF;\\n      if (hx >= 0x42AEAC50) {\\n        if (hx > 0x7F800000) return x; // NaN\\n        if (hx >= 0x42B17218) {\\n          if (!sign) return x * Ox1p127f;\\n          else if (hx >= 0x42CFF1B5) return 0;\\n        }\\n      }\\n      let hi: f32, lo: f32;\\n      let k: i32;\\n      if (hx > 0x3EB17218) {\\n        if (hx > 0x3F851592) {\\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\\n        } else {\\n          k = 1 - (sign << 1);\\n        }\\n        hi = x - <f32>k * ln2hi;\\n        lo = <f32>k * ln2lo;\\n        x = hi - lo;\\n      } else if (hx > 0x39000000) {\\n        k = 0;\\n        hi = x;\\n        lo = 0;\\n      } else {\\n        return 1 + x;\\n      }\\n      let xx = x * x;\\n      let c = x - xx * (P1 + xx * P2);\\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\\n      return k == 0 ? y : scalbn(y, k);\\n    }\\n  }\\n\\n  export function exp2(x: f32): f32 {\\n    return exp2f_lut(x);\\n  }\\n\\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\\n\\n    let u = reinterpret<u32>(x);\\n    let hx = u & 0x7FFFFFFF;\\n    let sign = u >> 31;\\n    if (hx >= 0x4195B844) {\\n      if (hx > 0x7F800000) return x;\\n      if (sign) return -1;\\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\\n        x *= Ox1p127f;\\n        return x;\\n      }\\n    }\\n    let c: f32 = 0.0, t: f32, k: i32;\\n    if (hx > 0x3EB17218) {\\n      k = select<i32>(\\n        1 - (sign << 1),\\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\\n        hx < 0x3F851592\\n      );\\n      t = <f32>k;\\n      let hi = x - t * ln2_hi;\\n      let lo = t * ln2_lo;\\n      x = hi - lo;\\n      c = (hi - x) - lo;\\n    } else if (hx < 0x33000000) {\\n      return x;\\n    } else k = 0;\\n    let hfx: f32 = 0.5 * x;\\n    let hxs: f32 = x * hfx;\\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\\n    t  = 3.0 - r1 * hfx;\\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\\n    if (k == 0) return x - (x * e - hxs);\\n    e  = x * (e - c) - c;\\n    e -= hxs;\\n    if (k == -1) return 0.5 * (x - e) - 0.5;\\n    if (k == 1) {\\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\\n      return 1.0 + 2.0 * (x - e);\\n    }\\n    u = (0x7F + k) << 23;\\n    let twopk = reinterpret<f32>(u);\\n    let y: f32;\\n    if (k < 0 || k > 56) {\\n      y = x - e + 1.0;\\n      if (k == 128) y = y * 2.0 * Ox1p127f;\\n      else y = y * twopk;\\n      return y - 1.0;\\n    }\\n    u = (0x7F - k) << 23;\\n    y = reinterpret<f32>(u);\\n    if (k < 20) y = (1 - y) - e;\\n    else y = 1 - (e + y);\\n    return (x + y) * twopk;\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function fround(x: f32): f32 {\\n    return x;\\n  }\\n\\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\\n    const\\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\\n      Ox1p_90f = reinterpret<f32>(0x12800000);\\n\\n    let ux = reinterpret<u32>(x);\\n    let uy = reinterpret<u32>(y);\\n    ux &= 0x7FFFFFFF;\\n    uy &= 0x7FFFFFFF;\\n    if (ux < uy) {\\n      let ut = ux;\\n      ux = uy;\\n      uy = ut;\\n    }\\n    x = reinterpret<f32>(ux);\\n    y = reinterpret<f32>(uy);\\n    if (uy == 0xFF << 23) return y;\\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\\n    let z: f32 = 1;\\n    if (ux >= (0x7F + 60) << 23) {\\n      z  = Ox1p90f;\\n      x *= Ox1p_90f;\\n      y *= Ox1p_90f;\\n    } else if (uy < (0x7F - 60) << 23) {\\n      z  = Ox1p_90f;\\n      x *= Ox1p90f;\\n      y *= Ox1p90f;\\n    }\\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function imul(x: f32, y: f32): f32 {\\n    /*\\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\\n     *\\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\\n     * our float-point arguments before actual convertion to integers.\\n     */\\n    if (!isFinite(x + y)) return 0;\\n    return <f32>(dtoi32(x) * dtoi32(y));\\n  }\\n\\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return logf_lut(x);\\n    } else {\\n      const\\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\\n        Ox1p25f = reinterpret<f32>(0x4C000000);\\n\\n      let u = reinterpret<u32>(x);\\n      let k = 0;\\n      let sign = u >> 31;\\n      if (sign || u < 0x00800000) {\\n        if (u << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0;\\n        k -= 25;\\n        x *= Ox1p25f;\\n        u = reinterpret<u32>(x);\\n      } else if (u >= 0x7F800000) {\\n        return x;\\n      } else if (u == 0x3F800000) {\\n        return 0;\\n      }\\n      u += 0x3F800000 - 0x3F3504F3;\\n      k += i32(u >> 23) - 0x7F;\\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\\n      x = reinterpret<f32>(u);\\n      let f = x - 1.0;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * Lg4);\\n      let t2 = z * (Lg1 + w * Lg3);\\n      let r = t2 + t1;\\n      let hfsq = <f32>0.5 * f * f;\\n      let dk = <f32>k;\\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\\n    }\\n  }\\n\\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\\n\\n    let ux = reinterpret<u32>(x);\\n    let k = 0;\\n    let sign = ux >> 31;\\n    if (sign || ux < 0x00800000) {\\n      if (ux << 1 == 0) return -1 / (x * x);\\n      if (sign) return (x - x) / 0.0;\\n      k -= 25;\\n      x *= Ox1p25f;\\n      ux = reinterpret<u32>(x);\\n    } else if (ux >= 0x7F800000) {\\n      return x;\\n    } else if (ux == 0x3F800000) {\\n      return 0;\\n    }\\n    ux += 0x3F800000 - 0x3F3504F3;\\n    k += i32(ux >> 23) - 0x7F;\\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\\n    x = reinterpret<f32>(ux);\\n    let f = x - 1.0;\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * Lg4);\\n    let t2 = z * (Lg1 + w * Lg3);\\n    let r = t2 + t1;\\n    let hfsq: f32 = 0.5 * f * f;\\n    let hi = f - hfsq;\\n    ux = reinterpret<u32>(hi);\\n    ux &= 0xFFFFF000;\\n    hi = reinterpret<f32>(ux);\\n    let lo = f - hi - hfsq + s * (hfsq + r);\\n    let dk = <f32>k;\\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\\n  }\\n\\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\\n    const\\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\\n\\n    let ix = reinterpret<u32>(x);\\n    let c: f32 = 0;\\n    let f: f32 = 0;\\n    let k = 1;\\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\\n      if (ix >= 0xBF800000) {\\n        if (x == -1) return x / 0.0;\\n        return (x - x) / 0.0;\\n      }\\n      if (ix << 1 < 0x33800000 << 1) return x;\\n      if (ix <= 0xBE95F619) {\\n        k = 0;\\n        c = 0;\\n        f = x;\\n      }\\n    } else if (ix >= 0x7F800000) return x;\\n    if (k) {\\n      let uf: f32 = 1 + x;\\n      let iu = reinterpret<u32>(uf);\\n      iu += 0x3F800000 - 0x3F3504F3;\\n      k = i32(iu >> 23) - 0x7F;\\n      if (k < 25) {\\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\\n        c /= uf;\\n      } else c = 0;\\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\\n      f = reinterpret<f32>(iu) - 1;\\n    }\\n    let s = f / (2.0 + f);\\n    let z = s * s;\\n    let w = z * z;\\n    let t1 = w * (Lg2 + w * Lg4);\\n    let t2 = z * (Lg1 + w * Lg3);\\n    let r = t2 + t1;\\n    let hfsq: f32 = 0.5 * f * f;\\n    let dk = <f32>k;\\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\\n  }\\n\\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      return log2f_lut(x);\\n    } else {\\n      const\\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\\n\\n      let ux = reinterpret<u32>(x);\\n      let k = 0;\\n      let sign = ux >> 31;\\n      if (sign || ux < 0x00800000) {\\n        if (ux << 1 == 0) return -1 / (x * x);\\n        if (sign) return (x - x) / 0.0;\\n        k -= 25;\\n        x *= Ox1p25f;\\n        ux = reinterpret<u32>(x);\\n      } else if (ux >= 0x7F800000) {\\n        return x;\\n      } else if (ux == 0x3F800000) {\\n        return 0;\\n      }\\n      ux += 0x3F800000 - 0x3F3504F3;\\n      k += i32(ux >> 23) - 0x7F;\\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\\n      x = reinterpret<f32>(ux);\\n      let f = x - 1.0;\\n      let s = f / (2.0 + f);\\n      let z = s * s;\\n      let w = z * z;\\n      let t1 = w * (Lg2 + w * Lg4);\\n      let t2 = z * (Lg1 + w * Lg3);\\n      let r = t2 + t1;\\n      let hfsq: f32 = 0.5 * f * f;\\n      let hi = f - hfsq;\\n      let u = reinterpret<u32>(hi);\\n      u &= 0xFFFFF000;\\n      hi = reinterpret<f32>(u);\\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\\n      let dk = <f32>k;\\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function max(value1: f32, value2: f32): f32 {\\n    return builtin_max<f32>(value1, value2);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function min(value1: f32, value2: f32): f32 {\\n    return builtin_min<f32>(value1, value2);\\n  }\\n\\n  export function pow(x: f32, y: f32): f32 {\\n    // TODO: remove this fast pathes after introduced own mid-end IR with \\\"stdlib call simplify\\\" transforms\\n    if (builtin_abs<f32>(y) <= 2) {\\n      if (y == 2.0) return x * x;\\n      if (y == 0.5) {\\n        return select<f32>(\\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\\n          Infinity,\\n          x != -Infinity\\n        );\\n      }\\n      if (y == -1.0) return 1 / x;\\n      if (y == 1.0) return x;\\n      if (y == 0.0) return 1.0;\\n    }\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      // see: musl/src/math/powf.c\\n      return powf_lut(x, y);\\n    } else {\\n      // based on:  jdh8/metallic/src/math/float/powf.c\\n      if (y == 0) return 1;\\n      // @ts-ignore: cast\\n      if (isNaN(x) | isNaN(y)) {\\n        return NaN;\\n      }\\n      let sign: u32 = 0;\\n      let uy = reinterpret<u32>(y);\\n      let ux = reinterpret<u32>(x);\\n      let sx = ux >> 31;\\n      ux &= 0x7FFFFFFF;\\n      if (sx && nearest(y) == y) {\\n        x = -x;\\n        sx = 0;\\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\\n      }\\n      let m: u32;\\n      if (ux == 0x3F800000) { // x == 1\\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\\n      } else if (ux == 0) {\\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\\n      } else if (ux == 0x7F800000) {\\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\\n      } else if (sx) {\\n        m = 0x7FC00000;\\n      } else {\\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\\n      }\\n      return reinterpret<f32>(m | sign);\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function seedRandom(value: i64): void {\\n    NativeMath.seedRandom(value);\\n  }\\n\\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\\n  export function random(): f32 {\\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\\n\\n    let s0 = random_state0_32;\\n    let s1 = random_state1_32;\\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\\n\\n    s1 ^= s0;\\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\\n    random_state1_32 = rotl<u32>(s1, 13);\\n\\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\\n  }\\n\\n  export function round(x: f32): f32 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\\n    } else {\\n      let roundUp = builtin_ceil<f32>(x);\\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\\n    }\\n  }\\n\\n  export function sign(x: f32): f32 {\\n    if (ASC_SHRINK_LEVEL > 0) {\\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\\n    } else {\\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\\n    }\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function signbit(x: f32): bool {\\n    return <bool>(reinterpret<u32>(x) >>> 31);\\n  }\\n\\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\\n    const\\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        return x;\\n      }\\n      return sin_kernf(x);\\n    }\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4\\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4\\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\\n        }\\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\\n      }\\n\\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4\\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4\\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\\n        }\\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\\n      }\\n    }\\n\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) return x - x;\\n\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n\\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\\n    return n & 2 ? -t : t;\\n  }\\n\\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\\n    let a = reinterpret<f32>(u);\\n    let h = builtin_copysign<f32>(0.5, x);\\n    if (u < 0x42B17217) {\\n      let t = expm1(a);\\n      if (u < 0x3F800000) {\\n        if (u < 0x3F800000 - (12 << 23)) return x;\\n        return h * (2 * t - t * t / (t + 1));\\n      }\\n      return h * (t + t / (t + 1));\\n    }\\n    return expo2f(a, 2 * h);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function sqrt(x: f32): f32 {\\n    return builtin_sqrt<f32>(x);\\n  }\\n\\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\\n    const\\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        return x;\\n      }\\n      return tan_kernf(x, 0);\\n    }\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4\\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4\\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\\n        } else {\\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\\n        }\\n      }\\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4\\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4\\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\\n        } else {\\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\\n        }\\n      }\\n    }\\n\\n    // tan(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) return x - x;\\n\\n    // argument reduction\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n    return tan_kernf(y, n & 1);\\n  }\\n\\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\\n    let u = reinterpret<u32>(x);\\n    u &= 0x7FFFFFFF;\\n    let y = reinterpret<f32>(u);\\n    let t: f32;\\n    if (u > 0x3F0C9F54) {\\n      if (u > 0x41200000) t = 1 + 0 / y;\\n      else {\\n        t = expm1(2 * y);\\n        t = 1 - 2 / (t + 2);\\n      }\\n    } else if (u > 0x3E82C578) {\\n      t = expm1(2 * y);\\n      t = t / (t + 2);\\n    } else if (u >= 0x00800000) {\\n      t = expm1(-2 * y);\\n      t = -t / (t + 2);\\n    } else t = y;\\n    return builtin_copysign<f32>(t, x);\\n  }\\n\\n  // @ts-ignore: decorator\\n  @inline\\n  export function trunc(x: f32): f32 {\\n    return builtin_trunc<f32>(x);\\n  }\\n\\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\\n    const\\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\\n      Ox1p_126f = reinterpret<f32>(0x00800000);\\n\\n    let y = x;\\n    if (n > 127) {\\n      y *= Ox1p127f;\\n      n -= 127;\\n      if (n > 127) {\\n        y *= Ox1p127f;\\n        n = builtin_min<i32>(n - 127, 127);\\n      }\\n    } else if (n < -126) {\\n      y *= Ox1p_126f * Ox1p24f;\\n      n += 126 - 24;\\n      if (n < -126) {\\n        y *= Ox1p_126f * Ox1p24f;\\n        n = builtin_max<i32>(n + 126 - 24, -126);\\n      }\\n    }\\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\\n  }\\n\\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\\n    if (builtin_abs<f32>(y) == 1.0) {\\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\\n      // TODO: move this rule to compiler's optimization pass.\\n      // It could be apply for any x % C_pot, where \\\"C_pot\\\" is pow of two const.\\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\\n    }\\n    let ux = reinterpret<u32>(x);\\n    let uy = reinterpret<u32>(y);\\n    let ex = i32(ux >> 23 & 0xFF);\\n    let ey = i32(uy >> 23 & 0xFF);\\n    let sm = ux & 0x80000000;\\n    let uy1 = uy << 1;\\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\\n      let m = x * y;\\n      return m / m;\\n    }\\n    let ux1 = ux << 1;\\n    if (ux1 <= uy1) {\\n      return x * f32(ux1 != uy1);\\n    }\\n    if (!ex) {\\n      ex -= builtin_clz<u32>(ux << 9);\\n      ux <<= 1 - ex;\\n    } else {\\n      ux &= <u32>-1 >> 9;\\n      ux |= 1 << 23;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<u32>(uy << 9);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u32(-1) >> 9;\\n      uy |= 1 << 23;\\n    }\\n    while (ex > ey) {\\n      if (ux >= uy) {\\n        if (ux == uy) return 0 * x;\\n        ux -= uy;\\n      }\\n      ux <<= 1;\\n      --ex;\\n    }\\n    if (ux >= uy) {\\n      if (ux == uy) return 0 * x;\\n      ux -= uy;\\n    }\\n    // for (; !(ux >> 23); ux <<= 1) --ex;\\n    let shift = <i32>builtin_clz<u32>(ux << 8);\\n    ex -= shift;\\n    ux <<= shift;\\n    if (ex > 0) {\\n      ux -= 1 << 23;\\n      ux |= <u32>ex << 23;\\n    } else {\\n      ux >>= -ex + 1;\\n    }\\n    return reinterpret<f32>(ux | sm);\\n  }\\n\\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\\n    let ux = reinterpret<u32>(x);\\n    let uy = reinterpret<u32>(y);\\n    let ex = i32(ux >> 23 & 0xFF);\\n    let ey = i32(uy >> 23 & 0xFF);\\n    let uxi = ux;\\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\\n    if (ux << 1 == 0) return x;\\n    if (!ex) {\\n      ex -= builtin_clz<u32>(uxi << 9);\\n      uxi <<= 1 - ex;\\n    } else {\\n      uxi &= u32(-1) >> 9;\\n      uxi |= 1 << 23;\\n    }\\n    if (!ey) {\\n      ey -= builtin_clz<u32>(uy << 9);\\n      uy <<= 1 - ey;\\n    } else {\\n      uy &= u32(-1) >> 9;\\n      uy |= 1 << 23;\\n    }\\n    let q = 0;\\n    do {\\n      if (ex < ey) {\\n        if (ex + 1 == ey) break; // goto end\\n        return x;\\n      }\\n      while (ex > ey) {\\n        if (uxi >= uy) {\\n          uxi -= uy;\\n          ++q;\\n        }\\n        uxi <<= 1;\\n        q <<= 1;\\n        --ex;\\n      }\\n      if (uxi >= uy) {\\n        uxi -= uy;\\n        ++q;\\n      }\\n      if (uxi == 0) ex = -30;\\n      else {\\n        let shift = builtin_clz<i32>(uxi << 8);\\n        ex -= shift;\\n        uxi <<= shift;\\n      }\\n      break;\\n    } while (false);\\n    // end:\\n    if (ex > 0) {\\n      uxi -= 1 << 23;\\n      uxi |= <u32>ex << 23;\\n    } else {\\n      uxi >>= -ex + 1;\\n    }\\n    x = reinterpret<f32>(uxi);\\n    y = builtin_abs<f32>(y);\\n    let x2 = x + x;\\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\\n      x -= y;\\n      // q++;\\n    }\\n    return <i32>ux < 0 ? -x : x;\\n  }\\n\\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\\n    const\\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\\n\\n    let ux = reinterpret<u32>(x);\\n    let sign = ux >> 31;\\n    ux &= 0x7FFFFFFF;\\n\\n    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4\\n      if (ux < 0x39800000) { // |x| < 2**-12\\n        sincos_sin = x;\\n        sincos_cos = 1;\\n        return;\\n      }\\n      sincos_sin = sin_kernf(x);\\n      sincos_cos = cos_kernf(x);\\n      return;\\n    }\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4\\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4\\n          if (sign) {\\n            sincos_sin = -cos_kernf(x + s1pio2);\\n            sincos_cos =  sin_kernf(x + s1pio2);\\n          } else {\\n            sincos_sin = cos_kernf(s1pio2 - x);\\n            sincos_cos = sin_kernf(s1pio2 - x);\\n          }\\n          return;\\n        }\\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\\n        return;\\n      }\\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4\\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4\\n          if (sign) {\\n            sincos_sin =  cos_kernf(x + s3pio2);\\n            sincos_cos = -sin_kernf(x + s3pio2);\\n          } else {\\n            sincos_sin = -cos_kernf(x - s3pio2);\\n            sincos_cos =  sin_kernf(x - s3pio2);\\n          }\\n          return;\\n        }\\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\\n        return;\\n      }\\n    }\\n    // sin(Inf or NaN) is NaN\\n    if (ux >= 0x7F800000) {\\n      let xx = x - x;\\n      sincos_sin = xx;\\n      sincos_cos = xx;\\n      return;\\n    }\\n    // general argument reduction needed\\n    let n = rempio2f(x, ux, sign);\\n    let y = rempio2f_y;\\n    let s = sin_kernf(y);\\n    let c = cos_kernf(y);\\n    let sin = s, cos = c;\\n    if (n & 1) {\\n      sin =  c;\\n      cos = -s;\\n    }\\n    if (n & 2) {\\n      sin = -sin;\\n      cos = -cos;\\n    }\\n    sincos_sin = sin;\\n    sincos_cos = cos;\\n  }\\n}\\n\\nexport function ipow32(x: i32, e: i32): i32 {\\n  let out = 1;\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (x == 2) {\\n      return select<i32>(1 << e, 0, <u32>e < 32);\\n    }\\n    if (e <= 0) {\\n      if (x == -1) return select<i32>(-1, 1, e & 1);\\n      return i32(e == 0) | i32(x == 1);\\n    }\\n    else if (e == 1) return x;\\n    else if (e == 2) return x * x;\\n    else if (e < 32) {\\n      let log = 32 - clz(e);\\n      // 32 = 2 ^ 5, so need only five cases.\\n      // But some extra cases needs for properly overflowing\\n      switch (log) {\\n        case 5: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 4: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 3: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 2: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 1: {\\n          if (e & 1) out *= x;\\n        }\\n      }\\n      return out;\\n    }\\n  }\\n  while (e) {\\n    if (e & 1) out *= x;\\n    e >>>= 1;\\n    x *= x;\\n  }\\n  return out;\\n}\\n\\nexport function ipow64(x: i64, e: i64): i64 {\\n  let out: i64 = 1;\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (x == 2) {\\n      return select<i64>(1 << e, 0, <u64>e < 64);\\n    }\\n    if (e <= 0) {\\n      if (x == -1) return select<i64>(-1, 1, e & 1);\\n      return i64(e == 0) | i64(x == 1);\\n    }\\n    else if (e == 1) return x;\\n    else if (e == 2) return x * x;\\n    else if (e < 64) {\\n      let log = 64 - <i32>clz(e);\\n      // 64 = 2 ^ 6, so need only six cases.\\n      // But some extra cases needs for properly overflowing\\n      switch (log) {\\n        case 6: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 5: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 4: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 3: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 2: {\\n          if (e & 1) out *= x;\\n          e >>>= 1;\\n          x *= x;\\n        }\\n        case 1: {\\n          if (e & 1) out *= x;\\n        }\\n      }\\n      return out;\\n    }\\n  }\\n  while (e) {\\n    if (e & 1) out *= x;\\n    e >>>= 1;\\n    x *= x;\\n  }\\n  return out;\\n}\\n\\n/*\\nTODO:\\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\\nwhich usually faster than exponentiation by squaring\\n\\nfor ipow32 and e < 32:\\n\\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\\nswitch (e) {\\n  case  1: return x;\\n  case  2: return x * x;\\n  case  3: return x * x * x;\\n  case  4: return (b = x * x) * b;\\n  case  5: return (b = x * x) * b * x;\\n  case  6: return (b = x * x) * b * b;\\n  case  7: return (b = x * x) * b * b * x;\\n  case  8: return (d = (b = x * x) * b) * d;\\n  case  9: return (c = x * x * x) * c * c;\\n  case 10: return (d = (b = x * x) * b) * d * b;\\n  case 11: return (d = (b = x * x) * b) * d * b * x;\\n  case 12: return (d = (b = x * x) * b) * d * d;\\n  case 13: return (d = (b = x * x) * b) * d * d * x;\\n  case 14: return (d = (b = x * x) * b) * d * d * b;\\n  case 15: return (k = (b = x * x) * b * x) * k * k;\\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\\n}\\n\\nfor ipow64: TODO\\nswitch (e) {\\n  case 32:\\n  ...\\n  case 63:\\n}\\n*/\\n\",\n  \"memory\": \"import { memcmp, memmove, memset } from \\\"./util/memory\\\";\\nimport { E_NOTIMPLEMENTED } from \\\"./util/error\\\";\\n\\n/** Memory manager interface. */\\nexport namespace memory {\\n\\n  /** Gets the size of the memory in pages. */\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function size(): i32;\\n\\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export declare function grow(pages: i32): i32;\\n\\n  /** Fills a section in memory with the specified byte value. */\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export function fill(dst: usize, c: u8, n: usize): void {\\n    memset(dst, c, n); // fallback if \\\"bulk-memory\\\" isn't enabled\\n  }\\n\\n  /** Copies a section of memory to another. Has move semantics. */\\n  // @ts-ignore: decorator\\n  @unsafe @builtin\\n  export function copy(dst: usize, src: usize, n: usize): void {\\n    memmove(dst, src, n); // fallback if \\\"bulk-memory\\\" isn't enabled\\n  }\\n\\n  /** Initializes a memory segment. */\\n  // @ts-ignore: decorator\\n  @unsafe\\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  /** Drops a memory segment. */\\n  // @ts-ignore: decorator\\n  @unsafe\\n  export function drop(segmentIndex: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  /** Repeats a section of memory at a specific address. */\\n  // @ts-ignore: decorator\\n  @unsafe\\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\\n    let index: usize = 0;\\n    let total = srcLength * count;\\n    while (index < total) {\\n      memory.copy(dst + index, src, srcLength);\\n      index += srcLength;\\n    }\\n  }\\n\\n  /** Compares a section of memory to another. */\\n  // @ts-ignore: decorator\\n  @inline\\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\\n    return memcmp(vl, vr, n);\\n  }\\n\\n  /** Gets a pointer to a static chunk of memory of the given size. */\\n  // @ts-ignore: decorator\\n  @builtin\\n  export declare function data<T>(size: T, align?: i32): usize;\\n}\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare const __data_end: usize;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare let __stack_pointer: usize;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare const __heap_base: usize;\\n\\n/** Heap memory interface. */\\nexport namespace heap {\\n\\n  /** Allocates a chunk of memory of at least the specified size. */\\n  // @ts-ignore: decorator\\n  @unsafe export function alloc(size: usize): usize {\\n    return __alloc(size);\\n  }\\n\\n  /** Reallocates a chunk of memory to have at least the specified size. */\\n  // @ts-ignore: decorator\\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\\n    return __realloc(ptr, size);\\n  }\\n\\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\\n  // @ts-ignore: decorator\\n  @unsafe export function free(ptr: usize): void {\\n    __free(ptr);\\n  }\\n\\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\\n  // @ts-ignore: decorator\\n  @unsafe export function reset(): void {\\n    if (isDefined(__reset)) {\\n      __reset();\\n    } else {\\n      throw new Error(E_NOTIMPLEMENTED);\\n    }\\n  }\\n}\\n\",\n  \"number\": \"import { itoa32, utoa32, itoa64, utoa64, dtoa } from \\\"./util/number\\\";\\nimport { strtol, strtod } from \\\"./util/string\\\";\\n\\n// @ts-ignore: decorator\\n@builtin @inline\\nexport const NaN: f64 = 0 / 0;\\n\\n// @ts-ignore: decorator\\n@builtin @inline\\nexport const Infinity: f64 = 1 / 0;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isNaN<T extends number>(value: T): bool;\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare function isFinite<T extends number>(value: T): bool;\\n\\n@final @unmanaged\\nexport abstract class I8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i8 {\\n    return <i8>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: i8, radix: i32 = 10): String {\\n    return itoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class I16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i16 {\\n    return <i16>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: i16, radix: i32 = 10): String {\\n    return itoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class I32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i32 {\\n    return <i32>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: i32, radix: i32 = 10): String {\\n    return itoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class I64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): i64 {\\n    return strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: i64, radix: i32 = 10): String {\\n    return itoa64(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class Isize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): isize {\\n    return <isize>strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: isize, radix: i32 = 10): String {\\n    if (sizeof<isize>() == 4) {\\n      return itoa32(<i32>this, radix);\\n    } else {\\n      return itoa64(<i64>this, radix);\\n    }\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U8 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u8 {\\n    return <u8>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: u8, radix: i32 = 10): String {\\n    return utoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U16 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u16 {\\n    return <u16>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: u16, radix: i32 = 10): String {\\n    return utoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u32 {\\n    return <u32>strtol<i32>(value, radix);\\n  }\\n\\n  toString(this: u32, radix: i32 = 10): String {\\n    return utoa32(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class U64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): u64 {\\n    return <u64>strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: u64, radix: i32 = 10): String {\\n    return utoa64(this, radix);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class Usize {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): usize {\\n    return <usize>strtol<i64>(value, radix);\\n  }\\n\\n  toString(this: usize, radix: i32 = 10): String {\\n    if (sizeof<usize>() == 4) {\\n      return utoa32(<u32>this, radix);\\n    } else {\\n      return utoa64(<u64>this, radix);\\n    }\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class Bool {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\\n\\n  toString(this: bool, radix: i32 = 0): String {\\n    return this ? \\\"true\\\" : \\\"false\\\";\\n  }\\n}\\n\\nexport { Bool as Boolean };\\n\\n@final @unmanaged\\nexport abstract class F32 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly EPSILON: f32 = f32.EPSILON;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NaN: f32 = f32.NaN;\\n\\n  static isNaN(value: f32): bool {\\n    return isNaN<f32>(value);\\n  }\\n\\n  static isFinite(value: f32): bool {\\n    return isFinite<f32>(value);\\n  }\\n\\n  static isSafeInteger(value: f32): bool {\\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\\n  }\\n\\n  static isInteger(value: f32): bool {\\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\\n  }\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): f32 {\\n    return <f32>strtol<f64>(value, radix);\\n  }\\n\\n  /** @deprecated */\\n  static parseFloat(value: string): f32 {\\n    return <f32>strtod(value);\\n  }\\n\\n  toString(this: f32, radix: i32 = 0): String {\\n    return dtoa(this);\\n  }\\n}\\n\\n@final @unmanaged\\nexport abstract class F64 {\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly EPSILON: f64 = f64.EPSILON;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly NaN: f64 = f64.NaN;\\n\\n  static isNaN(value: f64): bool {\\n    return isNaN<f64>(value);\\n  }\\n\\n  static isFinite(value: f64): bool {\\n    return isFinite<f64>(value);\\n  }\\n\\n  static isSafeInteger(value: f64): bool {\\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\\n  }\\n\\n  static isInteger(value: f64): bool {\\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\\n  }\\n\\n  /** @deprecated */\\n  static parseInt(value: string, radix: i32 = 0): f64 {\\n    return strtol<f64>(value, radix);\\n  }\\n\\n  /** @deprecated */\\n  static parseFloat(value: string): f64 {\\n    return strtod(value);\\n  }\\n\\n  toString(this: f64, radix: i32 = 0): String {\\n    return dtoa(this);\\n  }\\n}\\n\\nexport { F64 as Number };\\n\",\n  \"object\": \"export class Object {\\n  static is<T>(x: T, y: T): bool {\\n    if (isFloat<T>()) {\\n      // Float pointing is special we shoulr presere following identities:\\n      // 0.0 !=-0.0\\n      // NaN == NaN\\n      if (sizeof<T>() == 8) {\\n        return (\\n          bool(u32(x != x) & u32(y != y) |\\n          u32(reinterpret<u64>(f64(x)) == reinterpret<u64>(f64(y))))\\n        );\\n      } else {\\n        return (\\n          bool(u32(x != x) & u32(y != y) |\\n          u32(reinterpret<u32>(f32(x)) == reinterpret<u32>(f32(y))))\\n        );\\n      }\\n    }\\n    // For references, strings, integers and booleans\\n    return x == y;\\n  }\\n}\\n\",\n  \"params\": \"export namespace Params {\\n  // compiler re-directs all names inside this namespace here\\n  @inline\\n  function __get(name: string): ByteArray {\\n    return hook_param(name);\\n  }\\n}\\n\",\n  \"performance\": \"import {\\n  performance as performance_binding\\n} from \\\"bindings/dom\\\";\\n\\nexport namespace performance {\\n  export function now(): f64 {\\n    return performance_binding.now();\\n  }\\n}\\n\",\n  \"process\": \"import {\\n  Date as Date_binding,\\n  performance as performance_binding\\n} from \\\"bindings/dom\\\";\\n\\nimport {\\n  process as process_binding\\n} from \\\"bindings/node\\\";\\n\\nexport namespace process {\\n\\n  // @ts-ignore: decorator\\n  @lazy export const arch = sizeof<usize>() == 4 ? \\\"wasm32\\\" : \\\"wasm64\\\";\\n\\n  // @ts-ignore: decorator\\n  @lazy export const platform = \\\"wasm\\\";\\n\\n  // @ts-ignore: decorator\\n  @lazy export const argv = lazyArgv();\\n\\n  // @ts-ignore: decorator\\n  @lazy export const env = lazyEnv();\\n\\n  // @ts-ignore: decorator\\n  @lazy export let exitCode = 0;\\n\\n  export function exit(code: i32 = exitCode): void {\\n    process_binding.exit(code);\\n  }\\n\\n  export function time(): i64 {\\n    return Date_binding.now();\\n  }\\n\\n  export function hrtime(): u64 {\\n    let now = performance_binding.now();\\n    let millis = <u64>now;\\n    let fraction = now - <f64>millis;\\n    return millis * 1000000 + <u64>(fraction * 1000000);\\n  }\\n}\\n\\nfunction lazyArgv(): string[] {\\n  return process_binding.argv;\\n}\\n\\nfunction lazyEnv(): Map<string,string> {\\n  // TODO: What about Node?\\n  return new Map();\\n}\\n\",\n  \"pubkey\": \"export class PubKey {\\n  @inline\\n  constructor(public bytes: ByteView) {\\n    if (bytes.length != 33)\\n      rollback(\\\"Public key wrong length.\\\");\\n  }\\n\\n  @inline @operator(\\\"==\\\")\\n  private static __eq(left: PubKey, right: ByteArray): bool {\\n    if (right.length != 33)\\n      return false;\\n\\n    let ptr1 = changetype<usize>(left.bytes.underlying) + left.bytes.offset;\\n    let ptr2 = changetype<usize>(right);\\n    if (ptr1 == ptr2) return true;\\n\\n    for (let i = 0; max_iterations(4), i < 4; ++i) {\\n      if (load<u64>(ptr1) != load<u64>(ptr2)) return false;\\n      ptr1 += 8;\\n      ptr2 += 8;\\n    }\\n\\n    return load<u8>(ptr1) == load<u8>(ptr2);\\n  }\\n\\n  @inline @operator(\\\"!=\\\")\\n  private static __ne(left: PubKey, right: ByteArray): bool {\\n    return !this.__eq(left, right);\\n  }\\n\\n  @inline\\n  verify(data: ByteView, sig: ByteView): void {\\n    if (!$util_verify(\\n      changetype<u32>(data.underlying) + data.offset,\\n      data.length,\\n      changetype<u32>(sig.underlying) + sig.offset,\\n      sig.length,\\n      changetype<u32>(this.bytes.underlying) + this.bytes.offset,\\n      this.bytes.length)) {\\n      rollback(\\\"Invalid Signature.\\\");\\n    }\\n  }\\n}\\n\",\n  \"reference\": \"@unmanaged\\nabstract class Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class Funcref extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class Externref extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class Anyref extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class Eqref extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class I31ref extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class Dataref extends Ref {\\n}\\n\\n@final @unmanaged\\nexport abstract class Arrayref extends Ref {\\n}\\n\",\n  \"regexp\": \"export class RegExp {\\n\\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\\n  constructor(pattern: string, flags: string = \\\"\\\") { throw new Error(\\\"unreachable\\\"); }\\n\\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\\n  test(search: string): bool { throw new Error(\\\"unreachable\\\"); }\\n\\n  // @binding(CALL_THIS, [], STRING)\\n  toString(): string { throw new Error(\\\"unreachable\\\"); }\\n\\n}\\n\",\n  \"rt\": \"import { Typeinfo, TypeinfoFlags } from \\\"./shared/typeinfo\\\";\\nimport { E_INDEXOUTOFRANGE } from \\\"./util/error\\\";\\nimport { OBJECT, TOTAL_OVERHEAD } from \\\"./rt/common\\\";\\nimport { ArrayBufferView } from \\\"./arraybuffer\\\";\\n\\n// @ts-ignore: decorator\\n@builtin\\nexport declare const __rtti_base: usize;\\n\\n// @ts-ignore: decorator\\n@builtin @unsafe\\nexport declare function __visit_globals(cookie: u32): void;\\n\\n// @ts-ignore: decorator\\n@builtin @unsafe\\nexport declare function __visit_members(ref: usize, cookie: u32): void;\\n\\n// @ts-ignore: decorator\\n@unsafe\\nexport function __typeinfo(id: u32): TypeinfoFlags {\\n  let ptr = __rtti_base;\\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe\\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\\n  let id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\\n  let rttiBase = __rtti_base;\\n  if (id <= load<u32>(rttiBase)) {\\n    do if (id == classId) return true;\\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\\n  }\\n  return false;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe\\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\\n  let buffer = __new(size, id);\\n  if (data) memory.copy(buffer, data, size);\\n  return buffer;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe\\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\\n  let bufferSize = <usize>length << alignLog2;\\n  // make sure `buffer` is tracked by the shadow stack\\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\\n  // ...since allocating the array may trigger GC steps\\n  let array = __new(offsetof<i32[]>(), id);\\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\\\"buffer\\\"));\\n  __link(array, changetype<usize>(buffer), false);\\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\\\"dataStart\\\"));\\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\\\"byteLength\\\"));\\n  store<i32>(array, length, offsetof<i32[]>(\\\"length_\\\"));\\n  return array;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\\n  return ptr;\\n}\\n\\n// These are provided by the respective implementation, included as another entry file by asc:\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __alloc(size: usize): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __realloc(ptr: usize, size: usize): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __free(ptr: usize): void;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __new(size: usize, id: u32): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __renew(ptr: usize, size: usize): usize;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __collect(): void;\\n\\n// // @ts-ignore: decorator\\n// @builtin @unsafe\\n// export declare function __visit(ptr: usize, cookie: u32): void;\\n\",\n  \"rt/common\": \"// Alignment guarantees\\n\\n// @ts-ignore: decorator\\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\\n// @ts-ignore: decorator\\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\\n// @ts-ignore: decorator\\n@inline export const AL_MASK: usize = AL_SIZE - 1;\\n\\n// Extra debugging\\n\\n// @ts-ignore: decorator\\n@inline export const DEBUG = true;\\n// @ts-ignore: decorator\\n@inline export const TRACE = false;\\n// @ts-ignore: decorator\\n@inline export const RTRACE = isDefined(ASC_RTRACE);\\n// @ts-ignore: decorator\\n@inline export const PROFILE = isDefined(ASC_PROFILE);\\n\\n// Memory manager\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Memory manager block layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                           MM info                             \u2502 -4\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                              ...                              \u2502\\n@unmanaged export class BLOCK {\\n  /** Memory manager info. */\\n  mmInfo: usize;\\n}\\n\\n/** Overhead of a memory manager block. */\\n// @ts-ignore: decorator\\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\\n\\n/** Maximum size of a memory manager block's payload. */\\n// @ts-ignore: decorator\\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\\n\\n// Garbage collector\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Garbage collector object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                     Memory manager block                      \u2502 -20\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                            GC info                            \u2502 -16\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                            GC info                            \u2502 -12\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                            RT id                              \u2502 -8\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                            RT size                            \u2502 -4\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                              ...                              \u2502\\n@unmanaged export class OBJECT extends BLOCK {\\n  /** Garbage collector info. */\\n  gcInfo: u32;\\n  /** Garbage collector info. */\\n  gcInfo2: u32;\\n  /** Runtime class id. */\\n  rtId: u32;\\n  /** Runtime object size. */\\n  rtSize: u32;\\n}\\n\\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\\n// @ts-ignore: decorator\\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\\n\\n/** Maximum size of a garbage collector object's payload. */\\n// @ts-ignore: decorator\\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\\n\\n/** Total of memory manager and garbage collector overhead. */\\n// @ts-ignore: decorator\\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\\n\",\n  \"rt/index-incremental\": \"import \\\"rt/tlsf\\\";\\nimport \\\"rt/itcms\\\";\\n\",\n  \"rt/index-minimal\": \"import \\\"rt/tlsf\\\";\\nimport \\\"rt/tcms\\\";\\n\",\n  \"rt/index-stub\": \"import \\\"rt/stub\\\";\\n\",\n  \"rt/itcms\": \"import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \\\"./common\\\";\\nimport { onvisit, oncollect, oninterrupt, onyield } from \\\"./rtrace\\\";\\nimport { TypeinfoFlags } from \\\"../shared/typeinfo\\\";\\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \\\"../util/error\\\";\\n\\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\\n// Adapted from Bach Le's \u03BCgc, see: https://github.com/bullno1/ugc\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Colors \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n// \u2502 Color       \u2502 Meaning                                         \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502 WHITE*      \u2502 Unprocessed                                     \u2502\\n// \u2502 BLACK*      \u2502 Processed                                       \u2502\\n// \u2502 GRAY        \u2502 Processed with unprocessed children             \u2502\\n// \u2502 TRANSPARENT \u2502 Manually pinned (always reachable)              \u2502\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n// * flipped between cycles\\n\\n// @ts-ignore: decorator\\n@lazy let white = 0;\\n// @ts-ignore: decorator\\n@inline const gray = 2;\\n// @ts-ignore: decorator\\n@inline const transparent = 3;\\n// @ts-ignore: decorator\\n@inline const COLOR_MASK = 3;\\n\\n/** Size in memory of all objects currently managed by the GC. */\\n// @ts-ignore: decorator\\n@lazy let total: usize = 0;\\n\\n/** Currently transitioning from SWEEP to MARK state. */\\n// @ts-ignore: decorator\\n@inline const STATE_IDLE = 0;\\n/** Currently marking reachable objects. */\\n// @ts-ignore: decorator\\n@inline const STATE_MARK = 1;\\n/** Currently sweeping unreachable objects. */\\n// @ts-ignore: decorator\\n@inline const STATE_SWEEP = 2;\\n/** Current collector state. */\\n// @ts-ignore: decorator\\n@lazy let state = STATE_IDLE;\\n\\n// @ts-ignore: decorator\\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let iter: Object; // null\\n\\nfunction initLazy(space: Object): Object {\\n  space.nextWithColor = changetype<usize>(space);\\n  space.prev = space;\\n  return space;\\n}\\n\\n/** Visit cookie indicating scanning of an object. */\\n// @ts-ignore: decorator\\n@inline const VISIT_SCAN = 0;\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Managed object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                      Memory manager block                     \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2561\\n// \u2502                              next                         \u2502 C \u2502 = nextWithColor\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524\\n// \u2502                              prev                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtId                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtSize                           \u2502\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                               ...                             \u2502\\n// C: color\\n\\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\\n@unmanaged class Object extends BLOCK {\\n  /** Pointer to the next object with color flags stored in the alignment bits. */\\n  nextWithColor: usize; // *u32\\n  /** Pointer to the previous object. */\\n  prev: Object; // *u32\\n  /** Runtime id. */\\n  rtId: u32;\\n  /** Runtime size. */\\n  rtSize: u32;\\n\\n  /** Gets the pointer to the next object. */\\n  get next(): Object {\\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\\n  }\\n\\n  /** Sets the pointer to the next object. */\\n  set next(obj: Object) {\\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Gets this object's color. */\\n  get color(): i32 {\\n    return i32(this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Sets this object's color. */\\n  set color(color: i32) {\\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\\n  }\\n\\n  /** Gets the size of this object in memory. */\\n  get size(): usize {\\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\\n  }\\n\\n  /** Tests if this object is pointerfree. */\\n  get isPointerfree(): bool {\\n    let rtId = this.rtId;\\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\\n  }\\n\\n  /** Unlinks this object from its list. */\\n  unlink(): void {\\n    let next = this.next;\\n    if (next == null) {\\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\\n      return; // static data not yet linked\\n    }\\n    let prev = this.prev;\\n    if (DEBUG) assert(prev);\\n    next.prev = prev;\\n    prev.next = next;\\n  }\\n\\n  /** Links this object to the specified list, with the given color. */\\n  linkTo(list: Object, withColor: i32): void {\\n    let prev = list.prev;\\n    this.nextWithColor = changetype<usize>(list) | withColor;\\n    this.prev = prev;\\n    prev.next = this;\\n    list.prev = this;\\n  }\\n\\n  /** Marks this object as gray, that is reachable with unscanned children. */\\n  makeGray(): void {\\n    if (this == iter) iter = assert(this.prev);\\n    this.unlink();\\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\\n  }\\n}\\n\\n/** Visits all objects considered to be program roots. */\\nfunction visitRoots(cookie: u32): void {\\n  __visit_globals(cookie);\\n  let pn = pinSpace;\\n  let iter = pn.next;\\n  while (iter != pn) {\\n    if (DEBUG) assert(iter.color == transparent);\\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\\n    iter = iter.next;\\n  }\\n}\\n\\n/** Visits all objects on the stack. */\\nfunction visitStack(cookie: u32): void {\\n  let ptr = __stack_pointer;\\n  while (ptr < __heap_base) {\\n    __visit(load<usize>(ptr), cookie);\\n    ptr += sizeof<usize>();\\n  }\\n}\\n\\n/** Performs a single step according to the current state. */\\nfunction step(): usize {\\n  // Magic constants responsible for pause times. Obtained experimentally\\n  // using the compiler compiling itself. 2048 budget pro run by default.\\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\\n  let obj: Object;\\n  switch (state) {\\n    case STATE_IDLE: {\\n      state = STATE_MARK;\\n      visitCount = 0;\\n      visitRoots(VISIT_SCAN);\\n      iter = toSpace;\\n      return visitCount * MARKCOST;\\n    }\\n    case STATE_MARK: {\\n      let black = i32(!white);\\n      obj = iter.next;\\n      while (obj != toSpace) {\\n        iter = obj;\\n        if (obj.color != black) { // skip already-blacks (pointerfree)\\n          obj.color = black;\\n          visitCount = 0;\\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\\n          return visitCount * MARKCOST;\\n        }\\n        obj = obj.next;\\n      }\\n      visitCount = 0;\\n      visitRoots(VISIT_SCAN);\\n      obj = iter.next;\\n      if (obj == toSpace) {\\n        visitStack(VISIT_SCAN);\\n        obj = iter.next;\\n        while (obj != toSpace) {\\n          if (obj.color != black) {\\n            obj.color = black;\\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\\n          }\\n          obj = obj.next;\\n        }\\n        let from = fromSpace;\\n        fromSpace = toSpace;\\n        toSpace = from;\\n        white = black;\\n        iter = from.next;\\n        state = STATE_SWEEP;\\n      }\\n      return visitCount * MARKCOST;\\n    }\\n    case STATE_SWEEP: {\\n      obj = iter;\\n      if (obj != toSpace) {\\n        iter = obj.next;\\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\\n        free(obj);\\n        return SWEEPCOST;\\n      }\\n      toSpace.nextWithColor = changetype<usize>(toSpace);\\n      toSpace.prev = toSpace;\\n      state = STATE_IDLE;\\n      break;\\n    }\\n  }\\n  return 0;\\n}\\n\\n/** Frees an object. */\\nfunction free(obj: Object): void {\\n  if (changetype<usize>(obj) < __heap_base) {\\n    obj.nextWithColor = 0; // may become linked again\\n    obj.prev = changetype<Object>(0);\\n  } else {\\n    total -= obj.size;\\n    if (isDefined(__finalize)) {\\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\\n    }\\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\\n  }\\n}\\n\\n// Garbage collector interface\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __new(size: usize, id: i32): usize {\\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  if (total >= threshold) interrupt();\\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\\n  obj.rtId = id;\\n  obj.rtSize = <u32>size;\\n  obj.linkTo(fromSpace, white); // inits next/prev\\n  total += obj.size;\\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\\n  // may be visited before being fully initialized, so must fill\\n  memory.fill(ptr, 0, size);\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __renew(oldPtr: usize, size: usize): usize {\\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\\n  // Update object size if its block is large enough\\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\\n    oldObj.rtSize = <u32>size;\\n    return oldPtr;\\n  }\\n  // If not the same object anymore, we have to move it move it due to the\\n  // shadow stack potentially still referencing the old object\\n  let newPtr = __new(size, oldObj.rtId);\\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\\n  return newPtr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\\n  // Write barrier is unnecessary if non-incremental\\n  if (!childPtr) return;\\n  if (DEBUG) assert(parentPtr);\\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\\n  if (child.color == white) {\\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\\n    let parentColor = parent.color;\\n    if (parentColor == i32(!white)) {\\n      // Maintain the invariant that no black object may point to a white object.\\n      if (expectMultiple) {\\n        // Move the barrier \\\"backward\\\". Suitable for containers receiving multiple stores.\\n        // Avoids a barrier for subsequent objects stored into the same container.\\n        parent.makeGray();\\n      } else {\\n        // Move the barrier \\\"forward\\\". Suitable for objects receiving isolated stores.\\n        child.makeGray();\\n      }\\n    } else if (parentColor == transparent && state == STATE_MARK) {\\n      // Pinned objects are considered 'black' during the mark phase.\\n      child.makeGray();\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let visitCount = 0;\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __visit(ptr: usize, cookie: i32): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (RTRACE) if (!onvisit(obj)) return;\\n  if (obj.color == white) {\\n    obj.makeGray();\\n    ++visitCount;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __pin(ptr: usize): usize {\\n  if (ptr) {\\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n    if (obj.color == transparent) {\\n      throw new Error(E_ALREADY_PINNED);\\n    }\\n    obj.unlink(); // from fromSpace\\n    obj.linkTo(pinSpace, transparent);\\n  }\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __unpin(ptr: usize): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (obj.color != transparent) {\\n    throw new Error(E_NOT_PINNED);\\n  }\\n  if (state == STATE_MARK) {\\n    // We may be right at the point after marking roots for the second time and\\n    // entering the sweep phase, in which case the object would be missed if it\\n    // is not only pinned but also a root. Make sure it isn't missed.\\n    obj.makeGray();\\n  } else {\\n    obj.unlink();\\n    obj.linkTo(fromSpace, white);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __collect(): void {\\n  if (TRACE) trace(\\\"GC (full) at\\\", 1, total);\\n  if (state > STATE_IDLE) {\\n    // finish current cycle\\n    while (state != STATE_IDLE) step();\\n  }\\n  // perform a full cycle\\n  step();\\n  while (state != STATE_IDLE) step();\\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\\n  if (TRACE) trace(\\\"GC (full) done at cur/max\\\", 2, total, memory.size() << 16);\\n  if (RTRACE || PROFILE) oncollect(total);\\n}\\n\\n// Garbage collector automation\\n\\n/** How often to interrupt. The default of 1024 means \\\"interrupt each 1024 bytes allocated\\\". */\\n// @ts-ignore: decorator\\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\\n/** How long to interrupt. The default of 200% means \\\"run at double the speed of allocations\\\". */\\n// @ts-ignore: decorator\\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\\n/** How long to idle. The default of 200% means \\\"wait for memory to double before kicking in again\\\". */\\n// @ts-ignore: decorator\\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\\n\\n/** Threshold of memory used by objects to exceed before interrupting again. */\\n// @ts-ignore: decorator\\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\\n\\n/** Performs a reasonable amount of incremental GC steps. */\\nfunction interrupt(): void {\\n  if (PROFILE) oninterrupt(total);\\n  if (TRACE) trace(\\\"GC (auto) at\\\", 1, total);\\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\\n  do {\\n    budget -= step();\\n    if (state == STATE_IDLE) {\\n      if (TRACE) trace(\\\"\u2514 GC (auto) done at cur/max\\\", 2, total, memory.size() << 16);\\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\\n      if (PROFILE) onyield(total);\\n      return;\\n    }\\n  } while (budget > 0);\\n  if (TRACE) trace(\\\"\u2514 GC (auto) ongoing at\\\", 1, total);\\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\\n  if (PROFILE) onyield(total);\\n}\\n\",\n  \"rt/rtrace\": \"import { BLOCK } from \\\"./common\\\";\\n\\nexport declare function oninit(heapBase: usize): void;\\n\\n// Memory Allocator\\nexport declare function onalloc(block: BLOCK): void;\\nexport declare function onresize(block: BLOCK, oldSizeInclOverhead: usize): void;\\nexport declare function onmove(oldBlock: BLOCK, newBlock: BLOCK): void;\\nexport declare function onfree(block: BLOCK): void;\\n\\n// Garbage collector\\nexport declare function onvisit(block: BLOCK): bool;\\nexport declare function oncollect(total: usize): void;\\nexport declare function oninterrupt(total: usize): void;\\nexport declare function onyield(total: usize): void;\\n\",\n  \"rt/stub\": \"import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from \\\"./common\\\";\\nimport { E_ALLOCATION_TOO_LARGE } from \\\"../util/error\\\";\\n\\n// === A minimal runtime stub ===\\n\\n// @ts-ignore: decorator\\n@lazy let startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n// @ts-ignore: decorator\\n@lazy let offset: usize = startOffset;\\n\\n@inline function maybeGrowMemory(newOffset: usize): void {\\n  // assumes newOffset is aligned\\n  let pagesBefore = memory.size();\\n  let maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\\n  if (newOffset > maxOffset) {\\n      unreachable(); // out of memory\\n  }\\n  offset = newOffset;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function computeSize(size: usize): usize {\\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __alloc(size: usize): usize {\\n  if (size > BLOCK_MAXSIZE)\\n    unreachable();\\n\\n  let block = changetype<BLOCK>(offset);\\n  let ptr = offset + BLOCK_OVERHEAD;\\n  let payloadSize = computeSize(size);\\n  maybeGrowMemory(ptr + payloadSize);\\n  block.mmInfo = payloadSize;\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __realloc(ptr: usize, size: usize): usize {\\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\\n  let actualSize = block.mmInfo;\\n  let isLast = ptr + actualSize == offset;\\n  let payloadSize = computeSize(size);\\n  if (size > actualSize) {\\n    if (isLast) { // last block: grow\\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n      maybeGrowMemory(ptr + payloadSize);\\n      block.mmInfo = payloadSize;\\n    } else { // copy to new block at least double the size\\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\\n      memory.copy(newPtr, ptr, actualSize);\\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\\n    }\\n  } else if (isLast) { // last block: shrink\\n    offset = ptr + payloadSize;\\n    block.mmInfo = payloadSize;\\n  }\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __free(ptr: usize): void {\\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\\n  if (ptr + block.mmInfo == offset) { // last block: discard\\n    offset = changetype<usize>(block);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __reset(): void { // special\\n  offset = startOffset;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __new(size: usize, id: u32): usize {\\n  let ptr = __alloc(OBJECT_OVERHEAD + size);\\n  let object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\\n  object.gcInfo = 0;\\n  object.gcInfo2 = 0;\\n  object.rtId = id;\\n  object.rtSize = <u32>size;\\n  return ptr + OBJECT_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@unsafe @global\\nexport function __renew(oldPtr: usize, size: usize): usize {\\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\\n  return newPtr + OBJECT_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __pin(ptr: usize): usize {\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __unpin(ptr: usize): void {\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __collect(): void {\\n  // nop\\n}\\n\",\n  \"rt/tcms\": \"import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE } from \\\"./common\\\";\\nimport { onvisit, oncollect } from \\\"./rtrace\\\";\\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \\\"../util/error\\\";\\n\\n// === TCMS: A Two-Color Mark & Sweep garbage collector ===\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Colors \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n// \u2502 Color       \u2502 Meaning                                         \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502 WHITE*      \u2502 Unreachable                                     \u2502\\n// \u2502 BLACK*      \u2502 Reachable                                       \u2502\\n// \u2502 TRANSPARENT \u2502 Manually pinned (always reachable)              \u2502\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n// * flipped between cycles\\n\\n// @ts-ignore: decorator\\n@lazy let white = 0;\\n// @ts-ignore: decorator\\n@inline const transparent = 3;\\n// @ts-ignore: decorator\\n@inline const COLOR_MASK = 3;\\n\\n/** Size in memory of all objects currently managed by the GC. */\\n// @ts-ignore: decorator\\n@lazy let total: usize = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n// @ts-ignore: decorator\\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\\n\\nfunction initLazy(space: Object): Object {\\n  space.nextWithColor = changetype<usize>(space);\\n  space.prev = space;\\n  return space;\\n}\\n\\n/** Visit cookie indicating scanning of an object. */\\n// @ts-ignore: decorator\\n@inline const VISIT_SCAN = 0;\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Managed object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502                      Memory manager block                     \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2561\\n// \u2502                              next                         \u2502 C \u2502 = nextWithColor\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524\\n// \u2502                              prev                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtId                             \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              rtSize                           \u2502\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\\n// \u2502                               ...                             \u2502\\n// C: color\\n\\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\\n@unmanaged class Object extends BLOCK {\\n  /** Pointer to the next object with color flags stored in the alignment bits. */\\n  nextWithColor: usize; // *u32\\n  /** Pointer to the previous object. */\\n  prev: Object; // *u32\\n  /** Runtime id. */\\n  rtId: u32;\\n  /** Runtime size. */\\n  rtSize: u32;\\n\\n  /** Gets the pointer to the next object. */\\n  get next(): Object {\\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\\n  }\\n\\n  /** Sets the pointer to the next object. */\\n  set next(obj: Object) {\\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Gets this object's color. */\\n  get color(): i32 {\\n    return i32(this.nextWithColor & COLOR_MASK);\\n  }\\n\\n  /** Sets this object's color. */\\n  set color(color: i32) {\\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\\n  }\\n\\n  /** Gets the size of this object in memory. */\\n  get size(): usize {\\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\\n  }\\n\\n  /** Unlinks this object from its list. */\\n  unlink(): void {\\n    let next = this.next;\\n    if (next == null) {\\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\\n      return; // static data not yet linked\\n    }\\n    let prev = this.prev;\\n    if (DEBUG) assert(prev);\\n    next.prev = prev;\\n    prev.next = next;\\n  }\\n\\n  /** Links this object to the specified list, with the given color. */\\n  linkTo(list: Object, withColor: i32): void {\\n    let prev = list.prev;\\n    this.nextWithColor = changetype<usize>(list) | withColor;\\n    this.prev = prev;\\n    prev.next = this;\\n    list.prev = this;\\n  }\\n}\\n\\n// Garbage collector interface\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __new(size: usize, id: i32): usize {\\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\\n  obj.rtId = id;\\n  obj.rtSize = <u32>size;\\n  obj.linkTo(fromSpace, white);\\n  total += obj.size;\\n  return changetype<usize>(obj) + TOTAL_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __renew(oldPtr: usize, size: usize): usize {\\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\\n  if (oldPtr < __heap_base) { // move to heap for simplicity\\n    let newPtr = __new(size, oldObj.rtId);\\n    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\\n    return newPtr;\\n  }\\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  total -= oldObj.size;\\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;\\n  let newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);\\n  newObj.rtSize = <u32>size;\\n\\n  // Replace with new object\\n  newObj.next.prev = newObj;\\n  newObj.prev.next = newObj;\\n\\n  total += newObj.size;\\n  return newPtr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\\n  // nop\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __visit(ptr: usize, cookie: i32): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (RTRACE) if (!onvisit(obj)) return;\\n  if (obj.color == white) {\\n    obj.unlink(); // from fromSpace\\n    obj.linkTo(toSpace, i32(!white));\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __pin(ptr: usize): usize {\\n  if (ptr) {\\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n    if (obj.color == transparent) {\\n      throw new Error(E_ALREADY_PINNED);\\n    }\\n    obj.unlink(); // from fromSpace\\n    obj.linkTo(pinSpace, transparent);\\n  }\\n  return ptr;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __unpin(ptr: usize): void {\\n  if (!ptr) return;\\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\\n  if (obj.color != transparent) {\\n    throw new Error(E_NOT_PINNED);\\n  }\\n  obj.unlink(); // from pinSpace\\n  obj.linkTo(fromSpace, white);\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __collect(): void {\\n  if (TRACE) trace(\\\"GC at\\\", 1, total);\\n\\n  // Mark roots (add to toSpace)\\n  __visit_globals(VISIT_SCAN);\\n\\n  // Mark direct members of pinned objects (add to toSpace)\\n  let pn = pinSpace;\\n  let iter = pn.next;\\n  while (iter != pn) {\\n    if (DEBUG) assert(iter.color == transparent);\\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\\n    iter = iter.next;\\n  }\\n\\n  // Mark what's reachable from toSpace\\n  let black = i32(!white);\\n  let to = toSpace;\\n  iter = to.next;\\n  while (iter != to) {\\n    if (DEBUG) assert(iter.color == black);\\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\\n    iter = iter.next;\\n  }\\n\\n  // Sweep what's left in fromSpace\\n  let from = fromSpace;\\n  iter = from.next;\\n  while (iter != from) {\\n    if (DEBUG) assert(iter.color == white);\\n    let newNext = iter.next;\\n    if (changetype<usize>(iter) < __heap_base) {\\n      iter.nextWithColor = 0; // may become linked again\\n      iter.prev = changetype<Object>(0);\\n    } else {\\n      total -= iter.size;\\n      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);\\n      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);\\n    }\\n    iter = newNext;\\n  }\\n  from.nextWithColor = changetype<usize>(from);\\n  from.prev = from;\\n\\n  // Flip spaces and colors\\n  fromSpace = to;\\n  toSpace = from;\\n  white = black;\\n\\n  if (TRACE) trace(\\\"GC done at\\\", 1, total);\\n  if (RTRACE) oncollect(total);\\n}\\n\",\n  \"rt/tlsf\": \"import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \\\"./common\\\";\\nimport { oninit, onalloc, onresize, onmove, onfree } from \\\"./rtrace\\\";\\nimport { E_ALLOCATION_TOO_LARGE } from \\\"../util/error\\\";\\n\\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\\n// see: http://www.gii.upv.es/tlsf/\\n\\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block size interpretation (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u256B\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524\\n// \u2502 |                    FL                       \u2502 SB = SL + AL  \u2502 \u25C4\u2500 usize\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n// FL: first level, SL: second level, AL: alignment, SB: small block\\n\\n// @ts-ignore: decorator\\n@inline const SL_BITS: u32 = 4;\\n// @ts-ignore: decorator\\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\\n\\n// @ts-ignore: decorator\\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\\n// @ts-ignore: decorator\\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\\n\\n// @ts-ignore: decorator\\n@inline const FL_BITS: u32 = 31 - SB_BITS;\\n\\n// [00]: < 256B (SB)  [12]: < 1M\\n// [01]: < 512B       [13]: < 2M\\n// [02]: < 1K         [14]: < 4M\\n// [03]: < 2K         [15]: < 8M\\n// [04]: < 4K         [16]: < 16M\\n// [05]: < 8K         [17]: < 32M\\n// [06]: < 16K        [18]: < 64M\\n// [07]: < 32K        [19]: < 128M\\n// [08]: < 64K        [20]: < 256M\\n// [09]: < 128K       [21]: < 512M\\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\\n// [11]: < 512K\\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\\n\\n// Tags stored in otherwise unused alignment bits\\n\\n// @ts-ignore: decorator\\n@inline const FREE: usize = 1 << 0;\\n// @ts-ignore: decorator\\n@inline const LEFTFREE: usize = 1 << 1;\\n// @ts-ignore: decorator\\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u253C\u2500\u2524            \u2510\\n// \u2502                          size                             \u2502L\u2502F\u2502 \u25C4\u2500\u2510 info   overhead\\n// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2567\u2550\u2561   \u2502        \u2518\\n// \u2502                        if free: \u25C4 prev                        \u2502 \u25C4\u2500\u2524 usize\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\\n// \u2502                        if free: next \u25BA                        \u2502 \u25C4\u2500\u2524\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\\n// \u2502                             ...                               \u2502   \u2502 >= 0\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\\n// \u2502                        if free: back \u25B2                        \u2502 \u25C4\u2500\u2518\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 >= MIN SIZE\\n// F: FREE, L: LEFTFREE\\n@unmanaged export class Block extends BLOCK {\\n\\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\\n  prev: Block | null;\\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\\n  next: Block | null;\\n\\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\\n}\\n\\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\\n// `next` and `back` if free.\\n\\n// @ts-ignore: decorator\\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\\n// @ts-ignore: decorator\\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\\n\\n/** Gets the left block of a block. Only valid if the left block is free. */\\n// @ts-ignore: decorator\\n@inline function GETFREELEFT(block: Block): Block {\\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\\n}\\n\\n/** Gets the right block of a block by advancing to the right by its size. */\\n// @ts-ignore: decorator\\n@inline function GETRIGHT(block: Block): Block {\\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\\n}\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Root layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524          \u2510\\n// \u2502        0        |           flMap                            S\u2502 \u25C4\u2500\u2500\u2500\u2500\u2510\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502\\n// \u2502                           slMap[0] S                          \u2502 \u25C4\u2500\u2510  \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502  \u2502\\n// \u2502                           slMap[1]                            \u2502 \u25C4\u2500\u2524  \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  u32 \u2502\\n// \u2502                           slMap[22]                           \u2502 \u25C4\u2500\u2518  \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561    usize\\n// \u2502                            head[0]                            \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\\n// \u2502                              ...                              \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502\\n// \u2502                           head[367]                           \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502\\n// \u2502                             tail                              \u2502 \u25C4\u2500\u2500\u2500\u2500\u2518\\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   SIZE   \u2518\\n// S: Small blocks map\\n@unmanaged class Root {\\n  /** First level bitmap. */\\n  flMap: usize;\\n}\\n\\n// Root constants. Where stuff is stored inside of the root structure.\\n\\n// @ts-ignore: decorator\\n@inline const SL_START: usize = sizeof<usize>();\\n// @ts-ignore: decorator\\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\\n// @ts-ignore: decorator\\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\\n// @ts-ignore: decorator\\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\\n// @ts-ignore: decorator\\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\\n\\n// @ts-ignore: decorator\\n@lazy export let ROOT: Root;\\n\\n/** Gets the second level map of the specified first level. */\\n// @ts-ignore: decorator\\n@inline function GETSL(root: Root, fl: usize): u32 {\\n  return load<u32>(\\n    changetype<usize>(root) + (fl << alignof<u32>()),\\n    SL_START\\n  );\\n}\\n\\n/** Sets the second level map of the specified first level. */\\n// @ts-ignore: decorator\\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\\n  store<u32>(\\n    changetype<usize>(root) + (fl << alignof<u32>()),\\n    slMap,\\n    SL_START\\n  );\\n}\\n\\n/** Gets the head of the free list for the specified combination of first and second level. */\\n// @ts-ignore: decorator\\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\\n  return load<Block>(\\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\\n    HL_START\\n  );\\n}\\n\\n/** Sets the head of the free list for the specified combination of first and second level. */\\n// @ts-ignore: decorator\\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\\n  store<Block | null>(\\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\\n    head,\\n    HL_START\\n  );\\n}\\n\\n/** Gets the tail block.. */\\n// @ts-ignore: decorator\\n@inline function GETTAIL(root: Root): Block {\\n  return load<Block>(\\n    changetype<usize>(root),\\n    HL_END\\n  );\\n}\\n\\n/** Sets the tail block. */\\n// @ts-ignore: decorator\\n@inline function SETTAIL(root: Root, tail: Block): void {\\n  store<Block>(\\n    changetype<usize>(root),\\n    tail,\\n    HL_END\\n  );\\n}\\n\\n/** Inserts a previously used block back into the free list. */\\nfunction insertBlock(root: Root, block: Block): void {\\n  if (DEBUG) assert(block); // cannot be null\\n  let blockInfo = block.mmInfo;\\n  if (DEBUG) assert(blockInfo & FREE); // must be free\\n\\n  let right = GETRIGHT(block);\\n  let rightInfo = right.mmInfo;\\n\\n  // merge with right block if also free\\n  if (rightInfo & FREE) {\\n    removeBlock(root, right);\\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\\n    right = GETRIGHT(block);\\n    rightInfo = right.mmInfo;\\n    // 'back' is set below\\n  }\\n\\n  // merge with left block if also free\\n  if (blockInfo & LEFTFREE) {\\n    let left = GETFREELEFT(block);\\n    let leftInfo = left.mmInfo;\\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\\n    removeBlock(root, left);\\n    block = left;\\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\\n    // 'back' is set below\\n  }\\n\\n  right.mmInfo = rightInfo | LEFTFREE;\\n  // reference to right is no longer used now, hence rightInfo is not synced\\n\\n  // we now know the size of the block\\n  let size = blockInfo & ~TAGS_MASK;\\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\\n\\n  // set 'back' to itself at the end of block\\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\\n\\n  // mapping_insert\\n  let fl: usize, sl: u32;\\n  if (size < SB_SIZE) {\\n    fl = 0;\\n    sl = <u32>(size >> AL_BITS);\\n  } else {\\n    const inv: usize = sizeof<usize>() * 8 - 1;\\n    let boundedSize = min(size, BLOCK_MAXSIZE);\\n    fl = inv - clz<usize>(boundedSize);\\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\\n    fl -= SB_BITS - 1;\\n  }\\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\\n\\n  // perform insertion\\n  let head = GETHEAD(root, fl, sl);\\n  block.prev = null;\\n  block.next = head;\\n  if (head) head.prev = block;\\n  SETHEAD(root, fl, sl, block);\\n\\n  // update first and second level maps\\n  root.flMap |= (1 << fl);\\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\\n}\\n\\n/** Removes a free block from internal lists. */\\nfunction removeBlock(root: Root, block: Block): void {\\n  let blockInfo = block.mmInfo;\\n  if (DEBUG) assert(blockInfo & FREE); // must be free\\n  let size = blockInfo & ~TAGS_MASK;\\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\\n\\n  // mapping_insert\\n  let fl: usize, sl: u32;\\n  if (size < SB_SIZE) {\\n    fl = 0;\\n    sl = <u32>(size >> AL_BITS);\\n  } else {\\n    const inv: usize = sizeof<usize>() * 8 - 1;\\n    let boundedSize = min(size, BLOCK_MAXSIZE);\\n    fl = inv - clz<usize>(boundedSize);\\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\\n    fl -= SB_BITS - 1;\\n  }\\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\\n\\n  // link previous and next free block\\n  let prev = block.prev;\\n  let next = block.next;\\n  if (prev) prev.next = next;\\n  if (next) next.prev = prev;\\n\\n  // update head if we are removing it\\n  if (block == GETHEAD(root, fl, sl)) {\\n    SETHEAD(root, fl, sl, next);\\n\\n    // clear second level map if head is empty now\\n    if (!next) {\\n      let slMap = GETSL(root, fl);\\n      SETSL(root, fl, slMap &= ~(1 << sl));\\n\\n      // clear first level map if second level is empty now\\n      if (!slMap) root.flMap &= ~(1 << fl);\\n    }\\n  }\\n  // note: does not alter left/back because it is likely that splitting\\n  // is performed afterwards, invalidating those changes. so, the caller\\n  // must perform those updates.\\n}\\n\\n/** Searches for a free block of at least the specified size. */\\nfunction searchBlock(root: Root, size: usize): Block | null {\\n  // size was already asserted by caller\\n\\n  // mapping_search\\n  let fl: usize, sl: u32;\\n  if (size < SB_SIZE) {\\n    fl = 0;\\n    sl = <u32>(size >> AL_BITS);\\n  } else {\\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\\n    const inv: usize = sizeof<usize>() * 8 - 1;\\n    const invRound = inv - SL_BITS;\\n    let requestSize = size < halfMaxSize\\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\\n      : size;\\n    fl = inv - clz<usize>(requestSize);\\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\\n    fl -= SB_BITS - 1;\\n  }\\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\\n\\n  // search second level\\n  let slMap = GETSL(root, fl) & (~0 << sl);\\n  let head: Block | null = null;\\n  if (!slMap) {\\n    // search next larger first level\\n    let flMap = root.flMap & (~0 << (fl + 1));\\n    if (!flMap) {\\n      head = null;\\n    } else {\\n      fl = ctz<usize>(flMap);\\n      slMap = GETSL(root, fl);\\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\\n    }\\n  } else {\\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\\n  }\\n  return head;\\n}\\n\\n/** Prepares the specified block before (re-)use, possibly splitting it. */\\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\\n  // size was already asserted by caller\\n\\n  let blockInfo = block.mmInfo;\\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\\n\\n  // split if the block can hold another MINSIZE block incl. overhead\\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\\n\\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\\n    insertBlock(root, spare); // also sets 'back'\\n\\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\\n  } else {\\n    block.mmInfo = blockInfo & ~FREE;\\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\\n  }\\n}\\n\\n/** Adds more memory to the pool. */\\nfunction addMemory(root: Root, start: usize, end: usize): bool {\\n  if (DEBUG) assert(start <= end); // must be valid\\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n  end &= ~AL_MASK;\\n\\n  let tail = GETTAIL(root);\\n  let tailInfo: usize = 0;\\n  if (tail) { // more memory\\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\\n\\n    // merge with current tail if adjacent\\n    const offsetToTail = AL_SIZE;\\n    if (start - offsetToTail == changetype<usize>(tail)) {\\n      start -= offsetToTail;\\n      tailInfo = tail.mmInfo;\\n    } else {\\n      // We don't do this, but a user might `memory.grow` manually\\n      // leading to non-adjacent pages managed by TLSF.\\n    }\\n\\n  } else if (DEBUG) { // first memory\\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\\n  }\\n\\n  // check if size is large enough for a free block and the tail block\\n  let size = end - start;\\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\\n    return false;\\n  }\\n\\n  // left size is total minus its own and the zero-length tail's header\\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\\n  let left = changetype<Block>(start);\\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\\n  left.prev = null;\\n  left.next = null;\\n\\n  // tail is a zero-length used block\\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\\n  tail.mmInfo = 0 | LEFTFREE;\\n  SETTAIL(root, tail);\\n\\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\\n\\n  return true;\\n}\\n\\n/** Grows memory to fit at least another block of the specified size. */\\nfunction growMemory(root: Root, size: usize): void {\\n  if (ASC_LOW_MEMORY_LIMIT) {\\n    unreachable();\\n    return;\\n  }\\n  // Here, both rounding performed in searchBlock ...\\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\\n  if (size < halfMaxSize) { // don't round last fl\\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\\n    size += (1 << (invRound - clz<usize>(size))) - 1;\\n  }\\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\\n  // to merge with the tail block, that's one time, otherwise it's two times.\\n  let pagesBefore = memory.size();\\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\\n  if (memory.grow(pagesWanted) < 0) {\\n    if (memory.grow(pagesNeeded) < 0) unreachable();\\n  }\\n  let pagesAfter = memory.size();\\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\\n}\\n\\n/** Computes the size (excl. header) of a block. */\\nfunction computeSize(size: usize): usize {\\n  // Size must be large enough and aligned minus preceeding overhead\\n  return size <= BLOCK_MINSIZE\\n    ? BLOCK_MINSIZE\\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\\n}\\n\\n/** Prepares and checks an allocation size. */\\nfunction prepareSize(size: usize): usize {\\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\\n  return computeSize(size);\\n}\\n\\n/** Initializes the root structure. */\\nfunction initialize(): void {\\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\\n  let pagesBefore = memory.size();\\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\\n  let root = changetype<Root>(rootOffset);\\n  root.flMap = 0;\\n  SETTAIL(root, changetype<Block>(0));\\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\\n    SETSL(root, fl, 0);\\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\\n      SETHEAD(root, fl, sl, null);\\n    }\\n  }\\n  let memStart = rootOffset + ROOT_SIZE;\\n  if (ASC_LOW_MEMORY_LIMIT) {\\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\\n    else unreachable(); // low memory limit already exceeded\\n  } else {\\n    addMemory(root, memStart, memory.size() << 16);\\n  }\\n  ROOT = root;\\n}\\n\\n/** Allocates a block of the specified size. */\\nexport function allocateBlock(root: Root, size: usize): Block {\\n  let payloadSize = prepareSize(size);\\n  let block = searchBlock(root, payloadSize);\\n  if (!block) {\\n    growMemory(root, payloadSize);\\n    block = changetype<Block>(searchBlock(root, payloadSize));\\n    if (DEBUG) assert(block); // must be found now\\n  }\\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\\n  removeBlock(root, block);\\n  prepareBlock(root, block, payloadSize);\\n  if (isDefined(ASC_RTRACE)) onalloc(block);\\n  return block;\\n}\\n\\n/** Reallocates a block to the specified size. */\\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\\n  let payloadSize = prepareSize(size);\\n  let blockInfo = block.mmInfo;\\n  let blockSize = blockInfo & ~TAGS_MASK;\\n\\n  // possibly split and update runtime size if it still fits\\n  if (payloadSize <= blockSize) {\\n    prepareBlock(root, block, payloadSize);\\n    if (isDefined(ASC_RTRACE)) {\\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\\n    }\\n    return block;\\n  }\\n\\n  // merge with right free block if merger is large enough\\n  let right = GETRIGHT(block);\\n  let rightInfo = right.mmInfo;\\n  if (rightInfo & FREE) {\\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\\n    if (mergeSize >= payloadSize) {\\n      removeBlock(root, right);\\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\\n      prepareBlock(root, block, payloadSize);\\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\\n      return block;\\n    }\\n  }\\n\\n  // otherwise move the block\\n  return moveBlock(root, block, size);\\n}\\n\\n/** Moves a block to a new one of the specified size. */\\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\\n  let newBlock = allocateBlock(root, newSize);\\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\\n  if (changetype<usize>(block) >= __heap_base) {\\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\\n    freeBlock(root, block);\\n  }\\n  return newBlock;\\n}\\n\\n/** Frees a block. */\\nexport function freeBlock(root: Root, block: Block): void {\\n  if (isDefined(ASC_RTRACE)) onfree(block);\\n  block.mmInfo = block.mmInfo | FREE;\\n  insertBlock(root, block);\\n}\\n\\n/** Checks that a used block is valid to be freed or reallocated. */\\nfunction checkUsedBlock(ptr: usize): Block {\\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\\n  assert(\\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\\n    !(block.mmInfo & FREE)           // must be used\\n  );\\n  return block;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __alloc(size: usize): usize {\\n  if (!ROOT) initialize();\\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __realloc(ptr: usize, size: usize): usize {\\n  if (!ROOT) initialize();\\n  return (ptr < __heap_base\\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\\n  ) + BLOCK_OVERHEAD;\\n}\\n\\n// @ts-ignore: decorator\\n@global @unsafe\\nexport function __free(ptr: usize): void {\\n  if (ptr < __heap_base) return;\\n  if (!ROOT) initialize();\\n  freeBlock(ROOT, checkUsedBlock(ptr));\\n}\\n\",\n  \"set\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { HASH } from \\\"./util/hash\\\";\\n\\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\\n\\n// @ts-ignore: decorator\\n@inline const INITIAL_CAPACITY = 4;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_N = 8;\\n\\n// @ts-ignore: decorator\\n@inline const FILL_FACTOR_D = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_N = 3;\\n\\n// @ts-ignore: decorator\\n@inline const FREE_FACTOR_D = 4;\\n\\n/** Structure of a set entry. */\\n@unmanaged class SetEntry<K> {\\n  key: K;\\n  taggedNext: usize; // LSB=1 indicates EMPTY\\n}\\n\\n/** Empty bit. */\\n// @ts-ignore: decorator\\n@inline const EMPTY: usize = 1 << 0;\\n\\n/** Size of a bucket. */\\n// @ts-ignore: decorator\\n@inline const BUCKET_SIZE = sizeof<usize>();\\n\\n/** Computes the alignment of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_ALIGN<T>(): usize {\\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\\n  return align;\\n}\\n\\n/** Computes the aligned size of an entry. */\\n// @ts-ignore: decorator\\n@inline\\nfunction ENTRY_SIZE<T>(): usize {\\n  const align = ENTRY_ALIGN<T>();\\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\\n  return size;\\n}\\n\\nexport class Set<T> {\\n\\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\\n\\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\\n  private entriesOffset: i32 = 0;\\n  private entriesCount: i32 = 0;\\n\\n  constructor() {\\n    /* nop */\\n  }\\n\\n  get size(): i32 {\\n    return this.entriesCount;\\n  }\\n\\n  clear(): void {\\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\\n    this.bucketsMask = INITIAL_CAPACITY - 1;\\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\\n    this.entriesCapacity = INITIAL_CAPACITY;\\n    this.entriesOffset = 0;\\n    this.entriesCount = 0;\\n  }\\n\\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\\n    let entry = load<SetEntry<T>>( // unmanaged!\\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\\n    );\\n    while (entry) {\\n      let taggedNext = entry.taggedNext;\\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\\n    }\\n    return null;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  has(key: T): bool {\\n    return this.find(key, HASH<T>(key)) != null;\\n  }\\n\\n  add(key: T): this {\\n    let hashCode = HASH<T>(key);\\n    let entry = this.find(key, hashCode); // unmanaged!\\n    if (!entry) {\\n      // check if rehashing is necessary\\n      if (this.entriesOffset == this.entriesCapacity) {\\n        this.rehash(\\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\\n        );\\n      }\\n      // append new entry\\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\\n      entry.key = key;\\n      if (isManaged<T>()) {\\n        __link(changetype<usize>(this), changetype<usize>(key), true);\\n      }\\n      ++this.entriesCount;\\n      // link with previous entry in bucket\\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\\n      entry.taggedNext = load<usize>(bucketPtrBase);\\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\\n    }\\n    return this;\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(key: T, value: bool): void {\\n    if (value) this.add(key);\\n    else this.delete(key);\\n  }\\n\\n  delete(key: T): bool {\\n    let entry = this.find(key, HASH<T>(key)); // unmanaged!\\n    if (!entry) return false;\\n    entry.taggedNext |= EMPTY;\\n    --this.entriesCount;\\n    // check if rehashing is appropriate\\n    let halfBucketsMask = this.bucketsMask >> 1;\\n    if (\\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\\n    ) this.rehash(halfBucketsMask);\\n    return true;\\n  }\\n\\n  private rehash(newBucketsMask: u32): void {\\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\\n\\n    // copy old entries to new entries\\n    let oldPtr = changetype<usize>(this.entries);\\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\\n    let newPtr = changetype<usize>(newEntries);\\n    while (oldPtr != oldEnd) {\\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\\n      if (!(oldEntry.taggedNext & EMPTY)) {\\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\\n        let oldEntryKey = oldEntry.key;\\n        newEntry.key = oldEntryKey;\\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\\n        store<usize>(newBucketPtrBase, newPtr);\\n        newPtr += ENTRY_SIZE<T>();\\n      }\\n      oldPtr += ENTRY_SIZE<T>();\\n    }\\n\\n    this.buckets = newBuckets;\\n    this.bucketsMask = newBucketsMask;\\n    this.entries = newEntries;\\n    this.entriesCapacity = newEntriesCapacity;\\n    this.entriesOffset = this.entriesCount;\\n  }\\n\\n  values(): T[] {\\n    // FIXME: this is preliminary, needs iterators/closures\\n    let start = changetype<usize>(this.entries);\\n    let size = this.entriesOffset;\\n    let values = new Array<T>(size);\\n    let length = 0;\\n    for (let i = 0; i < size; ++i) {\\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\\n      if (!(entry.taggedNext & EMPTY)) {\\n        unchecked(values[length++] = entry.key);\\n      }\\n    }\\n    values.length = length;\\n    return values;\\n  }\\n\\n  toString(): string {\\n    return \\\"[object Set]\\\";\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    __visit(changetype<usize>(this.buckets), cookie);\\n    let entries = changetype<usize>(this.entries);\\n    if (isManaged<T>()) {\\n      let cur = entries;\\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\\n      while (cur < end) {\\n        let entry = changetype<SetEntry<T>>(cur);\\n        if (!(entry.taggedNext & EMPTY)) {\\n          let val = changetype<usize>(entry.key);\\n          if (isNullable<T>()) {\\n            if (val) __visit(val, cookie);\\n          } else __visit(val, cookie);\\n        }\\n        cur += ENTRY_SIZE<T>();\\n      }\\n    }\\n    __visit(entries, cookie);\\n  }\\n}\\n\",\n  \"shared/feature\": \"// This file is shared with the compiler and must remain portable\\n\\n/** Indicates specific features to activate. */\\nexport const enum Feature {\\n  /** No additional features. */\\n  None = 0,\\n  /** Sign extension operations. */\\n  SignExtension = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\\n  /** Mutable global imports and exports. */\\n  MutableGlobals = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\\n  /** Non-trapping float to integer operations. */\\n  NontrappingF2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\\n  /** Bulk memory operations. */\\n  BulkMemory = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\\n  /** SIMD types and operations. */\\n  Simd = 1 << 4, // see: https://github.com/WebAssembly/simd\\n  /** Threading and atomic operations. */\\n  Threads = 1 << 5, // see: https://github.com/WebAssembly/threads\\n  /** Exception handling operations. */\\n  ExceptionHandling = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\\n  /** Tail call operations. */\\n  TailCalls = 1 << 7, // see: https://github.com/WebAssembly/tail-call\\n  /** Reference types. */\\n  ReferenceTypes = 1 << 8, // see: https://github.com/WebAssembly/reference-types\\n  /** Multi value types. */\\n  MultiValue = 1 << 9, // see: https://github.com/WebAssembly/multi-value\\n  /** Garbage collection. */\\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\\n  /** Memory64. */\\n  Memory64 = 1 << 11, // see: https://github.com/WebAssembly/memory64\\n  /** Relaxed SIMD. */\\n  RelaxedSimd = 1 << 12, // see: https://github.com/WebAssembly/relaxed-simd\\n  /** Extended const expressions. */\\n  ExtendedConst = 1 << 13, // see: https://github.com/WebAssembly/extended-const\\n  /** Reference typed strings. */\\n  Stringref = 1 << 14, // see: https://github.com/WebAssembly/stringref\\n}\\n\\n/** Gets the name of the specified feature one would specify on the command line. */\\nexport function featureToString(feature: Feature): string {\\n  switch (feature) {\\n    case Feature.SignExtension: return \\\"sign-extension\\\";\\n    case Feature.MutableGlobals: return \\\"mutable-globals\\\";\\n    case Feature.NontrappingF2I: return \\\"nontrapping-f2i\\\";\\n    case Feature.BulkMemory: return \\\"bulk-memory\\\";\\n    case Feature.Simd: return \\\"simd\\\";\\n    case Feature.Threads: return \\\"threads\\\";\\n    case Feature.ExceptionHandling: return \\\"exception-handling\\\";\\n    case Feature.TailCalls: return \\\"tail-calls\\\";\\n    case Feature.ReferenceTypes: return \\\"reference-types\\\";\\n    case Feature.MultiValue: return \\\"multi-value\\\";\\n    case Feature.GC: return \\\"gc\\\";\\n    case Feature.Memory64: return \\\"memory64\\\";\\n    case Feature.RelaxedSimd: return \\\"relaxed-simd\\\";\\n    case Feature.ExtendedConst: return \\\"extended-const\\\";\\n    case Feature.Stringref: return \\\"stringref\\\";\\n  }\\n  assert(false);\\n  return \\\"\\\";\\n}\\n\",\n  \"shared/runtime\": \"// This file is shared with the compiler and must remain portable\\n\\n/** Runtime types. */\\nexport enum Runtime {\\n  /** Simple bump allocator without GC. */\\n  Stub = 0,\\n  /** Stop the world semi-automatic GC. */\\n  Minimal = 1,\\n  /** incremental GC. */\\n  Incremental = 2,\\n}\\n\",\n  \"shared/target\": \"// This file is shared with the compiler and must remain portable\\n\\n/** Compilation target. */\\nexport enum Target {\\n  /** Portable. */\\n  Js = 0,\\n  /** WebAssembly with 32-bit pointers. */\\n  Wasm32 = 1,\\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\\n  Wasm64 = 2,\\n}\\n\",\n  \"shared/typeinfo\": \"// This file is shared with the compiler and must remain portable\\n\\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Typeinfo interpretation \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\\n//    3                   2                   1\\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524 \u25C4\u2500 __rtti_base\\n// \u2502                             count                             \u2502\\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2510\\n// \u2502                      Typeinfo#flags [id=0]                    \u2502 id < count\\n// \u251C \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2524\\n// \u2502                      Typeinfo#base  [id=0]                    \u2502\\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n// \u2502                              ...                              \u2502\\n\\n/** Runtime type information data structure. */\\n@unmanaged\\nexport class Typeinfo {\\n  /** Flags describing the shape of this class type. */\\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\\n  /** Base class id or `0` if none. */\\n  base: u32 = 0;\\n}\\n\\n/** Runtime type information flags. */\\nexport const enum TypeinfoFlags {\\n  /** No specific flags. */\\n  NONE = 0,\\n  /** Type is an `ArrayBufferView`. */\\n  ARRAYBUFFERVIEW = 1 << 0,\\n  /** Type is an `Array`. */\\n  ARRAY = 1 << 1,\\n  /** Type is a `StaticArray`. */\\n  STATICARRAY = 1 << 2,\\n  /** Type is a `Set`. */\\n  SET = 1 << 3,\\n  /** Type is a `Map`. */\\n  MAP = 1 << 4,\\n  /** Type has no outgoing pointers. */\\n  POINTERFREE = 1 << 5,\\n  /** Value alignment of 1 byte. */\\n  VALUE_ALIGN_0 = 1 << 6,\\n  /** Value alignment of 2 bytes. */\\n  VALUE_ALIGN_1 = 1 << 7,\\n  /** Value alignment of 4 bytes. */\\n  VALUE_ALIGN_2 = 1 << 8,\\n  /** Value alignment of 8 bytes. */\\n  VALUE_ALIGN_3 = 1 << 9,\\n  /** Value alignment of 16 bytes. */\\n  VALUE_ALIGN_4 = 1 << 10,\\n  /** Value is a signed type. */\\n  VALUE_SIGNED = 1 << 11,\\n  /** Value is a float type. */\\n  VALUE_FLOAT = 1 << 12,\\n  /** Value type is nullable. */\\n  VALUE_NULLABLE = 1 << 13,\\n  /** Value type is managed. */\\n  VALUE_MANAGED = 1 << 14,\\n  /** Key alignment of 1 byte. */\\n  KEY_ALIGN_0 = 1 << 15,\\n  /** Key alignment of 2 bytes. */\\n  KEY_ALIGN_1 = 1 << 16,\\n  /** Key alignment of 4 bytes. */\\n  KEY_ALIGN_2 = 1 << 17,\\n  /** Key alignment of 8 bytes. */\\n  KEY_ALIGN_3 = 1 << 18,\\n  /** Key alignment of 16 bytes. */\\n  KEY_ALIGN_4 = 1 << 19,\\n  /** Key is a signed type. */\\n  KEY_SIGNED = 1 << 20,\\n  /** Key is a float type. */\\n  KEY_FLOAT = 1 << 21,\\n  /** Key type is nullable. */\\n  KEY_NULLABLE = 1 << 22,\\n  /** Key type is managed. */\\n  KEY_MANAGED = 1 << 23\\n}\\n\",\n  \"staticarray\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \\\"./rt/common\\\";\\nimport { Runtime } from \\\"shared/runtime\\\";\\nimport { COMPARATOR, SORT } from \\\"./util/sort\\\";\\nimport { REVERSE, FILL } from \\\"./util/bytes\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { Array } from \\\"./array\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \\\"./util/error\\\";\\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \\\"./util/string\\\";\\n\\n@final\\nexport class StaticArray<T> {\\n  [key: number]: T;\\n\\n  // Note that the interface of StaticArray instances must be a semantically\\n  // compatible subset of Array<T> in order for syntax highlighting to work\\n  // properly, for instance when creating static arrays from array literals.\\n  // The additionally provided static methods take care of dealing with static\\n  // arrays exclusively, without having to convert to Array<T> first.\\n\\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\\n    let length = source.length;\\n    let outSize = <usize>length << alignof<T>();\\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\\n    if (isManaged<T>()) {\\n      let sourcePtr = source.dataStart;\\n      for (let i = 0; i < length; ++i) {\\n        let off = <usize>i << alignof<T>();\\n        let ref = load<usize>(sourcePtr + off);\\n        store<usize>(changetype<usize>(out) + off, ref);\\n        __link(changetype<usize>(out), ref, true);\\n      }\\n    } else {\\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\\n    }\\n    return out;\\n  }\\n\\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\\n    return source.concat<StaticArray<T>>(other);\\n  }\\n\\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\\n    return source.slice<StaticArray<T>>(start, end);\\n  }\\n\\n  constructor(length: i32) {\\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\\n    let outSize = <usize>length << alignof<T>();\\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\\n    if (ASC_RUNTIME != Runtime.Incremental) {\\n      memory.fill(changetype<usize>(out), 0, outSize);\\n    }\\n    return out;\\n  }\\n\\n  get length(): i32 {\\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\\n  }\\n\\n  at(index: i32): T {\\n    let len = this.length;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  @operator(\\\"[]\\\") private __get(index: i32): T {\\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\\n    if (isReference<T>()) {\\n      if (!isNullable<T>()) {\\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\\n      }\\n    }\\n    return value;\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\") private __uget(index: i32): T {\\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\\n  }\\n\\n  @operator(\\\"[]=\\\") private __set(index: i32, value: T): void {\\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\\n    this.__uset(index, value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\") private __uset(index: i32, value: T): void {\\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\\n    if (isManaged<T>()) {\\n      __link(changetype<usize>(this), changetype<usize>(value), true);\\n    }\\n  }\\n\\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\\n    if (isManaged<T>()) {\\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\\n      __link(changetype<usize>(this), changetype<usize>(value), false);\\n    } else {\\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\\n    }\\n    return this;\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\\n    let ptr = changetype<usize>(this);\\n    let len = this.length;\\n\\n    end = min<i32>(end, len);\\n\\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\\n    let count = min(last - from, len - to);\\n\\n    memory.copy( // is memmove\\n      ptr + (<usize>to << alignof<T>()),\\n      ptr + (<usize>from << alignof<T>()),\\n      <usize>count << alignof<T>()\\n    );\\n    return this;\\n  }\\n\\n  includes(value: T, fromIndex: i32 = 0): bool {\\n    if (isFloat<T>()) {\\n      let length = this.length;\\n      if (length == 0 || fromIndex >= length) return false;\\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\\n      while (fromIndex < length) {\\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\\n        // @ts-ignore\\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\\n        ++fromIndex;\\n      }\\n      return false;\\n    } else {\\n      return this.indexOf(value, fromIndex) >= 0;\\n    }\\n  }\\n\\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\\n    let length = this.length;\\n    if (length == 0 || fromIndex >= length) return -1;\\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\\n    while (fromIndex < length) {\\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      ++fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\\n    let length = this.length;\\n    if (length == 0) return -1;\\n    if (fromIndex < 0) fromIndex = length + fromIndex;\\n    else if (fromIndex >= length) fromIndex = length - 1;\\n    while (fromIndex >= 0) {\\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\\n      --fromIndex;\\n    }\\n    return -1;\\n  }\\n\\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\\n    let sourceLen = this.length;\\n    let otherLen = other.length;\\n    let outLen = sourceLen + otherLen;\\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\\n      throw new Error(E_INVALIDLENGTH);\\n    }\\n    let sourceSize = <usize>sourceLen << alignof<T>();\\n    let out!: U;\\n\\n    if (out instanceof Array<T>) {\\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\\n      let outStart = changetype<Array<T>>(out).dataStart;\\n      let otherStart = changetype<Array<T>>(other).dataStart;\\n      let thisStart = changetype<usize>(this);\\n\\n      if (isManaged<T>()) {\\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(thisStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(changetype<usize>(out), ref, true);\\n        }\\n        outStart += sourceSize;\\n        let otherSize = <usize>otherLen << alignof<T>();\\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(otherStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(changetype<usize>(out), ref, true);\\n        }\\n      } else {\\n        memory.copy(outStart, thisStart, sourceSize);\\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\\n      }\\n    } else if (out instanceof StaticArray<T>) {\\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\\n      let outStart = changetype<usize>(out);\\n      let otherStart = changetype<usize>(other);\\n      let thisStart = changetype<usize>(this);\\n\\n      if (isManaged<T>()) {\\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(thisStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(outStart, ref, true);\\n        }\\n        outStart += sourceSize;\\n        let otherSize = <usize>otherLen << alignof<T>();\\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\\n          let ref = load<usize>(otherStart + offset);\\n          store<usize>(outStart + offset, ref);\\n          __link(outStart, ref, true);\\n        }\\n      } else {\\n        memory.copy(outStart, thisStart, sourceSize);\\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\\n      }\\n    } else {\\n      ERROR(\\\"Only Array<T> and StaticArray<T> accept for 'U' parameter\\\");\\n    }\\n    return out;\\n  }\\n\\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\\n    let length = this.length;\\n    start = start < 0 ? max(start + length, 0) : min(start, length);\\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\\n    length = max(end - start, 0);\\n\\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\\n    let size = <usize>length << alignof<T>();\\n    let out!: U;\\n\\n    if (out instanceof Array<T>) {\\n      // return Array\\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\\n      let outStart = changetype<Array<T>>(out).dataStart;\\n      if (isManaged<T>()) {\\n        let off: usize = 0;\\n        while (off < size) {\\n          let ref = load<usize>(sourceStart + off);\\n          store<usize>(outStart + off, ref);\\n          __link(changetype<usize>(out), ref, true);\\n          off += sizeof<usize>();\\n        }\\n      } else {\\n        memory.copy(outStart, sourceStart, size);\\n      }\\n    } else if (out instanceof StaticArray<T>) {\\n      // return StaticArray\\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\\n      let outStart = changetype<usize>(out);\\n      if (isManaged<T>()) {\\n        let off: usize = 0;\\n        while (off < size) {\\n          let ref = load<usize>(sourceStart + off);\\n          store<usize>(outStart + off, ref);\\n          __link(outStart, ref, true);\\n          off += sizeof<usize>();\\n        }\\n      } else {\\n        memory.copy(outStart, sourceStart, size);\\n      }\\n    } else {\\n      ERROR(\\\"Only Array<T> and StaticArray<T> accept for 'U' parameter\\\");\\n    }\\n    return out;\\n  }\\n\\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\\n    for (let i = this.length - 1; i >= 0; --i) {\\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\\n    }\\n    return -1;\\n  }\\n\\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n    }\\n  }\\n\\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\\n    let len = this.length;\\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\\n    let outStart = out.dataStart;\\n    for (let i = 0; i < len; ++i) {\\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\\n      if (isManaged<U>()) {\\n        __link(changetype<usize>(out), changetype<usize>(result), true);\\n      }\\n    }\\n    return out;\\n  }\\n\\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\\n      if (fn(value, i, this)) result.push(value);\\n    }\\n    return result;\\n  }\\n\\n  reduce<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  reduceRight<U>(\\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\\n    initialValue: U\\n  ): U {\\n    let acc = initialValue;\\n    for (let i = this.length - 1; i >= 0; --i) {\\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\\n    }\\n    return acc;\\n  }\\n\\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\\n    }\\n    return true;\\n  }\\n\\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\\n    for (let i = 0, len = this.length; i < len; ++i) {\\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\\n    }\\n    return false;\\n  }\\n\\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\\n    SORT<T>(changetype<usize>(this), this.length, comparator);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\\n    }\\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\\n    ERROR(\\\"unspported element type\\\");\\n    return <string>unreachable();\\n  }\\n\\n  reverse(): StaticArray<T> {\\n    REVERSE<T>(changetype<usize>(this), this.length);\\n    return this;\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  // RT integration\\n\\n  @unsafe private __visit(cookie: u32): void {\\n    if (isManaged<T>()) {\\n      let cur = changetype<usize>(this);\\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\\n      while (cur < end) {\\n        let val = load<usize>(cur);\\n        if (val) __visit(val, cookie);\\n        cur += sizeof<usize>();\\n      }\\n    }\\n  }\\n}\\n\\n// variable-length, cannot be compared\\n@final\\nexport class ByteArray {\\n  [key: number]: u8;\\n\\n  @inline\\n  constructor(length: i32) {\\n    return changetype<ByteArray>(__new(length, idof<StaticArray<u8>>()));\\n  }\\n\\n  @inline get length(): i32 {\\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\\n  }\\n\\n  @inline set length(length: i32) {\\n    changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize = <u32>length;\\n  }\\n\\n  @inline @operator(\\\"[]\\\")\\n  private __get(index: i32): u8 {\\n    return load<u8>(changetype<usize>(this) + <usize>index);\\n  }\\n\\n  @inline @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: u8): void {\\n    store<u8>(changetype<usize>(this) + <usize>index, value);\\n  }\\n\\n  @operator.prefix(\\\"!\\\")\\n  private static __not(a: ByteArray | null): bool {\\n    return changetype<usize>(a) == 0 || !changetype<ByteArray>(a).length;\\n  }\\n\\n  @inline\\n  static fromUInt(v: u32): ByteArray {\\n    let a = new ByteArray(4);\\n    a[0] = <u8>((v >> 24) & 0xFF);\\n    a[1] = <u8>((v >> 16) & 0xFF);\\n    a[2] = <u8>((v >> 8) & 0xFF);\\n    a[3] = <u8>(v & 0xFF);\\n    return a;\\n  }\\n\\n  @inline\\n  toUInt(): u32 {\\n    return (<u32>(this[0]) << 24) + (<u32>(this[1]) << 16) + (<u32>(this[2]) << 8) + <u32>(this[3]);\\n  }\\n\\n  @inline\\n  static fromUShort(v: u16): ByteArray {\\n    let a = new ByteArray(2);\\n    a[0] = <u8>((v >> 8) & 0xFF);\\n    a[1] = <u8>(v & 0xFF);\\n    return a;\\n  }\\n\\n  @inline\\n  toUShort(): u16 {\\n    return (<u16>(this[0]) << 8) + <u16>(this[1]);\\n  }\\n}\\n\\nexport class ByteView {\\n  [key: number]: u8;\\n\\n  @inline\\n  constructor(public underlying: ByteArray, public offset: i32, public length: i32) {\\n  }\\n\\n  @inline @operator(\\\"[]\\\")\\n  private __get(index: i32): u8 {\\n    return this.underlying[this.offset + index];\\n  }\\n\\n  @inline @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: u8): void {\\n    this.underlying[this.offset + index] = value;\\n  }\\n\\n  @inline @builtin @operator(\\\"==\\\")\\n  private static __eq(left: ByteView, right: string): bool {\\n    return false; // shouldn't even get here\\n  }\\n\\n  @inline @builtin @operator(\\\"!=\\\")\\n  private static __neq(left: ByteView, right: string): bool {\\n    return false; // shouldn't even get here\\n  }\\n\\n  @inline\\n  toUInt(): u32 {\\n    return (<u32>(this[0]) << 24) + (<u32>(this[1]) << 16) + (<u32>(this[2]) << 8) + <u32>(this[3]);\\n  }\\n}\\n\\nexport abstract class BytesBase {\\n  [key: number]: u8;\\n\\n  abstract get length(): i32;\\n\\n  @inline @operator(\\\"[]\\\")\\n  private __get(index: i32): u8 {\\n    return load<u8>(changetype<usize>(this) + <usize>index);\\n  }\\n\\n  @inline @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: u8): void {\\n    // this looks like a reasonable check, but actually gets compiled\\n    // into very strange (and often satisfied) conditions - maybe\\n    // classes backed by linear memory cannot have virtual functions?\\n    // if (<u32>index >= <u32>(this.length)) unreachable();\\n    this.__uset(index, value);\\n  }\\n\\n  @unsafe @inline @operator(\\\"{}=\\\") private __uset(index: i32, value: u8): void {\\n    store<u8>(changetype<usize>(this) + <usize>index, value);\\n  }\\n};\\n\\n@final\\nexport class Bytes8 extends BytesBase {\\n  @inline\\n  constructor() {\\n    super();\\n    return changetype<Bytes8>(__new(8, idof<StaticArray<u8>>()));\\n  }\\n\\n  override get length(): i32 {\\n    return 8;\\n  }\\n\\n  @inline @operator(\\\"==\\\")\\n  private static __eq(left: Bytes8, right: Bytes8): bool {\\n    let ptr1 = changetype<usize>(left);\\n    let ptr2 = changetype<usize>(right);\\n    if (ptr1 == ptr2) return true;\\n\\n    return load<u64>(ptr1) == load<u64>(ptr2);\\n  }\\n\\n  @inline @operator(\\\"!=\\\")\\n  private static __ne(left: Bytes8, right: Bytes8): bool {\\n    return !this.__eq(left, right);\\n  }\\n}\\n\\n@final\\nexport class Bytes32 extends BytesBase {\\n  @inline\\n  constructor() {\\n    super();\\n    return changetype<Bytes32>(__new(32, idof<StaticArray<u8>>()));\\n  }\\n\\n  override get length(): i32 {\\n    return 32;\\n  }\\n\\n  @inline @operator(\\\"==\\\")\\n  private static __eq(left: Bytes32, right: Bytes32): bool {\\n    let ptr1 = changetype<usize>(left);\\n    let ptr2 = changetype<usize>(right);\\n    if (ptr1 == ptr2) return true;\\n\\n    for (let i = 0; max_iterations(4), i < 4; ++i) {\\n      if (load<u64>(ptr1) != load<u64>(ptr2)) return false;\\n      ptr1 += 8;\\n      ptr2 += 8;\\n    }\\n\\n    return true;\\n  }\\n\\n  @inline @operator(\\\"!=\\\")\\n  private static __ne(left: Bytes32, right: Bytes32): bool {\\n    return !this.__eq(left, right);\\n  }\\n}\\n\",\n  \"string\": \"/// <reference path=\\\"./rt/index.d.ts\\\" />\\n\\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \\\"./rt/common\\\";\\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \\\"./util/string\\\";\\nimport { SPECIALS_UPPER, casemap, bsearch } from \\\"./util/casemap\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \\\"./util/error\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { Array } from \\\"./array\\\";\\n\\n@final export abstract class String {\\n\\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\\n\\n  static fromChar(c: u8): String {\\n    let out = __new(1, idof<String>());\\n    store<u8>(out, c);\\n    return changetype<String>(out);\\n  }\\n\\n  static fromCharCodes(units: Array<i32>): String {\\n    let length = units.length;\\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\\n    let ptr = units.dataStart;\\n    for (let i = 0; i < length; ++i) {\\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\\n    }\\n    return out;\\n  }\\n\\n  static fromCodePoint(code: i32): String {\\n    let hasSur = <u32>code > 0xFFFF;\\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\\n    if (!hasSur) {\\n      store<u16>(changetype<usize>(out), <u16>code);\\n    } else {\\n      // Checks valid code point range\\n      assert(<u32>code <= 0x10FFFF);\\n      code -= 0x10000;\\n      let hi = (code & 0x03FF) | 0xDC00;\\n      let lo = code >>> 10 | 0xD800;\\n      store<u32>(changetype<usize>(out), lo | hi << 16);\\n    }\\n    return out;\\n  }\\n\\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\\n\\n  get length(): i32 {\\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\\n  }\\n\\n  @operator(\\\"[]\\\") charAt(pos: i32): u8 {\\n    return load<u8>(changetype<usize>(this) + <usize>pos);\\n  }\\n\\n  @operator(\\\"+\\\") private static __concat(left: String, right: String): String {\\n    return left.concat(right);\\n  }\\n\\n  concat(other: String): String {\\n    let thisSize: isize = this.length << 1;\\n    let otherSize: isize = other.length << 1;\\n    let outSize: usize = thisSize + otherSize;\\n    if (outSize == 0) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(outSize, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\\n    return out;\\n  }\\n\\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\\n    end = min(max(end, 0), this.length);\\n    let searchLength = <isize>search.length;\\n    let searchStart = <isize>end - searchLength;\\n    if (searchStart < 0) return false;\\n    // @ts-ignore: string <-> String\\n    return !compareImpl(this, searchStart, search, 0, searchLength);\\n  }\\n\\n  @operator(\\\"==\\\") private static __eq(left: String | null, right: String | null): bool {\\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\\n    let leftLength = changetype<string>(left).length;\\n    if (leftLength != changetype<string>(right).length) return false;\\n    // @ts-ignore: string <-> String\\n    return !compareImpl(left, 0, right, 0, leftLength);\\n  }\\n\\n  @operator.prefix(\\\"!\\\")\\n  private static __not(str: String | null): bool {\\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\\n  }\\n\\n  @operator(\\\"!=\\\")\\n  private static __ne(left: String | null, right: String | null): bool {\\n    return !this.__eq(left, right);\\n  }\\n\\n  @operator(\\\">\\\") private static __gt(left: String, right: String): bool {\\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\\n    let leftLength  = left.length;\\n    if (!leftLength) return false;\\n    let rightLength = right.length;\\n    if (!rightLength) return true;\\n    // @ts-ignore: string <-> String\\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\\n    return res ? res > 0 : leftLength > rightLength;\\n  }\\n\\n  @operator(\\\">=\\\") private static __gte(left: String, right: String): bool {\\n    return !this.__lt(left, right);\\n  }\\n\\n  @operator(\\\"<\\\") private static __lt(left: String, right: String): bool {\\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\\n    let rightLength = right.length;\\n    if (!rightLength) return false;\\n    let leftLength  = left.length;\\n    if (!leftLength) return true;\\n    // @ts-ignore: string <-> String\\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\\n    return res ? res < 0 : leftLength < rightLength;\\n  }\\n\\n  @operator(\\\"<=\\\") private static __lte(left: String, right: String): bool {\\n    return !this.__gt(left, right);\\n  }\\n\\n  includes(search: String, start: i32 = 0): bool {\\n    return this.indexOf(search, start) != -1;\\n  }\\n\\n  indexOf(search: String, start: i32 = 0): i32 {\\n    let searchLen = <isize>search.length;\\n    if (!searchLen) return 0;\\n    let len = <isize>this.length;\\n    if (!len) return -1;\\n    let searchStart = min(max(<isize>start, 0), len);\\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\\n      // @ts-ignore: string <-> String\\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\\n    }\\n    return -1;\\n  }\\n\\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\\n    let searchLen = <isize>search.length;\\n    if (!searchLen) return this.length;\\n    let len = this.length;\\n    if (!len) return -1;\\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\\n    for (; searchStart >= 0; --searchStart) {\\n      // @ts-ignore: string <-> String\\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\\n    }\\n    return -1;\\n  }\\n\\n  // TODO: implement full locale comparison with locales and Collator options\\n  localeCompare(other: String): i32 {\\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\\n    let alen = this.length;\\n    let blen = other.length;\\n    // @ts-ignore: string <-> String\\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\\n    res = res ? res : alen - blen;\\n    // normalize to [-1, 1] range\\n    return i32(res > 0) - i32(res < 0);\\n  }\\n\\n  startsWith(search: String, start: i32 = 0): bool {\\n    let len = <isize>this.length;\\n    let searchStart = min(max(<isize>start, 0), len);\\n    let searchLength = <isize>search.length;\\n    if (searchLength + searchStart > len) return false;\\n    // @ts-ignore: string <-> String\\n    return !compareImpl(this, searchStart, search, 0, searchLength);\\n  }\\n\\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\\n    let intStart: isize = start;\\n    let end: isize = length;\\n    let len: isize = this.length;\\n    if (intStart < 0) intStart = max(len + intStart, 0);\\n    let size = min(max(end, 0), len - intStart) << 1;\\n    if (size <= 0) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\\n    return out;\\n  }\\n\\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\\n    let len: isize = this.length;\\n    let finalStart = min<isize>(max(start, 0), len);\\n    let finalEnd = min<isize>(max(end, 0), len);\\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\\n    let size = toPos - fromPos;\\n    if (!size) return changetype<String>(\\\"\\\");\\n    if (!fromPos && toPos == len << 1) return this;\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\\n    return out;\\n  }\\n\\n  trim(): String {\\n    let len = this.length;\\n    let size: usize = len << 1;\\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\\n      size -= 2;\\n    }\\n    let offset: usize = 0;\\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\\n      offset += 2; size -= 2;\\n    }\\n    if (!size) return changetype<String>(\\\"\\\");\\n    if (!offset && size == len << 1) return this;\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\\n    return out;\\n  }\\n\\n  @inline\\n  trimLeft(): String {\\n    return this.trimStart();\\n  }\\n\\n  @inline\\n  trimRight(): String {\\n    return this.trimEnd();\\n  }\\n\\n  trimStart(): String {\\n    let size = <usize>this.length << 1;\\n    let offset: usize = 0;\\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\\n      offset += 2;\\n    }\\n    if (!offset) return this;\\n    size -= offset;\\n    if (!size) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\\n    return out;\\n  }\\n\\n  trimEnd(): String {\\n    let originalSize = <usize>this.length << 1;\\n    let size = originalSize;\\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\\n      size -= 2;\\n    }\\n    if (!size) return changetype<String>(\\\"\\\");\\n    if (size == originalSize) return this;\\n    let out = changetype<String>(__new(size, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\\n    return out;\\n  }\\n\\n  padStart(length: i32, pad: string = \\\" \\\"): String {\\n    let thisSize = <usize>this.length << 1;\\n    let targetSize = <usize>length << 1;\\n    let padSize = <usize>pad.length << 1;\\n    if (targetSize < thisSize || !padSize) return this;\\n    let prependSize = targetSize - thisSize;\\n    let out = changetype<String>(__new(targetSize, idof<String>()));\\n    if (prependSize > padSize) {\\n      let repeatCount = (prependSize - 2) / padSize;\\n      let restBase = repeatCount * padSize;\\n      let restSize = prependSize - restBase;\\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\\n    } else {\\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\\n    }\\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\\n    return out;\\n  }\\n\\n  padEnd(length: i32, pad: string = \\\" \\\"): String {\\n    let thisSize = <usize>this.length << 1;\\n    let targetSize = <usize>length << 1;\\n    let padSize = <usize>pad.length << 1;\\n    if (targetSize < thisSize || !padSize) return this;\\n    let appendSize = targetSize - thisSize;\\n    let out = changetype<String>(__new(targetSize, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\\n    if (appendSize > padSize) {\\n      let repeatCount = (appendSize - 2) / padSize;\\n      let restBase = repeatCount * padSize;\\n      let restSize = appendSize - restBase;\\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\\n    } else {\\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\\n    }\\n    return out;\\n  }\\n\\n  repeat(count: i32 = 0): String {\\n    let length = this.length;\\n\\n    // Most browsers can't handle strings 1 << 28 chars or longer\\n    if (count < 0 || <u64>length * count > (1 << 28)) {\\n      throw new RangeError(E_INVALIDLENGTH);\\n    }\\n\\n    if (count == 0 || !length) return changetype<String>(\\\"\\\");\\n    if (count == 1) return this;\\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\\n    return out;\\n  }\\n\\n  replace(search: String, replacement: String): String {\\n    let len: usize = this.length;\\n    let slen: usize = search.length;\\n    if (len <= slen) {\\n      return len < slen ? this : select<String>(replacement, this, search == this);\\n    }\\n    let index: isize = this.indexOf(search);\\n    if (~index) {\\n      let rlen: usize = replacement.length;\\n      len -= slen;\\n      let olen = len + rlen;\\n      if (olen) {\\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\\n        memory.copy(\\n          changetype<usize>(out) + (index << 1),\\n          changetype<usize>(replacement),\\n          rlen << 1\\n        );\\n        memory.copy(\\n          changetype<usize>(out) + ((index + rlen) << 1),\\n          changetype<usize>(this) + ((index + slen) << 1),\\n          (len - index) << 1\\n        );\\n        return out;\\n      }\\n    }\\n    return this;\\n  }\\n\\n  replaceAll(search: String, replacement: String): String {\\n    let thisLen: usize = this.length;\\n    let searchLen: usize = search.length;\\n    if (thisLen <= searchLen) {\\n      return thisLen < searchLen\\n        ? this\\n        : select<String>(replacement, this, search == this);\\n    }\\n    let replaceLen: usize = replacement.length;\\n    if (!searchLen) {\\n      if (!replaceLen) return this;\\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\\n      let offset = replaceLen;\\n      for (let i: usize = 0; i < thisLen; ++i) {\\n        store<u16>(\\n          changetype<usize>(out) + (offset++ << 1),\\n          load<u16>(changetype<usize>(this) + (i << 1))\\n        );\\n        memory.copy(\\n          changetype<usize>(out) + (offset << 1),\\n          changetype<usize>(replacement),\\n          replaceLen << 1\\n        );\\n        offset += replaceLen;\\n      }\\n      return out;\\n    }\\n    let prev: isize = 0, next: isize = 0;\\n    if (searchLen == replaceLen) {\\n      // Fast path when search and replacement have same length\\n      let outSize = thisLen << 1;\\n      let out = changetype<String>(__new(outSize, idof<String>()));\\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\\n        prev = next + searchLen;\\n      }\\n      return out;\\n    }\\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\\n      let chunk = next - prev;\\n      if (offset + chunk + replaceLen > outSize) {\\n        outSize <<= 1;\\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\\n      }\\n      memory.copy(\\n        changetype<usize>(out) + (offset << 1),\\n        changetype<usize>(this) + (prev << 1),\\n        chunk << 1\\n      );\\n      offset += chunk;\\n      memory.copy(\\n        changetype<usize>(out) + (offset << 1),\\n        changetype<usize>(replacement),\\n        replaceLen << 1\\n      );\\n      offset += replaceLen;\\n      prev = next + searchLen;\\n    }\\n    if (out) {\\n      let rest = thisLen - prev;\\n      if (offset + rest > outSize) {\\n        outSize <<= 1;\\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\\n      }\\n      if (rest) {\\n        memory.copy(\\n          changetype<usize>(out) + (offset << 1),\\n          changetype<usize>(this) + (prev << 1),\\n          rest << 1\\n        );\\n      }\\n      rest += offset;\\n      if (outSize > rest) {\\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\\n      }\\n      return out;\\n    }\\n    return this;\\n  }\\n\\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\\n    let len = this.length;\\n    start = start < 0 ? max(start + len, 0) : min(start, len);\\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\\n    len   = end - start;\\n    if (len <= 0) return changetype<String>(\\\"\\\");\\n    let out = changetype<String>(__new(len << 1, idof<String>()));\\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\\n    return out;\\n  }\\n\\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\\n    if (changetype<usize>(separator) == 0) return [ this ];\\n    let length: isize = this.length;\\n    let sepLen = changetype<string>(separator).length;\\n    if (limit < 0) limit = i32.MAX_VALUE;\\n    if (!sepLen) {\\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\\n      // split by chars\\n      length = min<isize>(length, <isize>limit);\\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\\n      // @ts-ignore: cast\\n      let resultStart = result.dataStart as usize;\\n      for (let i: isize = 0; i < length; ++i) {\\n        let charStr = changetype<String>(__new(2, idof<String>()));\\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\\n      }\\n      return result;\\n    } else if (!length) {\\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\\n      // @ts-ignore: cast\\n      store<usize>(result.dataStart as usize, changetype<usize>(\\\"\\\")); // static \\\"\\\"\\n      return result;\\n    }\\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\\n    let end = 0, start = 0, i = 0;\\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\\n      let len = end - start;\\n      if (len > 0) {\\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\\n        result.push(out);\\n      } else {\\n        result.push(changetype<String>(\\\"\\\"));\\n      }\\n      if (++i == limit) return result;\\n      start = end + sepLen;\\n    }\\n    if (!start) { // also means: loop above didn't do anything\\n      result.push(this);\\n      return result;\\n    }\\n    let len = length - start;\\n    if (len > 0) {\\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\\n      result.push(out);\\n    } else {\\n      result.push(changetype<String>(\\\"\\\")); // static \\\"\\\"\\n    }\\n    return result;\\n  }\\n\\n  toLowerCase(): String {\\n    let len = <usize>this.length;\\n    if (!len) return this;\\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\\n    let j: usize = 0;\\n    for (let i: usize = 0; i < len; ++i, ++j) {\\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\\n      if (isAscii(c)) {\\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\\n      } else {\\n        // check and read surrogate pair\\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\\n            let c0 = c;\\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\\n            ++i;\\n            if (c >= 0x20000) {\\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\\n              ++j;\\n              continue;\\n            }\\n          }\\n        }\\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\\n        if (c == 0x0130) {\\n          // 0x0130 -> [0x0069, 0x0307]\\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\\n          ++j;\\n        } else if (c == 0x03A3) { // '\u03A3'\\n          // \u03A3 maps to \u03C3 but except at the end of a word where it maps to \u03C2\\n          let sigma = 0x03C3; // \u03C3\\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\\n            sigma = 0x03C2; // \u03C2\\n          }\\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\\n        } else {\\n          let code = casemap(c, 0) & 0x1FFFFF;\\n          if (code < 0x10000) {\\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\\n          } else {\\n            // store as surrogare pair\\n            code -= 0x10000;\\n            let lo = (code >>> 10) | 0xD800;\\n            let hi = (code & 0x03FF) | 0xDC00;\\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\\n            ++j;\\n          }\\n        }\\n      }\\n    }\\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\\n  }\\n\\n  toUpperCase(): String {\\n    let len = <usize>this.length;\\n    if (!len) return this;\\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\\n    let specialsLen = SPECIALS_UPPER.length;\\n    let j: usize = 0;\\n    for (let i: usize = 0; i < len; ++i, ++j) {\\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\\n      if (isAscii(c)) {\\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\\n      } else {\\n        // check and read surrogate pair\\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\\n            let c0 = c;\\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\\n            ++i;\\n            if (c >= 0x20000) {\\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\\n              ++j;\\n              continue;\\n            }\\n          }\\n        }\\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\\n          // monkey patch\\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\\n        } else {\\n          let index: usize = -1;\\n          // Fast range check. See first and last rows in specialsUpper table\\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\\n          }\\n          if (~index) {\\n            // load next 3 code points from row with `index` offset for specialsUpper table\\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\\n            j += 1 + usize(cc != 0);\\n          } else {\\n            let code = casemap(c, 1) & 0x1FFFFF;\\n            if (code < 0x10000) {\\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\\n            } else {\\n              // store as surrogare pair\\n              code -= 0x10000;\\n              let lo = (code >>> 10) | 0xD800;\\n              let hi = (code & 0x03FF) | 0xDC00;\\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\\n              ++j;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\\n  }\\n\\n  toString(): String {\\n    return this;\\n  }\\n}\\n\\n// @ts-ignore: nolib\\nexport type string = String;\\n\\nexport function parseInt(str: string, radix: i32 = 0): f64 {\\n  return strtol<f64>(str, radix);\\n}\\n\\nexport function parseFloat(str: string): f64 {\\n  return strtod(str);\\n}\\n\\n@global @inline\\nexport function newStringBuffer(size: usize): usize {\\n  return __new(size, idof<String>());\\n}\\n\\n@global @inline\\nexport function convertStringBuffer(buf: usize, size: usize): string {\\n  return changetype<string>(buf - size);\\n}\\n\\n// Encoding helpers\\nexport namespace String {\\n\\n  export namespace UTF8 {\\n\\n    export const enum ErrorMode {\\n      WTF8,\\n      REPLACE,\\n      ERROR\\n    }\\n\\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\\n      let strOff = changetype<usize>(str);\\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\\n      let bufLen = i32(nullTerminated);\\n      while (strOff < strEnd) {\\n        let c1 = <u32>load<u16>(strOff);\\n        if (c1 < 128) {\\n          // @ts-ignore: cast\\n          if (nullTerminated & !c1) break;\\n          bufLen += 1;\\n        } else if (c1 < 2048) {\\n          bufLen += 2;\\n        } else {\\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\\n              bufLen += 4; strOff += 4;\\n              continue;\\n            }\\n          }\\n          bufLen += 3;\\n        }\\n        strOff += 2;\\n      }\\n      return bufLen;\\n    }\\n\\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\\n      return buf;\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\\n      let strEnd = str + (<usize>len << 1);\\n      let bufOff = buf;\\n      while (str < strEnd) {\\n        let c1 = <u32>load<u16>(str);\\n        if (c1 < 128) {\\n          store<u8>(bufOff, c1);\\n          bufOff++;\\n          // @ts-ignore: cast\\n          if (nullTerminated & !c1) return bufOff - buf;\\n        } else if (c1 < 2048) {\\n          let b0 = c1 >> 6 | 192;\\n          let b1 = c1 & 63 | 128;\\n          store<u16>(bufOff, b1 << 8 | b0);\\n          bufOff += 2;\\n        } else {\\n          // D800: 11011 0 0000000000 Lead\\n          // DBFF: 11011 0 1111111111\\n          // DC00: 11011 1 0000000000 Trail\\n          // DFFF: 11011 1 1111111111\\n          // F800: 11111 0 0000000000 Mask\\n          // FC00: 11111 1 0000000000\\n          if ((c1 & 0xF800) == 0xD800) {\\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\\n              let c2 = <u32>load<u16>(str, 2);\\n              if ((c2 & 0xFC00) == 0xDC00) {\\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\\n                let b0 = c1 >> 18 | 240;\\n                let b1 = c1 >> 12 & 63 | 128;\\n                let b2 = c1 >> 6  & 63 | 128;\\n                let b3 = c1       & 63 | 128;\\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\\n                bufOff += 4; str += 4;\\n                continue;\\n              }\\n            }\\n            if (errorMode != ErrorMode.WTF8) { // unlikely\\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\\n              c1 = 0xFFFD;\\n            }\\n          }\\n          let b0 = c1 >> 12 | 224;\\n          let b1 = c1 >> 6  & 63 | 128;\\n          let b2 = c1       & 63 | 128;\\n          store<u16>(bufOff, b1 << 8 | b0);\\n          store<u8>(bufOff, b2, 2);\\n          bufOff += 3;\\n        }\\n        str += 2;\\n      }\\n      if (nullTerminated) {\\n        store<u8>(bufOff++, 0);\\n      }\\n      return bufOff - buf;\\n    }\\n\\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\\n      let bufOff = buf;\\n      let bufEnd = buf + len;\\n      assert(bufEnd >= bufOff); // guard wraparound\\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\\n      let strOff = changetype<usize>(str);\\n      while (bufOff < bufEnd) {\\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\\n        if (!(u0 & 128)) {\\n          // @ts-ignore: cast\\n          if (nullTerminated & !u0) break;\\n          store<u16>(strOff, u0);\\n        } else {\\n          if (bufEnd == bufOff) break;\\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\\n          if ((u0 & 224) == 192) {\\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\\n          } else {\\n            if (bufEnd == bufOff) break;\\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\\n            if ((u0 & 240) == 224) {\\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\\n            } else {\\n              if (bufEnd == bufOff) break;\\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\\n              ++bufOff;\\n            }\\n            if (u0 < 0x10000) {\\n              store<u16>(strOff, u0);\\n            } else {\\n              u0 -= 0x10000;\\n              let lo = u0 >> 10 | 0xD800;\\n              let hi = (u0 & 0x03FF) | 0xDC00;\\n              store<u32>(strOff, lo | (hi << 16));\\n              strOff += 2;\\n            }\\n          }\\n        }\\n        strOff += 2;\\n      }\\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\\n    }\\n  }\\n\\n  export namespace UTF16 {\\n\\n    export function byteLength(str: string): i32 {\\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\\n    }\\n\\n    export function encode(str: string): ArrayBuffer {\\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\\n      return buf;\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\\n      let size = <usize>len << 1;\\n      memory.copy(buf, changetype<usize>(str), size);\\n      return size;\\n    }\\n\\n    export function decode(buf: ArrayBuffer): String {\\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\\n    }\\n\\n    // @ts-ignore: decorator\\n    @unsafe\\n    export function decodeUnsafe(buf: usize, len: usize): String {\\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\\n      memory.copy(changetype<usize>(str), buf, len);\\n      return str;\\n    }\\n  }\\n}\\n\\nexport class TemplateStringsArray extends Array<string> {\\n  readonly raw: string[];\\n}\\n\",\n  \"symbol\": \"import { Map } from \\\"./map\\\";\\n\\n// @ts-ignore: decorator\\n@lazy let stringToId: Map<string, usize>;\\n\\n// @ts-ignore: decorator\\n@lazy let idToString: Map<usize, string>;\\n\\n// @ts-ignore: decorator\\n@lazy let nextId: usize = 12; // Symbol.unscopables + 1\\n\\n@unmanaged @final abstract class _Symbol {\\n\\n  // TODO: all of the following default symbols are unused currently yet add to\\n  // binary size if #toString becomes compiled. Ultimately we'll most likely want\\n  // to remove the unsupported ones and only keep what's actually supported.\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly hasInstance: symbol = changetype<symbol>(1);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly isConcatSpreadable: symbol = changetype<symbol>(2);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly isRegExp: symbol = changetype<symbol>(3);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly iterator: symbol = changetype<symbol>(3);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly match: symbol = changetype<symbol>(4);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly replace: symbol = changetype<symbol>(5);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly search: symbol = changetype<symbol>(6);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly species: symbol = changetype<symbol>(7);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly split: symbol = changetype<symbol>(8);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly toPrimitive: symbol = changetype<symbol>(9);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly toStringTag: symbol = changetype<symbol>(10);\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly unscopables: symbol = changetype<symbol>(11);\\n\\n  static for(key: string): symbol {\\n    if (!stringToId) { stringToId = new Map(); idToString = new Map(); }\\n    else if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));\\n    let id = nextId++;\\n    if (!id) unreachable(); // out of ids\\n    stringToId.set(key, id);\\n    idToString.set(id, key);\\n    return changetype<symbol>(id);\\n  }\\n\\n  static keyFor(sym: symbol): string | null {\\n    return idToString != null && idToString.has(changetype<usize>(sym))\\n      ? idToString.get(changetype<usize>(sym))\\n      : null;\\n  }\\n\\n  toString(): string {\\n    let id = changetype<usize>(this);\\n    let str = \\\"\\\";\\n    switch (<u32>id) {\\n      case 1:  { str = \\\"hasInstance\\\"; break; }\\n      case 2:  { str = \\\"isConcatSpreadable\\\"; break; }\\n      case 3:  { str = \\\"isRegExp\\\"; break; }\\n      case 4:  { str = \\\"match\\\"; break; }\\n      case 5:  { str = \\\"replace\\\"; break; }\\n      case 6:  { str = \\\"search\\\"; break; }\\n      case 7:  { str = \\\"species\\\"; break; }\\n      case 8:  { str = \\\"split\\\"; break; }\\n      case 9:  { str = \\\"toPrimitive\\\"; break; }\\n      case 10: { str = \\\"toStringTag\\\"; break; }\\n      case 11: { str = \\\"unscopables\\\"; break; }\\n      default: {\\n        if (idToString != null && idToString.has(id)) str = idToString.get(id);\\n        break;\\n      }\\n    }\\n    return \\\"Symbol(\\\" + str + \\\")\\\";\\n  }\\n}\\n\\nexport function Symbol(description: string | null = null): symbol {\\n  let id = nextId++;\\n  if (!id) unreachable(); // out of ids\\n  return changetype<symbol>(id);\\n}\\n\\nexport type Symbol = _Symbol;\\n\\n// @ts-ignore: nolib\\nexport type symbol = _Symbol;\\n\",\n  \"table\": \"import { E_NOTIMPLEMENTED } from \\\"./util/error\\\";\\n\\nexport namespace table {\\n\\n  export function copy(dst: u32, src: u32, n: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n\\n  export function drop(elementIndex: u32): void {\\n    throw new Error(E_NOTIMPLEMENTED);\\n  }\\n}\\n\",\n  \"transaction\": \"// @ts-ignore: decorator\\n@lazy\\nexport const COMPARE_EQUAL = 1;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const COMPARE_LESS = 2;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const COMPARE_GREATER = 4;\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfTransactionType = ((1 << 16) + 2);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfSignerWeight = ((1 << 16) + 3);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfFlags = ((2 << 16) + 2);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfSourceTag = ((2 << 16) + 3);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfSequence = ((2 << 16) + 4);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfFirstLedgerSequence = ((2 << 16) + 26);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfLastLedgerSequence = ((2 << 16) + 27);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfSignerQuorum = ((2 << 16) + 35);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfInvoiceID = ((5 << 16) + 17);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfAmount = ((6 << 16) + 1);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfLowLimit = ((6 << 16) + 6);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfHighLimit = ((6 << 16) + 7);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfFee = ((6 << 16) + 8);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfSigningPubKey = ((7 << 16) + 3);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfTxnSignature = ((7 << 16) + 4);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfMemoData = ((7 << 16) + 13);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfMemoFormat = ((7 << 16) + 14);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfAccount = ((8 << 16) + 1);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfMemo = ((14 << 16) + 10);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfEmitDetails = ((14 << 16) + 13);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfSigners = ((15 << 16) + 3);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfSignerEntries = ((15 << 16) + 4);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfTemplate = ((15 << 16) + 5);\\n\\n// @ts-ignore: decorator\\n@lazy\\nexport const sfMemos = ((15 << 16) + 9);\\n\\nexport class Tx {\\n  @inline\\n  static get Account(): Account {\\n    let a = new ByteArray(20);\\n    let r = otxn_field(changetype<u32>(a), 20, sfAccount);\\n    if (r != 20)\\n      rollback(\\\"\\\", r);\\n\\n    return new Account(a);\\n  }\\n\\n  @inline\\n  static get Amount(): Amount {\\n    let a = new ByteArray(48);\\n    let r = otxn_field(changetype<u32>(a), 48, sfAmount);\\n    if (r == 8)\\n      a.length = 8;\\n    else if (r != 48)\\n      rollback(\\\"\\\", r);\\n\\n    return new Amount(a);\\n  }\\n\\n  @inline\\n  static get InvoiceID(): ByteArray {\\n    let a = new ByteArray(32);\\n    let r = otxn_field(changetype<u32>(a), 32, sfInvoiceID);\\n    if (r < 0)\\n      r = 0;\\n\\n    a.length = <i32>r;\\n    return a;\\n  }\\n\\n  @inline\\n  static get Memos(): ByteArray {\\n    let a = new ByteArray(2048);\\n    let r = otxn_field(changetype<u32>(a), 2048, sfMemos);\\n    if (r < 0)\\n      r = 0;\\n\\n    a.length = <i32>r;\\n    return a;\\n  }\\n}\\n\\nexport class EmitSpec {\\n  account: Account;\\n  amount: Amount;\\n  sourceTag: u32;\\n  destinationTag: u32;\\n}\\n\",\n  \"typedarray\": \"import { COMPARATOR, SORT } from \\\"./util/sort\\\";\\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \\\"./util/error\\\";\\nimport { joinIntegerArray, joinFloatArray } from \\\"./util/string\\\";\\nimport { REVERSE, FILL } from \\\"./util/bytes\\\";\\nimport { idof } from \\\"./builtins\\\";\\nimport { ArrayBufferView } from \\\"./arraybuffer\\\";\\n\\nexport class Int8Array extends ArrayBufferView {\\n  [key: number]: i8;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i8>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i8 {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i8>(this.dataStart + <usize>index);\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i8 {\\n    return load<i8>(this.dataStart + <usize>index);\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<i8>): void {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<i8>): void {\\n    store<i8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  at(index: i32): i8 {\\n    let len = this.byteLength;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i8>(this.dataStart + <usize>index);\\n  }\\n\\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\\n    SORT<i8>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\\n    return SLICE<Int8Array, i8>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\\n    return MAP<Int8Array, i8>(this, fn);\\n  }\\n\\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\\n    return FILTER<Int8Array, i8>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\\n    return FIND_INDEX<Int8Array, i8>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\\n  }\\n\\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\\n    return SOME<Int8Array, i8>(this, fn);\\n  }\\n\\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\\n    return EVERY<Int8Array, i8>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\\n    FOREACH<Int8Array, i8>(this, fn);\\n  }\\n\\n  reverse(): Int8Array {\\n    REVERSE<u8>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint8Array extends ArrayBufferView {\\n  [key: number]: u8;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u8>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u8 {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u8 {\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<u8>): void {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<u8>): void {\\n    store<u8>(this.dataStart + <usize>index, value);\\n  }\\n\\n  at(index: i32): u8 {\\n    let len = this.byteLength;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\\n    SORT<u8>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    return SLICE<Uint8Array, u8>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\\n    return MAP<Uint8Array, u8>(this, fn);\\n  }\\n\\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\\n    return FILTER<Uint8Array, u8>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\\n  }\\n\\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\\n    return SOME<Uint8Array, u8>(this, fn);\\n  }\\n\\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\\n    return EVERY<Uint8Array, u8>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\\n    FOREACH<Uint8Array, u8>(this, fn);\\n  }\\n\\n  reverse(): Uint8Array {\\n    REVERSE<u8>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint8ClampedArray extends ArrayBufferView {\\n  [key: number]: u8;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u8>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength;\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u8 {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u8 {\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<u8>): void {\\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<u8>): void {\\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\\n  }\\n\\n  at(index: i32): u8 {\\n    let len = this.byteLength;\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u8>(this.dataStart + <usize>index);\\n  }\\n\\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\\n    SORT<u8>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\\n  }\\n\\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\\n    return MAP<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\\n    return SOME<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\\n  }\\n\\n  reverse(): Uint8ClampedArray {\\n    REVERSE<u8>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Int16Array extends ArrayBufferView {\\n  [key: number]: i16;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i16>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<i16>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i16 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i16 {\\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<i16>): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<i16>): void {\\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\\n  }\\n\\n  at(index: i32): i16 {\\n    let len = this.byteLength >>> alignof<i16>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\\n  }\\n\\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\\n    SORT<i16>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\\n    return SLICE<Int16Array, i16>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\\n    return MAP<Int16Array, i16>(this, fn);\\n  }\\n\\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\\n    return FILTER<Int16Array, i16>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\\n    return FIND_INDEX<Int16Array, i16>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\\n  }\\n\\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\\n    return SOME<Int16Array, i16>(this, fn);\\n  }\\n\\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\\n    return EVERY<Int16Array, i16>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\\n    FOREACH<Int16Array, i16>(this, fn);\\n  }\\n\\n  reverse(): Int16Array {\\n    REVERSE<u16>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint16Array extends ArrayBufferView {\\n  [key: number]: u16;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u16>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<u16>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u16 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u16 {\\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: native<u16>): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: native<u16>): void {\\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\\n  }\\n\\n  at(index: i32): u16 {\\n    let len = this.byteLength >>> alignof<u16>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\\n  }\\n\\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\\n    SORT<u16>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    return SLICE<Uint16Array, u16>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\\n    return MAP<Uint16Array, u16>(this, fn);\\n  }\\n\\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\\n    return FILTER<Uint16Array, u16>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\\n  }\\n\\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\\n    return SOME<Uint16Array, u16>(this, fn);\\n  }\\n\\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\\n    return EVERY<Uint16Array, u16>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\\n    FOREACH<Uint16Array, u16>(this, fn);\\n  }\\n\\n  reverse(): Uint16Array {\\n    REVERSE<u16>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Int32Array extends ArrayBufferView {\\n  [key: number]: i32;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i32>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<i32>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i32 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i32 {\\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: i32): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: i32): void {\\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\\n  }\\n\\n  at(index: i32): i32 {\\n    let len = this.byteLength >>> alignof<i32>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\\n  }\\n\\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\\n    SORT<i32>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\\n    return SLICE<Int32Array, i32>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\\n    return MAP<Int32Array, i32>(this, fn);\\n  }\\n\\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\\n    return FILTER<Int32Array, i32>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\\n    return FIND_INDEX<Int32Array, i32>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\\n  }\\n\\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\\n    return SOME<Int32Array, i32>(this, fn);\\n  }\\n\\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\\n    return EVERY<Int32Array, i32>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\\n    FOREACH<Int32Array, i32>(this, fn);\\n  }\\n\\n  reverse(): Int32Array {\\n    REVERSE<u32>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint32Array extends ArrayBufferView {\\n  [key: number]: u32;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u32>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<u32>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u32 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u32 {\\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: u32): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: u32): void {\\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\\n  }\\n\\n  at(index: i32): u32 {\\n    let len = this.byteLength >>> alignof<u32>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\\n  }\\n\\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    FILL<u32>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\\n    SORT<u32>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    return SLICE<Uint32Array, u32>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\\n    return MAP<Uint32Array, u32>(this, fn);\\n  }\\n\\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\\n    return FILTER<Uint32Array, u32>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\\n  }\\n\\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\\n    return SOME<Uint32Array, u32>(this, fn);\\n  }\\n\\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\\n    return EVERY<Uint32Array, u32>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\\n    FOREACH<Uint32Array, u32>(this, fn);\\n  }\\n\\n  reverse(): Uint32Array {\\n    REVERSE<u32>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Int64Array extends ArrayBufferView {\\n  [key: number]: i64;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<i64>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<i64>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): i64 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): i64 {\\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: i64): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: i64): void {\\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\\n  }\\n\\n  at(index: i32): i64 {\\n    let len = this.byteLength >>> alignof<i64>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\\n  }\\n\\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\\n    SORT<i64>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\\n    return SLICE<Int64Array, i64>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\\n    return MAP<Int64Array, i64>(this, fn);\\n  }\\n\\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\\n    return FILTER<Int64Array, i64>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\\n    return FIND_INDEX<Int64Array, i64>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\\n  }\\n\\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\\n    return SOME<Int64Array, i64>(this, fn);\\n  }\\n\\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\\n    return EVERY<Int64Array, i64>(this, fn);\\n  }\\n\\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\\n    FOREACH<Int64Array, i64>(this, fn);\\n  }\\n\\n  reverse(): Int64Array {\\n    REVERSE<u64>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Uint64Array extends ArrayBufferView {\\n  [key: number]: u64;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<u64>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<u64>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): u64 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): u64 {\\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: u64): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: u64): void {\\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\\n  }\\n\\n  at(index: i32): u64 {\\n    let len = this.byteLength >>> alignof<u64>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\\n  }\\n\\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    FILL<u64>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\\n    SORT<u64>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    return SLICE<Uint64Array, u64>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\\n    return MAP<Uint64Array, u64>(this, fn);\\n  }\\n\\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\\n    return FILTER<Uint64Array, u64>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\\n  }\\n\\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\\n    return SOME<Uint64Array, u64>(this, fn);\\n  }\\n\\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\\n    return EVERY<Uint64Array, u64>(this, fn);\\n  }\\n\\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\\n    FOREACH<Uint64Array, u64>(this, fn);\\n  }\\n\\n  reverse(): Uint64Array {\\n    REVERSE<u64>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Float32Array extends ArrayBufferView {\\n  [key: number]: f32;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<f32>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<f32>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): f32 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): f32 {\\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: f32): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: f32): void {\\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\\n  }\\n\\n  at(index: i32): f32 {\\n    let len = this.byteLength >>> alignof<f32>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\\n  }\\n\\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\\n    FILL<f32>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\\n    SORT<f32>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\\n    return SLICE<Float32Array, f32>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\\n    return MAP<Float32Array, f32>(this, fn);\\n  }\\n\\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\\n    return FILTER<Float32Array, f32>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\\n    return FIND_INDEX<Float32Array, f32>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\\n  }\\n\\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\\n    return SOME<Float32Array, f32>(this, fn);\\n  }\\n\\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\\n    return EVERY<Float32Array, f32>(this, fn);\\n  }\\n\\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\\n    FOREACH<Float32Array, f32>(this, fn);\\n  }\\n\\n  reverse(): Float32Array {\\n    REVERSE<f32>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\\n  }\\n}\\n\\nexport class Float64Array extends ArrayBufferView {\\n  [key: number]: f64;\\n\\n  // @ts-ignore: decorator\\n  @lazy\\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\\n\\n  constructor(length: i32) {\\n    super(length, alignof<f64>());\\n  }\\n\\n  get length(): i32 {\\n    return this.byteLength >>> alignof<f64>();\\n  }\\n\\n  @operator(\\\"[]\\\")\\n  private __get(index: i32): f64 {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\\n  }\\n\\n  @unsafe @operator(\\\"{}\\\")\\n  private __uget(index: i32): f64 {\\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\\n  }\\n\\n  @operator(\\\"[]=\\\")\\n  private __set(index: i32, value: f64): void {\\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\\n  }\\n\\n  @unsafe @operator(\\\"{}=\\\")\\n  private __uset(index: i32, value: f64): void {\\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\\n  }\\n\\n  at(index: i32): f64 {\\n    let len = this.byteLength >>> alignof<f64>();\\n    index += select(0, len, index >= 0);\\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\\n  }\\n\\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\\n  }\\n\\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\\n  }\\n\\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\\n  }\\n\\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\\n    FILL<f64>(this.dataStart, this.length, value, start, end);\\n    return this;\\n  }\\n\\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\\n    SORT<f64>(this.dataStart, this.length, comparator);\\n    return this;\\n  }\\n\\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\\n    return SLICE<Float64Array, f64>(this, begin, end);\\n  }\\n\\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\\n  }\\n\\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\\n  }\\n\\n  reduce<T extends number>(\\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\\n  }\\n\\n  reduceRight<T extends number>(\\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\\n    initialValue: T,\\n  ): T {\\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\\n  }\\n\\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\\n    return MAP<Float64Array, f64>(this, fn);\\n  }\\n\\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\\n    return FILTER<Float64Array, f64>(this, fn);\\n  }\\n\\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\\n    return FIND_INDEX<Float64Array, f64>(this, fn);\\n  }\\n\\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\\n  }\\n\\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\\n    return SOME<Float64Array, f64>(this, fn);\\n  }\\n\\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\\n    return EVERY<Float64Array, f64>(this, fn);\\n  }\\n\\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\\n    FOREACH<Float64Array, f64>(this, fn);\\n  }\\n\\n  reverse(): Float64Array {\\n    REVERSE<f64>(this.dataStart, this.length);\\n    return this;\\n  }\\n\\n  join(separator: string = \\\",\\\"): string {\\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\\n  }\\n\\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\\n    SET(this, source, offset);\\n  }\\n\\n  toString(): string {\\n    return this.join();\\n  }\\n\\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  start: i32,\\n  end: i32\\n): TArray {\\n  let len = array.length;\\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\\n  len = max(end - start, 0);\\n  let slice = instantiate<TArray>(len);\\n  memory.copy(\\n    slice.dataStart,\\n    array.dataStart + (<usize>start << alignof<T>()),\\n    <usize>len << alignof<T>()\\n  );\\n  return slice;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  begin: i32,\\n  end: i32\\n): TArray {\\n  let len = array.length;\\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\\n  end   = max(end, begin);\\n\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  let buf = changetype<usize>(array.buffer);\\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), buf, false);\\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\\\"dataStart\\\"));\\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\\\"byteLength\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  target: i32,\\n  start: i32,\\n  end: i32\\n): TArray {\\n  let len = array.length;\\n  let ptr = array.dataStart;\\n\\n  end   = min<i32>(end, len);\\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\\n  let count = min(last - from, len - to);\\n\\n  memory.copy(\\n    ptr + (<usize>to << alignof<T>()),\\n    ptr + (<usize>from << alignof<T>()),\\n    <usize>count << alignof<T>()\\n  );\\n  return array;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\\n  array: TArray,\\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\\n  initialValue: TRet\\n): TRet {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\\n  }\\n  return initialValue;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\\n  array: TArray,\\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\\n  initialValue: TRet\\n): TRet {\\n  let ptr = array.dataStart;\\n  for (let i = array.length - 1; i >= 0; i--) {\\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\\n  }\\n  return initialValue;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, self: TArray) => T,\\n): TArray {\\n  let len = array.length;\\n  let ptr = array.dataStart;\\n\\n  let byteLength = len << alignof<T>();\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\\n  for (let i = 0; i < len; i++) {\\n    store<T>(\\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\\n    );\\n  }\\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\\\"dataStart\\\"));\\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\\\"byteLength\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, self: TArray) => bool,\\n): TArray {\\n  let len = array.length;\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\\n  let dataStart  = array.dataStart;\\n  let j: usize = 0;\\n  for (let i = 0; i < len; i++) {\\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    if (fn(value, i, array)) {\\n      store<T>(\\n        changetype<usize>(buf) + (j++ << alignof<T>()),\\n        value\\n      );\\n    }\\n  }\\n  // shrink output buffer\\n  let byteLength = j << alignof<T>();\\n  let data = __renew(changetype<usize>(buf), byteLength);\\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), data, false);\\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\\\"byteLength\\\"));\\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\\\"dataStart\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): i32 {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): i32 {\\n  let ptr = array.dataStart;\\n  for (let i = array.length - 1; i >= 0; --i) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  searchElement: T,\\n  fromIndex: i32,\\n): bool {\\n  if (isFloat<T>()) {\\n    let index: isize = fromIndex;\\n    let len: isize = array.length;\\n    if (len == 0 || index >= len) return false;\\n    if (index < 0) index = max(len + index, 0);\\n    let dataStart = array.dataStart;\\n    while (index < len) {\\n      let elem = load<T>(dataStart + (index << alignof<T>()));\\n      // @ts-ignore\\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\\n      ++index;\\n    }\\n    return false;\\n  } else {\\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  searchElement: T,\\n  fromIndex: i32,\\n): i32 {\\n  let index: isize = fromIndex;\\n  let len: isize = array.length;\\n  if (len == 0 || index >= len) return -1;\\n  if (index < 0) index = max(len + index, 0);\\n  let dataStart = array.dataStart;\\n  while (index < len) {\\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\\n    ++index;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  searchElement: T,\\n  fromIndex: i32,\\n): i32 {\\n  let index: isize = fromIndex;\\n  let len: isize = array.length;\\n  if (len == 0) return -1;\\n  if (index < 0) index = len + index; // no need to clamp\\n  else if (index >= len) index = len - 1;\\n  let dataStart = array.dataStart;\\n  while (index >= 0) {\\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\\n    --index;\\n  }\\n  return -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): bool {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\\n  }\\n  return false;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => bool,\\n): bool {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\\n    return false;\\n  }\\n  return true;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\\n  array: TArray,\\n  fn: (value: T, index: i32, array: TArray) => void,\\n): void {\\n  let ptr = array.dataStart;\\n  for (let i = 0, k = array.length; i < k; i++) {\\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction WRAP<TArray extends ArrayBufferView, T>(\\n  buffer: ArrayBuffer,\\n  byteOffset: i32 = 0,\\n  len: i32 = -1\\n): TArray {\\n  let byteLength: i32;\\n  let bufferByteLength = buffer.byteLength;\\n  const mask: u32 = sizeof<T>() - 1;\\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\\n    throw new RangeError(E_INDEXOUTOFRANGE);\\n  }\\n  if (len < 0) {\\n    if (len == -1) {\\n      if (bufferByteLength & mask) {\\n        throw new RangeError(E_INVALIDLENGTH);\\n      }\\n      byteLength = bufferByteLength - byteOffset;\\n    } else {\\n      throw new RangeError(E_INVALIDLENGTH);\\n    }\\n  } else {\\n    byteLength = len << alignof<T>();\\n    if (byteOffset + byteLength > bufferByteLength) {\\n      throw new RangeError(E_INVALIDLENGTH);\\n    }\\n  }\\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\\\"buffer\\\"));\\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\\\"byteLength\\\"));\\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\\\"dataStart\\\"));\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction SET<\\n  TArray extends ArrayLike<number>,\\n  UArray extends ArrayLike<number>\\n>(\\n  target: TArray,\\n  source: UArray,\\n  offset: i32 = 0\\n): void {\\n  // need to assert at compile time that U is not a reference or a function\\n  if (isReference<valueof<UArray>>()) {\\n    ERROR(E_NOTIMPLEMENTED);\\n  }\\n  let sourceLen = source.length;\\n  if (offset < 0 || sourceLen + offset > target.length) {\\n    // offset is out of bounds\\n    throw new RangeError(E_INDEXOUTOFRANGE);\\n  }\\n  // @ts-ignore: dataStart\\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\\n  // @ts-ignore: dataStart\\n  let sourceStart = source.dataStart;\\n  // if the types align and match, use memory.copy() instead of manual loop\\n  if (\\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\\n  ) {\\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\\n  } else {\\n    for (let i = 0; i < sourceLen; i++) {\\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\\n      // if TArray is Uint8ClampedArray, then values must be clamped\\n      if (target instanceof Uint8ClampedArray) {\\n        if (isFloat<valueof<UArray>>()) {\\n          store<valueof<TArray>>(ptr,\\n            isFinite<valueof<UArray>>(value)\\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\\n              : 0\\n          );\\n        } else {\\n          if (!isSigned<valueof<UArray>>()) {\\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\\n          } else if (sizeof<valueof<TArray>>() <= 4) {\\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\\n          } else {\\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\\n          }\\n        }\\n      } else {\\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\\n        } else {\\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\\n        }\\n      }\\n    }\\n  }\\n}\\n\",\n  \"uri\": \"import { encode, decode, URI_UNSAFE, URL_UNSAFE } from \\\"./util/uri\\\";\\n\\nexport function encodeURI(str: string): string {\\n  return changetype<string>(encode(changetype<usize>(str), str.length, URI_UNSAFE));\\n}\\n\\nexport function decodeURI(str: string): string {\\n  return changetype<string>(decode(changetype<usize>(str), str.length, false));\\n}\\n\\nexport function encodeURIComponent(str: string): string {\\n  return changetype<string>(encode(changetype<usize>(str), str.length, URL_UNSAFE));\\n}\\n\\nexport function decodeURIComponent(str: string): string {\\n  return changetype<string>(decode(changetype<usize>(str), str.length, true));\\n}\\n\",\n  \"util/bytes\": \"export function REVERSE<T>(ptr: usize, len: usize): void {\\n  if (len > 1) {\\n    let\\n      i: usize = 0,\\n      tail: usize,\\n      hlen: usize = len >> 1;\\n\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      if (sizeof<T>() == 1) {\\n        // TODO: Decide later: Does we need this fast path cases?\\n        //\\n        // if (len == 4) {\\n        //   store<u32>(ptr, bswap(load<u32>(ptr)));\\n        //   return;\\n        // }\\n        // if (len == 8) {\\n        //   store<u64>(ptr, bswap(load<u64>(ptr)));\\n        //   return;\\n        // }\\n        tail = len - 8;\\n        while (i + 7 < hlen) {\\n          let front = ptr + i;\\n          let back  = ptr + tail - i;\\n          let temp  = bswap(load<u64>(front));\\n          store<u64>(front, bswap(load<u64>(back)));\\n          store<u64>(back, temp);\\n          i += 8;\\n        }\\n      }\\n\\n      if (sizeof<T>() == 2) {\\n        tail = len - 2;\\n        while (i + 1 < hlen) {\\n          let front = ptr + (i << 1);\\n          let back  = ptr + (tail - i << 1);\\n          let temp  = rotr(load<u32>(back), 16);\\n          store<u32>(back, rotr(load<u32>(front), 16));\\n          store<u32>(front, temp);\\n          i += 2;\\n        }\\n      }\\n    }\\n\\n    tail = len - 1;\\n    while (i < hlen) {\\n      let front = ptr + (i << alignof<T>());\\n      let back  = ptr + (tail - i << alignof<T>());\\n      let temp  = load<T>(front);\\n      store<T>(front, load<T>(back));\\n      store<T>(back, temp);\\n      i++;\\n    }\\n  }\\n}\\n\\nexport function FILL<T>(\\n  ptr: usize,\\n  len: usize,\\n  value: T,\\n  start: isize,\\n  end: isize\\n): void {\\n  start = start < 0 ? max(len + start, 0) : min(start, len);\\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\\n\\n  if (sizeof<T>() == 1) {\\n    if (start < end) {\\n      memory.fill(\\n        ptr + <usize>start,\\n        u8(value),\\n        <usize>(end - start)\\n      );\\n    }\\n  } else {\\n    if (ASC_SHRINK_LEVEL <= 1) {\\n      if (isInteger<T>()) {\\n        // @ts-ignore\\n        if (value == <T>0 | value == <T>-1) {\\n          if (start < end) {\\n            memory.fill(\\n              ptr + (<usize>start << alignof<T>()),\\n              u8(value),\\n              <usize>(end - start) << alignof<T>()\\n            );\\n          }\\n          return;\\n        }\\n      } else if (isFloat<T>()) {\\n        // for floating non-negative zeros we can use fast memory.fill\\n        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||\\n            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {\\n          if (start < end) {\\n            memory.fill(\\n              ptr + (<usize>start << alignof<T>()),\\n              0,\\n              <usize>(end - start) << alignof<T>()\\n            );\\n          }\\n          return;\\n        }\\n      }\\n    }\\n    for (; start < end; ++start) {\\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\\n    }\\n  }\\n}\\n\",\n  \"util/casemap\": \"// Total tables size: ~5 kb (usually compressed to ~4 kb)\\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h\\n\\n// @ts-ignore: decorator\\n@lazy @inline const TAB = memory.data<u8>([\\n  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,\\n  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,\\n  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,\\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,\\n  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,\\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,\\n  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,\\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,\\n  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,\\n  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,\\n  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,\\n  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,\\n  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,\\n  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,\\n  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,\\n  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,\\n  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,\\n  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,\\n  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,\\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,\\n  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\\n  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,\\n  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\\n  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,\\n  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\\n  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,\\n  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,\\n  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,\\n  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,\\n  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,\\n  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,\\n  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,\\n  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,\\n  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,\\n  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,\\n  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,\\n  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,\\n  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,\\n  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,\\n  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,\\n  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,\\n  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,\\n  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,\\n  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const RULES = memory.data<i32>([\\n  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,\\n  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,\\n  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,\\n  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,\\n  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,\\n  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,\\n  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,\\n  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,\\n  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,\\n  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,\\n  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,\\n  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,\\n  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,\\n  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,\\n  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,\\n  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,\\n  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,\\n  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,\\n  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,\\n  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,\\n  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,\\n  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,\\n  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,\\n  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,\\n  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,\\n  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,\\n  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,\\n  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,\\n  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,\\n  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,\\n  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,\\n  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,\\n  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,\\n  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,\\n  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,\\n  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,\\n  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,\\n  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,\\n  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,\\n  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const RULE_BASES = memory.data<u8>([\\n  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,\\n  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,\\n  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXCEPTIONS = memory.data<u8>([\\n  48, 12,  49, 13,  120, 14,  127, 15,\\n  128, 16,  129, 17,  134, 18,  137, 19,\\n  138, 19,  142, 20,  143, 21,  144, 22,\\n  147, 19,  148, 23,  149, 24,  150, 25,\\n  151, 26,  154, 27,  156, 25,  157, 28,\\n  158, 29,  159, 30,  166, 31,  169, 31,\\n  174, 31,  177, 32,  178, 32,  183, 33,\\n  191, 34,  197, 35,  200, 35,  203, 35,\\n  221, 36,  242, 35,  246, 37,  247, 38,\\n  32, 45,  58, 46,  61, 47,  62, 48,\\n  63, 49,  64, 49,  67, 50,  68, 51,\\n  69, 52,  80, 53,  81, 54,  82, 55,\\n  83, 56,  84, 57,  89, 58,  91, 59,\\n  92, 60,  97, 61,  99, 62,  101, 63,\\n  102, 64,  104, 65,  105, 66,  106, 64,\\n  107, 67,  108, 68,  111, 66,  113, 69,\\n  114, 70,  117, 71,  125, 72,  130, 73,\\n  135, 74,  137, 75,  138, 76,  139, 76,\\n  140, 77,  146, 78,  157, 79,  158, 80,\\n  69, 87,  123, 29,  124, 29,  125, 29,\\n  127, 88,  134, 89,  136, 90,  137, 90,\\n  138, 90,  140, 91,  142, 92,  143, 92,\\n  172, 93,  173, 94,  174, 94,  175, 94,\\n  194, 95,  204, 96,  205, 97,  206, 97,\\n  207, 98,  208, 99,  209, 100,  213, 101,\\n  214, 102,  215, 103,  240, 104,  241, 105,\\n  242, 106,  243, 107,  244, 108,  245, 109,\\n  249, 110,  253, 45,  254, 45,  255, 45,\\n  80, 105,  81, 105,  82, 105,  83, 105,\\n  84, 105,  85, 105,  86, 105,  87, 105,\\n  88, 105,  89, 105,  90, 105,  91, 105,\\n  92, 105,  93, 105,  94, 105,  95, 105,\\n  130, 0,  131, 0,  132, 0,  133, 0,\\n  134, 0,  135, 0,  136, 0,  137, 0,\\n  192, 117,  207, 118,  128, 137,  129, 138,\\n  130, 139,  133, 140,  134, 141,  112, 157,\\n  113, 157,  118, 158,  119, 158,  120, 159,\\n  121, 159,  122, 160,  123, 160,  124, 161,\\n  125, 161,  179, 162,  186, 163,  187, 163,\\n  188, 164,  190, 165,  195, 162,  204, 164,\\n  218, 166,  219, 166,  229, 106,  234, 167,\\n  235, 167,  236, 110,  243, 162,  248, 168,\\n  249, 168,  250, 169,  251, 169,  252, 164,\\n  38, 176,  42, 177,  43, 178,  78,  179,\\n  132,  8,  98, 186,  99, 187,  100, 188,\\n  101, 189,  102, 190,  109, 191,  110, 192,\\n  111, 193,  112, 194,  126, 195,  127, 195,\\n  125, 207,  141, 208,  148, 209,  171, 210,\\n  172, 211,  173, 212,  176, 213,  177, 214,\\n  178, 215,  196, 216,  197, 217,  198, 218\\n]);\\n\\n/* Special Case Mappings\\n * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt\\n */\\n\\n/*\\n@lazy @inline\\nconst SPECIALS_LOWER: StaticArray<u16> = [\\n  0x0130,  0x0069, 0x0307, 0x0000,\\n];\\n*/\\n\\n// @ts-ignore: decorator\\n@lazy @inlne\\nexport const SPECIALS_UPPER: StaticArray<u16> = [\\n  // String#toUpperCase needs .length\\n  0x00DF,  0x0053, 0x0053, 0x0000,\\n  0x0149,  0x02BC, 0x004E, 0x0000,\\n  0x01F0,  0x004A, 0x030C, 0x0000,\\n  0x0390,  0x0399, 0x0308, 0x0301,\\n  0x03B0,  0x03A5, 0x0308, 0x0301,\\n  0x0587,  0x0535, 0x0552, 0x0000,\\n  0x1E96,  0x0048, 0x0331, 0x0000,\\n  0x1E97,  0x0054, 0x0308, 0x0000,\\n  0x1E98,  0x0057, 0x030A, 0x0000,\\n  0x1E99,  0x0059, 0x030A, 0x0000,\\n  0x1E9A,  0x0041, 0x02BE, 0x0000,\\n  0x1F50,  0x03A5, 0x0313, 0x0000,\\n  0x1F52,  0x03A5, 0x0313, 0x0300,\\n  0x1F54,  0x03A5, 0x0313, 0x0301,\\n  0x1F56,  0x03A5, 0x0313, 0x0342,\\n  0x1F80,  0x1F08, 0x0399, 0x0000,\\n  0x1F81,  0x1F09, 0x0399, 0x0000,\\n  0x1F82,  0x1F0A, 0x0399, 0x0000,\\n  0x1F83,  0x1F0B, 0x0399, 0x0000,\\n  0x1F84,  0x1F0C, 0x0399, 0x0000,\\n  0x1F85,  0x1F0D, 0x0399, 0x0000,\\n  0x1F86,  0x1F0E, 0x0399, 0x0000,\\n  0x1F87,  0x1F0F, 0x0399, 0x0000,\\n  0x1F88,  0x1F08, 0x0399, 0x0000,\\n  0x1F89,  0x1F09, 0x0399, 0x0000,\\n  0x1F8A,  0x1F0A, 0x0399, 0x0000,\\n  0x1F8B,  0x1F0B, 0x0399, 0x0000,\\n  0x1F8C,  0x1F0C, 0x0399, 0x0000,\\n  0x1F8D,  0x1F0D, 0x0399, 0x0000,\\n  0x1F8E,  0x1F0E, 0x0399, 0x0000,\\n  0x1F8F,  0x1F0F, 0x0399, 0x0000,\\n  0x1F90,  0x1F28, 0x0399, 0x0000,\\n  0x1F91,  0x1F29, 0x0399, 0x0000,\\n  0x1F92,  0x1F2A, 0x0399, 0x0000,\\n  0x1F93,  0x1F2B, 0x0399, 0x0000,\\n  0x1F94,  0x1F2C, 0x0399, 0x0000,\\n  0x1F95,  0x1F2D, 0x0399, 0x0000,\\n  0x1F96,  0x1F2E, 0x0399, 0x0000,\\n  0x1F97,  0x1F2F, 0x0399, 0x0000,\\n  0x1F98,  0x1F28, 0x0399, 0x0000,\\n  0x1F99,  0x1F29, 0x0399, 0x0000,\\n  0x1F9A,  0x1F2A, 0x0399, 0x0000,\\n  0x1F9B,  0x1F2B, 0x0399, 0x0000,\\n  0x1F9C,  0x1F2C, 0x0399, 0x0000,\\n  0x1F9D,  0x1F2D, 0x0399, 0x0000,\\n  0x1F9E,  0x1F2E, 0x0399, 0x0000,\\n  0x1F9F,  0x1F2F, 0x0399, 0x0000,\\n  0x1FA0,  0x1F68, 0x0399, 0x0000,\\n  0x1FA1,  0x1F69, 0x0399, 0x0000,\\n  0x1FA2,  0x1F6A, 0x0399, 0x0000,\\n  0x1FA3,  0x1F6B, 0x0399, 0x0000,\\n  0x1FA4,  0x1F6C, 0x0399, 0x0000,\\n  0x1FA5,  0x1F6D, 0x0399, 0x0000,\\n  0x1FA6,  0x1F6E, 0x0399, 0x0000,\\n  0x1FA7,  0x1F6F, 0x0399, 0x0000,\\n  0x1FA8,  0x1F68, 0x0399, 0x0000,\\n  0x1FA9,  0x1F69, 0x0399, 0x0000,\\n  0x1FAA,  0x1F6A, 0x0399, 0x0000,\\n  0x1FAB,  0x1F6B, 0x0399, 0x0000,\\n  0x1FAC,  0x1F6C, 0x0399, 0x0000,\\n  0x1FAD,  0x1F6D, 0x0399, 0x0000,\\n  0x1FAE,  0x1F6E, 0x0399, 0x0000,\\n  0x1FAF,  0x1F6F, 0x0399, 0x0000,\\n  0x1FB2,  0x1FBA, 0x0399, 0x0000,\\n  0x1FB3,  0x0391, 0x0399, 0x0000,\\n  0x1FB4,  0x0386, 0x0399, 0x0000,\\n  0x1FB6,  0x0391, 0x0342, 0x0000,\\n  0x1FB7,  0x0391, 0x0342, 0x0399,\\n  0x1FBC,  0x0391, 0x0399, 0x0000,\\n  0x1FC2,  0x1FCA, 0x0399, 0x0000,\\n  0x1FC3,  0x0397, 0x0399, 0x0000,\\n  0x1FC4,  0x0389, 0x0399, 0x0000,\\n  0x1FC6,  0x0397, 0x0342, 0x0000,\\n  0x1FC7,  0x0397, 0x0342, 0x0399,\\n  0x1FCC,  0x0397, 0x0399, 0x0000,\\n  0x1FD2,  0x0399, 0x0308, 0x0300,\\n  0x1FD3,  0x0399, 0x0308, 0x0301,\\n  0x1FD6,  0x0399, 0x0342, 0x0000,\\n  0x1FD7,  0x0399, 0x0308, 0x0342,\\n  0x1FE2,  0x03A5, 0x0308, 0x0300,\\n  0x1FE3,  0x03A5, 0x0308, 0x0301,\\n  0x1FE4,  0x03A1, 0x0313, 0x0000,\\n  0x1FE6,  0x03A5, 0x0342, 0x0000,\\n  0x1FE7,  0x03A5, 0x0308, 0x0342,\\n  0x1FF2,  0x1FFA, 0x0399, 0x0000,\\n  0x1FF3,  0x03A9, 0x0399, 0x0000,\\n  0x1FF4,  0x038F, 0x0399, 0x0000,\\n  0x1FF6,  0x03A9, 0x0342, 0x0000,\\n  0x1FF7,  0x03A9, 0x0342, 0x0399,\\n  0x1FFC,  0x03A9, 0x0399, 0x0000,\\n  0xFB00,  0x0046, 0x0046, 0x0000,\\n  0xFB01,  0x0046, 0x0049, 0x0000,\\n  0xFB02,  0x0046, 0x004C, 0x0000,\\n  0xFB03,  0x0046, 0x0046, 0x0049,\\n  0xFB04,  0x0046, 0x0046, 0x004C,\\n  0xFB05,  0x0053, 0x0054, 0x0000,\\n  0xFB06,  0x0053, 0x0054, 0x0000,\\n  0xFB13,  0x0544, 0x0546, 0x0000,\\n  0xFB14,  0x0544, 0x0535, 0x0000,\\n  0xFB15,  0x0544, 0x053B, 0x0000,\\n  0xFB16,  0x054E, 0x0546, 0x0000,\\n  0xFB17,  0x0544, 0x053D, 0x0000\\n];\\n\\n// @ts-ignore: decorator\\n@lazy @inline const MT = memory.data<i32>([\\n  2048, 342, 57\\n]);\\n\\n// Special binary search routine for Special Casing Tables\\n// @ts-ignore: decorator\\n@inline\\nexport function bsearch(key: u32, ptr: usize, max: i32): i32 {\\n  let min = 0;\\n  while (min <= max) {\\n    let mid = (min + max) >>> 3 << 2;\\n    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;\\n    if (cmp == 0) return mid; // found\\n    else if (cmp >>> 31) min = mid + 4; // < 0\\n    else max = mid - 4; // > 0\\n  }\\n  return -1; // not found\\n}\\n\\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c\\nexport function casemap(c: u32, dir: i32): i32 {\\n  // if (c >= 0x20000) return c;\\n  let c0 = c as i32;\\n  let b = c >> 8;\\n  c &= 255;\\n\\n  let x = c / 3;\\n  let y = c % 3;\\n\\n  /* lookup entry in two-level base-6 table */\\n  // v = tab[(tab[b] as i32) * 86 + x] as u32;\\n  let v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);\\n  // v = (v * mt[y] >> 11) % 6;\\n  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;\\n  /* use the bit vector out of the tables as an index into\\n   * a block-specific set of rules and decode the rule into\\n   * a type and a case-mapping delta. */\\n  // r = rules[(ruleBases[b] as u32) + v];\\n  let r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));\\n  let rt: u32 = r & 255;\\n  let rd: i32 = r >> 8;\\n  /* rules 0/1 are simple lower/upper case with a delta.\\n   * apply according to desired mapping direction. */\\n  if (rt < 2) return c0 + (rd & -(rt ^ dir));\\n  /* binary search. endpoints of the binary search for\\n   * this block are stored in the rule delta field. */\\n  let xn: u32 = rd & 0xff;\\n  let xb: u32 = rd >>> 8;\\n  while (xn) {\\n    let h = xn >> 1;\\n    // let t = exceptions[(xb + h) * 2 + 0] as u32;\\n    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);\\n    if (t == c) {\\n      // r = rules[exceptions[(xb + h) * 2 + 1]];\\n      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));\\n      rt = r & 255;\\n      rd = r >> 8;\\n      if (rt < 2) return c0 + (rd & -(rt ^ dir));\\n      /* Hard-coded for the four exceptional titlecase */\\n      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);\\n    } else if (t > c) {\\n      xn = h;\\n    } else {\\n      xb += h;\\n      xn -= h;\\n    }\\n  }\\n  return c0;\\n}\\n\",\n  \"util/error\": \"// Common error messages for use across the standard library. Keeping error messages compact\\n// and reusing them where possible ensures minimal static data in binaries.\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_INDEXOUTOFRANGE: string = \\\"Index out of range\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_VALUEOUTOFRANGE: string = \\\"Value out of range\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_INVALIDLENGTH: string = \\\"Invalid length\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_EMPTYARRAY: string = \\\"Array is empty\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_HOLEYARRAY: string = \\\"Element type must be nullable if array is holey\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_NOTIMPLEMENTED: string = \\\"Not implemented\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_KEYNOTFOUND: string = \\\"Key does not exist\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_ALLOCATION_TOO_LARGE: string = \\\"Allocation too large\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_ALREADY_PINNED: string = \\\"Object already pinned\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_NOT_PINNED: string = \\\"Object is not pinned\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_URI_MALFORMED: string = \\\"URI malformed\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_INVALIDDATE: string = \\\"Invalid Date\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline\\nexport const E_UNPAIRED_SURROGATE: string = \\\"Unpaired surrogate\\\";\\n\",\n  \"util/hash\": \"export function HASH<T>(key: T): u32 {\\n  if (isString<T>()) {\\n    return hashStr(changetype<string>(key));\\n  } else if (isReference<T>()) {\\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\\n  } else if (isFloat<T>()) {\\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\\n  } else {\\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\\n    if (sizeof<T>() == 8) return hash64(u64(key));\\n  }\\n  return unreachable();\\n}\\n\\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\\n\\n// primes\\n// @ts-ignore: decorator\\n@inline const XXH32_P1: u32 = 2654435761;\\n// @ts-ignore: decorator\\n@inline const XXH32_P2: u32 = 2246822519;\\n// @ts-ignore: decorator\\n@inline const XXH32_P3: u32 = 3266489917;\\n// @ts-ignore: decorator\\n@inline const XXH32_P4: u32 = 668265263;\\n// @ts-ignore: decorator\\n@inline const XXH32_P5: u32 = 374761393;\\n// @ts-ignore: decorator\\n@inline const XXH32_SEED: u32 = 0;\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction hash32(key: u32, len: u32 = 4): u32 {\\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\\n  h += key * XXH32_P3;\\n  h  = rotl(h, 17) * XXH32_P4;\\n  h ^= h >> 15;\\n  h *= XXH32_P2;\\n  h ^= h >> 13;\\n  h *= XXH32_P3;\\n  h ^= h >> 16;\\n  return h;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction hash64(key: u64): u32 {\\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\\n  h += <u32>key * XXH32_P3;\\n  h  = rotl(h, 17) * XXH32_P4;\\n  h += <u32>(key >> 32) * XXH32_P3;\\n  h  = rotl(h, 17) * XXH32_P4;\\n  h ^= h >> 15;\\n  h *= XXH32_P2;\\n  h ^= h >> 13;\\n  h *= XXH32_P3;\\n  h ^= h >> 16;\\n  return h;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction mix(h: u32, key: u32): u32 {\\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction hashStr(key: string): u32 {\\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\\n\\n  let h: u32 = key.length << 1;\\n  let len: usize = h;\\n  let pos = changetype<usize>(key);\\n\\n  if (len >= 16) {\\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\\n    let s2 = XXH32_SEED + XXH32_P2;\\n    let s3 = XXH32_SEED;\\n    let s4 = XXH32_SEED - XXH32_P1;\\n\\n    let end = len + pos - 16;\\n    while (pos <= end) {\\n      s1 = mix(s1, load<u32>(pos    ));\\n      s2 = mix(s2, load<u32>(pos,  4));\\n      s3 = mix(s3, load<u32>(pos,  8));\\n      s4 = mix(s4, load<u32>(pos, 12));\\n      pos += 16;\\n    }\\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\\n  } else {\\n    h += XXH32_SEED + XXH32_P5;\\n  }\\n\\n  let end = changetype<usize>(key) + len - 4;\\n  while (pos <= end) {\\n    h += load<u32>(pos) * XXH32_P3;\\n    h = rotl(h, 17) * XXH32_P4;\\n    pos += 4;\\n  }\\n\\n  end = changetype<usize>(key) + len;\\n  while (pos < end) {\\n    h += <u32>load<u8>(pos) * XXH32_P5;\\n    h = rotl(h, 11) * XXH32_P1;\\n    pos++;\\n  }\\n\\n  h ^= h >> 15;\\n  h *= XXH32_P2;\\n  h ^= h >> 13;\\n  h *= XXH32_P3;\\n  h ^= h >> 16;\\n  return h;\\n}\\n\",\n  \"util/math\": \"//\\n// Lookup data for exp2f\\n//\\n\\n// @ts-ignore: decorator\\n@inline const EXP2F_TABLE_BITS = 5;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\\n  // used for computing 2^(k/N) for an int |k| < 150 N as\\n  // double(tab[k%N] + (k << 52-BITS))\\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\\n]);\\n\\n// ULP error: 0.502 (nearest rounding.)\\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\\n// @ts-ignore: decorator\\n@inline\\nexport function exp2f_lut(x: f32): f32 {\\n  const\\n    N      = 1 << EXP2F_TABLE_BITS,\\n    N_MASK = N - 1,\\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\\n    Ox127f = reinterpret<f32>(0x7F000000);\\n\\n  const\\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\\n\\n  let xd = <f64>x;\\n  let ix = reinterpret<u32>(x);\\n  let ux = ix >> 20 & 0x7FF;\\n  if (ux >= 0x430) {\\n    // |x| >= 128 or x is nan.\\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\\n  }\\n\\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\\n  let kd = xd + shift;\\n  let ki = reinterpret<u64>(kd);\\n  let r  = xd - (kd - shift);\\n  let t: u64, y: f64, s: f64;\\n\\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\\n  t += ki << (52 - EXP2F_TABLE_BITS);\\n  s  = reinterpret<f64>(t);\\n  y  = C2 * r + 1;\\n  y += (C0 * r + C1) * (r  * r);\\n  y *= s;\\n\\n  return <f32>y;\\n}\\n\\n// ULP error: 0.502 (nearest rounding.)\\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\\n// @ts-ignore: decorator\\n@inline\\nexport function expf_lut(x: f32): f32 {\\n  const\\n    N        = 1 << EXP2F_TABLE_BITS,\\n    N_MASK   = N - 1,\\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\\n    Ox1p127f = reinterpret<f32>(0x7F000000);\\n\\n  const\\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\\n\\n  let xd = <f64>x;\\n  let ix = reinterpret<u32>(x);\\n  let ux = ix >> 20 & 0x7FF;\\n  if (ux >= 0x42B) {\\n    // |x| >= 88 or x is nan.\\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\\n  }\\n\\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\\n  let z = InvLn2N * xd;\\n\\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\\n  // can be bigger which gives larger approximation error.\\n  let kd = <f64>(z + shift);\\n  let ki = reinterpret<u64>(kd);\\n  let r  = z - (kd - shift);\\n  let s: f64, y: f64, t: u64;\\n\\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\\n  t += ki << (52 - EXP2F_TABLE_BITS);\\n  s  = reinterpret<f64>(t);\\n  z  = C0 * r + C1;\\n  y  = C2 * r + 1;\\n  y += z * (r * r);\\n  y *= s;\\n\\n  return <f32>y;\\n}\\n\\n//\\n// Lookup data for log2f\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOG2F_TABLE_BITS = 4;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\\n]);\\n\\n// ULP error: 0.752 (nearest rounding.)\\n// Relative error: 1.9 * 2^-26 (before rounding.)\\n// @ts-ignore: decorator\\n@inline\\nexport function log2f_lut(x: f32): f32 {\\n  const\\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\\n\\n  let ux = reinterpret<u32>(x);\\n  // Fix sign of zero with downward rounding when x==1.\\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\\n    // x < 0x1p-126 or inf or nan.\\n    if (ux * 2 == 0) return -Infinity;\\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\\n    // x is subnormal, normalize it.\\n    ux = reinterpret<u32>(x * Ox1p23f);\\n    ux -= 23 << 23;\\n  }\\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ux - 0x3F330000;\\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\\n  let top  = tmp & 0xFF800000;\\n  let iz   = ux - top;\\n  let k    = <i32>tmp >> 23;\\n\\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\\n  let z    = <f64>reinterpret<f32>(iz);\\n\\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\\n  let r  = z * invc - 1;\\n  let y0 = logc + <f64>k;\\n\\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\\n  let y  = A1 * r + A2;\\n  let p  = A3 * r + y0;\\n  let r2 = r * r;\\n  y += A0 * r2;\\n  y  = y * r2 + p;\\n\\n  return <f32>y;\\n}\\n\\n//\\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOGF_TABLE_BITS = 4;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\\n]);\\n\\n// ULP error: 0.818 (nearest rounding.)\\n// Relative error: 1.957 * 2^-26 (before rounding.)\\n// @ts-ignore: decorator\\n@inline\\nexport function logf_lut(x: f32): f32 {\\n  const\\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\\n\\n  const\\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\\n\\n  let ux = reinterpret<u32>(x);\\n  // Fix sign of zero with downward rounding when x==1.\\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\\n    // x < 0x1p-126 or inf or nan.\\n    if ((ux << 1) == 0) return -Infinity;\\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\\n    // x is subnormal, normalize it.\\n    ux = reinterpret<u32>(x * Ox1p23f);\\n    ux -= 23 << 23;\\n  }\\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp = ux - 0x3F330000;\\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\\n  let k   = <i32>tmp >> 23;\\n  let iz  = ux - (tmp & 0x1FF << 23);\\n\\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\\n\\n  let z = <f64>reinterpret<f32>(iz);\\n\\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\\n  let r = z * invc - 1;\\n  let y0 = logc + <f64>k * Ln2;\\n\\n  // Pipelined polynomial evaluation to approximate log1p(r).\\n  let r2 = r * r;\\n  let y  = A1 * r + A2;\\n  y += A0 * r2;\\n  y = y * r2 + (y0 + r);\\n\\n  return <f32>y;\\n}\\n\\n//\\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction zeroinfnanf(ux: u32): bool {\\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\\n}\\n\\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\\n// the bit representation of a non-zero finite floating-point value.\\n// @ts-ignore: decorator\\n@inline\\nfunction checkintf(iy: u32): i32 {\\n  let e = iy >> 23 & 0xFF;\\n  if (e < 0x7F     ) return 0;\\n  if (e > 0x7F + 23) return 2;\\n  e = 1 << (0x7F + 23 - e);\\n  if (iy & (e - 1)) return 0;\\n  if (iy &  e     ) return 1;\\n  return 2;\\n}\\n\\n// Subnormal input is normalized so ix has negative biased exponent.\\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\\n// @ts-ignore: decorator\\n@inline\\nfunction log2f_inline(ux: u32): f64 {\\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\\n\\n  const\\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ux - 0x3F330000;\\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\\n  let top  = tmp & 0xFF800000;\\n  let uz   = ux - top;\\n  let k    = <i32>top >> 23;\\n\\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\\n  let z    = <f64>reinterpret<f32>(uz);\\n\\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\\n  let r  = z * invc - 1;\\n  let y0 = logc + <f64>k;\\n\\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\\n  let y = A0 * r + A1;\\n  let p = A2 * r + A3;\\n  let q = A4 * r + y0;\\n\\n  r *= r;\\n  q += p * r;\\n  y  = y * (r * r) + q;\\n\\n  return y;\\n}\\n\\n// The output of log2 and thus the input of exp2 is either scaled by N\\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\\n// in [-1021,1023], sign_bias sets the sign of the result.\\n// @ts-ignore: decorator\\n@inline\\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\\n  const\\n    N      = 1 << EXP2F_TABLE_BITS,\\n    N_MASK = N - 1,\\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\\n\\n  const\\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\\n\\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\\n  let kd = <f64>(xd + shift);\\n  let ki = reinterpret<u64>(kd);\\n  let r  = xd - (kd - shift);\\n  let t: u64, z: f64, y: f64, s: f64;\\n\\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\\n  s  = reinterpret<f64>(t);\\n  z  = C0 * r + C1;\\n  y  = C2 * r + 1;\\n  y += z * (r * r);\\n  y *= s;\\n  return <f32>y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction xflowf(sign: u32, y: f32): f32 {\\n  return select<f32>(-y, y, sign) * y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction oflowf(sign: u32): f32 {\\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction uflowf(sign: u32): f32 {\\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function powf_lut(x: f32, y: f32): f32 {\\n  const\\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\\n    LOWER_LIMIT = -150.0,\\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\\n\\n  let signBias: u32 = 0;\\n  let ix = reinterpret<u32>(x);\\n  let iy = reinterpret<u32>(y);\\n  let ny = 0;\\n\\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\\n    if (ny) {\\n      if ((iy << 1) == 0) return 1.0;\\n      if (ix == 0x3F800000) return NaN; // original: 1.0\\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\\n      return y * y;\\n    }\\n    if (zeroinfnanf(ix)) {\\n      let x2 = x * x;\\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\\n      return <i32>iy < 0 ? 1 / x2 : x2;\\n    }\\n    // x and y are non-zero finite.\\n    if (<i32>ix < 0) {\\n      // Finite x < 0.\\n      let yint = checkintf(iy);\\n      if (yint == 0) return (x - x) / (x - x);\\n      if (yint == 1) signBias = SIGN_BIAS;\\n      ix &= 0x7FFFFFFF;\\n    }\\n    if (ix < 0x00800000) {\\n      // Normalize subnormal x so exponent becomes negative.\\n      ix = reinterpret<u32>(x * Ox1p23f);\\n      ix &= 0x7FFFFFFF;\\n      ix -= 23 << 23;\\n    }\\n  }\\n  let logx = log2f_inline(ix);\\n  let ylogx = y * logx; // cannot overflow, y is single prec.\\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\\n    // |y * log(x)| >= 126\\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\\n  }\\n  return exp2f_inline(ylogx, signBias);\\n}\\n\\n//\\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const EXP_TABLE_BITS = 7;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\\n  0x0000000000000000, 0x3FF0000000000000,\\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\\n]);\\n\\n// Handle cases that may overflow or underflow when computing the result that\\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\\n// scale is in SBITS, however it has a computed exponent that may have\\n// overflown into the sign bit so that needs to be adjusted before using it as\\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\\n// adjustment of scale, positive k here means the result may overflow and\\n// negative k means the result may underflow.\\n// @ts-ignore: decorator\\n@inline\\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\\n  const\\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\\n\\n  let scale: f64;\\n  if (!(ki & 0x80000000)) {\\n    // k > 0, the exponent of scale might have overflowed by <= 460.\\n    sbits -= u64(1009) << 52;\\n    scale = reinterpret<f64>(sbits);\\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\\n  }\\n  // k < 0, need special care in the subnormal range.\\n  sbits += u64(1022) << 52;\\n  // Note: sbits is signed scale.\\n  scale = reinterpret<f64>(sbits);\\n  let y = scale + scale * tmp;\\n  if (abs(y) < 1.0) {\\n    // Round y to the right precision before scaling it into the subnormal\\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\\n    // E is the worst-case ulp error outside the subnormal range.  So this\\n    // is only useful if the goal is better than 1 ulp worst-case error.\\n    let one = copysign(1.0, y);\\n    let lo = scale - y + scale * tmp;\\n    let hi = one + y;\\n    lo = one - hi + y + lo;\\n    y  = (hi + lo) - one;\\n    // Fix the sign of 0.\\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\\n  }\\n  return y * Ox1p_1022;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function exp_lut(x: f64): f64 {\\n  const\\n    N      = 1 << EXP_TABLE_BITS,\\n    N_MASK = N - 1;\\n\\n  const\\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\\n\\n  const\\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\\n\\n  let ux = reinterpret<u64>(x);\\n  let abstop = u32(ux >> 52) & 0x7FF;\\n  if (abstop - 0x3C9 >= 0x03F) {\\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\\n    if (abstop >= 0x409) {\\n      if (ux == 0xFFF0000000000000) return 0;\\n      if (abstop >= 0x7FF) {\\n        return 1.0 + x;\\n      } else {\\n        return select<f64>(0, Infinity, <i64>ux < 0);\\n      }\\n    }\\n    // Large x is special cased below.\\n    abstop = 0;\\n  }\\n\\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\\n  let z = InvLn2N * x;\\n  // #if TOINT_INTRINSICS\\n  // \\tkd = roundtoint(z);\\n  // \\tki = converttoint(z);\\n  // #elif EXP_USE_TOINT_NARROW\\n  // \\t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\\n  // let kd = z + shift;\\n  // let ki = reinterpret<u64>(kd) >> 16;\\n  // let kd = <f64><i32>ki;\\n  // #else\\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\\n  let kd = z + shift;\\n  let ki = reinterpret<u64>(kd);\\n  kd -= shift;\\n  // #endif\\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\\n  // 2^(k/N) ~= scale * (1 + tail).\\n  let idx = usize((ki & N_MASK) << 1);\\n  let top = ki << (52 - EXP_TABLE_BITS);\\n\\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\\n  // This is only a valid scale when -1023*N < k < 1024*N\\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\\n  // Evaluation is optimized assuming superscalar pipelined execution.\\n  let r2 = r * r;\\n  // Without fma the worst case error is 0.25/N ulp larger.\\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\\n  let scale = reinterpret<f64>(sbits);\\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\\n  // is no spurious underflow here even without fma.\\n  return scale + scale * tmp;\\n}\\n\\n//\\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\\n//\\n\\n// Handle cases that may overflow or underflow when computing the result that\\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\\n// scale is in SBITS, however it has a computed exponent that may have\\n// overflown into the sign bit so that needs to be adjusted before using it as\\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\\n// adjustment of scale, positive k here means the result may overflow and\\n// negative k means the result may underflow.\\n// @ts-ignore: decorator\\n@inline\\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\\n  let scale: f64;\\n  if ((ki & 0x80000000) == 0) {\\n    // k > 0, the exponent of scale might have overflowed by 1\\n    sbits -= u64(1) << 52;\\n    scale = reinterpret<f64>(sbits);\\n    return 2 * (scale * tmp + scale);\\n  }\\n  // k < 0, need special care in the subnormal range\\n  sbits += u64(1022) << 52;\\n  scale = reinterpret<f64>(sbits);\\n  let y = scale * tmp + scale;\\n  if (y < 1.0) {\\n    // Round y to the right precision before scaling it into the subnormal\\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\\n    // E is the worst-case ulp error outside the subnormal range. So this\\n    // is only useful if the goal is better than 1 ulp worst-case error.\\n    let hi: f64, lo: f64;\\n    lo = scale - y + scale * tmp;\\n    hi = 1.0 + y;\\n    lo = 1.0 - hi + y + lo;\\n    y = (hi + lo) - 1.0;\\n  }\\n  return y * Ox1p_1022;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function exp2_lut(x: f64): f64 {\\n  const\\n    N      = 1 << EXP_TABLE_BITS,\\n    N_MASK = N - 1,\\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\\n\\n  const\\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\\n\\n  let ux = reinterpret<u64>(x);\\n  let abstop = u32(ux >> 52) & 0x7ff;\\n  if (abstop - 0x3C9 >= 0x03F) {\\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\\n    if (abstop >= 0x409) {\\n      if (ux == 0xFFF0000000000000) return 0;\\n      if (abstop >= 0x7FF) return 1.0 + x;\\n      if (<i64>ux >= 0) return Infinity;\\n      else if (ux >= 0xC090CC0000000000) return 0;\\n    }\\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\\n  }\\n\\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\\n  let kd = x + shift;\\n  let ki = reinterpret<u64>(kd);\\n  kd -= shift; // k/N for int k\\n  let r = x - kd;\\n  // 2^(k/N) ~= scale * (1 + tail)\\n  let idx = usize((ki & N_MASK) << 1);\\n  let top = ki << (52 - EXP_TABLE_BITS);\\n\\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\\n  // This is only a valid scale when -1023*N < k < 1024*N\\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\\n  // Evaluation is optimized assuming superscalar pipelined execution\\n  let r2 = r * r;\\n  // Without fma the worst case error is 0.5/N ulp larger.\\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\\n  let scale = reinterpret<f64>(sbits);\\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\\n  // is no spurious underflow here even without fma.\\n  return scale * tmp + scale;\\n}\\n\\n//\\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOG2_TABLE_BITS = 6;\\n\\n/* Algorithm:\\n\\n  x = 2^k z\\n  log2(x) = k + log2(c) + log2(z/c)\\n  log2(z/c) = poly(z/c - 1)\\n\\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\\ninto the ith one, then table entries are computed as\\n\\n  tab[i].invc = 1/c\\n  tab[i].logc = (double)log2(c)\\n  tab2[i].chi = (double)c\\n  tab2[i].clo = (double)(c - (double)c)\\n\\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\\nfloating point invc candidates around 1/center and selecting one for which\\n\\n  1) the rounding error in 0x1.8p10 + logc is 0,\\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\\n\\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\\n  //            invc                  ,                logc\\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\\n  //              chi                 ,                 clo\\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function log2_lut(x: f64): f64 {\\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\\n\\n  const\\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\\n\\n  const\\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\\n\\n  const\\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\\n\\n  let ix = reinterpret<u64>(x);\\n  if (ix - LO < HI - LO) {\\n    let r = x - 1.0;\\n    // #if __FP_FAST_FMA\\n    //     hi = r * InvLn2hi;\\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\\n    // #else\\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\\n    let rlo = r - rhi;\\n    let hi  = rhi * InvLn2hi;\\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\\n    // #endif\\n    let r2 = r * r; // rounding error: 0x1p-62\\n    let r4 = r2 * r2;\\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\\n    let p = r2 * (B0 + r * B1);\\n    let y = hi + p;\\n    lo += hi - y + p;\\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\\n    return y + lo;\\n  }\\n  let top = u32(ix >> 48);\\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\\n    // x < 0x1p-1022 or inf or nan.\\n    if ((ix << 1) == 0) return -1.0 / (x * x);\\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\\n    // x is subnormal, normalize it.\\n    ix = reinterpret<u64>(x * Ox1p52);\\n    ix -= u64(52) << 52;\\n  }\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ix - 0x3FE6000000000000;\\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\\n  let k    = <i64>tmp >> 52;\\n  let iz   = ix - (tmp & 0xFFF0000000000000);\\n\\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\\n  let z    = reinterpret<f64>(iz);\\n  let kd   = <f64>k;\\n\\n  // log2(x) = log2(z/c) + log2(c) + k.\\n  // r ~= z/c - 1, |r| < 1/(2*N).\\n  // #if __FP_FAST_FMA\\n  // \\t// rounding error: 0x1p-55/N.\\n  // \\tr = __builtin_fma(z, invc, -1.0);\\n  // \\tt1 = r * InvLn2hi;\\n  // \\tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\\n  // #else\\n  // rounding error: 0x1p-55/N + 0x1p-65.\\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\\n\\n  let r   = (z - chi - clo) * invc;\\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\\n  let rlo = r - rhi;\\n  let t1  = rhi * InvLn2hi;\\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\\n  // #endif\\n\\n  // hi + lo = r/ln2 + log2(c) + k\\n  let t3 = kd + logc;\\n  let hi = t3 + t1;\\n  let lo = t3 - hi + t1 + t2;\\n\\n  // log2(r+1) = r/ln2 + r^2*poly(r)\\n  // Evaluation is optimized assuming superscalar pipelined execution\\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\\n  return lo + r2 * p + hi;\\n}\\n\\n//\\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const LOG_TABLE_BITS = 7;\\n\\n/* Algorithm:\\n\\n  x = 2^k z\\n  log(x) = k ln2 + log(c) + log(z/c)\\n  log(z/c) = poly(z/c - 1)\\n\\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\\ninto the ith one, then table entries are computed as\\n\\n  tab[i].invc = 1/c\\n  tab[i].logc = (double)log(c)\\n  tab2[i].chi = (double)c\\n  tab2[i].clo = (double)(c - (double)c)\\n\\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\\nfloating point invc candidates around 1/center and selecting one for which\\n\\n  1) the rounding error in 0x1.8p9 + logc is 0,\\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\\n\\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\\n  //              invc                ,                 logc\\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\\n  //               chi                ,                  clo\\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function log_lut(x: f64): f64 {\\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\\n\\n  const\\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\\n\\n  const\\n    LO: u64 = 0x3FEE000000000000,\\n    HI: u64 = 0x3FF1090000000000;\\n\\n  const\\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\\n\\n  let ix = reinterpret<u64>(x);\\n  if (ix - LO < HI - LO) {\\n    let r  = x - 1.0;\\n    let r2 = r * r;\\n    let r3 = r2 * r;\\n    let y =\\n      r3 * (B1 + r * B2 + r2 * B3 +\\n      r3 * (B4 + r * B5 + r2 * B6 +\\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\\n    // Worst-case error is around 0.507 ULP\\n    let w   = r * Ox1p27;\\n    let rhi = r + w - w;\\n    let rlo = r - rhi;\\n    w = rhi * rhi * B0; // B[0] == -0.5\\n    let hi = r + w;\\n    let lo = r - hi + w;\\n    lo += B0 * rlo * (rhi + r);\\n    return y + lo + hi;\\n  }\\n  let top = u32(ix >> 48);\\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\\n    // x < 0x1p-1022 or inf or nan\\n    if ((ix << 1) == 0) return -1.0 / (x * x);\\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\\n    // x is subnormal, normalize it\\n    ix = reinterpret<u64>(x * Ox1p52);\\n    ix -= u64(52) << 52;\\n  }\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp  = ix - 0x3FE6000000000000;\\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\\n  let k    = <i64>tmp >> 52;\\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\\n\\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\\n  let z    = reinterpret<f64>(iz);\\n\\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\\n  // r ~= z/c - 1, |r| < 1/(2*N)\\n  // #if __FP_FAST_FMA\\n  // \\t// rounding error: 0x1p-55/N\\n  // \\tr = __builtin_fma(z, invc, -1.0);\\n  // #else\\n  // rounding error: 0x1p-55/N + 0x1p-66\\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\\n  let r = (z - chi - clo) * invc;\\n  // #endif\\n  let kd = <f64>k;\\n\\n  // hi + lo = r + log(c) + k*Ln2\\n  let w  = kd * Ln2hi + logc;\\n  let hi = w + r;\\n  let lo = w - hi + r + kd * Ln2lo;\\n\\n  // log(x) = lo + (log1p(r) - r) + hi\\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\\n  // Worst case error if |y| > 0x1p-5:\\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\\n  // Worst case error if |y| > 0x1p-4:\\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\\n}\\n\\n//\\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\\n//\\n\\n// @ts-ignore: decorator\\n@inline const POW_LOG_TABLE_BITS = 7;\\n\\n/* Algorithm:\\n\\n  x = 2^k z\\n  log(x) = k ln2 + log(c) + log(z/c)\\n  log(z/c) = poly(z/c - 1)\\n\\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\\nand z falls into the ith one, then table entries are computed as\\n\\n  tab[i].invc = 1/c\\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\\n  tab[i].logctail = (double)(log(c) - logc)\\n\\nwhere c is chosen near the center of the subinterval such that 1/c has only a\\nfew precision bits so z/c - 1 is exactly representible as double:\\n\\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\\n\\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\\nerror and the interval for z is selected such that near x == 1, where log(x)\\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\\n\\n// @ts-ignore: decorator\\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\\n  //             invc                 ,pad,               logc                 ,               logctail\\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\\n]);\\n\\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\\n// the bit representation of a non-zero finite floating-point value.\\n// @ts-ignore: decorator\\n@inline\\nfunction checkint(iy: u64): i32 {\\n  let e = iy >> 52 & 0x7FF;\\n  if (e < 0x3FF     ) return 0;\\n  if (e > 0x3FF + 52) return 2;\\n  e = u64(1) << (0x3FF + 52 - e);\\n  if (iy & (e - 1)) return 0;\\n  if (iy &  e     ) return 1;\\n  return 2;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction xflow(sign: u32, y: f64): f64 {\\n  return select(-y, y, sign) * y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction uflow(sign: u32): f64 {\\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction oflow(sign: u32): f64 {\\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\\n}\\n\\n// Returns 1 if input is the bit representation of 0, infinity or nan.\\n// @ts-ignore: decorator\\n@inline\\nfunction zeroinfnan(u: u64): bool {\\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let log_tail: f64 = 0;\\n\\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\\n// additional 15 bits precision. IX is the bit representation of x, but\\n// normalized in the subnormal range using the sign bit for the exponent.\\n// @ts-ignore: decorator\\n@inline\\nfunction log_inline(ix: u64): f64 {\\n  const N = 1 << POW_LOG_TABLE_BITS;\\n  const N_MASK = N - 1;\\n\\n  const\\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\\n\\n  const\\n    A0 = reinterpret<f64>(0xBFE0000000000000),\\n    A1 = reinterpret<f64>(0xBFE5555555555560),\\n    A2 = reinterpret<f64>(0x3FE0000000000006),\\n    A3 = reinterpret<f64>(0x3FE999999959554E),\\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\\n\\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\\n  // The range is split into N subintervals.\\n  // The ith subinterval contains z and c is near its center.\\n  let tmp = ix - 0x3fE6955500000000;\\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\\n  let k   = <i64>tmp >> 52;\\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\\n  let z   = reinterpret<f64>(iz);\\n  let kd  = <f64>k;\\n\\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\\n\\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\\n  let zlo = z - zhi;\\n  let rhi = zhi * invc - 1.0;\\n  let rlo = zlo * invc;\\n  let r   = rhi + rlo;\\n\\n  // k * Ln2 + log(c) + r.\\n  let t1  = kd * Ln2hi + logc;\\n  let t2  = t1 + r;\\n  let lo1 = kd * Ln2lo + logctail;\\n  let lo2 = t1 - t2 + r;\\n\\n  // Evaluation is optimized assuming superscalar pipelined execution.\\n  let ar  = A0 * r; // A[0] = -0.5\\n  let ar2 = r * ar;\\n  let ar3 = r * ar2;\\n  // k * Ln2 + log(c) + r + A[0] * r * r.\\n  let arhi  = A0  * rhi;\\n  let arhi2 = rhi * arhi;\\n  let hi    = t2  + arhi2;\\n  let lo3   = rlo * (ar + arhi);\\n  let lo4   = t2 - hi + arhi2;\\n\\n  // p = log1p(r) - r - A[0] * r * r.\\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\\n  let y  = hi + lo;\\n  log_tail = hi - y + lo;\\n\\n  return y;\\n}\\n\\n// @ts-ignore: decorator\\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\\n\\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\\n// @ts-ignore: decorator\\n@inline\\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\\n  const N      = 1 << EXP_TABLE_BITS;\\n  const N_MASK = N - 1;\\n\\n  const\\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\\n\\n  const\\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\\n\\n  let abstop: u32;\\n  let ki: u64, top: u64, sbits: u64;\\n  let idx: usize;\\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\\n\\n  let ux = reinterpret<u64>(x);\\n  abstop = u32(ux >> 52) & 0x7FF;\\n  if (abstop - 0x3C9 >= 0x03F) {\\n    if (abstop - 0x3C9 >= 0x80000000) {\\n      // Avoid spurious underflow for tiny x.\\n      // Note: 0 is common input.\\n      return select(-1.0, 1.0, sign_bias);\\n    }\\n    if (abstop >= 0x409) { // top12(1024.0)\\n      // Note: inf and nan are already handled.\\n      return <i64>ux < 0\\n        ? uflow(sign_bias)\\n        : oflow(sign_bias);\\n    }\\n    // Large x is special cased below.\\n    abstop = 0;\\n  }\\n\\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\\n  z = InvLn2N * x;\\n\\n  // #if TOINT_INTRINSICS\\n  //   kd = roundtoint(z);\\n  //   ki = converttoint(z);\\n  // #elif EXP_USE_TOINT_NARROW\\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\\n  //   kd = eval_as_double(z + shift);\\n  //   ki = asuint64(kd) >> 16;\\n  //   kd = (double_t)(int32_t)ki;\\n  // #else\\n  // z - kd is in [-1, 1] in non-nearest rounding modes\\n  kd  = z + shift;\\n  ki  = reinterpret<u64>(kd);\\n  kd -= shift;\\n  // #endif\\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\\n  r += xtail;\\n  // 2^(k/N) ~= scale * (1 + tail)\\n  idx = usize((ki & N_MASK) << 1);\\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\\n\\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\\n  // This is only a valid scale when -1023*N < k < 1024*N\\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\\n  // Evaluation is optimized assuming superscalar pipelined execution.\\n  r2 = r * r;\\n  // Without fma the worst case error is 0.25/N ulp larger.\\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\\n  scale = reinterpret<f64>(sbits);\\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\\n  // is no spurious underflow here even without fma.\\n  return scale + scale * tmp;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function pow_lut(x: f64, y: f64): f64 {\\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\\n\\n  let sign_bias: u32 = 0;\\n  let ix = reinterpret<u64>(x);\\n  let iy = reinterpret<u64>(y);\\n  let topx = ix >> 52;\\n  let topy = iy >> 52;\\n\\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\\n    // Special cases: (x < 0x1p-126 or inf or nan) or\\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\\n    if (zeroinfnan(iy)) {\\n      if ((iy << 1) == 0) return 1.0;\\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\\n      return y * y;\\n    }\\n    if (zeroinfnan(ix)) {\\n      let x2 = x * x;\\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\\n      return <i64>iy < 0 ? 1 / x2 : x2;\\n    }\\n    // Here x and y are non-zero finite\\n    if (<i64>ix < 0) {\\n      // Finite x < 0\\n      let yint = checkint(iy);\\n      if (yint == 0) return (x - x) / (x - x);\\n      if (yint == 1) sign_bias = SIGN_BIAS;\\n      ix   &= 0x7FFFFFFFFFFFFFFF;\\n      topx &= 0x7FF;\\n    }\\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\\n      // Note: sign_bias == 0 here because y is not odd.\\n      if (ix == 0x3FF0000000000000) return 1;\\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\\n    }\\n    if (topx == 0) {\\n      // Normalize subnormal x so exponent becomes negative.\\n      ix = reinterpret<u64>(x * Ox1p52);\\n      ix &= 0x7FFFFFFFFFFFFFFF;\\n      ix -= u64(52) << 52;\\n    }\\n  }\\n\\n  let hi = log_inline(ix);\\n  let lo = log_tail;\\n  let ehi: f64, elo: f64;\\n  // #if __FP_FAST_FMA\\n  //   ehi = y * hi;\\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\\n  // #else\\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\\n  let ylo = y - yhi;\\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\\n  let llo = hi - lhi + lo;\\n  ehi = yhi * lhi;\\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\\n  // #endif\\n  return exp_inline(ehi, elo, sign_bias);\\n}\\n\",\n  \"util/memory\": \"export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\\n  let w: u32, x: u32;\\n\\n  // copy 1 byte each until src is aligned to 4 bytes\\n  while (n && (src & 3)) {\\n    store<u8>(dest++, load<u8>(src++));\\n    n--;\\n  }\\n\\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\\n  if ((dest & 3) == 0) {\\n    while (n >= 16) {\\n      store<u32>(dest     , load<u32>(src     ));\\n      store<u32>(dest +  4, load<u32>(src +  4));\\n      store<u32>(dest +  8, load<u32>(src +  8));\\n      store<u32>(dest + 12, load<u32>(src + 12));\\n      src += 16; dest += 16; n -= 16;\\n    }\\n    if (n & 8) {\\n      store<u32>(dest    , load<u32>(src    ));\\n      store<u32>(dest + 4, load<u32>(src + 4));\\n      dest += 8; src += 8;\\n    }\\n    if (n & 4) {\\n      store<u32>(dest, load<u32>(src));\\n      dest += 4; src += 4;\\n    }\\n    if (n & 2) { // drop to 2 bytes each\\n      store<u16>(dest, load<u16>(src));\\n      dest += 2; src += 2;\\n    }\\n    if (n & 1) { // drop to 1 byte\\n      store<u8>(dest++, load<u8>(src++));\\n    }\\n    return;\\n  }\\n\\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\\n  if (n >= 32) {\\n    switch (<u32>dest & 3) {\\n      // known to be != 0\\n      case 1: {\\n        w = load<u32>(src);\\n        store<u8>(dest++, load<u8>(src++));\\n        store<u8>(dest++, load<u8>(src++));\\n        store<u8>(dest++, load<u8>(src++));\\n        n -= 3;\\n        while (n >= 17) {\\n          x = load<u32>(src + 1);\\n          store<u32>(dest, w >> 24 | x << 8);\\n          w = load<u32>(src + 5);\\n          store<u32>(dest + 4, x >> 24 | w << 8);\\n          x = load<u32>(src + 9);\\n          store<u32>(dest + 8, w >> 24 | x << 8);\\n          w = load<u32>(src + 13);\\n          store<u32>(dest + 12, x >> 24 | w << 8);\\n          src += 16; dest += 16; n -= 16;\\n        }\\n        break;\\n      }\\n      case 2: {\\n        w = load<u32>(src);\\n        store<u8>(dest++, load<u8>(src++));\\n        store<u8>(dest++, load<u8>(src++));\\n        n -= 2;\\n        while (n >= 18) {\\n          x = load<u32>(src + 2);\\n          store<u32>(dest, w >> 16 | x << 16);\\n          w = load<u32>(src + 6);\\n          store<u32>(dest + 4, x >> 16 | w << 16);\\n          x = load<u32>(src + 10);\\n          store<u32>(dest + 8, w >> 16 | x << 16);\\n          w = load<u32>(src + 14);\\n          store<u32>(dest + 12, x >> 16 | w << 16);\\n          src += 16; dest += 16; n -= 16;\\n        }\\n        break;\\n      }\\n      case 3: {\\n        w = load<u32>(src);\\n        store<u8>(dest++, load<u8>(src++));\\n        n -= 1;\\n        while (n >= 19) {\\n          x = load<u32>(src + 3);\\n          store<u32>(dest, w >> 8 | x << 24);\\n          w = load<u32>(src + 7);\\n          store<u32>(dest + 4, x >> 8 | w << 24);\\n          x = load<u32>(src + 11);\\n          store<u32>(dest + 8, w >> 8 | x << 24);\\n          w = load<u32>(src + 15);\\n          store<u32>(dest + 12, x >> 8 | w << 24);\\n          src += 16; dest += 16; n -= 16;\\n        }\\n        break;\\n      }\\n    }\\n  }\\n\\n  // copy remaining bytes one by one\\n  if (n & 16) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 8) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 4) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 2) {\\n    store<u8>(dest++, load<u8>(src++));\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n  if (n & 1) {\\n    store<u8>(dest++, load<u8>(src++));\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\\n  if (dest == src) return;\\n  if (ASC_SHRINK_LEVEL < 1) {\\n    if (src - dest - n <= -(n << 1)) {\\n      memcpy(dest, src, n);\\n      return;\\n    }\\n  }\\n  if (dest < src) {\\n    if (ASC_SHRINK_LEVEL < 2) {\\n      if ((src & 7) == (dest & 7)) {\\n        while (dest & 7) {\\n          if (!n) return;\\n          --n;\\n          store<u8>(dest++, load<u8>(src++));\\n        }\\n        while (n >= 8) {\\n          store<u64>(dest, load<u64>(src));\\n          n    -= 8;\\n          dest += 8;\\n          src  += 8;\\n        }\\n      }\\n    }\\n    while (n) {\\n      store<u8>(dest++, load<u8>(src++));\\n      --n;\\n    }\\n  } else {\\n    if (ASC_SHRINK_LEVEL < 2) {\\n      if ((src & 7) == (dest & 7)) {\\n        while ((dest + n) & 7) {\\n          if (!n) return;\\n          store<u8>(dest + --n, load<u8>(src + n));\\n        }\\n        while (n >= 8) {\\n          n -= 8;\\n          store<u64>(dest + n, load<u64>(src + n));\\n        }\\n      }\\n    }\\n    while (n) {\\n      store<u8>(dest + --n, load<u8>(src + n));\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\\n  if (ASC_SHRINK_LEVEL > 1) {\\n    while (n) {\\n      store<u8>(dest++, c);\\n      --n;\\n    }\\n  } else {\\n    // fill head and tail with minimal branching\\n    if (!n) return;\\n    let dend = dest + n;\\n    store<u8>(dest, c);\\n    store<u8>(dend - 1, c);\\n    if (n <= 2) return;\\n    store<u8>(dest, c, 1);\\n    store<u8>(dest, c, 2);\\n    store<u8>(dend - 2, c);\\n    store<u8>(dend - 3, c);\\n    if (n <= 6) return;\\n    store<u8>(dest, c, 3);\\n    store<u8>(dend - 4, c);\\n    if (n <= 8) return;\\n\\n    // advance pointer to align it at 4-byte boundary\\n    let k: usize = -dest & 3;\\n    dest += k;\\n    n -= k;\\n    n &= -4;\\n\\n    let c32: u32 = <u32>-1 / 255 * c;\\n\\n    // fill head/tail up to 28 bytes each in preparation\\n    dend = dest + n;\\n    store<u32>(dest, c32);\\n    store<u32>(dend - 4, c32);\\n    if (n <= 8) return;\\n    store<u32>(dest, c32, 4);\\n    store<u32>(dest, c32, 8);\\n    store<u32>(dend - 12, c32);\\n    store<u32>(dend - 8, c32);\\n    if (n <= 24) return;\\n    store<u32>(dest, c32, 12);\\n    store<u32>(dest, c32, 16);\\n    store<u32>(dest, c32, 20);\\n    store<u32>(dest, c32, 24);\\n    store<u32>(dend - 28, c32);\\n    store<u32>(dend - 24, c32);\\n    store<u32>(dend - 20, c32);\\n    store<u32>(dend - 16, c32);\\n\\n    // align to a multiple of 8\\n    k = 24 + (dest & 4);\\n    dest += k;\\n    n -= k;\\n\\n    // copy 32 bytes each\\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\\n    while (n >= 32) {\\n      store<u64>(dest, c64);\\n      store<u64>(dest, c64, 8);\\n      store<u64>(dest, c64, 16);\\n      store<u64>(dest, c64, 24);\\n      n -= 32;\\n      dest += 32;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\\n  if (vl == vr) return 0;\\n  if (ASC_SHRINK_LEVEL < 2) {\\n    if ((vl & 7) == (vr & 7)) {\\n      while (vl & 7) {\\n        if (!n) return 0;\\n        let a = <i32>load<u8>(vl);\\n        let b = <i32>load<u8>(vr);\\n        if (a != b) return a - b;\\n        n--; vl++; vr++;\\n      }\\n      while (n >= 8) {\\n        if (load<u64>(vl) != load<u64>(vr)) break;\\n        vl += 8;\\n        vr += 8;\\n        n  -= 8;\\n      }\\n    }\\n  }\\n  while (n--) {\\n    let a = <i32>load<u8>(vl);\\n    let b = <i32>load<u8>(vr);\\n    if (a != b) return a - b;\\n    vl++; vr++;\\n  }\\n  return 0;\\n}\\n\",\n  \"util/number\": \"/// <reference path=\\\"../rt/index.d.ts\\\" />\\n\\nimport { idof } from \\\"../builtins\\\";\\nimport { CharCode } from \\\"./string\\\";\\n\\n// @ts-ignore: decorator\\n@inline\\nexport const MAX_DOUBLE_LENGTH = 28;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const POWERS10 = memory.data<u32>([\\n  1,\\n  10,\\n  100,\\n  1000,\\n  10000,\\n  100000,\\n  1000000,\\n  10000000,\\n  100000000,\\n  1000000000\\n]);\\n\\n/*\\n  Lookup table for pairwise char codes in range [0-99]\\n\\n  \\\"00\\\", \\\"01\\\", \\\"02\\\", \\\"03\\\", \\\"04\\\", \\\"05\\\", \\\"06\\\", \\\"07\\\", \\\"08\\\", \\\"09\\\",\\n  \\\"10\\\", \\\"11\\\", \\\"12\\\", \\\"13\\\", \\\"14\\\", \\\"15\\\", \\\"16\\\", \\\"17\\\", \\\"18\\\", \\\"19\\\",\\n  \\\"20\\\", \\\"21\\\", \\\"22\\\", \\\"23\\\", \\\"24\\\", \\\"25\\\", \\\"26\\\", \\\"27\\\", \\\"28\\\", \\\"29\\\",\\n  \\\"30\\\", \\\"31\\\", \\\"32\\\", \\\"33\\\", \\\"34\\\", \\\"35\\\", \\\"36\\\", \\\"37\\\", \\\"38\\\", \\\"39\\\",\\n  \\\"40\\\", \\\"41\\\", \\\"42\\\", \\\"43\\\", \\\"44\\\", \\\"45\\\", \\\"46\\\", \\\"47\\\", \\\"48\\\", \\\"49\\\",\\n  \\\"50\\\", \\\"51\\\", \\\"52\\\", \\\"53\\\", \\\"54\\\", \\\"55\\\", \\\"56\\\", \\\"57\\\", \\\"58\\\", \\\"59\\\",\\n  \\\"60\\\", \\\"61\\\", \\\"62\\\", \\\"63\\\", \\\"64\\\", \\\"65\\\", \\\"66\\\", \\\"67\\\", \\\"68\\\", \\\"69\\\",\\n  \\\"70\\\", \\\"71\\\", \\\"72\\\", \\\"73\\\", \\\"74\\\", \\\"75\\\", \\\"76\\\", \\\"77\\\", \\\"78\\\", \\\"79\\\",\\n  \\\"80\\\", \\\"81\\\", \\\"82\\\", \\\"83\\\", \\\"84\\\", \\\"85\\\", \\\"86\\\", \\\"87\\\", \\\"88\\\", \\\"89\\\",\\n  \\\"90\\\", \\\"91\\\", \\\"92\\\", \\\"93\\\", \\\"94\\\", \\\"95\\\", \\\"96\\\", \\\"97\\\", \\\"98\\\", \\\"99\\\"\\n*/\\n// @ts-ignore: decorator\\n@lazy @inline const DIGITS = memory.data<u32>([\\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\\n]);\\n\\n// Lookup table for pairwise char codes in range [0x00-0xFF]\\n// @ts-ignore: decorator\\n@lazy @inline const HEX_DIGITS =\\n\\\"000102030405060708090a0b0c0d0e0f\\\\\\n101112131415161718191a1b1c1d1e1f\\\\\\n202122232425262728292a2b2c2d2e2f\\\\\\n303132333435363738393a3b3c3d3e3f\\\\\\n404142434445464748494a4b4c4d4e4f\\\\\\n505152535455565758595a5b5c5d5e5f\\\\\\n606162636465666768696a6b6c6d6e6f\\\\\\n707172737475767778797a7b7c7d7e7f\\\\\\n808182838485868788898a8b8c8d8e8f\\\\\\n909192939495969798999a9b9c9d9e9f\\\\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline const ANY_DIGITS = \\\"0123456789abcdefghijklmnopqrstuvwxyz\\\";\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\\n    907,   933,   960,   986,  1013,  1039,  1066\\n/* eslint-enable indent */]);\\n\\n// 1e-348, 1e-340, ..., 1e340\\n// @ts-ignore: decorator\\n@lazy @inline const FRC_POWERS = memory.data<u64>([\\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isPowerOf2<T extends number>(value: T): bool {\\n  return popcnt<T>(value) == 1;\\n}\\n\\n// Count number of decimals for u32 values\\n// In our case input value always non-zero so we can simplify some parts\\nexport function decimalCount32(value: u32): u32 {\\n  if (value < 100000) {\\n    if (value < 100) {\\n      return 1 + u32(value >= 10);\\n    } else {\\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\\n    }\\n  } else {\\n    if (value < 10000000) {\\n      return 6 + u32(value >= 1000000);\\n    } else {\\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\\n    }\\n  }\\n}\\n\\n// Count number of decimals for u64 values\\n// In our case input value always greater than 2^32-1 so we can skip some parts\\nexport function decimalCount64High(value: u64): u32 {\\n  if (value < 1000000000000000) {\\n    if (value < 1000000000000) {\\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\\n    } else {\\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\\n    }\\n  } else {\\n    if (value < 100000000000000000) {\\n      return 16 + u32(value >= 10000000000000000);\\n    } else {\\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\\n    }\\n  }\\n}\\n\\nfunction ulog_base(num: u64, base: i32): u32 {\\n  if (isPowerOf2(base)) {\\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\\n  }\\n  let b64 = u64(base), b = b64, e: u32 = 1;\\n  while (num >= b) {\\n    num /= b;\\n    b *= b;\\n    e <<= 1;\\n  }\\n  while (num >= 1) {\\n    num /= b64;\\n    e++;\\n  }\\n  return e - 1;\\n}\\n\\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\\n  while (num >= 10000) {\\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\\n    let t = num / 10000;\\n    let r = num % 10000;\\n    num = t;\\n\\n    let d1 = r / 100;\\n    let d2 = r % 100;\\n\\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\\n\\n    offset -= 4;\\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\\n  }\\n\\n  if (num >= 100) {\\n    let t  = num / 100;\\n    let d1 = num % 100;\\n    num = t;\\n    offset -= 2;\\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\\n    store<u32>(buffer + (offset << 1), digits);\\n  }\\n\\n  if (num >= 10) {\\n    offset -= 2;\\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\\n    store<u32>(buffer + (offset << 1), digits);\\n  } else {\\n    offset -= 1;\\n    let digit = CharCode._0 + num;\\n    store<u16>(buffer + (offset << 1), digit);\\n  }\\n}\\n\\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\\n  while (num >= 100000000) {\\n    let t = num / 100000000;\\n    let r = <usize>(num - t * 100000000);\\n    num = t;\\n\\n    let b = r / 10000;\\n    let c = r % 10000;\\n\\n    let b1 = b / 100;\\n    let b2 = b % 100;\\n    let c1 = c / 100;\\n    let c2 = c % 100;\\n\\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\\n\\n    offset -= 4;\\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\\n\\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\\n\\n    offset -= 4;\\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\\n  }\\n\\n  utoa32_dec_lut(buffer, <u32>num, offset);\\n}\\n\\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\\n  const lut = changetype<usize>(HEX_DIGITS);\\n  while (offset >= 2) {\\n    offset -= 2;\\n    store<u32>(\\n      buffer + (offset << 1),\\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\\n    );\\n    num >>= 8;\\n  }\\n  if (offset & 1) {\\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\\n  }\\n}\\n\\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\\n  do {\\n    let t = num / 10;\\n    let r = <u32>(num % 10);\\n    num = changetype<T>(t);\\n    offset--;\\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\\n  } while (num);\\n}\\n\\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\\n  do {\\n    let d = num & 0x0F | CharCode._0;\\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\\n    offset--;\\n    store<u16>(buffer + (offset << 1), d);\\n    // @ts-ignore: type\\n    num >>= 4;\\n  } while (num);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_dec_simple<u32>(buffer, num, offset);\\n  } else {\\n    utoa32_dec_lut(buffer, num, offset);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_hex_simple<u32>(buffer, num, offset);\\n  } else {\\n    utoa_hex_lut(buffer, num, offset);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_dec_simple<u64>(buffer, num, offset);\\n  } else {\\n    utoa64_dec_lut(buffer, num, offset);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    utoa_hex_simple<u64>(buffer, num, offset);\\n  } else {\\n    utoa_hex_lut(buffer, num, offset);\\n  }\\n}\\n\\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\\n  const lut = changetype<usize>(ANY_DIGITS);\\n  let base = u64(radix);\\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\\n    let shift = u64(ctz(radix) & 7);\\n    let mask = base - 1;\\n    do {\\n      offset--;\\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\\n      num >>= shift;\\n    } while (num);\\n  } else {\\n    do {\\n      offset--;\\n      let q = num / base;\\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\\n      num = q;\\n    } while (num);\\n  }\\n}\\n\\nexport function utoa32(value: u32, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n  let out: String;\\n\\n  if (radix == 10) {\\n    let decimals = decimalCount32(value);\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\\n  } else if (radix == 16) {\\n    let decimals = (31 - clz(value) >> 2) + 1;\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\\n  } else {\\n    let decimals = ulog_base(value, radix);\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\\n  }\\n  return out;\\n}\\n\\nexport function itoa32(value: i32, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n\\n  let sign = (value >>> 31) << 1;\\n  if (sign) value = -value;\\n  let out: String;\\n\\n  if (radix == 10) {\\n    let decimals = decimalCount32(value);\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\\n  } else if (radix == 16) {\\n    let decimals = (31 - clz(value) >> 2) + 1;\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\\n  } else {\\n    let val32 = u32(value);\\n    let decimals = ulog_base(val32, radix);\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\\n  }\\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\\n  return out;\\n}\\n\\nexport function utoa64(value: u64, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n  let out: String;\\n\\n  if (radix == 10) {\\n    if (value <= u32.MAX_VALUE) {\\n      let val32    = <u32>value;\\n      let decimals = decimalCount32(val32);\\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\\n    } else {\\n      let decimals = decimalCount64High(value);\\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\\n    }\\n  } else if (radix == 16) {\\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\\n  } else {\\n    let decimals = ulog_base(value, radix);\\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\\n  }\\n  return out;\\n}\\n\\nexport function itoa64(value: i64, radix: i32): String {\\n  if (radix < 2 || radix > 36) {\\n    throw new RangeError(\\\"toString() radix argument must be between 2 and 36\\\");\\n  }\\n  if (!value) return \\\"0\\\";\\n\\n  let sign = u32(value >>> 63) << 1;\\n  if (sign) value = -value;\\n  let out: String;\\n\\n  if (radix == 10) {\\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\\n      let val32    = <u32>value;\\n      let decimals = decimalCount32(val32);\\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\\n    } else {\\n      let decimals = decimalCount64High(value);\\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\\n    }\\n  } else if (radix == 16) {\\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\\n  } else {\\n    let decimals = ulog_base(value, radix);\\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\\n  }\\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\\n  return out;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let _K: i32 = 0;\\n\\n// // @ts-ignore: decorator\\n// @lazy\\n// let _frc: u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _exp: i32 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _frc_minus: u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _frc_plus:  u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _frc_pow: u64 = 0;\\n\\n// @ts-ignore: decorator\\n@lazy let _exp_pow: i32 = 0;\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction umul64f(u: u64, v: u64): u64 {\\n  let u0 = u & 0xFFFFFFFF;\\n  let v0 = v & 0xFFFFFFFF;\\n\\n  let u1 = u >> 32;\\n  let v1 = v >> 32;\\n\\n  let l = u0 * v0;\\n  let t = u1 * v0 + (l >> 32);\\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\\n\\n  w += 0x7FFFFFFF; // rounding\\n\\n  t >>= 32;\\n  w >>= 32;\\n\\n  return u1 * v1 + t + w;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction umul64e(e1: i32, e2: i32): i32 {\\n  return e1 + e2 + 64; // where 64 is significand size\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction normalizedBoundaries(f: u64, e: i32): void {\\n  let frc = (f << 1) + 1;\\n  let exp = e - 1;\\n  let off = <i32>clz<u64>(frc);\\n  frc <<= off;\\n  exp  -= off;\\n\\n  let m = 1 + i32(f == 0x0010000000000000);\\n\\n  _frc_plus  = frc;\\n  _frc_minus = ((f << m) - 1) << e - m - exp;\\n  _exp = exp;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\\n  let lastp = buffer + ((len - 1) << 1);\\n  let digit = load<u16>(lastp);\\n  while (\\n    rest < wp_w &&\\n    delta - rest >= ten_kappa && (\\n      rest + ten_kappa < wp_w ||\\n      wp_w - rest > rest + ten_kappa - wp_w\\n    )\\n  ) {\\n    --digit;\\n    rest += ten_kappa;\\n  }\\n  store<u16>(lastp, digit);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction getCachedPower(minExp: i32): void {\\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\\n  let dk = (-61 - minExp) * c + 347;\\t            // dk must be positive, so can do ceiling in positive\\n  let k = <i32>dk;\\n  k += i32(k != dk); // conversion with ceil\\n\\n  let index = (k >> 3) + 1;\\n  _K = 348 - (index << 3);\\t// decimal exponent no need lookup table\\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\\n\\n  // frexp routine\\n  let uv  = reinterpret<u64>(value);\\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\\n  let sid = uv & 0x000FFFFFFFFFFFFF;\\n  let frc = (u64(exp != 0) << 52) + sid;\\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\\n\\n  normalizedBoundaries(frc, exp);\\n  getCachedPower(_exp);\\n\\n  // normalize\\n  let off = <i32>clz<u64>(frc);\\n  frc <<= off;\\n  exp  -= off;\\n\\n  let frc_pow = _frc_pow;\\n  let exp_pow = _exp_pow;\\n\\n  let w_frc = umul64f(frc, frc_pow);\\n  let w_exp = umul64e(exp, exp_pow);\\n\\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\\n  let wp_exp = umul64e(_exp, exp_pow);\\n\\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\\n  let delta  = wp_frc - wm_frc;\\n\\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\\n}\\n\\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\\n  let one_exp = -mp_exp;\\n  let one_frc = (<u64>1) << one_exp;\\n  let mask    = one_frc - 1;\\n\\n  let wp_w_frc = mp_frc - w_frc;\\n\\n  let p1 = u32(mp_frc >> one_exp);\\n  let p2 = mp_frc & mask;\\n\\n  let kappa = <i32>decimalCount32(p1);\\n  let len = sign;\\n\\n  while (kappa > 0) {\\n    let d: u32;\\n    switch (kappa) {\\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\\n      case  3: { d = p1 /        100; p1 %=        100; break; }\\n      case  2: { d = p1 /         10; p1 %=         10; break; }\\n      case  1: { d = p1;              p1 =           0; break; }\\n      default: { d = 0; break; }\\n    }\\n\\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\\n\\n    --kappa;\\n    let tmp = ((<u64>p1) << one_exp) + p2;\\n    if (tmp <= delta) {\\n      _K += kappa;\\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\\n      return len;\\n    }\\n  }\\n\\n  while (true) {\\n    p2    *= 10;\\n    delta *= 10;\\n\\n    let d = p2 >> one_exp;\\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\\n\\n    p2 &= mask;\\n    --kappa;\\n    if (p2 < delta) {\\n      _K += kappa;\\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\\n      return len;\\n    }\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction genExponent(buffer: usize, k: i32): i32 {\\n  let sign = k < 0;\\n  if (sign) k = -k;\\n  let decimals = decimalCount32(k) + 1;\\n  utoa32_dec_core(buffer, k, decimals);\\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\\n  return decimals;\\n}\\n\\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\\n  if (!k) {\\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\\n    return length + 2;\\n  }\\n\\n  let kk = length + k;\\n  if (length <= kk && kk <= 21) {\\n    // 1234e7 -> 12340000000\\n    for (let i = length; i < kk; ++i) {\\n      store<u16>(buffer + (i << 1), CharCode._0);\\n    }\\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\\n    return kk + 2;\\n  } else if (kk > 0 && kk <= 21) {\\n    // 1234e-2 -> 12.34\\n    let ptr = buffer + (kk << 1);\\n    memory.copy(\\n      ptr + 2,\\n      ptr,\\n      -k << 1\\n    );\\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\\n    return length + 1;\\n  } else if (-6 < kk && kk <= 0) {\\n    // 1234e-6 -> 0.001234\\n    let offset = 2 - kk;\\n    memory.copy(\\n      buffer + (offset << 1),\\n      buffer,\\n      length << 1\\n    );\\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\\n    for (let i = 2; i < offset; ++i) {\\n      store<u16>(buffer + (i << 1), CharCode._0);\\n    }\\n    return length + offset;\\n  } else if (length == 1) {\\n    // 1e30\\n    store<u16>(buffer, CharCode.e, 2);\\n    length = genExponent(buffer + 4, kk - 1);\\n    return length + 2;\\n  } else {\\n    let len = length << 1;\\n    memory.copy(\\n      buffer + 4,\\n      buffer + 2,\\n      len - 2\\n    );\\n    store<u16>(buffer,       CharCode.DOT, 2);\\n    store<u16>(buffer + len, CharCode.e,   2);\\n    length += genExponent(buffer + len + 4, kk - 1);\\n    return length + 2;\\n  }\\n}\\n\\nfunction dtoa_core(buffer: usize, value: f64): i32 {\\n  let sign = i32(value < 0);\\n  if (sign) {\\n    value = -value;\\n    store<u16>(buffer, CharCode.MINUS);\\n  }\\n  // assert(value > 0 && value <= 1.7976931348623157e308);\\n  let len = grisu2(value, buffer, sign);\\n  len = prettify(buffer + (sign << 1), len - sign, _K);\\n  return len + sign;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\\n\\nexport function dtoa(value: f64): String {\\n  if (value == 0) return \\\"0.0\\\";\\n  if (!isFinite(value)) {\\n    if (isNaN(value)) return \\\"NaN\\\";\\n    return select<String>(\\\"-Infinity\\\", \\\"Infinity\\\", value < 0);\\n  }\\n  let size = dtoa_core(dtoa_buf, value) << 1;\\n  let result = changetype<String>(__new(size, idof<String>()));\\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\\n  return result;\\n}\\n\\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\\n  let sign: u32 = 0;\\n  if (isSigned<T>()) {\\n    sign = u32(value < 0);\\n    if (sign) {\\n      if (sizeof<T>() == 1) {\\n        if (value == -0x80) {\\n          // -0x80  ->  -128\\n          store<u64>(buffer,\\n            <u64>CharCode.MINUS |\\n            <u64>(CharCode._0 + 1) << 16 |\\n            <u64>(CharCode._0 + 2) << 32 |\\n            <u64>(CharCode._0 + 8) << 48\\n          );\\n          return 4;\\n        }\\n      }\\n      if (sizeof<T>() == 2) {\\n        if (value == -0x8000) {\\n          // -0x8000  ->  -32768\\n          store<u64>(buffer,\\n            <u64>CharCode.MINUS |\\n            <u64>(CharCode._0 + 3) << 16 |\\n            <u64>(CharCode._0 + 2) << 32 |\\n            <u64>(CharCode._0 + 7) << 48\\n          ); // -327\\n          store<u32>(buffer + 8,\\n            (CharCode._0 + 6) << 0 |\\n            (CharCode._0 + 8) << 16\\n          ); // 68\\n          return 6;\\n        }\\n      }\\n      store<u16>(buffer, CharCode.MINUS);\\n      // @ts-ignore\\n      value = -value;\\n    }\\n  }\\n  let dest = buffer + (sign << 1);\\n  if (ASC_SHRINK_LEVEL <= 1) {\\n    if (isSigned<T>()) {\\n      if (sizeof<T>() <= 4) {\\n        if (<u32>value < 10) {\\n          store<u16>(dest, value | CharCode._0);\\n          return 1 + sign;\\n        }\\n      } else {\\n        if (<u64>value < 10) {\\n          store<u16>(dest, value | CharCode._0);\\n          return 1 + sign;\\n        }\\n      }\\n    } else {\\n      if (value < 10) {\\n        store<u16>(buffer, value | CharCode._0);\\n        return 1;\\n      }\\n    }\\n  }\\n  let decimals: u32 = 0;\\n  if (sizeof<T>() <= 4) {\\n    let val32 = <u32>value;\\n    decimals = decimalCount32(val32);\\n    utoa32_dec_core(dest, val32, decimals);\\n  } else {\\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\\n      let val32 = <u32>value;\\n      decimals = decimalCount32(val32);\\n      utoa32_dec_core(dest, val32, decimals);\\n    } else {\\n      let val64 = <u64>value;\\n      decimals = decimalCount64High(val64);\\n      utoa64_dec_core(dest, val64, decimals);\\n    }\\n  }\\n  return sign + decimals;\\n}\\n\\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\\n  if (value == 0) {\\n    store<u16>(buffer, CharCode._0);\\n    store<u16>(buffer, CharCode.DOT, 2);\\n    store<u16>(buffer, CharCode._0,  4);\\n    return 3;\\n  }\\n  if (!isFinite(value)) {\\n    if (isNaN(value)) {\\n      store<u16>(buffer, CharCode.N);\\n      store<u16>(buffer, CharCode.a, 2);\\n      store<u16>(buffer, CharCode.N, 4);\\n      return 3;\\n    } else {\\n      let sign = value < 0;\\n      if (sign) {\\n        store<u16>(buffer, CharCode.MINUS); // -\\n        buffer += 2;\\n      }\\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\\n      return 8 + u32(sign);\\n    }\\n  }\\n  return dtoa_core(buffer, value);\\n}\\n\",\n  \"util/sort\": \"import { compareImpl } from \\\"./string\\\";\\n\\ntype Comparator<T> = (a: T, b: T) => i32;\\n\\n// @ts-ignore: decorator\\n@lazy @inline const EMPTY = u32.MAX_VALUE;\\n// @ts-ignore: decorator\\n@inline const INSERTION_SORT_THRESHOLD = 48;\\n// @ts-ignore: decorator\\n@inline const MIN_RUN_LENGTH = 32;\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction log2u(n: u32): u32 {\\n  return 31 - clz(n);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function COMPARATOR<T>(): Comparator<T> {\\n  if (isInteger<T>()) {\\n    if (isSigned<T>() && sizeof<T>() <= 4) {\\n      return (a, b) => i32(a) - i32(b);\\n    } else {\\n      return (a, b) => i32(a > b) - i32(a < b);\\n    }\\n  } else if (isFloat<T>()) {\\n    if (sizeof<T>() == 4) {\\n      return (a, b) => {\\n        let ia = reinterpret<i32>(f32(a));\\n        let ib = reinterpret<i32>(f32(b));\\n        ia ^= ia >> 31 >>> 1;\\n        ib ^= ib >> 31 >>> 1;\\n        return i32(ia > ib) - i32(ia < ib);\\n      };\\n    } else {\\n      return (a, b) => {\\n        let ia = reinterpret<i64>(f64(a));\\n        let ib = reinterpret<i64>(f64(b));\\n        ia ^= ia >> 63 >>> 1;\\n        ib ^= ib >> 63 >>> 1;\\n        return i32(ia > ib) - i32(ia < ib);\\n      };\\n    }\\n  } else if (isString<T>()) {\\n    return (a, b) => {\\n      if (\\n        changetype<usize>(a) == changetype<usize>(b) ||\\n        changetype<usize>(a) == 0 ||\\n        changetype<usize>(b) == 0\\n      ) return 0;\\n      let alen = changetype<string>(a).length;\\n      let blen = changetype<string>(b).length;\\n      if (!(alen | blen)) return 0;\\n      if (!alen) return -1;\\n      if (!blen) return  1;\\n      let res = compareImpl(\\n        changetype<string>(a), 0,\\n        changetype<string>(b), 0,\\n        <usize>min(alen, blen)\\n      );\\n      return res ? res : alen - blen;\\n    };\\n  } else {\\n    return (a, b) => i32(a > b) - i32(a < b);\\n  }\\n}\\n\\n// Power Sort implementation (stable) from paper \\\"Nearly-Optimal Mergesorts\\\"\\n// https://arxiv.org/pdf/1805.04154.pdf\\n// This method usually outperform TimSort.\\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\\nexport function SORT<T>(\\n  ptr: usize,\\n  len: i32,\\n  comparator: Comparator<T>\\n): void {\\n  if (len <= INSERTION_SORT_THRESHOLD) {\\n    if (len <= 1) return;\\n    if (ASC_SHRINK_LEVEL < 1) {\\n      switch (len) {\\n        case 3: {\\n          let a = load<T>(ptr, 0);\\n          let b = load<T>(ptr, 1 << alignof<T>());\\n          let c = comparator(a, b) > 0;\\n          store<T>(ptr, select<T>(b, a, c), 0);\\n          a = select<T>(a, b, c);\\n          b = load<T>(ptr, 2 << alignof<T>());\\n          c = comparator(a, b) > 0;\\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\\n        }\\n        case 2: {\\n          let a = load<T>(ptr, 0);\\n          let b = load<T>(ptr, 1 << alignof<T>());\\n          let c = comparator(a, b) > 0;\\n          store<T>(ptr, select<T>(b, a, c), 0);\\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\\n          return;\\n        }\\n      }\\n    }\\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\\n    return;\\n  }\\n\\n  let lgPlus2         = log2u(len) + 2;\\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\\n\\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\\n  }\\n\\n  let buffer = __alloc(len << alignof<T>());\\n\\n  let hi   = len - 1;\\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\\n  let lenA = endA + 1;\\n\\n  if (lenA < MIN_RUN_LENGTH) {\\n    endA = min(hi, MIN_RUN_LENGTH - 1);\\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\\n  }\\n\\n  let top: u32 = 0, startA = 0;\\n  while (endA < hi) {\\n    let startB = endA + 1;\\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\\n    let lenB = endB - startB + 1;\\n\\n    if (lenB < MIN_RUN_LENGTH) {\\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\\n    }\\n\\n    let k = nodePower(0, hi, startA, startB, endB);\\n\\n    for (let i = top; i > k; --i) {\\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\\n      if (start != EMPTY) {\\n        mergeRuns<T>(\\n          ptr,\\n          start,\\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\\n          endA,\\n          buffer,\\n          comparator\\n        );\\n        startA = start;\\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\\n      }\\n    }\\n\\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\\n    startA = startB;\\n    endA = endB;\\n    top = k;\\n  }\\n\\n  for (let i = top; i != 0; --i) {\\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\\n    if (start != EMPTY) {\\n      mergeRuns<T>(\\n        ptr,\\n        start,\\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\\n        hi,\\n        buffer,\\n        comparator\\n      );\\n    }\\n  }\\n  // dealloc aux buffers\\n  __free(buffer);\\n  __free(leftRunStartBuf);\\n}\\n\\nfunction insertionSort<T>(\\n  ptr: usize,\\n  left: i32,\\n  right: i32,\\n  presorted: i32,\\n  comparator: Comparator<T>\\n): void {\\n  if (ASC_SHRINK_LEVEL >= 1) {\\n    // slightly improved original insertion sort\\n    for (let i = left + presorted; i <= right; ++i) {\\n      let j = i - 1;\\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\\n      while (j >= left) {\\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\\n        if (comparator(a, b) < 0) {\\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\\n        } else break;\\n      }\\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\\n    }\\n  } else {\\n    // even-odd two-way insertion sort which allow increase minRunLen\\n    let range = right - left + 1;\\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\\n    for (; i <= right; i += 2) {\\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\\n      let min = b, max = a;\\n      if (comparator(a, b) <= 0) {\\n        min = a, max = b;\\n      }\\n      let j = i - 1;\\n      while (j >= left) {\\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\\n        if (comparator(a, max) > 0) {\\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\\n        } else break;\\n      }\\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\\n      while (j >= left) {\\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\\n        if (comparator(a, min) > 0) {\\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\\n        } else break;\\n      }\\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\\n    }\\n  }\\n}\\n\\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\\n  let n: u64 = right - left + 1;\\n  let s = startB - (left << 1);\\n  let l = startA + s;\\n  let r = endB   + s + 1;\\n  let a = (<u64>l << 30) / n;\\n  let b = (<u64>r << 30) / n;\\n  return clz(<u32>(a ^ b));\\n}\\n\\nfunction extendRunRight<T>(\\n  ptr: usize,\\n  i: i32,\\n  right: i32,\\n  comparator: Comparator<T>\\n): i32 {\\n  if (i == right) return i;\\n  let j = i;\\n  if (comparator(\\n    load<T>(ptr + (<usize>  j << alignof<T>())),\\n    load<T>(ptr + (<usize>++j << alignof<T>()))\\n  ) > 0) {\\n    while (\\n      j < right &&\\n      (comparator(\\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\\n        load<T>(ptr + (<usize>j << alignof<T>()))\\n      ) >>> 31) // < 0\\n    ) ++j;\\n    // reverse\\n    let k = j;\\n    while (i < k) {\\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\\n    }\\n  } else {\\n    while (\\n      j < right &&\\n      comparator(\\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\\n        load<T>(ptr + (<usize>j << alignof<T>()))\\n      ) >= 0\\n    ) ++j;\\n  }\\n  return j;\\n}\\n\\n// Merges arr[l..m - 1] and arr[m..r]\\nfunction mergeRuns<T>(\\n  ptr: usize,\\n  l: i32,\\n  m: i32,\\n  r: i32,\\n  buffer: usize,\\n  comparator: Comparator<T>\\n): void {\\n  --m;\\n  let i: i32, j: i32, t = r + m;\\n  for (i = m + 1; i > l; --i) {\\n    store<T>(\\n      buffer + (<usize>(i - 1) << alignof<T>()),\\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\\n    );\\n  }\\n  for (j = m; j < r; ++j) {\\n    store<T>(\\n      buffer + (<usize>(t - j) << alignof<T>()),\\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\\n    );\\n  }\\n  for (let k = l; k <= r; ++k) {\\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\\n    if (comparator(a, b) < 0) {\\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\\n      --j;\\n    } else {\\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\\n      ++i;\\n    }\\n  }\\n}\\n\",\n  \"util/string\": \"import {\\n  itoa32,\\n  utoa32,\\n  itoa64,\\n  utoa64,\\n  dtoa,\\n  itoa_buffered,\\n  dtoa_buffered,\\n  MAX_DOUBLE_LENGTH\\n} from \\\"./number\\\";\\n\\nimport {\\n  ipow32\\n} from \\\"../math\\\";\\n\\n// All tables are stored as two staged lookup tables (static tries)\\n// because the full range of Unicode symbols can't be efficiently\\n// represented as-is in memory (see Unicode spec ch 5, p.196):\\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\\n// Tables have been generated using these forked musl tools:\\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\\n\\n// Lookup table to check if a character is alphanumeric or not\\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\\n// size: 3904 bytes\\n// @ts-ignore\\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\\n  16,16,125,16,16,16,\\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\\n  31,254,225,255,\\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\\n  63,\\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,\\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\\n  255,\\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\\n  0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,\\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\\n]);\\n\\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\\n// @ts-ignore: decorator\\n@lazy @inline const CASED = memory.data<u8>([\\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0\\n]);\\n\\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\\n// @ts-ignore: decorator\\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\n  0,0,0,0,0,0,0,248\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const LOWER127 = memory.data<u8>([\\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\\n  64,\\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\\n  91,92,93,94,95,96,\\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\\n  123,124,125,126,127\\n]);\\n\\n// @ts-ignore: decorator\\n@lazy @inline const UPPER127 = memory.data<u8>([\\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\\n  64,\\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\\n  91,92,93,94,95,96,\\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\\n  123,124,125,126,127\\n]);\\n\\n// 23 * 8 = 184 bytes\\n// @ts-ignore: decorator\\n@lazy @inline const POWERS10 = memory.data<f64>([\\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\\n  1e20, 1e21, 1e22\\n]);\\n\\n// @ts-ignore: decorator\\n@inline\\nexport const enum CharCode {\\n  PERCENT = 0x25,\\n  PLUS = 0x2B,\\n  MINUS = 0x2D,\\n  DOT = 0x2E,\\n  _0 = 0x30,\\n  _1 = 0x31,\\n  _2 = 0x32,\\n  _3 = 0x33,\\n  _4 = 0x34,\\n  _5 = 0x35,\\n  _6 = 0x36,\\n  _7 = 0x37,\\n  _8 = 0x38,\\n  _9 = 0x39,\\n  A = 0x41,\\n  B = 0x42,\\n  E = 0x45,\\n  I = 0x49,\\n  N = 0x4E,\\n  O = 0x4F,\\n  X = 0x58,\\n  Z = 0x5A,\\n  a = 0x61,\\n  b = 0x62,\\n  e = 0x65,\\n  n = 0x6E,\\n  o = 0x6F,\\n  u = 0x75,\\n  x = 0x78,\\n  z = 0x7A\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isAscii(c: u32): bool {\\n  return !(c >> 7);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isLower8(c: u32): bool {\\n  return c - CharCode.a < 26;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isUpper8(c: u32): bool {\\n  return c - CharCode.A < 26;\\n}\\n\\nexport function isSpace(c: u32): bool {\\n  if (c < 0x1680) { // < <LS> (1)\\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\\n  }\\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\\n  switch (c) {\\n    case 0x1680: // <LS> (1)\\n    case 0x2028: // <LS> (2)\\n    case 0x2029: // <PS>\\n    case 0x202F: // <NNS>\\n    case 0x205F: // <MMSP>\\n    case 0x3000: // <IS>\\n    case 0xFEFF: return true; // <ZWNBSP>\\n  }\\n  return false;\\n}\\n\\nexport function isAlpha(c: u32): bool {\\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\\n  if (c < 0x20000) {\\n    // @ts-ignore: cast\\n    return stagedBinaryLookup(ALPHA_TABLE, c);\\n  }\\n  return c < 0x2FFFE;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isCased(c: u32): bool {\\n  // @ts-ignore: cast\\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isCaseIgnorable(c: u32): bool {\\n  // @ts-ignore: cast\\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\\n  const lookaheadLimit = 30; // max lookahead limit\\n  let found = false;\\n  let pos = index;\\n  let minPos = max(0, pos - lookaheadLimit);\\n  while (pos > minPos) {\\n    let c = codePointBefore(buffer, pos);\\n    if (!isCaseIgnorable(c)) {\\n      if (isCased(c)) {\\n        found = true;\\n      } else {\\n        return false;\\n      }\\n    }\\n    pos -= isize(c >= 0x10000) + 1;\\n  }\\n  if (!found) return false;\\n  pos = index + 1;\\n  let maxPos = min(pos + lookaheadLimit, len);\\n  while (pos < maxPos) {\\n    let c = <u32>load<u16>(buffer + (pos << 1));\\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\\n      if ((c1 & 0xFC00) == 0xDC00) {\\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\\n      }\\n    }\\n    if (!isCaseIgnorable(c)) {\\n      return !isCased(c);\\n    }\\n    pos += isize(c >= 0x10000) + 1;\\n  }\\n  return true;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction codePointBefore(buffer: usize, index: isize): i32 {\\n  if (index <= 0) return -1;\\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\\n    if ((c1 & 0xFC00) == 0xD800) {\\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\\n    }\\n  }\\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\\n}\\n\\n// Search routine for two-staged lookup tables\\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\\n}\\n\\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\\n  if (ASC_SHRINK_LEVEL < 2) {\\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\\n      do {\\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\\n        ptr1 += 8;\\n        ptr2 += 8;\\n        len  -= 4;\\n      } while (len >= 4);\\n    }\\n  }\\n  while (len--) {\\n    let a = <i32>load<u16>(ptr1);\\n    let b = <i32>load<u16>(ptr2);\\n    if (a != b) return a - b;\\n    ptr1 += 2;\\n    ptr2 += 2;\\n  }\\n  return 0;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function toLower8(c: u32): u32 {\\n  if (ASC_SHRINK_LEVEL > 0) {\\n    return c | u32(isUpper8(c)) << 5;\\n  } else {\\n    return <u32>load<u8>(LOWER127 + c);\\n  }\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nexport function toUpper8(c: u32): u32 {\\n  if (ASC_SHRINK_LEVEL > 0) {\\n    return c & ~(u32(isLower8(c)) << 5);\\n  } else {\\n    return <u32>load<u8>(UPPER127 + c);\\n  }\\n}\\n\\n/** Parses a string to an integer (usually), using the specified radix. */\\nexport function strtol<T>(str: string, radix: i32 = 0): T {\\n  let len = str.length;\\n  if (!len) {\\n    if (isFloat<T>()) {\\n      // @ts-ignore: cast\\n      return <T>NaN;\\n    } else {\\n      // @ts-ignore: cast\\n      return <T>0;\\n    }\\n  }\\n\\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\\n  let code = <u32>load<u16>(ptr);\\n\\n  // trim white spaces\\n  while (isSpace(code)) {\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  // determine sign\\n  // @ts-ignore\\n  let sign: T = 1;\\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\\n    if (!--len) {\\n      if (isFloat<T>()) {\\n        // @ts-ignore: cast\\n        return <T>NaN;\\n      } else {\\n        // @ts-ignore: cast\\n        return <T>0;\\n      }\\n    }\\n    if (code == CharCode.MINUS) {\\n      // @ts-ignore: type\\n      sign = -1;\\n    }\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n\\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\\n  if (radix) {\\n    if (radix < 2 || radix > 36) {\\n      if (isFloat<T>()) {\\n        // @ts-ignore: cast\\n        return <T>NaN;\\n      } else {\\n        // @ts-ignore: cast\\n        return <T>0;\\n      }\\n    }\\n    // handle case as parseInt(\\\"0xFF\\\", 16) by spec\\n    if (radix == 16) {\\n      if (\\n        len > 2 &&\\n        code == CharCode._0 &&\\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\\n      ) {\\n        ptr += 4; len -= 2;\\n      }\\n    }\\n  } else {\\n    // determine radix by literal prefix\\n    if (code == CharCode._0 && len > 2) {\\n      switch (<u32>load<u16>(ptr, 2) | 32) {\\n        case CharCode.b: {\\n          ptr += 4; len -= 2;\\n          radix = 2;\\n          break;\\n        }\\n        case CharCode.o: {\\n          ptr += 4; len -= 2;\\n          radix = 8;\\n          break;\\n        }\\n        case CharCode.x: {\\n          ptr += 4; len -= 2;\\n          radix = 16;\\n          break;\\n        }\\n      }\\n    }\\n    if (!radix) radix = 10;\\n  }\\n\\n  // calculate value\\n  // @ts-ignore: type\\n  let num: T = 0;\\n  let initial = len - 1;\\n  while (len--) {\\n    code = <u32>load<u16>(ptr);\\n    if (code - CharCode._0 < 10) {\\n      code -= CharCode._0;\\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\\n      code -= CharCode.A - 10;\\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\\n      code -= CharCode.a - 10;\\n    }\\n    if (code >= <u32>radix) {\\n      if (initial == len) {\\n        if (isFloat<T>()) {\\n          // @ts-ignore: cast\\n          return <T>NaN;\\n        } else {\\n          // @ts-ignore: cast\\n          return <T>0;\\n        }\\n      }\\n      break;\\n    }\\n    // @ts-ignore: type\\n    num = num * radix + code;\\n    ptr += 2;\\n  }\\n  // @ts-ignore: type\\n  return sign * num;\\n}\\n\\nexport function strtod(str: string): f64 {\\n  let len = str.length;\\n  if (!len) return NaN;\\n\\n  let ptr  = changetype<usize>(str);\\n  let code = <u32>load<u16>(ptr);\\n\\n  let sign = 1.0;\\n  // skip white spaces\\n  while (len && isSpace(code)) {\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  if (!len) return NaN;\\n\\n  // try parse '-' or '+'\\n  if (code == CharCode.MINUS) {\\n    if (!--len) return NaN;\\n    code = <u32>load<u16>(ptr += 2);\\n    sign = -1;\\n  } else if (code == CharCode.PLUS) {\\n    if (!--len) return NaN;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n\\n  // try parse Infinity\\n  if (len >= 8 && code == CharCode.I) {\\n    if (\\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\\n    ) {\\n      return Infinity * sign;\\n    }\\n    return NaN;\\n  }\\n  // validate next symbol\\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\\n    return NaN;\\n  }\\n  let savedPtr = ptr;\\n  // skip zeros\\n  while (code == CharCode._0) {\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  if (len <= 0) return 0.0 * sign;\\n  const capacity = 19; // int(64 * 0.3010)\\n  let pointed = false;\\n  let consumed = 0;\\n  let position = 0;\\n  let x: u64 = 0;\\n  if (code == CharCode.DOT) {\\n    let noDigits = !(savedPtr - ptr);\\n    ptr += 2; --len;\\n    if (!len && noDigits) return NaN;\\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\\n    if (len <= 0) return 0.0 * sign;\\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\\n  }\\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\\n    if (digit < 10) {\\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\\n      ++consumed;\\n    } else {\\n      position = consumed;\\n      pointed = true;\\n    }\\n    if (!--len) break;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n\\n  if (!pointed) position = consumed;\\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\\n}\\n\\nexport function strtob(str: string): bool {\\n  let size: usize = str.length << 1;\\n  let offset: usize = 0;\\n  if (size > 8) {\\n    // try trim end whitespaces first\\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\\n    if (size > 8) {\\n      // trim start whitespaces\\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\\n      size -= offset;\\n    }\\n  }\\n  if (size != 8) return false;\\n  // \\\"true\\\" represents as \\\\00\\\\e\\\\00\\\\u\\\\00\\\\e\\\\00\\\\t (00 65 00 75 00 72 00 74)\\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\\n}\\n\\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) return select(\\\"true\\\", \\\"false\\\", load<bool>(dataStart));\\n\\n  let sepLen = separator.length;\\n  let valueLen = 5; // max possible length of element len(\\\"false\\\")\\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\\n  let offset = 0;\\n  let value: bool;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<bool>(dataStart + i);\\n    valueLen = 4 + i32(!value);\\n    memory.copy(\\n      changetype<usize>(result) + (<usize>offset << 1),\\n      changetype<usize>(select(\\\"true\\\", \\\"false\\\", value)),\\n      <usize>valueLen << 1\\n    );\\n    offset += valueLen;\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<bool>(dataStart + <usize>lastIndex);\\n  valueLen = 4 + i32(!value);\\n  memory.copy(\\n    changetype<usize>(result) + (<usize>offset << 1),\\n    changetype<usize>(select(\\\"true\\\", \\\"false\\\", value)),\\n    valueLen << 1\\n  );\\n  offset += valueLen;\\n\\n  if (estLen > offset) return result.substring(0, offset);\\n  return result;\\n}\\n\\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) {\\n    let value = load<T>(dataStart);\\n    if (isSigned<T>()) {\\n      if (sizeof<T>() <= 4) {\\n        // @ts-ignore: type\\n        return changetype<string>(itoa32(<i32>value, 10));\\n      } else {\\n        // @ts-ignore: type\\n        return changetype<string>(itoa64(<i32>value, 10));\\n      }\\n    } else {\\n      if (sizeof<T>() <= 4) {\\n        // @ts-ignore: type\\n        return changetype<string>(utoa32(<u32>value, 10));\\n      } else {\\n        // @ts-ignore: type\\n        return changetype<string>(utoa64(<u64>value, 10));\\n      }\\n    }\\n  }\\n\\n  let sepLen = separator.length;\\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\\n  let offset = 0;\\n  let value: T;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    // @ts-ignore: type\\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\\n  // @ts-ignore: type\\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\\n  if (estLen > offset) return result.substring(0, offset);\\n  return result;\\n}\\n\\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) {\\n    return changetype<string>(dtoa(\\n      // @ts-ignore: type\\n      load<T>(dataStart))\\n    );\\n  }\\n\\n  const valueLen = MAX_DOUBLE_LENGTH;\\n  let sepLen = separator.length;\\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\\n  let offset = 0;\\n  let value: T;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    // @ts-ignore: type\\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\\n  // @ts-ignore: type\\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\\n  if (estLen > offset) return result.substring(0, offset);\\n  return result;\\n}\\n\\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  if (!lastIndex) {\\n    // @ts-ignore: type\\n    return load<string>(dataStart) || \\\"\\\";\\n  }\\n  let estLen = 0;\\n  let value: string;\\n  for (let i = 0; i < length; ++i) {\\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\\n    if (changetype<usize>(value) != 0) estLen += value.length;\\n  }\\n  let offset = 0;\\n  let sepLen = separator.length;\\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\\n    if (changetype<usize>(value) != 0) {\\n      let valueLen = value.length;\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(value),\\n        <usize>valueLen << 1\\n      );\\n      offset += valueLen;\\n    }\\n    if (sepLen) {\\n      memory.copy(\\n        changetype<usize>(result) + (<usize>offset << 1),\\n        changetype<usize>(separator),\\n        <usize>sepLen << 1\\n      );\\n      offset += sepLen;\\n    }\\n  }\\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\\n  if (changetype<usize>(value) != 0) {\\n    memory.copy(\\n      changetype<usize>(result) + (<usize>offset << 1),\\n      changetype<usize>(value),\\n      <usize>value.length << 1\\n    );\\n  }\\n  return result;\\n}\\n\\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\\n  let lastIndex = length - 1;\\n  if (lastIndex < 0) return \\\"\\\";\\n  let value: T;\\n  if (!lastIndex) {\\n    value = load<T>(dataStart);\\n    // @ts-ignore: type\\n    return value != null ? value.toString() : \\\"\\\";\\n  }\\n  let result = \\\"\\\";\\n  let sepLen = separator.length;\\n  for (let i = 0; i < lastIndex; ++i) {\\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\\n    // @ts-ignore: type\\n    if (value != null) result += value.toString();\\n    if (sepLen) result += separator;\\n  }\\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\\n  // @ts-ignore: type\\n  if (value != null) result += value.toString();\\n  return result;\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction scientific(significand: u64, exp: i32): f64 {\\n  if (!significand || exp < -342) return 0;\\n  if (exp > 308) return Infinity;\\n  // Try use fast path\\n  // Use fast path for string-to-double conversion if possible\\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\\n  // Simple integer\\n  let significandf = <f64>significand;\\n  if (!exp) return significandf;\\n  if (exp > 22 && exp <= 22 + 15) {\\n    significandf *= pow10(exp - 22);\\n    exp = 22;\\n  }\\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\\n    if (exp > 0) return significandf * pow10(exp);\\n    return significandf / pow10(-exp);\\n  } else if (exp < 0) {\\n    return scaledown(significand, exp);\\n  } else {\\n    return scaleup(significand, exp);\\n  }\\n}\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction scaledown(significand: u64, exp: i32): f64 {\\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\\n\\n  let shift = clz(significand);\\n  significand <<= shift;\\n  shift = exp - shift;\\n\\n  for (; exp <= -14; exp += 14) {\\n    let q = significand / denom;\\n    let r = significand % denom;\\n    let s = clz(q);\\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\\n    shift -= s;\\n  }\\n  let b = <u64>ipow32(5, -exp);\\n  let q = significand / b;\\n  let r = significand % b;\\n  let s = clz(q);\\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\\n  shift -= s;\\n\\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\\n}\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction scaleup(significand: u64, exp: i32): f64 {\\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\\n  let shift = ctz(significand);\\n  significand >>= shift;\\n  shift += exp;\\n\\n  __fixmulShift = shift;\\n  for (; exp >= 13; exp -= 13) {\\n    significand = fixmul(significand, coeff);\\n  }\\n  significand = fixmul(significand, <u32>ipow32(5, exp));\\n  shift = __fixmulShift;\\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\\n}\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction parseExp(ptr: usize, len: i32): i32 {\\n  let sign = 1, magnitude = 0;\\n  let code = <u32>load<u16>(ptr);\\n  // check code is 'e' or 'E'\\n  if ((code | 32) != CharCode.e) return 0;\\n\\n  if (!--len) return 0;\\n  code = <u32>load<u16>(ptr += 2);\\n  if (code == CharCode.MINUS) {\\n    if (!--len) return 0;\\n    code = <u32>load<u16>(ptr += 2);\\n    sign = -1;\\n  } else if (code == CharCode.PLUS) {\\n    if (!--len) return 0;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n  // skip zeros\\n  while (code == CharCode._0) {\\n    if (!--len) return 0;\\n    code = <u32>load<u16>(ptr += 2);\\n  }\\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\\n    if (magnitude >= 3200) return sign * 3200;\\n    magnitude = 10 * magnitude + digit;\\n    code = <u32>load<u16>(ptr += 2);\\n    --len;\\n  }\\n  return sign * magnitude;\\n}\\n\\n// @ts-ignore: decorator\\n@lazy let __fixmulShift: u64 = 0;\\n\\n// Adopted from metallic lib:\\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\\n// @ts-ignore: decorator\\n@inline\\nfunction fixmul(a: u64, b: u32): u64 {\\n  let low  = (a & 0xFFFFFFFF) * b;\\n  let high = (a >> 32) * b + (low >> 32);\\n  let overflow = <u32>(high >> 32);\\n  let space = clz(overflow);\\n  let revspace: u64 = 32 - space;\\n  __fixmulShift += revspace;\\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\\n}\\n\\n// @ts-ignore: decorator\\n@inline\\nfunction pow10(n: i32): f64 {\\n  // argument `n` should bounds in [0, 22] range\\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\\n}\\n\",\n  \"util/uri\": \"import { E_URI_MALFORMED } from \\\"./error\\\";\\nimport { CharCode } from \\\"./string\\\";\\n\\n// Truncated lookup boolean table that helps us quickly determine\\n// if a char needs to be escaped for URIs (RFC 2396).\\n// @ts-ignore: decorator\\n@lazy export const URI_UNSAFE = memory.data<u8>([\\n/* skip 32 + 1 always set to '1' head slots\\n  */ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,\\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*\\n  skip 128 + 1 always set to '1' tail slots */\\n]);\\n\\n// Truncated lookup boolean table that helps us quickly determine\\n// if a char needs to be escaped for URLs (RFC 3986).\\n// @ts-ignore: decorator\\n@lazy export const URL_UNSAFE = memory.data<u8>([\\n/* skip 32 + 1 always set to '1' head slots\\n  */ 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,\\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*\\n  skip 128 + 1 always set to '1' tail slots */\\n]);\\n\\n// Truncated lookup boolean table for determine reserved chars: ;/?:@&=+$,#\\n// @ts-ignore: decorator\\n@lazy export const URI_RESERVED = memory.data<u8>([\\n  /*  skip 32 + 3 always set to '0' head slots\\n        */ 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,\\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1,\\n  1, /* skip 191 always set to '0' tail slots */\\n]);\\n\\nexport function encode(src: usize, len: usize, table: usize): usize {\\n  if (!len) return src;\\n\\n  let i: usize = 0, offset: usize = 0, outSize = len << 1;\\n  let dst = __new(outSize, idof<String>());\\n\\n  while (i < len) {\\n    let org = i;\\n    let c: u32, c1: u32;\\n    // fast scan a check chars until it valid ASCII\\n    // and safe for copying withoud escaping.\\n    do {\\n      c = <u32>load<u16>(src + (i << 1));\\n      // is it valid ASII and safe?\\n      if (c - 33 < 94) { // 127 - 33\\n        if (load<u8>(table + (c - 33))) break;\\n      } else break;\\n    } while (++i < len);\\n\\n    // if we have some safe range of sequence just copy it without encoding\\n    if (i > org) {\\n      let size = i - org << 1;\\n      if (offset + size > outSize) {\\n        outSize = offset + size;\\n        dst = __renew(dst, outSize);\\n      }\\n      // TODO: should we optimize for short cases like 2 byte size?\\n      memory.copy(\\n        dst + offset,\\n        src + (org << 1),\\n        size\\n      );\\n      offset += size;\\n      // return if we reach end on input string\\n      if (i >= len) break;\\n    }\\n\\n    // decode UTF16 with checking for unpaired surrogates\\n    if (c >= 0xD800) {\\n      if (c >= 0xDC00 && c <= 0xDFFF) {\\n        throw new URIError(E_URI_MALFORMED);\\n      }\\n      if (c <= 0xDBFF) {\\n        if (i >= len) {\\n          throw new URIError(E_URI_MALFORMED);\\n        }\\n        c1 = <u32>load<u16>(src + (++i << 1));\\n        if (c1 < 0xDC00 || c1 > 0xDFFF) {\\n          throw new URIError(E_URI_MALFORMED);\\n        }\\n        c = (((c & 0x3FF) << 10) | (c1 & 0x3FF)) + 0x10000;\\n      }\\n    }\\n\\n    let estSize = offset + (c < 0x80 ? 1 * 6 : 4 * 6);\\n    if (estSize > outSize) {\\n      // doubling estimated size but only for greater than one\\n      // input lenght due to we already estemated it for worst case\\n      outSize = len > 1 ? estSize << 1 : estSize;\\n      dst = __renew(dst, outSize);\\n    }\\n\\n    if (c < 0x80) {\\n      // encode ASCII unsafe code point\\n      storeHex(dst, offset, c);\\n      offset += 6;\\n    } else {\\n      // encode UTF-8 unsafe code point\\n      if (c < 0x800) {\\n        storeHex(dst, offset, (c >> 6) | 0xC0);\\n        offset += 6;\\n      } else {\\n        if (c < 0x10000) {\\n          storeHex(dst, offset, (c >> 12) | 0xE0);\\n          offset += 6;\\n        } else {\\n          storeHex(dst, offset, (c >> 18) | 0xF0);\\n          offset += 6;\\n          storeHex(dst, offset, (c >> 12 & 0x3F) | 0x80);\\n          offset += 6;\\n        }\\n        storeHex(dst, offset, (c >> 6 & 0x3F) | 0x80);\\n        offset += 6;\\n      }\\n      storeHex(dst, offset, (c & 0x3F) | 0x80);\\n      offset += 6;\\n    }\\n    ++i;\\n  }\\n  // shink output string buffer if necessary\\n  if (outSize > offset) {\\n    dst = __renew(dst, offset);\\n  }\\n  return dst;\\n}\\n\\nexport function decode(src: usize, len: usize, component: bool): usize {\\n  if (!len) return src;\\n\\n  let i: usize = 0, offset: usize = 0, ch: u32 = 0;\\n  let dst = __new(len << 1, idof<String>());\\n\\n  while (i < len) {\\n    let org = i;\\n    while (i < len && (ch = load<u16>(src + (i << 1))) != CharCode.PERCENT) i++;\\n\\n    if (i > org) {\\n      let size = i - org << 1;\\n      // TODO: should we optimize for short cases like 2 byte size?\\n      memory.copy(\\n        dst + offset,\\n        src + (org << 1),\\n        size\\n      );\\n      offset += size;\\n      if (i >= len) break;\\n    }\\n\\n    // decode hex\\n    if (\\n      i + 2 >= len ||\\n      ch != CharCode.PERCENT ||\\n      (ch = loadHex(src, i + 1 << 1)) == -1\\n    ) throw new URIError(E_URI_MALFORMED);\\n\\n    i += 3;\\n    if (ch < 0x80) {\\n      if (!component && isReserved(ch)) {\\n        ch = CharCode.PERCENT;\\n        i -= 2;\\n      }\\n    } else {\\n      // decode UTF-8 sequence\\n      let nb = utf8LenFromUpperByte(ch);\\n      // minimal surrogate: 2 => 0x80, 3 => 0x800, 4 => 0x10000, _ => -1\\n      let lo: u32 = 1 << (17 * nb >> 2) - 1;\\n      // mask: 2 => 31, 3 => 15, 4 => 7, _ =>  0\\n      ch &= nb ? (0x80 >> nb) - 1 : 0;\\n\\n      while (--nb != 0) {\\n        let c1: u32;\\n        // decode hex\\n        if (\\n          i + 2 >= len ||\\n          load<u16>(src + (i << 1)) != CharCode.PERCENT ||\\n          (c1 = loadHex(src, i + 1 << 1)) == -1\\n        ) throw new URIError(E_URI_MALFORMED);\\n\\n        i += 3;\\n        if ((c1 & 0xC0) != 0x80) {\\n          ch = 0;\\n          break;\\n        }\\n        ch = (ch << 6) | (c1 & 0x3F);\\n      }\\n\\n      // check if UTF8 code point properly fit into invalid UTF16 encoding\\n      if (ch < lo || lo == -1 || ch > 0x10FFFF || (ch >= 0xD800 && ch < 0xE000)) {\\n        throw new URIError(E_URI_MALFORMED);\\n      }\\n\\n      // encode UTF16\\n      if (ch >= 0x10000) {\\n        ch -= 0x10000;\\n        let lo = ch >> 10 | 0xD800;\\n        let hi = (ch & 0x03FF) | 0xDC00;\\n        store<u32>(dst + offset, lo | (hi << 16));\\n        offset += 4;\\n        continue;\\n      }\\n    }\\n    store<u16>(dst + offset, ch);\\n    offset += 2;\\n  }\\n\\n  assert(offset <= (len << 1));\\n  // shink output string buffer if necessary\\n  if ((len << 1) > offset) {\\n    dst = __renew(dst, offset);\\n  }\\n  return dst;\\n}\\n\\nfunction storeHex(dst: usize, offset: usize, ch: u32): void {\\n  // @ts-ignore: decorator\\n  const HEX_CHARS = memory.data<u8>([\\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\\n    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46\\n  ]);\\n\\n  store<u16>(dst + offset, CharCode.PERCENT, 0); // %\\n  store<u32>(\\n    dst + offset,\\n    <u32>load<u8>(HEX_CHARS + (ch >> 4 & 0x0F)) |\\n    <u32>load<u8>(HEX_CHARS + (ch      & 0x0F)) << 16,\\n    2\\n  ); // XX\\n}\\n\\nfunction loadHex(src: usize, offset: usize): u32 {\\n  let c0 = <u32>load<u16>(src + offset, 0);\\n  let c1 = <u32>load<u16>(src + offset, 2);\\n  return isHex(c0) && isHex(c1)\\n    ? fromHex(c0) << 4 | fromHex(c1)\\n    : -1;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function fromHex(ch: u32): u32 {\\n  return (ch | 32) % 39 - 9;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function utf8LenFromUpperByte(c0: u32): u32 {\\n  // same as\\n  // if (c0 - 0xC0 <= 0xDF - 0xC0) return 2;\\n  // if (c0 - 0xE0 <= 0xEF - 0xE0) return 3;\\n  // if (c0 - 0xF0 <= 0xF7 - 0xF0) return 4;\\n  // return 0;\\n  return c0 - 0xC0 < 56\\n    ? clz(~(c0 << 24))\\n    : 0;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function isReserved(ch: u32): bool {\\n  return ch - 35 < 30\\n    ? <bool>load<u8>(URI_RESERVED + (ch - 35))\\n    : false;\\n}\\n\\n// @ts-ignore: decorator\\n@inline function isHex(ch: u32): bool {\\n  return (ch - CharCode._0 < 10) || ((ch | 32) - CharCode.a < 6);\\n}\\n\",\n  \"vector\": \"/** Vector abstraction. */\\n@final @unmanaged\\nexport abstract class V128 {\\n}\\n\"\n};\nexport const definitionFiles = {\n  \"assembly\": \"/**\\n * Environment definitions for compiling AssemblyScript to WebAssembly using asc.\\n * @module std/assembly\\n *//***/\\n\\n/// <reference no-default-lib=\\\"true\\\"/>\\n\\n// Types\\n\\n/** An 8-bit signed integer. */\\ndeclare type i8 = number;\\n/** A 16-bit signed integer. */\\ndeclare type i16 = number;\\n/** A 32-bit signed integer. */\\ndeclare type i32 = number;\\n/** A 64-bit signed integer. */\\ndeclare type i64 = number;\\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\\ndeclare type isize = number;\\n/** An 8-bit unsigned integer. */\\ndeclare type u8 = number;\\n/** A 16-bit unsigned integer. */\\ndeclare type u16 = number;\\n/** A 32-bit unsigned integer. */\\ndeclare type u32 = number;\\n/** A 64-bit unsigned integer. */\\ndeclare type u64 = number;\\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\\ndeclare type usize = number;\\n/** A 1-bit unsigned integer. */\\ndeclare type bool = boolean | number;\\n/** A 32-bit float. */\\ndeclare type f32 = number;\\n/** A 64-bit float. */\\ndeclare type f64 = number;\\n/** A 128-bit vector. */\\ndeclare type v128 = object;\\n/** Function reference. */\\ndeclare type funcref = object | null;\\n/** External reference. */\\ndeclare type externref = object | null;\\n/** Any reference. */\\ndeclare type anyref = object | null;\\n/** Equatable reference. */\\ndeclare type eqref = object | null;\\n/** 31-bit integer reference. */\\ndeclare type i31ref = object | null;\\n/** Data reference. */\\ndeclare type dataref = object | null;\\n/** Array reference. */\\ndeclare type arrayref = object | null;\\n/** String reference. */\\ndeclare type stringref = object | null;\\n/** WTF-8 string view. */\\ndeclare type stringview_wtf8 = object | null;\\n/** WTF-16 string view. */\\ndeclare type stringview_wtf16 = object | null;\\n/** String iterator. */\\ndeclare type stringview_iter = object | null;\\n\\n// Compiler hints\\n\\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\\ndeclare const ASC_TARGET: i32;\\n/** Runtime type. 0 = Stub, 1 = Minimal, 2 = Incremental. */\\ndeclare const ASC_RUNTIME: i32;\\n/** Provided noAssert option. */\\ndeclare const ASC_NO_ASSERT: bool;\\n/** Provided memoryBase option. */\\ndeclare const ASC_MEMORY_BASE: i32;\\n/** Provided tableBase option. */\\ndeclare const ASC_TABLE_BASE: i32;\\n/** Provided optimizeLevel option. */\\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\\n/** Provided shrinkLevel option. */\\ndeclare const ASC_SHRINK_LEVEL: i32;\\n/** Provided lowMemoryLimit option. */\\ndeclare const ASC_LOW_MEMORY_LIMIT: i32;\\n/** Provided noExportRuntime option. */\\ndeclare const ASC_NO_EXPORT_RUNTIME: i32;\\n/** Whether the sign extension feature is enabled. */\\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\\n/** Whether the mutable globals feature is enabled. */\\ndeclare const ASC_FEATURE_MUTABLE_GLOBALS: bool;\\n/** Whether the non-trapping float-to-int feature is enabled. */\\ndeclare const ASC_FEATURE_NONTRAPPING_F2I: bool;\\n/** Whether the bulk memory feature is enabled. */\\ndeclare const ASC_FEATURE_BULK_MEMORY: bool;\\n/** Whether the SIMD feature is enabled. */\\ndeclare const ASC_FEATURE_SIMD: bool;\\n/** Whether the threads feature is enabled. */\\ndeclare const ASC_FEATURE_THREADS: bool;\\n/** Whether the exception handling feature is enabled. */\\ndeclare const ASC_FEATURE_EXCEPTION_HANDLING: bool;\\n/** Whether the tail calls feature is enabled. */\\ndeclare const ASC_FEATURE_TAIL_CALLS: bool;\\n/** Whether the reference types feature is enabled. */\\ndeclare const ASC_FEATURE_REFERENCE_TYPES: bool;\\n/** Whether the multi value types feature is enabled. */\\ndeclare const ASC_FEATURE_MULTI_VALUE: bool;\\n/** Whether the garbage collection feature is enabled. */\\ndeclare const ASC_FEATURE_GC: bool;\\n/** Whether the memory64 feature is enabled. */\\ndeclare const ASC_FEATURE_MEMORY64: bool;\\n/** Whether the relaxed SIMD feature is enabled. */\\ndeclare const ASC_FEATURE_RELAXED_SIMD: bool;\\n/** Whether the extended const expression feature is enabled. */\\ndeclare const ASC_FEATURE_EXTENDED_CONST: bool;\\n/** Whether the string references feature is enabled. */\\ndeclare const ASC_FEATURE_STRINGREF: bool;\\n/** Major version of the compiler. */\\ndeclare const ASC_VERSION_MAJOR: i32;\\n/** Minor version of the compiler. */\\ndeclare const ASC_VERSION_MINOR: i32;\\n/** Patch version of the compiler. */\\ndeclare const ASC_VERSION_PATCH: i32;\\n\\n// Builtins\\n\\n/** Performs the sign-agnostic reverse bytes **/\\ndeclare function bswap<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;\\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\\ndeclare function clz<T extends i32 | i64>(value: T): T;\\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\\ndeclare function ctz<T extends i32 | i64>(value: T): T;\\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\\ndeclare function popcnt<T extends i32 | i64>(value: T): T;\\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\\ndeclare function rotl<T extends i32 | i64>(value: T, shift: T): T;\\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\\ndeclare function rotr<T extends i32 | i64>(value: T, shift: T): T;\\n/** Computes the absolute value of an integer or float. */\\ndeclare function abs<T extends i32 | i64 | f32 | f64>(value: T): T;\\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function max<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function min<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\\ndeclare function ceil<T extends f32 | f64>(value: T): T;\\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\\ndeclare function copysign<T extends f32 | f64>(x: T, y: T): T;\\n/** Performs the floor operation on a 32-bit or 64-bit float. */\\ndeclare function floor<T extends f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\\ndeclare function nearest<T extends f32 | f64>(value: T): T;\\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\\ndeclare function reinterpret<T extends i32 | i64 | f32 | f64>(value: number): T;\\n/** Selects one of two pre-evaluated values depending on the condition. */\\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\\n/** Calculates the square root of a 32-bit or 64-bit float. */\\ndeclare function sqrt<T extends f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\\ndeclare function trunc<T extends f32 | f64>(value: T): T;\\n/** Computes the sum of two integers or floats. */\\ndeclare function add<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Computes the difference of two integers or floats. */\\ndeclare function sub<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Computes the product of two integers or floats. */\\ndeclare function mul<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Computes the quotient of two integers or floats. */\\ndeclare function div<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;\\n/** Return 1 if two numbers are equal to each other, 0 otherwise. */\\ndeclare function eq<T extends i32 | i64 | f32 | f64>(left: T, right: T): i32;\\n/** Return 0 if two numbers are equal to each other, 1 otherwise. */\\ndeclare function ne<T extends i32 | i64 | f32 | f64>(left: T, right: T): i32;\\n/** Computes the remainder of two integers. */\\ndeclare function rem<T extends i32 | i64>(left: T, right: T): T;\\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\\ndeclare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\\ndeclare function store<T>(ptr: usize, value: T, immOffset?: usize, immAlign?: usize): void;\\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression. */\\ndeclare function unreachable(): never;\\n\\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\\ndeclare const NaN: f32 | f64;\\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\\ndeclare const Infinity: f32 | f64;\\n/** Data end offset. */\\ndeclare const __data_end: usize;\\n/** Stack pointer offset. */\\ndeclare let __stack_pointer: usize;\\n/** Heap base offset. */\\ndeclare const __heap_base: usize;\\n/** Determines the byte size of the specified underlying core type. Compiles to a constant. */\\ndeclare function sizeof<T>(): usize;\\n/** Determines the alignment (log2) of the specified underlying core type. Compiles to a constant. */\\ndeclare function alignof<T>(): usize;\\n/** Determines the end offset of the given class type. Compiles to a constant. */\\ndeclare function offsetof<T>(): usize;\\n/** Determines the offset of the specified field within the given class type. Compiles to a constant. */\\ndeclare function offsetof<T>(fieldName: keyof T | string): usize;\\n/** Determines the offset of the specified field within the given class type. Returns the class type's end offset if field name has been omitted. Compiles to a constant. */\\ndeclare function offsetof<T>(fieldName?: string): usize;\\n/** Determines the name of a given type. */\\ndeclare function nameof<T>(value?: T): string;\\n/** Determines the unique runtime id of a class type. Compiles to a constant. */\\ndeclare function idof<T>(): u32;\\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\\ndeclare function changetype<T>(value: any): T;\\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\\ndeclare function unchecked<T>(value: T): T;\\n/** Emits a `call_indirect` instruction, calling the specified function in the function table by index with the specified arguments. Does result in a runtime error if the arguments do not match the called function. */\\ndeclare function call_indirect<T>(index: u32, ...args: unknown[]): T;\\n/** Instantiates a new instance of `T` using the specified constructor arguments. */\\ndeclare function instantiate<T>(...args: any[]): T;\\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\\ndeclare function isNaN<T extends f32 | f64>(value: T): bool;\\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\\ndeclare function isFinite<T extends f32 | f64>(value: T): bool;\\n/** Tests if the specified type *or* expression is of a boolean type. */\\ndeclare function isBoolean<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression is of an integer type and not a reference. Compiles to a constant. */\\ndeclare function isInteger<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression can represent negative numbers. Compiles to a constant. */\\ndeclare function isSigned<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression is of a float type. Compiles to a constant. */\\ndeclare function isFloat<T>(value?: any): value is number;\\n/** Tests if the specified type *or* expression is of a v128 type. Compiles to a constant. */\\ndeclare function isVector<T>(value?: any): value is v128;\\n/** Tests if the specified type *or* expression is of a reference type. Compiles to a constant. */\\ndeclare function isReference<T>(value?: any): value is object | string;\\n/** Tests if the specified type *or* expression can be used as a string. Compiles to a constant. */\\ndeclare function isString<T>(value?: any): value is string | String;\\n/** Tests if the specified type *or* expression can be used as an array. Compiles to a constant. */\\ndeclare function isArray<T>(value?: any): value is Array<any>;\\n/** Tests if the specified type *or* expression can be used as an array like object. Compiles to a constant. */\\ndeclare function isArrayLike<T>(value?: any): value is ArrayLike<any>;\\n/** Tests if the specified type *or* expression is of a function type. Compiles to a constant. */\\ndeclare function isFunction<T>(value?: any): value is (...args: any) => any;\\n/** Tests if the specified type *or* expression is of a nullable reference type. Compiles to a constant. */\\ndeclare function isNullable<T>(value?: any): bool;\\n/** Tests if the specified expression resolves to a defined element. Compiles to a constant. */\\ndeclare function isDefined(expression: any): bool;\\n/** Tests if the specified expression evaluates to a constant value. Compiles to a constant. */\\ndeclare function isConstant(expression: any): bool;\\n/** Tests if the specified type *or* expression is of a managed type. Compiles to a constant. */\\ndeclare function isManaged<T>(value?: any): bool;\\n/** Tests if the specified type is void. Compiles to a constant. */\\ndeclare function isVoid<T>(): bool;\\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\\ndeclare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?\\n/** Parses an integer string to a 64-bit float. */\\ndeclare function parseInt(str: string, radix?: i32): f64;\\n/** Parses a string to a 64-bit float. */\\ndeclare function parseFloat(str: string): f64;\\n/** Returns the 64-bit floating-point remainder of `x/y`. */\\ndeclare function fmod(x: f64, y: f64): f64;\\n/** Returns the 32-bit floating-point remainder of `x/y`. */\\ndeclare function fmodf(x: f32, y: f32): f32;\\n/** Returns the number of parameters in the given function signature type. */\\ndeclare function lengthof<T extends (...args: any[]) => any>(func?: T): i32;\\n/** Encodes a text string as a valid Uniform Resource Identifier (URI). */\\ndeclare function encodeURI(str: string): string;\\n/** Encodes a text string as a valid component of a Uniform Resource Identifier (URI). */\\ndeclare function encodeURIComponent(str: string): string;\\n/** Decodes a Uniform Resource Identifier (URI) previously created by encodeURI. */\\ndeclare function decodeURI(str: string): string;\\n/** Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent. */\\ndeclare function decodeURIComponent(str: string): string;\\n\\n/** Atomic operations. */\\ndeclare namespace atomic {\\n  /** Atomically loads an integer value from memory and returns it. */\\n  export function load<T>(ptr: usize, immOffset?: usize): T;\\n  /** Atomically stores an integer value to memory. */\\n  export function store<T>(ptr: usize, value: T, immOffset?: usize): void;\\n  /** Atomically adds an integer value in memory. */\\n  export function add<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically subtracts an integer value in memory. */\\n  export function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically performs a bitwise AND operation on an integer value in memory. */\\n  export function and<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically performs a bitwise OR operation on an integer value in memory. */\\n  export function or<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically performs a bitwise XOR operation on an integer value in memory. */\\n  export function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically exchanges an integer value in memory. */\\n  export function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\\n  /** Atomically compares and exchanges an integer value in memory if the condition is met. */\\n  export function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\\n  /** Performs a wait operation on an address in memory suspending this agent if the integer condition is met. */\\n  export function wait<T>(ptr: usize, expected: T, timeout?: i64): AtomicWaitResult;\\n  /** Performs a notify operation on an address in memory waking up suspended agents. */\\n  export function notify(ptr: usize, count?: i32): i32;\\n  /** Performs a fence operation, preserving synchronization guarantees of higher level languages. */\\n  export function fence(): void;\\n}\\n\\n/** Describes the result of an atomic wait operation. */\\ndeclare enum AtomicWaitResult {\\n  /** Woken by another agent. */\\n  OK,\\n  /** Loaded value did not match the expected value. */\\n  NOT_EQUAL,\\n  /** Not woken before the timeout expired. */\\n  TIMED_OUT\\n}\\n\\n/** Converts any other numeric value to an 8-bit signed integer. */\\ndeclare function i8(value: any): i8;\\ndeclare namespace i8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i8;\\n}\\n/** Converts any other numeric value to a 16-bit signed integer. */\\ndeclare function i16(value: any): i16;\\ndeclare namespace i16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i16;\\n}\\n/** Converts any other numeric value to a 32-bit signed integer. */\\ndeclare function i32(value: any): i32;\\ndeclare namespace i32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i32;\\n  /** Converts a string to an i32 of this type. */\\n  export function parse(value: string, radix?: i32): i32;\\n  /** Loads an 8-bit signed integer value from memory and returns it as a 32-bit integer. */\\n  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads a 16-bit signed integer value from memory and returns it as a 32-bit integer. */\\n  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Loads a 32-bit integer value from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\\n  /** Stores a 32-bit integer value to memory as an 8-bit integer. */\\n  export function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 32-bit integer value to memory as a 16-bit integer. */\\n  export function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 32-bit integer value to memory. */\\n  export function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\\n  /** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\\n  export function clz(value: i32): i32;\\n  /** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\\n  export function ctz(value: i32): i32;\\n  /** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\\n  export function popcnt(value: i32): i32;\\n  /** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\\n  export function rotl(value: i32, shift: i32): i32;\\n  /** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\\n  export function rotr(value: i32, shift: i32): i32;\\n  /** Reinterprets the bits of the specified 32-bit float as a 32-bit integer. */\\n  export function reinterpret_f32(value: f32): i32;\\n  /** Computes the sum of two 32-bit integers. */\\n  export function add(left: i32, right: i32): i32;\\n  /** Computes the difference of two 32-bit integers. */\\n  export function sub(left: i32, right: i32): i32;\\n  /** Computes the product of two 32-bit integers. */\\n  export function mul(left: i32, right: i32): i32;\\n  /** Computes the signed quotient of two 32-bit integers. */\\n  export function div_s(left: i32, right: i32): i32;\\n  /** Computes the unsigned quotient of two 32-bit integers. */\\n  export function div_u(left: i32, right: i32): i32;\\n  /** Return 1 if two 32-bit integers are equal to each other, 0 otherwise. */\\n  export function eq(left: i32, right: i32): i32;\\n  /** Return 0 if two 32-bit integers are equal to each other, 1 otherwise. */\\n  export function ne(left: i32, right: i32): i32;\\n  /** Computes the signed remainder of two 32-bit integers. */\\n  export function rem_s(left: i32, right: i32): i32;\\n  /** Computes the unsigned remainder of two 32-bit integers. */\\n  export function rem_u(left: u32, right: u32): u32;\\n\\n  /** Atomic 32-bit integer operations. */\\n  export namespace atomic {\\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n    export function load8_u(ptr: usize, immOffset?: usize): i32;\\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\\n    export function load16_u(ptr: usize, immOffset?: usize): i32;\\n    /** Atomically loads a 32-bit integer value from memory and returns it. */\\n    export function load(ptr: usize, immOffset?: usize): i32;\\n    /** Atomically stores a 32-bit integer value to memory as an 8-bit integer. */\\n    export function store8(ptr: usize, value: i32, immOffset?: usize): void;\\n    /** Atomically stores a 32-bit integer value to memory as a 16-bit integer. */\\n    export function store16(ptr: usize, value: i32, immOffset?: usize): void;\\n    /** Atomically stores a 32-bit integer value to memory. */\\n    export function store(ptr: usize, value: i32, immOffset?: usize): void;\\n    /** Performs a wait operation on a 32-bit integer value in memory suspending this agent if the condition is met. */\\n    export function wait(ptr: usize, expected: i32, timeout?: i64): AtomicWaitResult;\\n    /** Atomic 32-bit integer read-modify-write operations on 8-bit values. */\\n    export namespace rmw8 {\\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise AND operation an 8-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise OR operation an 8-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise XOR operation an 8-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n    /** Atomic 32-bit integer read-modify-write operations on 16-bit values. */\\n    export namespace rmw16 {\\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise AND operation a 16-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise OR operation a 16-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise XOR operation a 16-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n    /** Atomic 32-bit integer read-modify-write operations. */\\n    export namespace rmw {\\n      /** Atomically adds a 32-bit integer value in memory. */\\n      export function add(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically subtracts a 32-bit integer value in memory. */\\n      export function sub(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise AND operation a 32-bit integer value in memory. */\\n      export function and(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise OR operation a 32-bit integer value in memory. */\\n      export function or(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically performs a bitwise XOR operation a 32-bit integer value in memory. */\\n      export function xor(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically exchanges a 32-bit integer value in memory. */\\n      export function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\\n      /** Atomically compares and exchanges a 32-bit integer value in memory if the condition is met. */\\n      export function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\\n    }\\n  }\\n}\\n/** Converts any other numeric value to a 64-bit signed integer. */\\ndeclare function i64(value: any): i64;\\ndeclare namespace i64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i64;\\n  /** Converts a string to an i64 of this type. */\\n  export function parse(value: string, radix?: i32): i64;\\n  /** Loads an 8-bit signed integer value from memory and returns it as a 64-bit integer. */\\n  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 16-bit signed integer value from memory and returns it as a 64-bit integer. */\\n  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 32-bit signed integer value from memory and returns it as a 64-bit integer. */\\n  export function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n  export function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Loads a 64-bit unsigned integer value from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\\n  /** Stores a 64-bit integer value to memory as an 8-bit integer. */\\n  export function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 64-bit integer value to memory as a 16-bit integer. */\\n  export function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 64-bit integer value to memory as a 32-bit integer. */\\n  export function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Stores a 64-bit integer value to memory. */\\n  export function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\\n  /** Performs the sign-agnostic count leading zero bits operation on a 64-bit integer. All zero bits are considered leading if the value is zero. */\\n  export function clz(value: i64): i64;\\n  /** Performs the sign-agnostic count tailing zero bits operation on a 64-bit integer. All zero bits are considered trailing if the value is zero. */\\n  export function ctz(value: i64): i64;\\n  /** Performs the sign-agnostic count number of one bits operation on a 64-bit integer. */\\n  export function popcnt(value: i64): i64;\\n  /** Performs the sign-agnostic rotate left operation on a 64-bit integer. */\\n  export function rotl(value: i64, shift: i64): i64;\\n  /** Performs the sign-agnostic rotate right operation on a 64-bit integer. */\\n  export function rotr(value: i64, shift: i64): i64;\\n  /** Reinterprets the bits of the specified 64-bit float as a 64-bit integer. */\\n  export function reinterpret_f64(value: f64): i64;\\n  /** Computes the sum of two 64-bit integers. */\\n  export function add(left: i64, right: i64): i64;\\n  /** Computes the difference of two 64-bit integers. */\\n  export function sub(left: i64, right: i64): i64;\\n  /** Computes the product of two 64-bit integers. */\\n  export function mul(left: i64, right: i64): i64;\\n  /** Computes the signed quotient of two 64-bit integers. */\\n  export function div_s(left: i64, right: i64): i64;\\n  /** Computes the unsigned quotient of two 64-bit integers. */\\n  export function div_u(left: i64, right: i64): i64;\\n  /** Return 1 if two 64-bit integers are equal to each other, 0 otherwise. */\\n  export function eq(left: i64, right: i64): i32;\\n  /** Return 0 if two 64-bit integers are equal to each other, 1 otherwise. */\\n  export function ne(left: i64, right: i64): i32;\\n  /** Computes the signed remainder of two 64-bit integers. */\\n  export function rem_s(left: i64, right: i64): i64;\\n  /** Computes the unsigned remainder of two 64-bit integers. */\\n  export function rem_u(left: u64, right: u64): u64;\\n\\n  /** Atomic 64-bit integer operations. */\\n  export namespace atomic {\\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n    export function load8_u(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n    export function load16_u(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\\n    export function load32_u(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically loads a 64-bit integer value from memory and returns it. */\\n    export function load(ptr: usize, immOffset?: usize): i64;\\n    /** Atomically stores a 64-bit integer value to memory as an 8-bit integer. */\\n    export function store8(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Atomically stores a 64-bit integer value to memory as a 16-bit integer. */\\n    export function store16(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Atomically stores a 64-bit integer value to memory as a 32-bit integer. */\\n    export function store32(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Atomically stores a 64-bit integer value to memory. */\\n    export function store(ptr: usize, value: i64, immOffset?: usize): void;\\n    /** Performs a wait operation on a 64-bit integer value in memory suspending this agent if the condition is met. */\\n    export function wait(ptr: usize, expected: i64, timeout?: i64): AtomicWaitResult;\\n    /** Atomic 64-bit integer read-modify-write operations on 8-bit values. */\\n    export namespace rmw8 {\\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on an 8-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on an 8-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on an 8-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n    /** Atomic 64-bit integer read-modify-write operations on 16-bit values. */\\n    export namespace rmw16 {\\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts a 16-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on a 16-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on a 16-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on a 16-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n    /** Atomic 64-bit integer read-modify-write operations on 32-bit values. */\\n    export namespace rmw32 {\\n      /** Atomically adds a 32-bit unsigned integer value in memory. */\\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts a 32-bit unsigned integer value in memory. */\\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on a 32-bit unsigned integer value in memory. */\\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on a 32-bit unsigned integer value in memory. */\\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on a 32-bit unsigned integer value in memory. */\\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges a 32-bit unsigned integer value in memory. */\\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges a 32-bit unsigned integer value in memory if the condition is met. */\\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n    /** Atomic 64-bit integer read-modify-write operations. */\\n    export namespace rmw {\\n      /** Atomically adds a 64-bit integer value in memory. */\\n      export function add(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically subtracts a 64-bit integer value in memory. */\\n      export function sub(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise AND operation on a 64-bit integer value in memory. */\\n      export function and(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise OR operation on a 64-bit integer value in memory. */\\n      export function or(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically performs a bitwise XOR operation on a 64-bit integer value in memory. */\\n      export function xor(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically exchanges a 64-bit integer value in memory. */\\n      export function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\\n      /** Atomically compares and exchanges a 64-bit integer value in memory if the condition is met. */\\n      export function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\\n    }\\n  }\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\\ndeclare let isize: typeof i32 | typeof i64;\\n/** Converts any other numeric value to an 8-bit unsigned integer. */\\ndeclare function u8(value: any): u8;\\ndeclare namespace u8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u8;\\n  /** Converts a string to an u8 of this type. */\\n  export function parse(value: string, radix?: i32): u8;\\n}\\n/** Converts any other numeric value to a 16-bit unsigned integer. */\\ndeclare function u16(value: any): u16;\\ndeclare namespace u16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u16;\\n  /** Converts a string to an u16 of this type. */\\n  export function parse(value: string, radix?: i32): u16;\\n}\\n/** Converts any other numeric value to a 32-bit unsigned integer. */\\ndeclare function u32(value: any): u32;\\ndeclare namespace u32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u32;\\n  /** Converts a string to an u32 of this type. */\\n  export function parse(value: string, radix?: i32): u32;\\n}\\n/** Converts any other numeric value to a 64-bit unsigned integer. */\\ndeclare function u64(value: any): u64;\\ndeclare namespace u64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u64;\\n  /** Converts a string to an u64 of this type. */\\n  export function parse(value: string, radix?: i32): u64;\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\\ndeclare let usize: typeof u32 | typeof u64;\\n/** Converts any other numeric value to a 1-bit unsigned integer. */\\ndeclare function bool(value: any): bool;\\ndeclare namespace bool {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: bool;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: bool;\\n  /** Converts a string to an bool of this type. */\\n  export function parse(value: string): bool;\\n}\\n/** Converts any other numeric value to a 32-bit float. */\\ndeclare function f32(value: any): f32;\\ndeclare namespace f32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f32;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f32;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f32;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f32;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f32;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f32;\\n  /** Not a number value. */\\n  export const NaN: f32;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f32;\\n  /** Converts a string to an f32 of this type. */\\n  export function parse(value: string, radix?: i32): f32;\\n  /** Loads a 32-bit float from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\\n  /** Stores a 32-bit float to memory. */\\n  export function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\\n  /** Computes the sum of two 32-bit floats. */\\n  export function add(left: f32, right: f32): f32;\\n  /** Computes the difference of two 32-bit floats. */\\n  export function sub(left: f32, right: f32): f32;\\n  /** Computes the product of two 32-bit floats. */\\n  export function mul(left: f32, right: f32): f32;\\n  /** Computes the quotient of two 32-bit floats. */\\n  export function div(left: f32, right: f32): f32;\\n  /** Return 1 two 32-bit floats are equal to each other, 0 otherwise. */\\n  export function eq(left: f32, right: f32): i32;\\n  /** Return 0 two 32-bit floats are equal to each other, 1 otherwise. */\\n  export function ne(left: f32, right: f32): i32;\\n  /** Computes the absolute value of a 32-bit float. */\\n  export function abs(value: f32): f32;\\n  /** Determines the maximum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function max(left: f32, right: f32): f32;\\n  /** Determines the minimum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function min(left: f32, right: f32): f32;\\n  /** Performs the ceiling operation on a 32-bit float. */\\n  export function ceil(value: f32): f32;\\n  /** Composes a 32-bit float from the magnitude of `x` and the sign of `y`. */\\n  export function copysign(x: f32, y: f32): f32;\\n  /** Performs the floor operation on a 32-bit float. */\\n  export function floor(value: f32): f32;\\n  /** Rounds to the nearest integer tied to even of a 32-bit float. */\\n  export function nearest(value: f32): f32;\\n  /** Reinterprets the bits of the specified 32-bit integer as a 32-bit float. */\\n  export function reinterpret_i32(value: i32): f32;\\n  /** Calculates the square root of a 32-bit float. */\\n  export function sqrt(value: f32): f32;\\n  /** Rounds to the nearest integer towards zero of a 32-bit float. */\\n  export function trunc(value: f32): f32;\\n}\\n/** Converts any other numeric value to a 64-bit float. */\\ndeclare function f64(value: any): f64;\\ndeclare namespace f64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f64;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f64;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f64;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f64;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f64;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f64;\\n  /** Not a number value. */\\n  export const NaN: f64;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f64;\\n  /** Converts a string to an f64 of this type. */\\n  export function parse(value: string, radix?: i32): f64;\\n  /** Loads a 64-bit float from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\\n  /** Stores a 64-bit float to memory. */\\n  export function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\\n  /** Computes the sum of two 64-bit floats. */\\n  export function add(left: f64, right: f64): f64;\\n  /** Computes the difference of two 64-bit floats. */\\n  export function sub(left: f64, right: f64): f64;\\n  /** Computes the product of two 64-bit floats. */\\n  export function mul(left: f64, right: f64): f64;\\n  /** Computes the quotient of two 64-bit floats. */\\n  export function div(left: f64, right: f64): f64;\\n  /** Return 1 two 64-bit floats are equal to each other, 0 otherwise. */\\n  export function eq(left: f64, right: f64): i32;\\n  /** Return 0 two 32-bit floats are equal to each other, 1 otherwise. */\\n  export function ne(left: f64, right: f64): i32;\\n  /** Computes the absolute value of a 64-bit float. */\\n  export function abs(value: f64): f64;\\n  /** Determines the maximum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function max(left: f64, right: f64): f64;\\n  /** Determines the minimum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */\\n  export function min(left: f64, right: f64): f64;\\n  /** Performs the ceiling operation on a 64-bit float. */\\n  export function ceil(value: f64): f64;\\n  /** Composes a 64-bit float from the magnitude of `x` and the sign of `y`. */\\n  export function copysign(x: f64, y: f64): f64;\\n  /** Performs the floor operation on a 64-bit float. */\\n  export function floor(value: f64): f64;\\n  /** Rounds to the nearest integer tied to even of a 64-bit float. */\\n  export function nearest(value: f64): f64;\\n  /** Reinterprets the bits of the specified 64-bit integer as a 64-bit float. */\\n  export function reinterpret_i64(value: i64): f64;\\n  /** Calculates the square root of a 64-bit float. */\\n  export function sqrt(value: f64): f64;\\n  /** Rounds to the nearest integer towards zero of a 64-bit float. */\\n  export function trunc(value: f64): f64;\\n}\\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\\ndeclare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\\ndeclare namespace v128 {\\n  /** Creates a vector with identical lanes. */\\n  export function splat<T>(x: T): v128;\\n  /** Extracts one lane as a scalar. */\\n  export function extract_lane<T>(x: v128, idx: u8): T;\\n  /** Replaces one lane. */\\n  export function replace_lane<T>(x: v128, idx: u8, value: T): v128;\\n  /** Selects lanes from either vector according to the specified lane indexes. */\\n  export function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n  /** Loads a vector from memory. */\\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading the lanes of the specified type and extending each to the next larger type. */\\n  export function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading a value of the specified type into the lowest bits and initializing all other bits of the vector to zero. */\\n  export function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores the single lane at the specified index of the given vector to memory. */\\n  export function store_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector with eight 16-bit integer lanes by loading and sign extending eight 8-bit integers. */\\n  export function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with eight 16-bit integer lanes by loading and zero extending eight 8-bit integers. */\\n  export function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with four 32-bit integer lanes by loading and sign extending four 16-bit integers. */\\n  export function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with four 32-bit integer lanes by loading and zero extending four 16-bit integers. */\\n  export function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with two 64-bit integer lanes by loading and sign extending two 32-bit integers. */\\n  export function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with two 64-bit integer lanes by loading and zero extending two 32-bit integers. */\\n  export function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\\n  /** Creates a vector with identical lanes by loading the splatted value. */\\n  export function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads an 8-bit integer and splats it sixteen times forming a new vector. */\\n  export function load8_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a 16-bit integer and splats it eight times forming a new vector. */\\n  export function load16_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a 32-bit integer and splats it four times forming a new vector. */\\n  export function load32_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a 64-bit integer and splats it two times forming a new vector. */\\n  export function load64_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading a 32-bit value into the lowest bits and initializing all other bits of the vector to zero. */\\n  export function load32_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Creates a vector by loading a 64-bit value into the lowest bits and initializing all other bits of the vector to zero. */\\n  export function load64_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 8-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 16-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 32-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Loads a single 64-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */\\n  export function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores the 8-bit lane at the specified lane of the given vector to memory. */\\n  export function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores the 16-bit lane at the specified lane of the given vector to memory. */\\n  export function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores the 32-bit lane at the specified lane of the given vector to memory. */\\n  export function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores the 64-bit lane at the specified lane of the given vector to memory. */\\n  export function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\\n  /** Stores a vector to memory. */\\n  export function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\\n  /** Adds each lane. */\\n  export function add<T>(a: v128, b: v128): v128;\\n  /** Subtracts each lane. */\\n  export function sub<T>(a: v128, b: v128): v128;\\n  /** Multiplies each lane. */\\n  export function mul<T>(a: v128, b: v128): v128; // except i64\\n  /** Divides each lane. */\\n  export function div<T extends f32 | f64>(a: v128, b: v128): v128;\\n  /** Negates each lane of a vector. */\\n  export function neg<T>(a: v128): v128;\\n  /** Adds each lane using saturation. */\\n  export function add_sat<T>(a: v128, b: v128): v128;\\n  /** Subtracts each lane using saturation. */\\n  export function sub_sat<T>(a: v128, b: v128): v128;\\n  /** Performs a bitwise left shift on each lane of a vector by a scalar. */\\n  export function shl<T>(a: v128, b: i32): v128;\\n  /** Performs a bitwise right shift on each lane of a vector by a scalar. */\\n  export function shr<T>(a: v128, b: i32): v128;\\n  /** Performs the bitwise AND operation on two vectors. */\\n  export function and(a: v128, b: v128): v128;\\n  /** Performs the bitwise OR operation on two vectors. */\\n  export function or(a: v128, b: v128): v128;\\n  /** Performs the bitwise XOR operation on two vectors. */\\n  export function xor(a: v128, b: v128): v128;\\n  /** Performs the bitwise ANDNOT operation on two vectors. */\\n  export function andnot(a: v128, b: v128): v128;\\n  /** Performs the bitwise NOT operation on a vector. */\\n  export function not(a: v128): v128;\\n  /** Selects bits of either vector according to the specified mask. */\\n  export function bitselect(v1: v128, v2: v128, mask: v128): v128;\\n  /** Reduces a vector to a scalar indicating whether any lane is considered `true`. */\\n  export function any_true(a: v128): bool;\\n  /** Reduces a vector to a scalar indicating whether all lanes are considered `true`. */\\n  export function all_true<T>(a: v128): bool;\\n  /** Extracts the high bit of each lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask<T>(a: v128): i32;\\n  /** Counts the number of bits set to one within each lane. */\\n  export function popcnt<T>(a: v128): v128;\\n  /** Computes the minimum of each lane. */\\n  export function min<T>(a: v128, b: v128): v128;\\n  /** Computes the maximum of each lane. */\\n  export function max<T>(a: v128, b: v128): v128;\\n  /** Computes the pseudo-minimum of each lane. */\\n  export function pmin<T extends f32 | f64>(a: v128, b: v128): v128;\\n  /** Computes the pseudo-maximum of each lane. */\\n  export function pmax<T extends f32 | f64>(a: v128, b: v128): v128;\\n  /** Computes the dot product of two lanes each, yielding lanes one size wider than the input. */\\n  export function dot<T extends i16>(a: v128, b: v128): v128;\\n  /** Computes the average of each lane. */\\n  export function avgr<T extends u8 | u16>(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each lane. */\\n  export function abs<T extends f32 | f64>(a: v128): v128;\\n  /** Computes the square root of each lane. */\\n  export function sqrt<T extends f32 | f64>(a: v128): v128;\\n  /** Performs the ceiling operation on each lane. */\\n  export function ceil<T extends f32 | f64>(a: v128): v128;\\n  /** Performs the floor operation on each lane. */\\n  export function floor<T extends f32 | f64>(a: v128): v128;\\n  /** Rounds to the nearest integer towards zero of each lane. */\\n  export function trunc<T extends f32 | f64>(a: v128): v128;\\n  /** Rounds to the nearest integer tied to even of each lane. */\\n  export function nearest<T extends f32 | f64>(a: v128): v128;\\n  /** Computes which lanes are equal. */\\n  export function eq<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes are not equal. */\\n  export function ne<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are less than those of the second. */\\n  export function lt<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are less than or equal those of the second. */\\n  export function le<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are greater than those of the second. */\\n  export function gt<T>(a: v128, b: v128): v128;\\n  /** Computes which lanes of the first vector are greater than or equal those of the second. */\\n  export function ge<T>(a: v128, b: v128): v128;\\n  /** Converts each lane of a vector from integer to single-precision floating point. */\\n  export function convert<TFrom extends i32 | u32>(a: v128): v128;\\n  /** Converts the low lanes of a vector from integer to double-precision floating point. */\\n  export function convert_low<TFrom extends i32 | u32>(a: v128): v128;\\n  /** Truncates each lane of a vector from single-precision floating point to integer with saturation. Takes the target type. */\\n  export function trunc_sat<TTo extends i32 | u32>(a: v128): v128;\\n  /** Truncates each lane of a vector from double-precision floating point to integer with saturation. Takes the target type. */\\n  export function trunc_sat_zero<TTo extends i32 | u32>(a: v128): v128;\\n  /** Narrows each lane to their respective narrower lanes. */\\n  export function narrow<TFrom extends i16 | i32>(a: v128, b: v128): v128;\\n  /** Extends the low lanes of a vector to their respective wider lanes. */\\n  export function extend_low<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;\\n  /** Extends the high lanes of a vector to their respective wider lanes. */\\n  export function extend_high<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;\\n  /** Adds lanes pairwise producing twice wider extended results. */\\n  export function extadd_pairwise<TFrom extends i8 | u8 | i16 | u16>(a: v128): v128;\\n  /** Demotes each float lane to lower precision. The higher lanes of the result are initialized to zero. */\\n  export function demote_zero<T extends f64 = f64>(a: v128): v128;\\n  /** Promotes the lower float lanes to higher precision. */\\n  export function promote_low<T extends f32 = f32>(a: v128): v128;\\n  /** Performs the line-wise saturating rounding multiplication in Q15 format. */\\n  export function q15mulr_sat<T extends i16>(a: v128, b: v128): v128;\\n  /** Performs the lane-wise integer extended multiplication of the lower lanes producing a twice wider result than the inputs. */\\n  export function extmul_low<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;\\n  /** Performs the lane-wise integer extended multiplication of the higher lanes producing a twice wider result than the inputs. */\\n  export function extmul_high<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;\\n}\\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\\ndeclare namespace i8x16 {\\n  /** Creates a vector with sixteen identical 8-bit integer lanes. */\\n  export function splat(x: i8): v128;\\n  /** Extracts one 8-bit integer lane as a signed scalar. */\\n  export function extract_lane_s(x: v128, idx: u8): i8;\\n  /** Extracts one 8-bit integer lane as an unsigned scalar. */\\n  export function extract_lane_u(x: v128, idx: u8): u8;\\n  /** Replaces one 8-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i8): v128;\\n  /** Adds each 8-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 8-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Computes the signed minimum of each 8-bit integer lane. */\\n  export function min_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned minimum of each 8-bit integer lane. */\\n  export function min_u(a: v128, b: v128): v128;\\n  /** Computes the signed maximum of each 8-bit integer lane. */\\n  export function max_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned maximum of each 8-bit integer lane. */\\n  export function max_u(a: v128, b: v128): v128;\\n  /** Computes the unsigned average of each 8-bit integer lane. */\\n  export function avgr_u(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 8-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 8-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Adds each 8-bit integer lane using signed saturation. */\\n  export function add_sat_s(a: v128, b: v128): v128;\\n  /** Adds each 8-bit integer lane using unsigned saturation. */\\n  export function add_sat_u(a: v128, b: v128): v128;\\n  /** Subtracts each 8-bit integer lane using signed saturation. */\\n  export function sub_sat_s(a: v128, b: v128): v128;\\n  /** Subtracts each 8-bit integer lane using unsigned saturation. */\\n  export function sub_sat_u(a: v128, b: v128): v128;\\n  /** Performs a bitwise left shift on each 8-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift on each 8-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 8-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 8-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 8-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Counts the number of bits set to one within each 8-bit integer lane. */\\n  export function popcnt(a: v128): v128;\\n  /** Computes which 8-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 8-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are less than those of the second. */\\n  export function lt_u(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_u(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than those of the second. */\\n  export function gt_u(a: v128, b: v128): v128;\\n  /** Computes which 8-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_u(a: v128, b: v128): v128;\\n  /** Narrows each 16-bit signed integer lane to 8-bit signed integer lanes. */\\n  export function narrow_i16x8_s(a: v128, b: v128): v128;\\n  /** Narrows each 16-bit signed integer lane to 8-bit unsigned integer lanes. */\\n  export function narrow_i16x8_u(a: v128, b: v128): v128;\\n  /** Selects 8-bit lanes from either vector according to the specified [0-15] respectively [16-31] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n}\\n/** Initializes a 128-bit vector from eight 16-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\\ndeclare namespace i16x8 {\\n  /** Creates a vector with eight identical 16-bit integer lanes. */\\n  export function splat(x: i16): v128;\\n  /** Extracts one 16-bit integer lane as a signed scalar. */\\n  export function extract_lane_s(x: v128, idx: u8): i16;\\n  /** Extracts one 16-bit integer lane as an unsigned scalar. */\\n  export function extract_lane_u(x: v128, idx: u8): u16;\\n  /** Replaces one 16-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i16): v128;\\n  /** Adds each 16-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 16-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 16-bit integer lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Computes the signed minimum of each 16-bit integer lane. */\\n  export function min_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned minimum of each 16-bit integer lane. */\\n  export function min_u(a: v128, b: v128): v128;\\n  /** Computes the signed maximum of each 16-bit integer lane. */\\n  export function max_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned maximum of each 16-bit integer lane. */\\n  export function max_u(a: v128, b: v128): v128;\\n  /** Computes the unsigned average of each 16-bit integer lane. */\\n  export function avgr_u(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 16-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 16-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Adds each 16-bit integer lane using signed saturation. */\\n  export function add_sat_s(a: v128, b: v128): v128;\\n  /** Adds each 16-bit integer lane using unsigned saturation. */\\n  export function add_sat_u(a: v128, b: v128): v128;\\n  /** Subtracts each 16-bit integer lane using signed saturation. */\\n  export function sub_sat_s(a: v128, b: v128): v128;\\n  /** Subtracts each 16-bit integer lane using unsigned saturation. */\\n  export function sub_sat_u(a: v128, b: v128): v128;\\n  /** Performs a bitwise left shift on each 16-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift each 16-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 16-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 16-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 16-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Computes which 16-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 16-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are less than those of the second. */\\n  export function lt_u(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_u(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than those of the second. */\\n  export function gt_u(a: v128, b: v128): v128;\\n  /** Computes which 16-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_u(a: v128, b: v128): v128;\\n  /** Narrows each 32-bit signed integer lane to 16-bit signed integer lanes. */\\n  export function narrow_i32x4_s(a: v128, b: v128): v128;\\n  /** Narrows each 32-bit signed integer lane to 16-bit unsigned integer lanes. */\\n  export function narrow_i32x4_u(a: v128, b: v128): v128;\\n  /** Extends the low 8-bit signed integer lanes to 16-bit signed integer lanes. */\\n  export function extend_low_i8x16_s(a: v128): v128;\\n  /** Extends the low 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */\\n  export function extend_low_i8x16_u(a: v128): v128;\\n  /** Extends the high 8-bit signed integer lanes to 16-bit signed integer lanes. */\\n  export function extend_high_i8x16_s(a: v128): v128;\\n  /** Extends the high 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */\\n  export function extend_high_i8x16_u(a: v128): v128;\\n  /** Adds the sixteen 8-bit signed integer lanes pairwise producing eight 16-bit signed integer results. */\\n  export function extadd_pairwise_i8x16_s(a: v128): v128;\\n  /** Adds the sixteen 8-bit unsigned integer lanes pairwise producing eight 16-bit unsigned integer results. */\\n  export function extadd_pairwise_i8x16_u(a: v128): v128;\\n  /** Performs the line-wise 16-bit signed integer saturating rounding multiplication in Q15 format. */\\n  export function q15mulr_sat_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */\\n  export function extmul_low_i8x16_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */\\n  export function extmul_low_i8x16_u(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */\\n  export function extmul_high_i8x16_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */\\n  export function extmul_high_i8x16_u(a: v128, b: v128): v128;\\n  /** Selects 16-bit lanes from either vector according to the specified [0-7] respectively [8-15] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n}\\n/** Initializes a 128-bit vector from four 32-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\\ndeclare namespace i32x4 {\\n  /** Creates a vector with four identical 32-bit integer lanes. */\\n  export function splat(x: i32): v128;\\n  /** Extracts one 32-bit integer lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): i32;\\n  /** Replaces one 32-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i32): v128;\\n  /** Adds each 32-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 32-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 32-bit integer lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Computes the signed minimum of each 32-bit integer lane. */\\n  export function min_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned minimum of each 32-bit integer lane. */\\n  export function min_u(a: v128, b: v128): v128;\\n  /** Computes the signed maximum of each 32-bit integer lane. */\\n  export function max_s(a: v128, b: v128): v128;\\n  /** Computes the unsigned maximum of each 32-bit integer lane. */\\n  export function max_u(a: v128, b: v128): v128;\\n  /** Computes the dot product of two 16-bit integer lanes each, yielding 32-bit integer lanes. */\\n  export function dot_i16x8_s(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 32-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 32-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Performs a bitwise left shift on each 32-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift on each 32-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 32-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 32-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 32-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Computes which 32-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 32-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are less than those of the second. */\\n  export function lt_u(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_u(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than those of the second. */\\n  export function gt_u(a: v128, b: v128): v128;\\n  /** Computes which 32-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_u(a: v128, b: v128): v128;\\n  /** Truncates each 32-bit float lane to a signed integer with saturation. */\\n  export function trunc_sat_f32x4_s(a: v128): v128;\\n  /** Truncates each 32-bit float lane to an unsigned integer with saturation. */\\n  export function trunc_sat_f32x4_u(a: v128): v128;\\n  /** Truncates the two 64-bit float lanes to the two lower signed integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */\\n  export function trunc_sat_f64x2_s_zero(a: v128): v128;\\n  /** Truncates the two 64-bit float lanes to the two lower unsigned integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */\\n  export function trunc_sat_f64x2_u_zero(a: v128): v128;\\n  /** Extends the low 16-bit signed integer lanes to 32-bit signed integer lanes. */\\n  export function extend_low_i16x8_s(a: v128): v128;\\n  /** Extends the low 16-bit unsigned integer lane to 32-bit unsigned integer lanes. */\\n  export function extend_low_i16x8_u(a: v128): v128;\\n  /** Extends the high 16-bit signed integer lanes to 32-bit signed integer lanes. */\\n  export function extend_high_i16x8_s(a: v128): v128;\\n  /** Extends the high 16-bit unsigned integer lanes to 32-bit unsigned integer lanes. */\\n  export function extend_high_i16x8_u(a: v128): v128;\\n  /** Adds the eight 16-bit signed integer lanes pairwise producing four 32-bit signed integer results. */\\n  export function extadd_pairwise_i16x8_s(a: v128): v128;\\n  /** Adds the eight 16-bit unsigned integer lanes pairwise producing four 32-bit unsigned integer results. */\\n  export function extadd_pairwise_i16x8_u(a: v128): v128;\\n  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */\\n  export function extmul_low_i16x8_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */\\n  export function extmul_low_i16x8_u(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */\\n  export function extmul_high_i16x8_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */\\n  export function extmul_high_i16x8_u(a: v128, b: v128): v128;\\n  /** Selects 32-bit lanes from either vector according to the specified [0-3] respectively [4-7] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n}\\n/** Initializes a 128-bit vector from two 64-bit integer values. Arguments must be compile-time constants. */\\ndeclare function i64x2(a: i64, b: i64): v128;\\ndeclare namespace i64x2 {\\n  /** Creates a vector with two identical 64-bit integer lanes. */\\n  export function splat(x: i64): v128;\\n  /** Extracts one 64-bit integer lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): i64;\\n  /** Replaces one 64-bit integer lane. */\\n  export function replace_lane(x: v128, idx: u8, value: i64): v128;\\n  /** Adds each 64-bit integer lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 64-bit integer lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 64-bit integer lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 64-bit integer lane. */\\n  export function abs(a: v128): v128;\\n  /** Negates each 64-bit integer lane. */\\n  export function neg(a: v128): v128;\\n  /** Performs a bitwise left shift on each 64-bit integer lane by a scalar. */\\n  export function shl(a: v128, b: i32): v128;\\n  /** Performs a bitwise arithmetic right shift on each 64-bit integer lane by a scalar. */\\n  export function shr_s(a: v128, b: i32): v128;\\n  /** Performs a bitwise logical right shift on each 64-bit integer lane by a scalar. */\\n  export function shr_u(a: v128, b: i32): v128;\\n  /** Reduces a vector to a scalar indicating whether all 64-bit integer lanes are considered `true`. */\\n  export function all_true(a: v128): bool;\\n  /** Extracts the high bit of each 64-bit integer lane and produces a scalar mask with all bits concatenated. */\\n  export function bitmask(a: v128): i32;\\n  /** Computes which 64-bit integer lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 64-bit integer lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are less than those of the second. */\\n  export function lt_s(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are less than or equal those of the second. */\\n  export function le_s(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are greater than those of the second. */\\n  export function gt_s(a: v128, b: v128): v128;\\n  /** Computes which 64-bit signed integer lanes of the first vector are greater than or equal those of the second. */\\n  export function ge_s(a: v128, b: v128): v128;\\n  /** Extends the low 32-bit signed integer lanes to 64-bit signed integer lanes. */\\n  export function extend_low_i32x4_s(a: v128): v128;\\n  /** Extends the low 32-bit unsigned integer lane to 64-bit unsigned integer lanes. */\\n  export function extend_low_i32x4_u(a: v128): v128;\\n  /** Extends the high 32-bit signed integer lanes to 64-bit signed integer lanes. */\\n  export function extend_high_i32x4_s(a: v128): v128;\\n  /** Extends the high 32-bit unsigned integer lanes to 64-bit unsigned integer lanes. */\\n  export function extend_high_i32x4_u(a: v128): v128;\\n  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */\\n  export function extmul_low_i32x4_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */\\n  export function extmul_low_i32x4_u(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */\\n  export function extmul_high_i32x4_s(a: v128, b: v128): v128;\\n  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */\\n  export function extmul_high_i32x4_u(a: v128, b: v128): v128;\\n  /** Selects 64-bit lanes from either vector according to the specified [0-1] respectively [2-3] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n}\\n/** Initializes a 128-bit vector from four 32-bit float values. Arguments must be compile-time constants. */\\ndeclare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\\ndeclare namespace f32x4 {\\n  /** Creates a vector with four identical 32-bit float lanes. */\\n  export function splat(x: f32): v128;\\n  /** Extracts one 32-bit float lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): f32;\\n  /** Replaces one 32-bit float lane. */\\n  export function replace_lane(x: v128, idx: u8, value: f32): v128;\\n  /** Adds each 32-bit float lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 32-bit float lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 32-bit float lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Divides each 32-bit float lane. */\\n  export function div(a: v128, b: v128): v128;\\n  /** Negates each 32-bit float lane. */\\n  export function neg(a: v128): v128;\\n  /** Computes the minimum of each 32-bit float lane. */\\n  export function min(a: v128, b: v128): v128;\\n  /** Computes the maximum of each 32-bit float lane. */\\n  export function max(a: v128, b: v128): v128;\\n  /** Computes the pseudo-minimum of each 32-bit float lane. */\\n  export function pmin(a: v128, b: v128): v128;\\n  /** Computes the pseudo-maximum of each 32-bit float lane. */\\n  export function pmax(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 32-bit float lane. */\\n  export function abs(a: v128): v128;\\n  /** Computes the square root of each 32-bit float lane. */\\n  export function sqrt(a: v128): v128;\\n  /** Performs the ceiling operation on each 32-bit float lane. */\\n  export function ceil(a: v128): v128;\\n  /** Performs the floor operation on each each 32-bit float lane. */\\n  export function floor(a: v128): v128;\\n  /** Rounds to the nearest integer towards zero of each 32-bit float lane. */\\n  export function trunc(a: v128): v128;\\n  /** Rounds to the nearest integer tied to even of each 32-bit float lane. */\\n  export function nearest(a: v128): v128;\\n  /** Computes which 32-bit float lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are less than those of the second. */\\n  export function lt(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are less than or equal those of the second. */\\n  export function le(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are greater than those of the second. */\\n  export function gt(a: v128, b: v128): v128;\\n  /** Computes which 32-bit float lanes of the first vector are greater than or equal those of the second. */\\n  export function ge(a: v128, b: v128): v128;\\n  /** Converts each 32-bit signed integer lane of a vector to single-precision floating point. */\\n  export function convert_i32x4_s(a: v128): v128;\\n  /** Converts each 32-bit unsigned integer lane of a vector to single-precision floating point. */\\n  export function convert_i32x4_u(a: v128): v128;\\n  /** Demotes each 64-bit float lane of a vector to single-precision. The higher lanes of the result are initialized to zero. */\\n  export function demote_f64x2_zero(a: v128): v128;\\n  /** Selects 32-bit lanes from either vector according to the specified [0-3] respectively [4-7] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n}\\n/** Initializes a 128-bit vector from two 64-bit float values. Arguments must be compile-time constants. */\\ndeclare function f64x2(a: f64, b: f64): v128;\\ndeclare namespace f64x2 {\\n  /** Creates a vector with two identical 64-bit float lanes. */\\n  export function splat(x: f64): v128;\\n  /** Extracts one 64-bit float lane as a scalar. */\\n  export function extract_lane(x: v128, idx: u8): f64;\\n  /** Replaces one 64-bit float lane. */\\n  export function replace_lane(x: v128, idx: u8, value: f64): v128;\\n  /** Adds each 64-bit float lane. */\\n  export function add(a: v128, b: v128): v128;\\n  /** Subtracts each 64-bit float lane. */\\n  export function sub(a: v128, b: v128): v128;\\n  /** Multiplies each 64-bit float lane. */\\n  export function mul(a: v128, b: v128): v128;\\n  /** Divides each 64-bit float lane. */\\n  export function div(a: v128, b: v128): v128;\\n  /** Negates each 64-bit float lane. */\\n  export function neg(a: v128): v128;\\n  /** Computes the minimum of each 64-bit float lane. */\\n  export function min(a: v128, b: v128): v128;\\n  /** Computes the maximum of each 64-bit float lane. */\\n  export function max(a: v128, b: v128): v128;\\n  /** Computes the pseudo-minimum of each 64-bit float lane. */\\n  export function pmin(a: v128, b: v128): v128;\\n  /** Computes the pseudo-maximum of each 64-bit float lane. */\\n  export function pmax(a: v128, b: v128): v128;\\n  /** Computes the absolute value of each 64-bit float lane. */\\n  export function abs(a: v128): v128;\\n  /** Computes the square root of each 64-bit float lane. */\\n  export function sqrt(a: v128): v128;\\n  /** Performs the ceiling operation on each 64-bit float lane. */\\n  export function ceil(a: v128): v128;\\n  /** Performs the floor operation on each each 64-bit float lane. */\\n  export function floor(a: v128): v128;\\n  /** Rounds to the nearest integer towards zero of each 64-bit float lane. */\\n  export function trunc(a: v128): v128;\\n  /** Rounds to the nearest integer tied to even of each 64-bit float lane. */\\n  export function nearest(a: v128): v128;\\n  /** Computes which 64-bit float lanes are equal. */\\n  export function eq(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes are not equal. */\\n  export function ne(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are less than those of the second. */\\n  export function lt(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are less than or equal those of the second. */\\n  export function le(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are greater than those of the second. */\\n  export function gt(a: v128, b: v128): v128;\\n  /** Computes which 64-bit float lanes of the first vector are greater than or equal those of the second. */\\n  export function ge(a: v128, b: v128): v128;\\n  /** Converts the low 32-bit signed integer lanes of a vector to double-precision floating point. */\\n  export function convert_low_i32x4_s(a: v128): v128;\\n  /** Converts the low 32-bit unsigned integer lanes of a vector to double-precision floating point. */\\n  export function convert_low_i32x4_u(a: v128): v128;\\n  /** Promotes the low 32-bit float lanes of a vector to double-precision. */\\n  export function promote_low_f32x4(a: v128): v128;\\n  /** Selects 64-bit lanes from either vector according to the specified [0-1] respectively [2-3] lane indexes. */\\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\\n  export function swizzle(a: v128, s: v128): v128;\\n}\\n\\ndeclare abstract class i31 {\\n  /** Creates a new i31ref from the specified integer value. */\\n  static new(value: i32): i31ref;\\n  /** Gets the integer value of an i31ref. */\\n  static get(i31expr: i31ref): i32;\\n}\\n\\n/** Macro type evaluating to the underlying native WebAssembly type. */\\ndeclare type native<T> = T;\\n/** Special type evaluating the indexed access index type. */\\ndeclare type indexof<T extends ArrayLike<unknown>> = keyof T;\\n/** Special type evaluating the indexed access value type. */\\ndeclare type valueof<T extends ArrayLike<unknown>> = T[0];\\n/** A special type evaluated to the return type of T if T is a callable function. */\\ndeclare type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\\n/** A special type evaluated to the return type of T if T is a callable function. */\\ndeclare type returnof<T extends (...args: any) => any> = ReturnType<T>;\\n/** A special type that excludes null and undefined from T. */\\ndeclare type NonNullable<T> = T extends null | undefined ? never : T;\\n/** A special type that excludes null and undefined from T. */\\ndeclare type nonnull<T> = NonNullable<T>;\\n\\n/** Pseudo-class representing the backing class of integer types. */\\n/** @internal */\\ndeclare class _Integer {\\n  /** Smallest representable value. */\\n  static readonly MIN_VALUE: number;\\n  /** Largest representable value. */\\n  static readonly MAX_VALUE: number;\\n  /** @deprecated Converts a string to an integer of this type. Please use \\\"i32.parse\\\" method. */\\n  static parseInt(value: string, radix?: number): number;\\n  /** Converts this integer to a string. */\\n  toString(radix?: number): string;\\n}\\n\\n/** Pseudo-class representing the backing class of floating-point types. */\\n/** @internal */\\ndeclare class _Float {\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  static readonly EPSILON: f32 | f64;\\n  /** Smallest representable value. */\\n  static readonly MIN_VALUE: f32 | f64;\\n  /** Largest representable value. */\\n  static readonly MAX_VALUE: f32 | f64;\\n  /** Smallest safely representable integer value. */\\n  static readonly MIN_SAFE_INTEGER: f32 | f64;\\n  /** Largest safely representable integer value. */\\n  static readonly MAX_SAFE_INTEGER: f32 | f64;\\n  /** Value representing positive infinity. */\\n  static readonly POSITIVE_INFINITY: f32 | f64;\\n  /** Value representing negative infinity. */\\n  static readonly NEGATIVE_INFINITY: f32 | f64;\\n  /** Value representing 'not a number'. */\\n  static readonly NaN: f32 | f64;\\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\\n  static isNaN(value: f32 | f64): bool;\\n  /** Returns true if passed value is finite. */\\n  static isFinite(value: f32 | f64): bool;\\n  /** Returns true if the value passed is a safe integer. */\\n  static isSafeInteger(value: f32 | f64): bool;\\n  /** Returns true if the value passed is an integer, false otherwise. */\\n  static isInteger(value: f32 | f64): bool;\\n  /** @deprecated Converts a string to an integer. Please use \\\"i32.parse\\\" / \\\"i64.parse\\\" methods. */\\n  static parseInt(value: string, radix?: i32): f32 | f64;\\n  /** @deprecated Converts a string to a floating-point number. Please use \\\"f32.parse\\\" / \\\"f64.parse\\\" methods. */\\n  static parseFloat(value: string): f32 | f64;\\n  /** Converts this floating-point number to a string. */\\n  toString(radix?: number): string;\\n}\\n\\ndeclare class Boolean {\\n  toString(radix?: number): string;\\n}\\n\\n/** Backing class of signed 8-bit integers. */\\ndeclare const I8: typeof _Integer;\\n/** Backing class of signed 16-bit integers. */\\ndeclare const I16: typeof _Integer;\\n/** Backing class of signed 32-bit integers. */\\ndeclare const I32: typeof _Integer;\\n/** Backing class of signed 64-bit integers. */\\ndeclare const I64: typeof _Integer;\\n/** Backing class of signed size integers. */\\ndeclare const Isize: typeof _Integer;\\n/** Backing class of unsigned 8-bit integers. */\\ndeclare const U8: typeof _Integer;\\n/** Backing class of unsigned 16-bit integers. */\\ndeclare const U16: typeof _Integer;\\n/** Backing class of unsigned 32-bit integers. */\\ndeclare const U32: typeof _Integer;\\n/** Backing class of unsigned 64-bit integers. */\\ndeclare const U64: typeof _Integer;\\n/** Backing class of unsigned size integers. */\\ndeclare const Usize: typeof _Integer;\\n/** Backing class of 32-bit floating-point values. */\\ndeclare const F32: typeof _Float;\\n/** Backing class of 64-bit floating-point values. */\\ndeclare const F64: typeof _Float;\\n/** Alias of F64. */\\ndeclare const Number: typeof F64;\\ndeclare type Number = _Float;\\n\\n// User-defined diagnostic macros\\n\\n/** Emits a user-defined diagnostic error when encountered. */\\ndeclare function ERROR(message?: any): never;\\n/** Emits a user-defined diagnostic warning when encountered. */\\ndeclare function WARNING(message?: any): void;\\n/** Emits a user-defined diagnostic info when encountered. */\\ndeclare function INFO(message?: any): void;\\n\\n// Standard library\\n\\n/** Memory operations. */\\ndeclare namespace memory {\\n  /** Whether the memory managed interface is implemented. */\\n  export const implemented: bool;\\n  /** Returns the current memory size in units of pages. One page is 64kb. */\\n  export function size(): i32;\\n  /** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\\n  export function grow(value: i32): i32;\\n  /** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\\n  export function fill(dst: usize, value: u8, count: usize): void;\\n  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\\n  export function copy(dst: usize, src: usize, n: usize): void;\\n  /** Repeats `src` of length `srcLength` `count` times at `dst`. */\\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void;\\n  /** Copies elements from a passive element segment to a table. */\\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void;\\n  /** Prevents further use of a passive element segment. */\\n  export function drop(segmentIndex: u32): void;\\n  /** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\\n  export function compare(vl: usize, vr: usize, n: usize): i32;\\n  /** Gets a pointer to a zeroed static chunk of memory of the given size. Alignment defaults to `16`. Arguments must be compile-time constants. */\\n  export function data(size: i32, align?: i32): usize;\\n  /** Gets a pointer to a pre-initialized static chunk of memory. Alignment defaults to the size of `T`. Arguments must be compile-time constants. */\\n  export function data<T>(values: T[], align?: i32): usize;\\n}\\n\\n/** Heap memory interface. */\\ndeclare namespace heap {\\n  /** Allocates a chunk of memory of at least the specified size. */\\n  export function alloc(size: usize): usize;\\n  /** Reallocates a chunk of memory to have at least the specified size. */\\n  export function realloc(ptr: usize, size: usize): usize;\\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub/none runtime. */\\n  export function free(ptr: usize): void;\\n}\\n\\n/** Table operations. */\\ndeclare namespace table {\\n  /** Copies elements from a passive element segment to a table. */\\n  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void;\\n  /** Prevents further use of a passive element segment. */\\n  export function drop(elementIndex: u32): void;\\n  /** Copies elements from one region of a table to another region. */\\n  export function copy(dest: u32, src: u32, n: u32): void;\\n}\\n\\ndeclare namespace Atomics {\\n  export function load<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32): T;\\n  export function store<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): void;\\n  export function add<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function sub<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function and<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function or<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function xor<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function exchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\\n  export function compareExchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, expectedValue: T, replacementValue: T): T;\\n  export function wait<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, value: T, timeout?: i64): AtomicWaitResult;\\n  export function notify<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, count?: i32): i32;\\n  /** The static Atomics.isLockFree() method is used to determine whether to use locks or atomic operations. It returns true, if the given size is one of the BYTES_PER_ELEMENT */\\n  export function isLockFree(size: usize): bool;\\n}\\n\\n/** Class representing a generic, fixed-length raw binary data buffer. */\\ndeclare class ArrayBuffer {\\n  /** The size, in bytes, of the array. */\\n  readonly byteLength: i32;\\n  /** Returns true if value is one of the ArrayBuffer views, such as typed array or a DataView **/\\n  static isView<T>(value: T): bool;\\n  /** Constructs a new array buffer of the given length in bytes. */\\n  constructor(length: i32);\\n  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */\\n  slice(begin?: i32, end?: i32): ArrayBuffer;\\n  /** Returns a string representation of ArrayBuffer. */\\n  toString(): string;\\n}\\n\\n/** The `DataView` view provides a low-level interface for reading and writing multiple number types in a binary `ArrayBuffer`, without having to care about the platform's endianness. */\\ndeclare class DataView {\\n  /** The `buffer` accessor property represents the `ArrayBuffer` or `SharedArrayBuffer` referenced by the `DataView` at construction time. */\\n  readonly buffer: ArrayBuffer;\\n  /** Returns raw pointer to data storage including offset (unsafe). */\\n  readonly dataStart: usize;\\n  /** The `byteLength` accessor property represents the length (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\\n  readonly byteLength: i32;\\n  /** The `byteOffset` accessor property represents the offset (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\\n  readonly byteOffset: i32;\\n  /** Constructs a new `DataView` with the given properties */\\n  constructor(buffer: ArrayBuffer, byteOffset?: i32, byteLength?: i32);\\n  /** The `getFloat32()` method gets a signed 32-bit float (float) at the specified byte offset from the start of the `DataView`. */\\n  getFloat32(byteOffset: i32, littleEndian?: bool): f32;\\n  /** The `getFloat64()` method gets a signed 64-bit float (double) at the specified byte offset from the start of the `DataView`. */\\n  getFloat64(byteOffset: i32, littleEndian?: bool): f64;\\n  /** The `getInt8()` method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the `DataView`. */\\n  getInt8(byteOffset: i32): i8;\\n  /** The `getInt16()` method gets a signed 16-bit integer (short) at the specified byte offset from the start of the `DataView`. */\\n  getInt16(byteOffset: i32, littleEndian?: bool): i16;\\n  /** The `getInt32()` method gets a signed 32-bit integer (long) at the specified byte offset from the start of the `DataView`. */\\n  getInt32(byteOffset: i32, littleEndian?: bool): i32;\\n  /** The `getInt64()` method gets a signed 64-bit integer (long long) at the specified byte offset from the start of the `DataView`. */\\n  getInt64(byteOffset: i32, littleEndian?: bool): i64;\\n  /** The `getUint8()` method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the `DataView`. */\\n  getUint8(byteOffset: i32): u8;\\n  /** The `getUint16()` method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the `DataView`. */\\n  getUint16(byteOffset: i32, littleEndian?: bool): u16;\\n  /** The `getUint32()` method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the `DataView`. */\\n  getUint32(byteOffset: i32, littleEndian?: bool): u32;\\n  /** The `getUint64()` method gets an unsigned 64-bit integer (unsigned long long) at the specified byte offset from the start of the `DataView`. */\\n  getUint64(byteOffset: i32, littleEndian?: bool): u64;\\n  /** The `setFloat32()` method stores a signed 32-bit float (float) value at the specified byte offset from the start of the `DataView`. */\\n  setFloat32(byteOffset: i32, value: f32, littleEndian?: bool): void;\\n  /** The `setFloat64()` method stores a signed 64-bit float (double) value at the specified byte offset from the start of the `DataView`. */\\n  setFloat64(byteOffset: i32, value: f64, littleEndian?: bool): void;\\n  /** The `setInt8()` method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\\n  setInt8(byteOffset: i32, value: i8): void;\\n  /** The `setInt16()` method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the `DataView`. */\\n  setInt16(byteOffset: i32, value: i16, littleEndian?: bool): void;\\n  /** The `setInt32()` method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the `DataView`. */\\n  setInt32(byteOffset: i32, value: i32, littleEndian?: bool): void;\\n  /** The `setInt64()` method stores a signed 64-bit integer (long long) value at the specified byte offset from the start of the `DataView`. */\\n  setInt64(byteOffset: i32, value: i64, littleEndian?: bool): void;\\n  /** The `setUint8()` method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\\n  setUint8(byteOffset: i32, value: u8): void;\\n  /** The `setUint16()` method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the `DataView`. */\\n  setUint16(byteOffset: i32, value: u16, littleEndian?: bool): void;\\n  /** The `setUint32()` method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the `DataView`. */\\n  setUint32(byteOffset: i32, value: u32, littleEndian?: bool): void;\\n  /** The `setUint64()` method stores an unsigned 64-bit integer (unsigned long long) value at the specified byte offset from the start of the `DataView`. */\\n  setUint64(byteOffset: i32, value: u64, littleEndian?: bool): void;\\n  /** Returns a string representation of DataView. */\\n  toString(): string;\\n}\\n\\ninterface ArrayLike<T> {\\n  [key: number]: T;\\n  length: i32;\\n}\\n\\n/** Interface for a typed view on an array buffer. */\\ninterface ArrayBufferView {\\n  /** The {@link ArrayBuffer} referenced by this view. */\\n  readonly buffer: ArrayBuffer;\\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteOffset: i32;\\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteLength: i32;\\n  /** Returns raw pointer to data storage including offset (unsafe). */\\n  readonly dataStart: usize;\\n}\\n\\n/** @internal */\\ndeclare abstract class TypedArray<T> implements ArrayBufferView {\\n  [key: number]: T;\\n  /** Number of bytes per element. */\\n  static readonly BYTES_PER_ELEMENT: usize;\\n  /** Constructs a new typed array. */\\n  constructor(length: i32);\\n  /** The {@link ArrayBuffer} referenced by this view. */\\n  readonly buffer: ArrayBuffer;\\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteOffset: i32;\\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\\n  readonly byteLength: i32;\\n  /** Returns raw pointer to data storage including offset (unsafe). */\\n  readonly dataStart: usize;\\n  /** The length (in elements). */\\n  readonly length: i32;\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): T;\\n  /** The includes() method determines whether a typed array includes a certain element, returning true or false as appropriate. */\\n  includes(searchElement: T, fromIndex?: i32): bool;\\n  /** The indexOf() method returns the first index at which a given element can be found in the typed array, or -1 if it is not present. */\\n  indexOf(searchElement: T, fromIndex?: i32): i32;\\n  /** The lastIndexOf() method returns the last index at which a given element can be found in the typed array, or -1 if it is not present. The typed array is searched backwards, starting at fromIndex. */\\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\\n  /** Returns copied section of an TypedArray from begin inclusive to end exclusive */\\n  slice(begin?: i32, end?: i32): TypedArray<T>;\\n  /** Returns a new TypedArray of this type on the same ArrayBuffer from begin inclusive to end exclusive. */\\n  subarray(begin?: i32, end?: i32): TypedArray<T>;\\n  /** The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end. The end argument is optional and defaults to the length of the array. */\\n  copyWithin(target: i32, start: i32, end?: i32): this;\\n  /**  The reduce() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value. This method has the same algorithm as Array.prototype.reduce(). */\\n  reduce<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;\\n  /**  The reduceRight() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value, starting from the end of the array. This method has the same algorithm as Array.prototype.reduceRight(). */\\n  reduceRight<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;\\n  /** The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some().*/\\n  some(callbackfn: (value: T, index: i32, self: this) => bool): bool;\\n  /** The map() method creates a new typed array with the results of calling a provided function on every element in this typed array. This method has the same algorithm as Array.prototype.map().*/\\n  map(callbackfn: (value: T, index: i32, self: this) => T): TypedArray<T>;\\n  /** The filter() method creates a new typed array with all elements that pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.filter(). */\\n  filter(callbackfn: (value: T, index: i32, self: this) => bool): TypedArray<T>;\\n  /** The sort() method sorts the elements of a typed array numerically in place and returns the typed array. This method has the same algorithm as Array.prototype.sort(), except that sorts the values numerically instead of as strings. TypedArray is one of the typed array types here. */\\n  sort(callback?: (a: T, b: T) => i32): this;\\n  /** The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). */\\n  fill(value: T, start?: i32, end?: i32): this;\\n  /** The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */\\n  findIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;\\n  /** The findLastIndex() method returns an index start searching from the end in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */\\n  findLastIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;\\n  /** The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). */\\n  every(callbackfn: (value: T, index: i32, self: this) => bool): bool;\\n  /** The forEach() method executes a provided function once per array element. This method has the same algorithm as Array.prototype.forEach().*/\\n  forEach(callbackfn: (value: T, index: i32, self: this) => void): void;\\n  /** The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). */\\n  reverse(): this;\\n  /** The join() method joins all elements of an array into a string. This method has the same algorithm as Array.prototype.join(). */\\n  join(separator?: string): string;\\n  /** The set() method stores multiple values in the typed array, reading input values from a specified array. */\\n  set<U extends ArrayLike<number>>(source: U, offset?: i32): void\\n  /** The toString() method returns a string representing the specified array and its elements. This method has the same algorithm as Array.prototype.toString() */\\n  toString(): string;\\n}\\n\\n/** An array of twos-complement 8-bit signed integers. */\\ndeclare class Int8Array extends TypedArray<i8> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;\\n}\\n/** An array of 8-bit unsigned integers. */\\ndeclare class Uint8Array extends TypedArray<u8> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;\\n}\\n/** A clamped array of 8-bit unsigned integers. */\\ndeclare class Uint8ClampedArray extends TypedArray<u8> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;\\n}\\n/** An array of twos-complement 16-bit signed integers. */\\ndeclare class Int16Array extends TypedArray<i16> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;\\n}\\n/** An array of 16-bit unsigned integers. */\\ndeclare class Uint16Array extends TypedArray<u16> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;\\n}\\n/** An array of twos-complement 32-bit signed integers. */\\ndeclare class Int32Array extends TypedArray<i32> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;\\n}\\n/** An array of 32-bit unsigned integers. */\\ndeclare class Uint32Array extends TypedArray<u32> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;\\n}\\n/** An array of twos-complement 64-bit signed integers. */\\ndeclare class Int64Array extends TypedArray<i64> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int64Array;\\n}\\n/** An array of 64-bit unsigned integers. */\\ndeclare class Uint64Array extends TypedArray<u64> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint64Array;\\n}\\n/** An array of 32-bit floating point numbers. */\\ndeclare class Float32Array extends TypedArray<f32> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;\\n}\\n/** An array of 64-bit floating point numbers. */\\ndeclare class Float64Array extends TypedArray<f64> {\\n  /** Wrap an ArrayBuffer */\\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;\\n}\\n\\n/** Class representing a sequence of values of type `T`. */\\ndeclare class Array<T> {\\n\\n  /** Tests if a value is an array. */\\n  static isArray<U>(value: any): value is Array<any>;\\n\\n  [key: number]: T;\\n  /** Current length of the array. */\\n  length: i32;\\n  /** Returns raw pointer to data storage (unsafe). */\\n  readonly dataStart: usize;\\n  /** Constructs a new array. */\\n  constructor(length?: i32);\\n  at(index: i32): T;\\n  fill(value: T, start?: i32, end?: i32): this;\\n  findIndex(callbackfn: (value: T, index: i32, array: Array<T>) => bool): i32;\\n  findLastIndex(callbackfn: (value: T, index: i32, array: Array<T>) => bool): i32;\\n  includes(searchElement: T, fromIndex?: i32): bool;\\n  indexOf(searchElement: T, fromIndex?: i32): i32;\\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\\n  push(element: T): i32;\\n  concat(items: T[]): T[];\\n  copyWithin(target: i32, start: i32, end?: i32): this;\\n  pop(): T;\\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;\\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;\\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;\\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\\n  every(callbackfn: (value: T, index: i32, array: Array<T>) => bool): bool;\\n  some(callbackfn: (value: T, index: i32, array: Array<T>) => bool): bool;\\n  shift(): T;\\n  unshift(element: T): i32;\\n  slice(from?: i32, to?: i32): Array<T>;\\n  splice(start: i32, deleteCount?: i32): Array<T>;\\n  sort(comparator?: (a: T, b: T) => i32): this;\\n  join(separator?: string): string;\\n  reverse(): this;\\n  /** Flattens an array of arrays. If any null entries exist in the array, they are ignored, unlike JavaScript's version of Array#flat(). */\\n  flat(): T extends unknown[] ? T : never;\\n  toString(): string;\\n}\\n\\n/** Class representing a static (not resizable) sequence of values of type `T`. This class is @final. */\\ndeclare class StaticArray<T> {\\n  [key: number]: T;\\n  static fromArray<T>(source: Array<T>): StaticArray<T>;\\n  /** @deprecated */\\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T>;\\n  /** @deprecated */\\n  static slice<T>(source: StaticArray<T>, start?: i32, end?: i32): StaticArray<T>;\\n  readonly length: i32;\\n  constructor(length?: i32);\\n  at(index: i32): T;\\n  fill(value: T, start?: i32, end?: i32): this;\\n  findIndex(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): i32;\\n  findLastIndex(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): i32;\\n  copyWithin(target: i32, start: i32, end?: i32): this;\\n  includes(searchElement: T, fromIndex?: i32): bool;\\n  indexOf(searchElement: T, fromIndex?: i32): i32;\\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\\n  forEach(callbackfn: (value: T, index: i32, array: StaticArray<T>) => void): void;\\n  map<U>(callbackfn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U>;\\n  filter(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T>;\\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U, initialValue: U): U;\\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U, initialValue: U): U;\\n  every(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): bool;\\n  some(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): bool;\\n  concat(items: Array<T>): Array<T>;\\n  concat<U extends ArrayLike<T>>(other: U): U;\\n  slice(from?: i32, to?: i32): Array<T>;\\n  slice<U extends ArrayLike<T>>(from?: i32, to?: i32): U;\\n  sort(comparator?: (a: T, b: T) => i32): this;\\n  join(separator?: string): string;\\n  reverse(): this;\\n  toString(): string;\\n}\\n\\n/** Class representing a sequence of characters. */\\ndeclare class String {\\n  static fromCharCode(ls: i32, hs?: i32): string;\\n  static fromCharCodes(arr: i32[]): string;\\n  static fromCodePoint(code: i32): string;\\n  static fromCodePoints(arr: i32[]): string;\\n  static raw(parts: TemplateStringsArray, ...args: any[]): string;\\n  readonly length: i32;\\n  at(index: i32): string;\\n  charAt(index: i32): string;\\n  charCodeAt(index: i32): i32;\\n  codePointAt(index: i32): i32;\\n  concat(other: string): string;\\n  endsWith(other: string): bool;\\n  indexOf(other: string, fromIndex?: i32): i32;\\n  lastIndexOf(other: string, fromIndex?: i32): i32;\\n  localeCompare(other: string): i32;\\n  includes(other: string): bool;\\n  startsWith(other: string): bool;\\n  substr(start: i32, length?: i32): string;\\n  substring(start: i32, end?: i32): string;\\n  trim(): string;\\n  trimLeft(): string;\\n  trimRight(): string;\\n  trimStart(): string;\\n  trimEnd(): string;\\n  padStart(targetLength: i32, padString?: string): string;\\n  padEnd(targetLength: i32, padString?: string): string;\\n  repeat(count?: i32): string;\\n  replace(search: string, replacement: string): string;\\n  replaceAll(search: string, replacement: string): string;\\n  slice(beginIndex: i32, endIndex?: i32): string;\\n  split(separator?: string, limit?: i32): string[];\\n  toLowerCase(): string;\\n  toUpperCase(): string;\\n  toString(): string;\\n}\\n\\ndeclare namespace String {\\n  /** Encoding helpers for UTF-8. */\\n  export namespace UTF8 {\\n    /** UTF-8 encoding error modes. */\\n    export const enum ErrorMode {\\n      /** Keeps unpaired surrogates as of WTF-8. This is the default. */\\n      WTF8,\\n      /** Replaces unpaired surrogates with the replacement character (U+FFFD). */\\n      REPLACE,\\n      /** Throws an error on unpaired surrogates. */\\n      ERROR\\n    }\\n    /** Calculates the byte length of the specified string when encoded as UTF-8, optionally null terminated. */\\n    export function byteLength(str: string, nullTerminated?: bool): i32;\\n    /** Encodes the specified string to UTF-8 bytes, optionally null terminated. ErrorMode defaults to WTF-8. */\\n    export function encode(str: string, nullTerminated?: bool, errorMode?: ErrorMode): ArrayBuffer;\\n    /** Encodes the specified raw string to UTF-8 bytes, opionally null terminated. ErrorMode defaults to WTF-8. Returns the number of bytes written. */\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated?: bool, errorMode?: ErrorMode): usize;\\n    /** Decodes the specified buffer from UTF-8 bytes to a string, optionally null terminated. */\\n    export function decode(buf: ArrayBuffer, nullTerminated?: bool): string;\\n    /** Decodes raw UTF-8 bytes to a string, optionally null terminated. */\\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated?: bool): string;\\n  }\\n  /** Encoding helpers for UTF-16. */\\n  export namespace UTF16 {\\n    /** Calculates the byte length of the specified string when encoded as UTF-16. */\\n    export function byteLength(str: string): i32;\\n    /** Encodes the specified string to UTF-16 bytes. */\\n    export function encode(str: string): ArrayBuffer;\\n    /** Encodes the specified raw string to UTF-16 bytes. Returns the number of bytes written. */\\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize;\\n    /** Decodes the specified buffer from UTF-16 bytes to a string. */\\n    export function decode(buf: ArrayBuffer): string;\\n    /** Decodes raw UTF-16 bytes to a string. */\\n    export function decodeUnsafe(buf: usize, len: usize): string;\\n  }\\n}\\n\\ndeclare class TemplateStringsArray extends Array<string> {\\n  readonly raw: string[];\\n}\\n\\ndeclare class Object {\\n  /** The Object.is() method determines whether two values are the same value. */\\n  static is<T>(value1: T, value2: T): bool;\\n}\\n\\ndeclare namespace performance {\\n  /** Gets a high resolution timestamp measured in milliseconds. */\\n  export function now(): f64;\\n}\\n\\ndeclare class Date {\\n  /** Returns the UTC timestamp in milliseconds of the specified date. */\\n  static UTC(\\n    year: i32,\\n    month: i32,\\n    day: i32,\\n    hour: i32,\\n    minute: i32,\\n    second: i32,\\n    millisecond: i32\\n  ): i64;\\n  /** Returns the current UTC timestamp in milliseconds. */\\n  static now(): i64;\\n  /** Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC. */\\n  static parse(dateString: string): Date;\\n  static fromString(dateString: string): Date;\\n  /** Constructs a new date object from an UTC timestamp in milliseconds. */\\n  constructor(value: i64);\\n  /** Returns the UTC timestamp of this date in milliseconds. */\\n  getTime(): i64;\\n  /** Sets the UTC timestamp of this date in milliseconds. */\\n  setTime(value: i64): i64;\\n\\n  getUTCFullYear(): i32;\\n  getUTCMonth(): i32;\\n  getUTCDate(): i32;\\n  getUTCDay(): i32;\\n  getUTCHours(): i32;\\n  getUTCMinutes(): i32;\\n  getUTCSeconds(): i32;\\n  getUTCMilliseconds(): i32;\\n\\n  setUTCFullYear(value: i32): void;\\n  setUTCMonth(value: i32, day?: i32): void;\\n  setUTCDate(value: i32): void;\\n  setUTCHours(value: i32): void;\\n  setUTCMinutes(value: i32): void;\\n  setUTCSeconds(value: i32): void;\\n  setUTCMilliseconds(value: i32): void;\\n\\n  toString(): string;\\n  toISOString(): string;\\n  toUTCString(): string;\\n  toDateString(): string;\\n  toTimeString(): string;\\n}\\n\\n/** Class for representing a runtime error. Base class of all errors. */\\ndeclare class Error {\\n\\n  /** Error name. */\\n  name: string;\\n\\n  /** Message provided on construction. */\\n  message: string;\\n\\n  /** Stack trace. */\\n  stack?: string;\\n\\n  /** Constructs a new error, optionally with a message. */\\n  constructor(message?: string);\\n\\n  /** Method returns a string representing the specified Error class. */\\n  toString(): string;\\n}\\n\\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\\ndeclare class RangeError extends Error { }\\n\\n/** Class for indicating an error when a value is not of the expected type. */\\ndeclare class TypeError extends Error { }\\n\\n/** Class for indicating an error when trying to interpret syntactically invalid code. */\\ndeclare class SyntaxError extends Error { }\\n\\n/** Class for indicating an error when a global URI handling function was used in a wrong way. */\\ndeclare class URIError extends Error { }\\n\\ninterface Function {\\n  /** Function table index. */\\n  readonly index: u32;\\n  /** Function name. Always an empty string. */\\n  readonly name: string;\\n  /** Number of expected parameters. */\\n  readonly length: u32;\\n  /** Calls this function indirectly with the specified arguments. */\\n  call(thisArg: unknown, ...args: unknown[]): any;\\n  /** Returns a string representation of this function. */\\n  toString(): string;\\n}\\ninterface IArguments {}\\ninterface RegExp {}\\n\\ndeclare class Map<K,V> {\\n  readonly size: i32;\\n  has(key: K): bool;\\n  set(key: K, value: V): this;\\n  get(key: K): V;\\n  delete(key: K): bool;\\n  clear(): void;\\n  keys(): K[]; // preliminary\\n  values(): V[]; // preliminary\\n  toString(): string;\\n}\\n\\ndeclare class Set<K> {\\n  readonly size: i32;\\n  has(value: K): bool;\\n  add(value: K): this;\\n  delete(value: K): bool;\\n  clear(): void;\\n  values(): K[]; // preliminary\\n  toString(): string;\\n}\\n\\ninterface SymbolConstructor {\\n  readonly hasInstance: symbol;\\n  readonly isConcatSpreadable: symbol;\\n  readonly isRegExp: symbol;\\n  readonly iterator: symbol;\\n  readonly match: symbol;\\n  readonly replace: symbol;\\n  readonly search: symbol;\\n  readonly species: symbol;\\n  readonly split: symbol;\\n  readonly toPrimitive: symbol;\\n  readonly toStringTag: symbol;\\n  readonly unscopables: symbol;\\n  (description?: string | null): symbol;\\n  for(key: string): symbol;\\n  keyFor(sym: symbol): string | null;\\n}\\n\\ndeclare const Symbol: SymbolConstructor;\\n\\n/** @internal */\\ninterface IMath<T> {\\n  /** The base of natural logarithms, e, approximately 2.718. */\\n  readonly E: T;\\n  /** The natural logarithm of 2, approximately 0.693. */\\n  readonly LN2: T;\\n  /** The natural logarithm of 10, approximately 2.302. */\\n  readonly LN10: T;\\n  /** The base 2 logarithm of e, approximately 1.442. */\\n  readonly LOG2E: T;\\n  /** The base 10 logarithm of e, approximately 0.434. */\\n  readonly LOG10E: T;\\n  /** The ratio of the circumference of a circle to its diameter, approximately 3.14159. */\\n  readonly PI: T;\\n  /** The square root of 1/2, approximately 0.707. */\\n  readonly SQRT1_2: T;\\n  /** The square root of 2, approximately 1.414. */\\n  readonly SQRT2: T;\\n  /** Returns the absolute value of `x`. */\\n  abs(x: T): T;\\n  /** Returns the arccosine (in radians) of `x`. */\\n  acos(x: T): T;\\n  /** Returns the hyperbolic arc-cosine of `x`. */\\n  acosh(x: T): T;\\n  /** Returns the arcsine (in radians) of `x`. */\\n  asin(x: T): T;\\n  /** Returns the hyperbolic arcsine of `x`. */\\n  asinh(x: T): T;\\n  /** Returns the arctangent (in radians) of `x`. */\\n  atan(x: T): T;\\n  /** Returns the arctangent of the quotient of its arguments. */\\n  atan2(y: T, x: T): T;\\n  /** Returns the hyperbolic arctangent of `x`. */\\n  atanh(x: T): T;\\n  /** Returns the cube root of `x`. */\\n  cbrt(x: T): T;\\n  /** Returns the smallest integer greater than or equal to `x`. */\\n  ceil(x: T): T;\\n  /** Returns the number of leading zero bits in the 32-bit binary representation of `x`. */\\n  clz32(x: T): T;\\n  /** Returns the cosine (in radians) of `x`. */\\n  cos(x: T): T;\\n  /** Returns the hyperbolic cosine of `x`. */\\n  cosh(x: T): T;\\n  /** Returns e to the power of `x`. */\\n  exp(x: T): T;\\n  /** Returns e to the power of `x`, minus 1. */\\n  expm1(x: T): T;\\n  /** Returns the largest integer less than or equal to `x`. */\\n  floor(x: T): T;\\n  /** Returns the nearest 32-bit single precision float representation of `x`. */\\n  fround(x: T): T;\\n  /** Returns the square root of the sum of squares of its arguments. */\\n  hypot(value1: T, value2: T): T; // TODO: rest\\n  /** Returns the result of the C-like 32-bit multiplication of `a` and `b`. */\\n  imul(a: T, b: T): T;\\n  /** Returns the natural logarithm (base e) of `x`. */\\n  log(x: T): T;\\n  /** Returns the base 10 logarithm of `x`. */\\n  log10(x: T): T;\\n  /** Returns the natural logarithm (base e) of 1 + `x`. */\\n  log1p(x: T): T;\\n  /** Returns the base 2 logarithm of `x`. */\\n  log2(x: T): T;\\n  /** Returns the largest-valued number of its arguments. */\\n  max(value1: T, value2: T): T; // TODO: rest\\n  /** Returns the lowest-valued number of its arguments. */\\n  min(value1: T, value2: T): T; // TODO: rest\\n  /** Returns `base` to the power of `exponent`. */\\n  pow(base: T, exponent: T): T;\\n  /** Returns a pseudo-random number in the range from 0.0 inclusive up to but not including 1.0. */\\n  random(): T;\\n  /** Returns the value of `x` rounded to the nearest integer. */\\n  round(x: T): T;\\n  /** Returns the sign of `x`, indicating whether the number is positive, negative or zero. */\\n  sign(x: T): T;\\n  /** Returns whether the sign bit of `x` is set. */\\n  signbit(x: T): bool;\\n  /** Returns the sine of `x`. */\\n  sin(x: T): T;\\n  /** Returns the hyperbolic sine of `x`. */\\n  sinh(x: T): T;\\n  /** Returns the square root of `x`. */\\n  sqrt(x: T): T;\\n  /** Returns the tangent of `x`. */\\n  tan(x: T): T;\\n  /** Returns the hyperbolic tangent of `x`. */\\n  tanh(x: T): T;\\n  /** Returns the integer part of `x` by removing any fractional digits. */\\n  trunc(x: T): T;\\n}\\n\\n/** @internal */\\ninterface INativeMath<T> extends IMath<T> {\\n  /** Contains sin value produced after Math/Mathf.sincos */\\n  sincos_sin: T;\\n  /** Contains cos value produced after Math/Mathf.sincos */\\n  sincos_cos: T;\\n  /** Seeds the random number generator. */\\n  seedRandom(value: i64): void;\\n  /** Multiplies a floating point `x` by 2 raised to power exp `n`. */\\n  scalbn(x: T, n: i32): T;\\n  /** Returns the floating-point remainder of `x / y` (rounded towards zero). */\\n  mod(x: T, y: T): T;\\n  /** Returns the floating-point remainder of `x / y` (rounded to nearest). */\\n  rem(x: T, y: T): T;\\n  /** Returns sin and cos simultaneously for same angle. Results stored to `sincos_s32/64` and `sincos_c32/64` globals */\\n  sincos(x: T): void;\\n  /** Returns 2 raised to the given power x. Equivalent to 2 ** x. */\\n  exp2(x: T): T;\\n}\\n\\n/** Double precision math imported from JavaScript. */\\ndeclare const JSMath: IMath<f64>;\\n/** Double precision math implemented natively. */\\ndeclare const NativeMath: INativeMath<f64>;\\n/** Single precision math implemented natively. */\\ndeclare const NativeMathf: INativeMath<f32>;\\n/** Alias of {@link NativeMath} or {@link JSMath} respectively. Defaults to `NativeMath`. */\\ndeclare const Math: IMath<f64>;\\n/** Alias of {@link NativeMathf} or {@link JSMath} respectively. Defaults to `NativeMathf`. */\\ndeclare const Mathf: IMath<f32>;\\n\\n/** Environmental abort function. */\\ndeclare function abort(msg?: string | null, fileName?: string | null, lineNumber?: i32, columnNumber?: i32): never;\\n/** Environmental tracing function. */\\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\\n/** Environmental seeding function. */\\ndeclare function seed(): f64;\\n\\n/** Node-like process. */\\ndeclare namespace process {\\n  /** String representing the CPU architecture for which the binary was compiled. Either `wasm32` or `wasm64`. */\\n  export const arch: string;\\n  /** String representing the operating system platform for which the binary was compiled. Always `wasm`. */\\n  export const platform: string;\\n  /** Array of command line arguments passed to the binary upon instantiation. */\\n  export const argv: string[];\\n  /** Map of variables in the binary's user environment. */\\n  export const env: Map<string,string>;\\n  /** Terminates the process with either the given exit code, or `process.exitCode` if omitted. */\\n  export function exit(code?: i32): void;\\n  /** `exit()`\u2019s default value. Defaults to `0`. */\\n  export let exitCode: i32;\\n  /** Stream connected to `stdin` (fd `0`). */\\n  export const stdin: ReadableStream;\\n  /** Stream connected to `stdout` (fd `1`). */\\n  export const stdout: WritableStream;\\n  /** Stream connected to `stderr` (fd `2`). */\\n  export const stderr: WritableStream;\\n  /** Obtains the system's current time of day, in milliseconds since Unix epoch. */\\n  export function time(): i64;\\n  /** Obtains the system's monotonic high resolution time, in nanoseconds since an arbitrary time in the past. */\\n  export function hrtime(): u64;\\n\\n  interface Stream {\\n    /** Closes the stream. Throws if already closed or if the stream cannot be closed. */\\n    close(): void;\\n  }\\n  interface ReadableStream extends Stream {\\n    /** Reads available data from the stream, into `buffer` at offset `offset`, returning the number of bytes read. */\\n    read(buffer: ArrayBuffer, offset?: isize): i32;\\n  }\\n  interface WritableStream extends Stream {\\n    /** Writes string or buffer to the stream. */\\n    write<T extends string | ArrayBuffer>(data: T): void;\\n  }\\n}\\n\\n/** Browser-like console. */\\ndeclare namespace console {\\n  /** Logs `message` to console if `assertion` is false-ish. */\\n  export function assert<T>(assertion: T, message?: string): void;\\n  /** Outputs `message` to the console. */\\n  export function log(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Debug:\\\". */\\n  export function debug(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Info:\\\". */\\n  export function info(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Warning:\\\". */\\n  export function warn(message?: string): void;\\n  /** Outputs `message` to the console, prefixed with \\\"Error:\\\". */\\n  export function error(message?: string): void;\\n  /** Starts a new timer using the specified `label`. */\\n  export function time(label?: string): void;\\n  /** Logs the current value of a timer previously started with `console.time`. */\\n  export function timeLog(label?: string): void;\\n  /** Logs the current value of a timer previously started with `console.time` and discards the timer. */\\n  export function timeEnd(label?: string): void;\\n}\\n\\n/** Browser-like crypto utilities. */\\ndeclare namespace crypto {\\n  /** Fills `array` with cryptographically strong random values. */\\n  export function getRandomValues(array: Uint8Array): void;\\n}\\n\\n// Decorators\\n\\ninterface TypedPropertyDescriptor<T> {\\n  configurable?: boolean;\\n  enumerable?: boolean;\\n  writable?: boolean;\\n  value?: T;\\n  get?(): T;\\n  set?(value: T): void;\\n}\\n\\n/** Annotates a method as a binary operator overload for the specified `token`. */\\ndeclare function operator(token:\\n  \\\"[]\\\" | \\\"[]=\\\" | \\\"{}\\\" | \\\"{}=\\\" | \\\"==\\\" | \\\"!=\\\" | \\\">\\\" | \\\"<\\\" | \\\"<=\\\" | \\\">=\\\" |\\n  \\\">>\\\" | \\\">>>\\\" | \\\"<<\\\" |  \\\"&\\\"  | \\\"|\\\"  | \\\"^\\\"  | \\\"+\\\" | \\\"-\\\" | \\\"*\\\"  | \\\"**\\\" | \\\"/\\\"  | \\\"%\\\"\\n): (\\n  target: any,\\n  propertyKey: string,\\n  descriptor: TypedPropertyDescriptor<any>\\n) => TypedPropertyDescriptor<any> | void;\\n\\ndeclare namespace operator {\\n  /** Annotates a method as a binary operator overload for the specified `token`. */\\n  export function binary(token:\\n    \\\"[]\\\" | \\\"[]=\\\" | \\\"{}\\\" | \\\"{}=\\\" | \\\"==\\\" | \\\"!=\\\" | \\\">\\\" | \\\"<\\\" | \\\"<=\\\" | \\\">=\\\" |\\n    \\\">>\\\" | \\\">>>\\\" | \\\"<<\\\" |  \\\"&\\\"  | \\\"|\\\"  | \\\"^\\\"  | \\\"+\\\" | \\\"-\\\" | \\\"*\\\"  | \\\"**\\\" | \\\"/\\\"  | \\\"%\\\"\\n  ): (\\n    target: any,\\n    propertyKey: string,\\n    descriptor: TypedPropertyDescriptor<any>\\n  ) => TypedPropertyDescriptor<any> | void;\\n  /** Annotates a method as an unary prefix operator overload for the specified `token`. */\\n  export function prefix(token: \\\"!\\\" | \\\"~\\\" | \\\"+\\\" | \\\"-\\\" | \\\"++\\\" | \\\"--\\\"): (\\n    target: any,\\n    propertyKey: string,\\n    descriptor: TypedPropertyDescriptor<any>\\n  ) => TypedPropertyDescriptor<any> | void;\\n  /** Annotates a method as an unary postfix operator overload for the specified `token`. */\\n  export function postfix(token: \\\"++\\\" | \\\"--\\\"): (\\n    target: any,\\n    propertyKey: string,\\n    descriptor: TypedPropertyDescriptor<any>\\n  ) => TypedPropertyDescriptor<any> | void;\\n}\\n\\n/** Annotates an element as a program global. */\\ndeclare function global(...args: any[]): any;\\n\\n/** Annotates a class as being unmanaged with limited capabilities. */\\ndeclare function unmanaged(constructor: Function): void;\\n\\n/** Annotates a class as being final / non-derivable. */\\ndeclare function final(constructor: Function): void;\\n\\n/** Annotates a method, function or constant global as always inlined. */\\ndeclare function inline(...args: any[]): any;\\n\\n/** Annotates a method, function or constant global as unsafe. */\\ndeclare function unsafe(...args: any[]): any;\\n\\n/** Annotates an explicit external name of a function or global. */\\ndeclare function external(name: string): any;\\ndeclare function external(moduleName: string, name: string): any;\\ndeclare namespace external {\\n  function js(code: string): any;\\n}\\n\\n/** Annotates a global for lazy compilation. */\\ndeclare function lazy(...args: any[]): any;\\n\",\n  \"portable\": \"/**\\n * Environment definitions for compiling AssemblyScript to JavaScript using tsc.\\n *\\n * Note that semantic differences require additional explicit conversions for full compatibility.\\n * For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\\n * result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\\n *\\n * Note that i64's are not portable (JS numbers are IEEE754 doubles with a maximum safe integer\\n * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example\\n * {@link glue/js/i64} respectively {@link glue/wasm/i64}.\\n *\\n * @module std/portable\\n *//***/\\n\\n// Types\\n\\ndeclare type bool = boolean;\\ndeclare type i8 = number;\\ndeclare type i16 = number;\\ndeclare type i32 = number;\\ndeclare type isize = number;\\ndeclare type u8 = number;\\ndeclare type u16 = number;\\ndeclare type u32 = number;\\ndeclare type usize = number;\\ndeclare type f32 = number;\\ndeclare type f64 = number;\\n\\n/** Special type evaluating the indexed access index type. */\\ndeclare type indexof<T extends unknown[]> = keyof T;\\n/** Special type evaluating the indexed access value type. */\\ndeclare type valueof<T extends unknown[]> = T[0];\\n\\n// Compiler hints\\n\\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\\ndeclare const ASC_TARGET: i32;\\n/** Runtime type. 0 = Stub, 1 = Minimal, 2 = Incremental. */\\ndeclare const ASC_RUNTIME: i32;\\n/** Provided noAssert option. */\\ndeclare const ASC_NO_ASSERT: bool;\\n/** Provided memoryBase option. */\\ndeclare const ASC_MEMORY_BASE: i32;\\n/** Provided optimizeLevel option. */\\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\\n/** Provided shrinkLevel option. */\\ndeclare const ASC_SHRINK_LEVEL: i32;\\n/** Whether the mutable global feature is enabled. */\\ndeclare const ASC_FEATURE_MUTABLE_GLOBAL: bool;\\n/** Whether the sign extension feature is enabled. */\\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\\n\\n// Builtins\\n\\n/** Performs the sign-agnostic reverse bytes **/\\ndeclare function bswap<T = i32 | u32 | isize | usize>(value: T): T;\\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\\ndeclare function clz<T = i32>(value: T): T;\\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\\ndeclare function ctz<T = i32>(value: T): T;\\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\\ndeclare function popcnt<T = i32>(value: T): T;\\n/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\\ndeclare function rotl<T = i32>(value: T, shift: T): T;\\n/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\\ndeclare function rotr<T = i32>(value: T, shift: T): T;\\n/** Computes the absolute value of an integer or float. */\\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\\ndeclare function ceil<T = f32 | f64>(value: T): T;\\n/** Performs the floor operation on a 32-bit or 64-bit float. */\\ndeclare function floor<T = f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\\ndeclare function nearest<T = f32 | f64>(value: T): T;\\n/** Selects one of two pre-evaluated values depending on the condition. */\\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\\n/** Calculates the square root of a 32-bit or 64-bit float. */\\ndeclare function sqrt<T = f32 | f64>(value: T): T;\\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\\ndeclare function trunc<T = f32 | f64>(value: T): T;\\n/** Emits an unreachable operation that results in a runtime error when executed. */\\ndeclare function unreachable(): any; // sic\\n\\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\\ndeclare function changetype<T>(value: any): T;\\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\\ndeclare function unchecked<T>(value: T): T;\\n/** Tests if the specified value is a valid integer. Can't distinguish an integer from an integral float. */\\ndeclare function isInteger(value: any): value is number;\\n/** Tests if the specified value is a valid float. Can't distinguish a float from an integer. */\\ndeclare function isFloat(value: any): value is number;\\n/** Tests if the specified value is of a nullable reference type. */\\ndeclare function isNullable(value: any): bool;\\n/** Tests if the specified value is of a reference type. */\\ndeclare function isReference(value: any): value is object | string;\\n/** Tests if the specified value is of a function type */\\ndeclare function isFunction(value: any): value is Function;\\n/** Tests if the specified value can be used as a string. */\\ndeclare function isString(value: any): value is string | String;\\n/** Tests if the specified value can be used as an array. */\\ndeclare function isArray(value: any): value is Array<any>;\\n/** Tests if the specified type *or* expression can be used as an array like object. */\\ndeclare function isArrayLike(value: any): value is ArrayLike<any>;\\n/** Tests if the specified expression resolves to a defined element. */\\ndeclare function isDefined(expression: any): bool;\\n/** Tests if the specified expression evaluates to a constant value. */\\ndeclare function isConstant(expression: any): bool;\\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\\ndeclare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?\\n/** Parses an integer string to a 64-bit float. */\\ndeclare function parseInt(str: string, radix?: i32): f64;\\n/** Parses a floating point string to a 64-bit float. */\\ndeclare function parseFloat(str: string): f64;\\n/** Returns the 64-bit floating-point remainder of `x/y`. */\\ndeclare function fmod(x: f64, y: f64): f64;\\n/** Returns the 32-bit floating-point remainder of `x/y`. */\\ndeclare function fmodf(x: f32, y: f32): f32;\\n\\n/** Converts any other numeric value to an 8-bit signed integer. */\\ndeclare function i8(value: any): i8;\\ndeclare namespace i8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i8;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): i8;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): i8;\\n}\\n/** Converts any other numeric value to a 16-bit signed integer. */\\ndeclare function i16(value: any): i16;\\ndeclare namespace i16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i16;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): i16;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): i16;\\n}\\n/** Converts any other numeric value to a 32-bit signed integer. */\\ndeclare function i32(value: any): i32;\\ndeclare namespace i32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: i32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: i32;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): i32;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): i32;\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\\ndeclare function isize(value: any): isize;\\ndeclare namespace isize {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: isize;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: isize;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): isize;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): isize;\\n}\\n/** Converts any other numeric value to an 8-bit unsigned integer. */\\ndeclare function u8(value: any): u8;\\ndeclare namespace u8 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u8;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u8;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): u8;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): u8;\\n}\\n/** Converts any other numeric value to a 16-bit unsigned integer. */\\ndeclare function u16(value: any): u16;\\ndeclare namespace u16 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u16;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u16;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): u16;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): u16;\\n}\\n/** Converts any other numeric value to a 32-bit unsigned integer. */\\ndeclare function u32(value: any): u32;\\ndeclare namespace u32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: u32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: u32;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): u32;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): u32;\\n}\\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\\ndeclare function usize(value: any): isize;\\ndeclare namespace usize {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: usize;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: usize;\\n  /** Converts a string to a floating-point number and cast to target integer after. */\\n  export function parseFloat(string: string): usize;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): usize;\\n}\\n/** Converts any other numeric value to a 1-bit unsigned integer. */\\ndeclare function bool(value: any): bool;\\ndeclare namespace bool {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: bool;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: bool;\\n}\\n/** Converts any other numeric value to a 32-bit float. */\\ndeclare function f32(value: any): f32;\\ndeclare namespace f32 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f32;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f32;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f32;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f32;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f32;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f32;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f32;\\n  /** Not a number value. */\\n  /* eslint no-shadow-restricted-names: \\\"off\\\" */\\n  export const NaN: f32;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f32;\\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\\n  export function isNaN(value: f32): bool;\\n  /** Returns true if passed value is finite. */\\n  export function isFinite(value: f32): bool;\\n  /** Returns true if the value passed is a safe integer. */\\n  export function isSafeInteger(value: f32): bool;\\n  /** Returns true if the value passed is an integer, false otherwise. */\\n  export function isInteger(value: f32): bool;\\n  /** Converts a string to a floating-point number. */\\n  export function parseFloat(string: string): f32;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): f32;\\n}\\n/** Converts any other numeric value to a 64-bit float. */\\ndeclare function f64(value: any): f64;\\ndeclare namespace f64 {\\n  /** Smallest representable value. */\\n  export const MIN_VALUE: f64;\\n  /** Largest representable value. */\\n  export const MAX_VALUE: f64;\\n  /** Smallest normalized positive value. */\\n  export const MIN_NORMAL_VALUE: f64;\\n  /** Smallest safely representable integer value. */\\n  export const MIN_SAFE_INTEGER: f64;\\n  /** Largest safely representable integer value. */\\n  export const MAX_SAFE_INTEGER: f64;\\n  /** Positive infinity value. */\\n  export const POSITIVE_INFINITY: f64;\\n  /** Negative infinity value. */\\n  export const NEGATIVE_INFINITY: f64;\\n  /** Not a number value. */\\n  /* eslint no-shadow-restricted-names: \\\"off\\\" */\\n  export const NaN: f64;\\n  /** Difference between 1 and the smallest representable value greater than 1. */\\n  export const EPSILON: f64;\\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\\n  export function isNaN(value: f32): bool;\\n  /** Returns true if passed value is finite. */\\n  export function isFinite(value: f32): bool;\\n  /** Returns true if the value passed is a safe integer. */\\n  export function isSafeInteger(value: f64): bool;\\n  /** Returns true if the value passed is an integer, false otherwise. */\\n  export function isInteger(value: f64): bool;\\n  /** Converts a string to a floating-point number. */\\n  export function parseFloat(string: string): f64;\\n  /** Converts A string to an integer. */\\n  export function parseInt(string: string, radix?: i32): f64;\\n}\\n\\n// Standard library\\n\\ndeclare const Mathf: typeof Math;\\ndeclare const JSMath: typeof Math;\\n\\ndeclare interface StringConstructor {\\n  /** Equivalent to calling `String.fromCharCode` with multiple arguments. */\\n  fromCharCodes(arr: i32[]): string;\\n  /** Equivalent to calling `String.fromCodePoint` with multiple arguments. */\\n  fromCodePoints(arr: i32[]): string;\\n}\\n\\ndeclare interface String {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): string;\\n}\\n\\n/** Annotates a class as being unmanaged with limited capabilities. */\\ndeclare function unmanaged(constructor: Function): void;\\n\\n/** Environmental tracing function. */\\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\\n\\ndeclare interface Array<T> {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): T;\\n  /** Returns an index start searching from the end in the array */\\n  findLastIndex(callbackfn: (value: T, index: i32, self: Array<T>) => bool): i32;\\n}\\n\\ndeclare interface Int8ArrayConstructor {\\n  /** Equivalent to calling `new Int8Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;\\n}\\n\\ndeclare interface Int8Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): i8;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): i32;\\n}\\n\\ndeclare interface Uint8ArrayConstructor {\\n  /** Equivalent to calling `new Uint8Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;\\n}\\n\\ndeclare interface Uint8Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u8;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): i32;\\n}\\n\\ndeclare interface Uint8ClampedArrayConstructor {\\n  /** Equivalent to calling `new Uint8ClampedArray` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;\\n}\\n\\ndeclare interface Uint8ClampedArray {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u8;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32;\\n}\\n\\ndeclare interface Int16ArrayConstructor {\\n  /** Equivalent to calling `new Int16Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;\\n}\\n\\ndeclare interface Int16Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): i16;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): i32;\\n}\\n\\ndeclare interface Uint16ArrayConstructor {\\n  /** Equivalent to calling `new Uint16Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;\\n}\\n\\ndeclare interface Uint16Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u16;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): i32;\\n}\\n\\ndeclare interface Int32ArrayConstructor {\\n  /** Equivalent to calling `new Int32Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;\\n}\\n\\ndeclare interface Int32Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): i32;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): i32;\\n}\\n\\ndeclare interface Uint32ArrayConstructor {\\n  /** Equivalent to calling `new Uint32Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;\\n}\\n\\ndeclare interface Uint32Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): u32;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): i32;\\n}\\n\\ndeclare interface Float32ArrayConstructor {\\n  /** Equivalent to calling `new Float32Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;\\n}\\n\\ndeclare interface Float32Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): f32;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): i32;\\n}\\n\\ndeclare interface Float64ArrayConstructor {\\n  /** Equivalent to calling `new Float64Array` with multiple arguments. */\\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;\\n}\\n\\ndeclare interface Float64Array {\\n  /** Returns value using relative indexing. Index may be negative */\\n  at(index: i32): f64;\\n  /** Returns an index start searching from the end in the typedarray */\\n  findLastIndex(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): i32;\\n}\\n\\n// FIXME: remove\\ndeclare function offsetof<T>(fieldName?: string): usize;\\ndeclare function idof<T>(): u32;\\n\"\n};\n", "export * from \"binaryen\";\nexport { default } from \"binaryen\";\n", "import \"./glue/js/index\";\nexport * from \"./index-wasm\";\n\n// Full API\nexport * from \"./ast\";\nexport * from \"./common\";\nexport * from \"./compiler\";\nexport * from \"./bindings\";\nexport * from \"./diagnostics\";\nexport * from \"./flow\";\nexport * from \"./module\";\nexport * from \"./parser\";\nexport * from \"./program\";\nexport * from \"./resolver\";\nexport * from \"./tokenizer\";\nexport * from \"./types\";\nexport * from \"./extra/ast\";\nimport * as util from \"./util\";\nexport { util };\n", "/** @module std/portable *//***/\n\nlet globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\nif (typeof globalScope.ASC_TARGET === \"undefined\") {\n\n  globalScope.ASC_TARGET = 0; // Target.JS\n  globalScope.ASC_RUNTIME = 0; // Runtime.Stub\n  globalScope.ASC_NO_ASSERT = false;\n  globalScope.ASC_MEMORY_BASE = 0;\n  globalScope.ASC_OPTIMIZE_LEVEL = 3;\n  globalScope.ASC_SHRINK_LEVEL = 0;\n  globalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\n  globalScope.ASC_FEATURE_SIGN_EXTENSION = false;\n  globalScope.ASC_FEATURE_BULK_MEMORY = false;\n  globalScope.ASC_FEATURE_SIMD = false;\n  globalScope.ASC_FEATURE_THREADS = false;\n\n  let F64 = new Float64Array(1);\n  let U64 = new Uint32Array(F64.buffer);\n\n  Object.defineProperties(\n    globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\n    {\n      \"MIN_VALUE\": { value: -128 },\n      \"MAX_VALUE\": { value:  127 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\n    {\n      \"MIN_VALUE\": { value: -32768 },\n      \"MAX_VALUE\": { value:  32767 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\n    {\n      \"MIN_VALUE\": { value: -2147483648 },\n      \"MAX_VALUE\": { value:  2147483647 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\n    {\n      \"MIN_VALUE\": { value:   0 },\n      \"MAX_VALUE\": { value: 255 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\n    {\n      \"MIN_VALUE\": { value:     0 },\n      \"MAX_VALUE\": { value: 65535 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\n    {\n      \"MIN_VALUE\": { value:          0 },\n      \"MAX_VALUE\": { value: 4294967295 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"bool\"] = function bool(value) { return !!value; },\n    {\n      \"MIN_VALUE\": { value: false },\n      \"MAX_VALUE\": { value: true }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\n    {\n      \"EPSILON\":   { value: 1.1920928955078125e-07 },\n      \"MIN_VALUE\": { value: 1.401298464324817e-45 },\n      \"MAX_VALUE\": { value: 3.4028234663852886e+38 },\n      \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38 },\n      \"MIN_SAFE_INTEGER\":  { value: -16777215 },\n      \"MAX_SAFE_INTEGER\":  { value:  16777215 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f64\"] = function f64(value) { return +value; },\n    {\n      \"EPSILON\":   { value: 2.2204460492503131e-016 },\n      \"MIN_VALUE\": { value:                  5e-324 },\n      \"MAX_VALUE\": { value: 1.7976931348623157e+308 },\n      \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308 },\n      \"MIN_SAFE_INTEGER\":  { value: -9007199254740991 },\n      \"MAX_SAFE_INTEGER\":  { value:  9007199254740991 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN }\n    }\n  );\n\n  globalScope[\"clz\"] = Math.clz32;\n\n  globalScope[\"ctz\"] = function ctz(value) {\n    return 32 - Math.clz32(~value & (value - 1));\n  };\n\n  globalScope[\"popcnt\"] = function popcnt(value) {\n    value -= value >>> 1 & 0x55555555;\n    value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\n    return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n  };\n\n  globalScope[\"rotl\"] = function rotl(value, shift) {\n    shift &= 31;\n    return (value << shift) | (value >>> (32 - shift));\n  };\n\n  globalScope[\"rotr\"] = function rotr(value, shift) {\n    shift &= 31;\n    return (value >>> shift) | (value << (32 - shift));\n  };\n\n  globalScope[\"abs\"] = Math.abs;\n\n  globalScope[\"max\"] = Math.max;\n\n  globalScope[\"min\"] = Math.min;\n\n  globalScope[\"ceil\"] = Math.ceil;\n\n  globalScope[\"floor\"] = Math.floor;\n\n  globalScope[\"nearest\"] = function nearest(value) {\n    const INV_EPS64 = 4503599627370496.0;\n    const y = Math.abs(value);\n    return y < INV_EPS64\n      ? (y + INV_EPS64 - INV_EPS64) * Math.sign(value)\n      : value;\n  };\n\n  globalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\n    return condition ? ifTrue : ifFalse;\n  };\n\n  globalScope[\"sqrt\"] = Math.sqrt;\n\n  globalScope[\"trunc\"] = Math.trunc;\n\n  globalScope[\"copysign\"] = function copysign(x, y) {\n    return y\n      ? Math.abs(x) * Math.sign(y)\n      : (F64[0] = y, U64[1] >>> 31 ? -1 : 1); // +0, -0, -NaN, +NaN\n  };\n\n  globalScope[\"bswap\"] = function bswap(value) {\n    let a = value >> 8 & 0x00FF00FF;\n    let b = (value & 0x00FF00FF) << 8;\n    value = a | b;\n    a = value >> 16 & 0x0000FFFF;\n    b = (value & 0x0000FFFF) << 16;\n    return a | b;\n  };\n\n  function UnreachableError() {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnreachableError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  UnreachableError.prototype = Object.create(Error.prototype);\n  UnreachableError.prototype.name = \"UnreachableError\";\n  UnreachableError.prototype.message = \"unreachable\";\n\n  globalScope[\"unreachable\"] = function unreachable() {\n    throw new UnreachableError();\n  };\n\n  function AssertionError(message) {\n    this.message = message || \"assertion failed\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  AssertionError.prototype = Object.create(Error.prototype);\n  AssertionError.prototype.name = \"AssertionError\";\n\n  globalScope[\"assert\"] = function assert(isTrueish, message) {\n    if (isTrueish) return isTrueish;\n    throw new AssertionError(message);\n  };\n\n  globalScope[\"changetype\"] = function changetype(value) {\n    return value;\n  };\n\n  String[\"fromCharCodes\"] = function fromCharCodes(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCharCode.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCharCode.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  String[\"fromCodePoints\"] = function fromCodePoints(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCodePoint.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCodePoint.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  if (!String.prototype.at) {\n    Object.defineProperty(String.prototype, \"at\", {\n      value: function at(index) {\n        return this.charAt(index >= 0 ? index : index + this.length);\n      },\n      configurable: true\n    });\n  }\n\n  if (!String.prototype.replaceAll) {\n    Object.defineProperty(String.prototype, \"replaceAll\", {\n      value: function replaceAll(search, replacment) {\n        let res = this.split(search).join(replacment);\n        if (!search.length) res = replacment + res + replacment;\n        return res;\n      },\n      configurable: true\n    });\n  }\n\n  function defaultComparator(a, b) {\n    if (a == b) {\n      if (a != 0) return 0;\n      a = 1 / a, b = 1 / b;\n    } else {\n      let nanA = a != a, nanB = b != b;\n      if (nanA | nanB) return nanA - nanB;\n      if (a == null) a = String(a);\n      if (b == null) b = String(b);\n    }\n    return a > b ? 1 : -1;\n  }\n\n  const arraySort = Array.prototype.sort;\n  Array.prototype.sort = function sort(comparator) {\n    return arraySort.call(this, comparator || defaultComparator);\n  };\n\n  [ Array,\n    Uint8ClampedArray,\n    Uint8Array, Int8Array,\n    Uint16Array, Int16Array,\n    Uint32Array, Int32Array,\n    Float32Array, Float64Array\n  ].forEach(Ctr => {\n    if (!Ctr.prototype.at) {\n      Object.defineProperty(Ctr.prototype, \"at\", {\n        value: function at(index) {\n          return this[index >= 0 ? index : index + this.length];\n        },\n        configurable: true\n      });\n    }\n\n    if (!Ctr.prototype.findLastIndex) {\n      Object.defineProperty(Ctr.prototype, \"findLastIndex\", {\n        value: function findLastIndex(fn) {\n          for (let i = this.length - 1; i >= 0; --i) {\n            if (fn(this[i], i, this)) return i;\n          }\n          return -1;\n        },\n        configurable: true\n      });\n    }\n\n    if (Ctr != Array) {\n      Object.defineProperty(Ctr, \"wrap\", {\n        value: function wrap(buffer, byteOffset, length) {\n          return new Ctr(buffer, byteOffset, length);\n        },\n        configurable: true\n      });\n    }\n  });\n\n  globalScope[\"isInteger\"] = Number.isInteger;\n\n  globalScope[\"isFloat\"] = function isFloat(arg) {\n    return typeof arg === \"number\";\n  };\n\n  globalScope[\"isNullable\"] = function isNullable(arg) {\n    return true;\n  };\n\n  globalScope[\"isReference\"] = function isReference(arg) {\n    return typeof arg === \"object\" || typeof arg === \"string\";\n  };\n\n  globalScope[\"isFunction\"] = function isFunction(arg) {\n    return typeof arg === \"function\";\n  };\n\n  globalScope[\"isString\"] = function isString(arg) {\n    return typeof arg === \"string\" || arg instanceof String;\n  };\n\n  globalScope[\"isArray\"] = Array.isArray;\n  globalScope[\"isArrayLike\"] = function isArrayLike(expr) {\n    return expr\n      && typeof expr === 'object'\n      && typeof expr.length === 'number'\n      && expr.length >= 0\n      && Math.trunc(expr.length) === expr.length;\n  };\n\n  globalScope[\"isDefined\"] = function isDefined(expr) {\n    return typeof expr !== \"undefined\";\n  };\n\n  globalScope[\"isConstant\"] = function isConstant(expr) {\n    return false;\n  };\n\n  globalScope[\"unchecked\"] = function unchecked(expr) {\n    return expr;\n  };\n\n  globalScope[\"fmod\"] = function fmod(x, y) {\n    return x % y;\n  };\n\n  globalScope[\"fmodf\"] = function fmodf(x, y) {\n    return Math.fround(x % y);\n  };\n\n  globalScope[\"JSMath\"] = Math;\n\n  Object.defineProperties(globalScope[\"JSMath\"], {\n    sincos_sin: { value: 0.0, writable: true },\n    sincos_cos: { value: 0.0, writable: true },\n    signbit: {\n      value: function signbit(x) {\n        F64[0] = x; return Boolean(U64[1] >>> 31);\n      }\n    },\n    sincos: {\n      value: function sincos(x) {\n        this.sincos_sin = Math.sin(x);\n        this.sincos_cos = Math.cos(x);\n      }\n    },\n    exp2: {\n      value: function exp2(x) {\n        return Math.pow(2, x);\n      }\n    }\n  });\n\n  globalScope[\"unmanaged\"] = function() { /* nop */ };\n\n  globalScope[\"trace\"] = function(message, n) {\n    if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\n    console.error(\"trace: \" + message);\n  };\n} else {\n  console.warn(\"compiler mismatch: std/portable included twice\");\n}\n", "export * from \"binaryen\";\nexport { default } from \"binaryen\";\n", "/**\n * @fileoverview Binaryen glue code for JavaScript.\n * @license Apache-2.0\n */\n\nimport binaryen from \"../../lib/binaryen.js\";\n\nexport const {\n  _BinaryenTypeCreate,\n  _BinaryenTypeArity,\n  _BinaryenTypeExpand,\n  _BinaryenTypeGetHeapType,\n  _BinaryenTypeFromHeapType,\n  _BinaryenTypeIsNullable,\n\n  _BinaryenTypeFuncref,\n  _BinaryenTypeExternref,\n  _BinaryenTypeAnyref,\n  _BinaryenTypeEqref,\n  _BinaryenTypeI31ref,\n  _BinaryenTypeDataref,\n  _BinaryenTypeArrayref,\n  _BinaryenTypeStringref,\n  _BinaryenTypeStringviewWTF8,\n  _BinaryenTypeStringviewWTF16,\n  _BinaryenTypeStringviewIter,\n  _BinaryenTypeNullref,\n  _BinaryenTypeNullExternref,\n  _BinaryenTypeNullFuncref,\n\n  _BinaryenHeapTypeFunc,\n  _BinaryenHeapTypeExt,\n  _BinaryenHeapTypeAny,\n  _BinaryenHeapTypeEq,\n  _BinaryenHeapTypeI31,\n  _BinaryenHeapTypeData,\n  _BinaryenHeapTypeArray,\n  _BinaryenHeapTypeString,\n  _BinaryenHeapTypeStringviewWTF8,\n  _BinaryenHeapTypeStringviewWTF16,\n  _BinaryenHeapTypeStringviewIter,\n  _BinaryenHeapTypeNone,\n  _BinaryenHeapTypeNoext,\n  _BinaryenHeapTypeNofunc,\n\n  _BinaryenHeapTypeIsBottom,\n  _BinaryenHeapTypeGetBottom,\n\n  _BinaryenModuleCreate,\n  _BinaryenModuleDispose,\n\n  _BinaryenSizeofLiteral,\n  _BinaryenLiteralInt32,\n  _BinaryenLiteralInt64,\n  _BinaryenLiteralFloat32,\n  _BinaryenLiteralFloat64,\n  _BinaryenLiteralVec128,\n  _BinaryenLiteralFloat32Bits,\n  _BinaryenLiteralFloat64Bits,\n\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenExpressionSetType,\n  _BinaryenExpressionPrint,\n  _BinaryenExpressionCopy,\n  _BinaryenExpressionFinalize,\n\n  _BinaryenBlock,\n  _BinaryenBlockGetName,\n  _BinaryenBlockSetName,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenBlockSetChildAt,\n  _BinaryenBlockAppendChild,\n  _BinaryenBlockInsertChildAt,\n  _BinaryenBlockRemoveChildAt,\n\n  _BinaryenIf,\n  _BinaryenIfGetCondition,\n  _BinaryenIfSetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenIfSetIfFalse,\n\n  _BinaryenLoop,\n  _BinaryenLoopGetName,\n  _BinaryenLoopSetName,\n  _BinaryenLoopGetBody,\n  _BinaryenLoopSetBody,\n\n  _BinaryenBreak,\n  _BinaryenBreakGetName,\n  _BinaryenBreakSetName,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenBreakSetValue,\n\n  _BinaryenSwitch,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenSwitchSetNameAt,\n  _BinaryenSwitchAppendName,\n  _BinaryenSwitchInsertNameAt,\n  _BinaryenSwitchRemoveNameAt,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchSetDefaultName,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenSwitchSetValue,\n\n  _BinaryenCall,\n  _BinaryenCallGetTarget,\n  _BinaryenCallSetTarget,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallAppendOperand,\n  _BinaryenCallInsertOperandAt,\n  _BinaryenCallRemoveOperandAt,\n  _BinaryenCallIsReturn,\n  _BinaryenCallSetReturn,\n  _BinaryenReturnCall,\n\n  _BinaryenCallIndirect,\n  _BinaryenCallIndirectGetTable,\n  _BinaryenCallIndirectSetTable,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallIndirectAppendOperand,\n  _BinaryenCallIndirectInsertOperandAt,\n  _BinaryenCallIndirectRemoveOperandAt,\n  _BinaryenCallIndirectIsReturn,\n  _BinaryenCallIndirectSetReturn,\n  _BinaryenReturnCallIndirect,\n\n  _BinaryenLocalGet,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalGetSetIndex,\n\n  _BinaryenLocalSet,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetSetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetSetValue,\n  _BinaryenLocalTee,\n\n  _BinaryenGlobalGet,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalGetSetName,\n\n  _BinaryenGlobalSet,\n  _BinaryenGlobalSetGetName,\n  _BinaryenGlobalSetSetName,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalSetSetValue,\n\n  _BinaryenMemorySize,\n\n  _BinaryenMemoryGrow,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenMemoryGrowSetDelta,\n\n  _BinaryenLoad,\n  _BinaryenLoadIsAtomic,\n  _BinaryenLoadSetAtomic,\n  _BinaryenLoadIsSigned,\n  _BinaryenLoadSetSigned,\n  _BinaryenLoadGetOffset,\n  _BinaryenLoadSetOffset,\n  _BinaryenLoadGetBytes,\n  _BinaryenLoadSetBytes,\n  _BinaryenLoadGetAlign,\n  _BinaryenLoadSetAlign,\n  _BinaryenLoadGetPtr,\n  _BinaryenLoadSetPtr,\n  _BinaryenAtomicLoad,\n\n  _BinaryenStore,\n  _BinaryenStoreIsAtomic,\n  _BinaryenStoreSetAtomic,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreSetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreSetOffset,\n  _BinaryenStoreGetAlign,\n  _BinaryenStoreSetAlign,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenStoreSetValue,\n  _BinaryenStoreGetValueType,\n  _BinaryenStoreSetValueType,\n  _BinaryenAtomicStore,\n\n  _BinaryenConst,\n  _BinaryenConstGetValueI32,\n  _BinaryenConstSetValueI32,\n  _BinaryenConstGetValueI64Low,\n  _BinaryenConstSetValueI64Low,\n  _BinaryenConstGetValueI64High,\n  _BinaryenConstSetValueI64High,\n  _BinaryenConstGetValueF32,\n  _BinaryenConstSetValueF32,\n  _BinaryenConstGetValueF64,\n  _BinaryenConstSetValueF64,\n  _BinaryenConstGetValueV128,\n  _BinaryenConstSetValueV128,\n\n  _BinaryenUnary,\n  _BinaryenUnaryGetOp,\n  _BinaryenUnarySetOp,\n  _BinaryenUnaryGetValue,\n  _BinaryenUnarySetValue,\n\n  _BinaryenBinary,\n  _BinaryenBinaryGetOp,\n  _BinaryenBinarySetOp,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenBinarySetRight,\n\n  _BinaryenSelect,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenSelectSetCondition,\n\n  _BinaryenDrop,\n  _BinaryenDropGetValue,\n  _BinaryenDropSetValue,\n\n  _BinaryenReturn,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n\n  _BinaryenNop,\n\n  _BinaryenUnreachable,\n\n  _BinaryenAtomicRMW,\n  _BinaryenAtomicRMWGetOp,\n  _BinaryenAtomicRMWSetOp,\n  _BinaryenAtomicRMWGetBytes,\n  _BinaryenAtomicRMWSetBytes,\n  _BinaryenAtomicRMWGetOffset,\n  _BinaryenAtomicRMWSetOffset,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicRMWSetValue,\n\n  _BinaryenAtomicCmpxchg,\n  _BinaryenAtomicCmpxchgGetBytes,\n  _BinaryenAtomicCmpxchgSetBytes,\n  _BinaryenAtomicCmpxchgGetOffset,\n  _BinaryenAtomicCmpxchgSetOffset,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicCmpxchgSetReplacement,\n\n  _BinaryenAtomicWait,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicWaitGetExpectedType,\n  _BinaryenAtomicWaitSetExpectedType,\n\n  _BinaryenAtomicNotify,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n\n  _BinaryenAtomicFence,\n  _BinaryenAtomicFenceGetOrder,\n  _BinaryenAtomicFenceSetOrder,\n\n  _BinaryenSIMDExtract,\n  _BinaryenSIMDExtractGetOp,\n  _BinaryenSIMDExtractSetOp,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDExtractGetIndex,\n  _BinaryenSIMDExtractSetIndex,\n\n  _BinaryenSIMDReplace,\n  _BinaryenSIMDReplaceGetOp,\n  _BinaryenSIMDReplaceSetOp,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceGetIndex,\n  _BinaryenSIMDReplaceSetIndex,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDReplaceSetValue,\n\n  _BinaryenSIMDShuffle,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDShuffleGetMask,\n  _BinaryenSIMDShuffleSetMask,\n\n  _BinaryenSIMDTernary,\n  _BinaryenSIMDTernaryGetOp,\n  _BinaryenSIMDTernarySetOp,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDTernarySetC,\n\n  _BinaryenSIMDShift,\n  _BinaryenSIMDShiftGetOp,\n  _BinaryenSIMDShiftSetOp,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDShiftSetShift,\n\n  _BinaryenSIMDLoad,\n  _BinaryenSIMDLoadGetOp,\n  _BinaryenSIMDLoadSetOp,\n  _BinaryenSIMDLoadGetOffset,\n  _BinaryenSIMDLoadSetOffset,\n  _BinaryenSIMDLoadGetAlign,\n  _BinaryenSIMDLoadSetAlign,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenSIMDLoadSetPtr,\n\n  _BinaryenSIMDLoadStoreLane,\n  _BinaryenSIMDLoadStoreLaneGetOp,\n  _BinaryenSIMDLoadStoreLaneSetOp,\n  _BinaryenSIMDLoadStoreLaneGetOffset,\n  _BinaryenSIMDLoadStoreLaneSetOffset,\n  _BinaryenSIMDLoadStoreLaneGetAlign,\n  _BinaryenSIMDLoadStoreLaneSetAlign,\n  _BinaryenSIMDLoadStoreLaneGetIndex,\n  _BinaryenSIMDLoadStoreLaneSetIndex,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenSIMDLoadStoreLaneIsStore,\n\n  _BinaryenMemoryInit,\n  _BinaryenMemoryInitGetSegment,\n  _BinaryenMemoryInitSetSegment,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryInitSetSize,\n\n  _BinaryenDataDrop,\n  _BinaryenDataDropGetSegment,\n  _BinaryenDataDropSetSegment,\n\n  _BinaryenMemoryCopy,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryCopySetSize,\n\n  _BinaryenMemoryFill,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenMemoryFillSetSize,\n\n  _BinaryenRefNull,\n\n  _BinaryenRefIs,\n  _BinaryenRefIsGetOp,\n  _BinaryenRefIsSetOp,\n  _BinaryenRefIsGetValue,\n  _BinaryenRefIsSetValue,\n\n  _BinaryenRefAs,\n  _BinaryenRefAsGetOp,\n  _BinaryenRefAsSetOp,\n  _BinaryenRefAsGetValue,\n  _BinaryenRefAsSetValue,\n\n  _BinaryenRefFunc,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenRefFuncSetFunc,\n\n  _BinaryenRefEq,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetRight,\n\n  _BinaryenTableGet,\n  _BinaryenTableGetGetTable,\n  _BinaryenTableGetSetTable,\n  _BinaryenTableGetGetIndex,\n  _BinaryenTableGetSetIndex,\n\n  _BinaryenTableSet,\n  _BinaryenTableSetGetTable,\n  _BinaryenTableSetSetTable,\n  _BinaryenTableSetGetIndex,\n  _BinaryenTableSetSetIndex,\n  _BinaryenTableSetGetValue,\n  _BinaryenTableSetSetValue,\n\n  _BinaryenTableSize,\n  _BinaryenTableSizeGetTable,\n  _BinaryenTableSizeSetTable,\n\n  _BinaryenTableGrow,\n  _BinaryenTableGrowGetTable,\n  _BinaryenTableGrowSetTable,\n  _BinaryenTableGrowGetValue,\n  _BinaryenTableGrowSetValue,\n  _BinaryenTableGrowGetDelta,\n  _BinaryenTableGrowSetDelta,\n\n  _BinaryenTry,\n  _BinaryenTryGetName,\n  _BinaryenTrySetName,\n  _BinaryenTryGetBody,\n  _BinaryenTrySetBody,\n  _BinaryenTryGetNumCatchTags,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchTagAt,\n  _BinaryenTrySetCatchTagAt,\n  _BinaryenTryAppendCatchTag,\n  _BinaryenTryInsertCatchTagAt,\n  _BinaryenTryRemoveCatchTagAt,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenTryAppendCatchBody,\n  _BinaryenTryInsertCatchBodyAt,\n  _BinaryenTryRemoveCatchBodyAt,\n  _BinaryenTryHasCatchAll,\n  _BinaryenTryGetDelegateTarget,\n  _BinaryenTrySetDelegateTarget,\n  _BinaryenTryIsDelegate,\n\n  _BinaryenThrow,\n  _BinaryenThrowGetTag,\n  _BinaryenThrowSetTag,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenThrowAppendOperand,\n  _BinaryenThrowInsertOperandAt,\n  _BinaryenThrowRemoveOperandAt,\n\n  _BinaryenRethrow,\n  _BinaryenRethrowGetTarget,\n  _BinaryenRethrowSetDepth,\n\n  _BinaryenTupleMake,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenTupleMakeAppendOperand,\n  _BinaryenTupleMakeInsertOperandAt,\n  _BinaryenTupleMakeRemoveOperandAt,\n\n  _BinaryenTupleExtract,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenTupleExtractGetIndex,\n  _BinaryenTupleExtractSetIndex,\n\n  _BinaryenPop,\n\n  _BinaryenI31New,\n  _BinaryenI31NewGetValue,\n  _BinaryenI31NewSetValue,\n\n  _BinaryenI31Get,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31GetSetI31,\n  _BinaryenI31GetIsSigned,\n  _BinaryenI31GetSetSigned,\n\n  _BinaryenCallRef,\n  _BinaryenCallRefGetNumOperands,\n  _BinaryenCallRefGetOperandAt,\n  _BinaryenCallRefSetOperandAt,\n  _BinaryenCallRefAppendOperand,\n  _BinaryenCallRefInsertOperandAt,\n  _BinaryenCallRefRemoveOperandAt,\n  _BinaryenCallRefGetTarget,\n  _BinaryenCallRefSetTarget,\n  _BinaryenCallRefIsReturn,\n  _BinaryenCallRefSetReturn,\n\n  _BinaryenRefTest,\n  _BinaryenRefTestGetRef,\n  _BinaryenRefTestSetRef,\n  _BinaryenRefTestGetIntendedType,\n  _BinaryenRefTestSetIntendedType,\n\n  _BinaryenRefCast,\n  _BinaryenRefCastGetRef,\n  _BinaryenRefCastSetRef,\n  _BinaryenRefCastGetIntendedType,\n  _BinaryenRefCastSetIntendedType,\n\n  _BinaryenBrOn,\n  _BinaryenBrOnGetOp,\n  _BinaryenBrOnSetOp,\n  _BinaryenBrOnGetName,\n  _BinaryenBrOnSetName,\n  _BinaryenBrOnGetRef,\n  _BinaryenBrOnSetRef,\n  _BinaryenBrOnGetIntendedType,\n  _BinaryenBrOnSetIntendedType,\n\n  _BinaryenStructNew,\n  _BinaryenStructNewGetNumOperands,\n  _BinaryenStructNewGetOperandAt,\n  _BinaryenStructNewSetOperandAt,\n  _BinaryenStructNewAppendOperand,\n  _BinaryenStructNewInsertOperandAt,\n  _BinaryenStructNewRemoveOperandAt,\n\n  _BinaryenStructGet,\n  _BinaryenStructGetGetIndex,\n  _BinaryenStructGetSetIndex,\n  _BinaryenStructGetGetRef,\n  _BinaryenStructGetSetRef,\n  _BinaryenStructGetIsSigned,\n  _BinaryenStructGetSetSigned,\n\n  _BinaryenStructSet,\n  _BinaryenStructSetGetIndex,\n  _BinaryenStructSetSetIndex,\n  _BinaryenStructSetGetRef,\n  _BinaryenStructSetSetRef,\n  _BinaryenStructSetGetValue,\n  _BinaryenStructSetSetValue,\n\n  _BinaryenArrayNew,\n  _BinaryenArrayNewGetInit,\n  _BinaryenArrayNewSetInit,\n  _BinaryenArrayNewGetSize,\n  _BinaryenArrayNewSetSize,\n\n  _BinaryenArrayInit,\n  _BinaryenArrayInitGetNumValues,\n  _BinaryenArrayInitGetValueAt,\n  _BinaryenArrayInitSetValueAt,\n  _BinaryenArrayInitAppendValue,\n  _BinaryenArrayInitInsertValueAt,\n  _BinaryenArrayInitRemoveValueAt,\n\n  _BinaryenArrayGet,\n  _BinaryenArrayGetGetRef,\n  _BinaryenArrayGetSetRef,\n  _BinaryenArrayGetGetIndex,\n  _BinaryenArrayGetSetIndex,\n  _BinaryenArrayGetIsSigned,\n  _BinaryenArrayGetSetSigned,\n\n  _BinaryenArraySet,\n  _BinaryenArraySetGetRef,\n  _BinaryenArraySetSetRef,\n  _BinaryenArraySetGetIndex,\n  _BinaryenArraySetSetIndex,\n  _BinaryenArraySetGetValue,\n  _BinaryenArraySetSetValue,\n\n  _BinaryenArrayLen,\n  _BinaryenArrayLenGetRef,\n  _BinaryenArrayLenSetRef,\n\n  _BinaryenArrayCopy,\n  _BinaryenArrayCopyGetDestRef,\n  _BinaryenArrayCopySetDestRef,\n  _BinaryenArrayCopyGetDestIndex,\n  _BinaryenArrayCopySetDestIndex,\n  _BinaryenArrayCopyGetSrcRef,\n  _BinaryenArrayCopySetSrcRef,\n  _BinaryenArrayCopyGetSrcIndex,\n  _BinaryenArrayCopySetSrcIndex,\n  _BinaryenArrayCopyGetLength,\n  _BinaryenArrayCopySetLength,\n\n  _BinaryenStringNew,\n  _BinaryenStringNewGetOp,\n  _BinaryenStringNewSetOp,\n  _BinaryenStringNewGetPtr,\n  _BinaryenStringNewSetPtr,\n  _BinaryenStringNewGetLength,\n  _BinaryenStringNewSetLength,\n  _BinaryenStringNewGetStart,\n  _BinaryenStringNewSetStart,\n  _BinaryenStringNewGetEnd,\n  _BinaryenStringNewSetEnd,\n\n  _BinaryenStringConst,\n  _BinaryenStringConstGetString,\n  _BinaryenStringConstSetString,\n\n  _BinaryenStringMeasure,\n  _BinaryenStringMeasureGetOp,\n  _BinaryenStringMeasureSetOp,\n  _BinaryenStringMeasureGetRef,\n  _BinaryenStringMeasureSetRef,\n\n  _BinaryenStringEncode,\n  _BinaryenStringEncodeGetOp,\n  _BinaryenStringEncodeSetOp,\n  _BinaryenStringEncodeGetRef,\n  _BinaryenStringEncodeSetRef,\n  _BinaryenStringEncodeGetPtr,\n  _BinaryenStringEncodeSetPtr,\n  _BinaryenStringEncodeGetStart,\n  _BinaryenStringEncodeSetStart,\n\n  _BinaryenStringConcat,\n  _BinaryenStringConcatGetLeft,\n  _BinaryenStringConcatSetLeft,\n  _BinaryenStringConcatGetRight,\n  _BinaryenStringConcatSetRight,\n\n  _BinaryenStringEq,\n  _BinaryenStringEqGetLeft,\n  _BinaryenStringEqSetLeft,\n  _BinaryenStringEqGetRight,\n  _BinaryenStringEqSetRight,\n\n  _BinaryenStringAs,\n  _BinaryenStringAsGetOp,\n  _BinaryenStringAsSetOp,\n  _BinaryenStringAsGetRef,\n  _BinaryenStringAsSetRef,\n\n  _BinaryenStringWTF8Advance,\n  _BinaryenStringWTF8AdvanceGetRef,\n  _BinaryenStringWTF8AdvanceSetRef,\n  _BinaryenStringWTF8AdvanceGetPos,\n  _BinaryenStringWTF8AdvanceSetPos,\n  _BinaryenStringWTF8AdvanceGetBytes,\n  _BinaryenStringWTF8AdvanceSetBytes,\n\n  _BinaryenStringWTF16Get,\n  _BinaryenStringWTF16GetGetRef,\n  _BinaryenStringWTF16GetSetRef,\n  _BinaryenStringWTF16GetGetPos,\n  _BinaryenStringWTF16GetSetPos,\n\n  _BinaryenStringIterNext,\n  _BinaryenStringIterNextGetRef,\n  _BinaryenStringIterNextSetRef,\n\n  _BinaryenStringIterMove,\n  _BinaryenStringIterMoveGetOp,\n  _BinaryenStringIterMoveSetOp,\n  _BinaryenStringIterMoveGetRef,\n  _BinaryenStringIterMoveSetRef,\n  _BinaryenStringIterMoveGetNum,\n  _BinaryenStringIterMoveSetNum,\n\n  _BinaryenStringSliceWTF,\n  _BinaryenStringSliceWTFGetOp,\n  _BinaryenStringSliceWTFSetOp,\n  _BinaryenStringSliceWTFGetRef,\n  _BinaryenStringSliceWTFSetRef,\n  _BinaryenStringSliceWTFGetStart,\n  _BinaryenStringSliceWTFSetStart,\n  _BinaryenStringSliceWTFGetEnd,\n  _BinaryenStringSliceWTFSetEnd,\n\n  _BinaryenStringSliceIter,\n  _BinaryenStringSliceIterGetRef,\n  _BinaryenStringSliceIterSetRef,\n  _BinaryenStringSliceIterGetNum,\n  _BinaryenStringSliceIterSetNum,\n\n  _BinaryenAddFunction,\n  _BinaryenGetFunction,\n  _BinaryenRemoveFunction,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionHasLocalName,\n  _BinaryenFunctionGetLocalName,\n  _BinaryenFunctionSetLocalName,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionSetBody,\n  _BinaryenFunctionOptimize,\n  _BinaryenFunctionRunPasses,\n  _BinaryenFunctionSetDebugLocation,\n\n  _BinaryenAddFunctionImport,\n  _BinaryenAddTableImport,\n  _BinaryenAddMemoryImport,\n  _BinaryenAddGlobalImport,\n  _BinaryenAddTagImport,\n\n  _BinaryenAddFunctionExport,\n  _BinaryenAddTableExport,\n  _BinaryenAddMemoryExport,\n  _BinaryenAddGlobalExport,\n  _BinaryenAddTagExport,\n  _BinaryenGetExport,\n  _BinaryenRemoveExport,\n  _BinaryenGetNumExports,\n  _BinaryenGetExportByIndex,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n\n  _BinaryenAddGlobal,\n  _BinaryenGetGlobal,\n  _BinaryenRemoveGlobal,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n\n  _BinaryenGlobalGetName,\n  _BinaryenGlobalGetType,\n  _BinaryenGlobalIsMutable,\n  _BinaryenGlobalGetInitExpr,\n\n  _BinaryenAddTag,\n  _BinaryenGetTag,\n  _BinaryenRemoveTag,\n\n  _BinaryenTagGetName,\n  _BinaryenTagGetParams,\n  _BinaryenTagGetResults,\n\n  _BinaryenAddTable,\n  _BinaryenRemoveTable,\n  _BinaryenGetNumTables,\n  _BinaryenGetTable,\n  _BinaryenGetTableByIndex,\n\n  _BinaryenTableGetName,\n  _BinaryenTableSetName,\n  _BinaryenTableGetInitial,\n  _BinaryenTableSetInitial,\n  _BinaryenTableHasMax,\n  _BinaryenTableGetMax,\n  _BinaryenTableSetMax,\n\n  _BinaryenAddActiveElementSegment,\n  _BinaryenAddPassiveElementSegment,\n  _BinaryenRemoveElementSegment,\n  _BinaryenGetNumElementSegments,\n  _BinaryenGetElementSegment,\n  _BinaryenGetElementSegmentByIndex,\n\n  _BinaryenSetMemory,\n  _BinaryenGetNumMemorySegments,\n  _BinaryenGetMemorySegmentByteOffset,\n  _BinaryenGetMemorySegmentByteLength,\n  _BinaryenCopyMemorySegmentData,\n\n  _BinaryenSetStart,\n\n  _BinaryenModuleParse,\n  _BinaryenModulePrint,\n  _BinaryenModulePrintAsmjs,\n  _BinaryenModuleValidate,\n  _BinaryenModuleOptimize,\n  _BinaryenModuleRunPasses,\n  _BinaryenModuleAutoDrop,\n  _BinaryenSizeofAllocateAndWriteResult,\n  _BinaryenModuleAllocateAndWrite,\n  _BinaryenModuleAllocateAndWriteText,\n  _BinaryenModuleAllocateAndWriteStackIR,\n  _BinaryenModuleRead,\n  _BinaryenModuleInterpret,\n  _BinaryenModuleAddDebugInfoFileName,\n  _BinaryenModuleGetDebugInfoFileName,\n  _BinaryenModuleGetFeatures,\n  _BinaryenModuleSetFeatures,\n\n  _BinaryenAddCustomSection,\n\n  _BinaryenExpressionGetSideEffects,\n\n  _RelooperCreate,\n  _RelooperAddBlock,\n  _RelooperAddBranch,\n  _RelooperAddBlockWithSwitch,\n  _RelooperAddBranchForSwitch,\n  _RelooperRenderAndDispose,\n\n  _ExpressionRunnerCreate,\n  _ExpressionRunnerSetLocalValue,\n  _ExpressionRunnerSetGlobalValue,\n  _ExpressionRunnerRunAndDispose,\n\n  _TypeBuilderCreate,\n  _TypeBuilderGrow,\n  _TypeBuilderGetSize,\n  _TypeBuilderSetBasicHeapType,\n  _TypeBuilderSetSignatureType,\n  _TypeBuilderSetStructType,\n  _TypeBuilderSetArrayType,\n  _TypeBuilderIsBasic,\n  _TypeBuilderGetBasic,\n  _TypeBuilderGetTempHeapType,\n  _TypeBuilderGetTempTupleType,\n  _TypeBuilderGetTempRefType,\n  _TypeBuilderSetSubType,\n  _TypeBuilderCreateRecGroup,\n  _TypeBuilderBuildAndDispose,\n  _BinaryenModuleSetTypeName,\n  _BinaryenModuleSetFieldName,\n\n  _BinaryenGetOptimizeLevel,\n  _BinaryenSetOptimizeLevel,\n  _BinaryenGetShrinkLevel,\n  _BinaryenSetShrinkLevel,\n  _BinaryenGetDebugInfo,\n  _BinaryenSetDebugInfo,\n  _BinaryenGetLowMemoryUnused,\n  _BinaryenSetLowMemoryUnused,\n  _BinaryenGetZeroFilledMemory,\n  _BinaryenSetZeroFilledMemory,\n  _BinaryenGetFastMath,\n  _BinaryenSetFastMath,\n  _BinaryenGetPassArgument,\n  _BinaryenSetPassArgument,\n  _BinaryenClearPassArguments,\n  _BinaryenGetAlwaysInlineMaxSize,\n  _BinaryenSetAlwaysInlineMaxSize,\n  _BinaryenGetFlexibleInlineMaxSize,\n  _BinaryenSetFlexibleInlineMaxSize,\n  _BinaryenGetOneCallerInlineMaxSize,\n  _BinaryenSetOneCallerInlineMaxSize,\n  _BinaryenGetAllowInliningFunctionsWithLoops,\n  _BinaryenSetAllowInliningFunctionsWithLoops,\n  _BinaryenGetTypeSystem,\n  _BinaryenSetTypeSystem,\n\n  // Helpers\n\n  _malloc,\n  _free,\n  __i32_store8,\n  __i32_store16,\n  __i32_store,\n  __f32_store,\n  __f64_store,\n  __i32_load8_s,\n  __i32_load8_u,\n  __i32_load16_s,\n  __i32_load16_u,\n  __i32_load,\n  __f32_load,\n  __f64_load\n\n} = binaryen;\n\nexport default binaryen;\n", "/**\n * @fileoverview Floating point glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst F64 = new Float64Array(1);\nconst F32 = new Float32Array(F64.buffer);\nconst I32 = new Int32Array(F64.buffer);\n\nglobalThis.f32_as_i32 = function f32_as_i32(value) {\n  F32[0] = value;\n  return I32[0];\n};\n\nglobalThis.i32_as_f32 = function i32_as_f32(value) {\n  I32[0] = value;\n  return F32[0];\n};\n\nglobalThis.f64_as_i64 = function f64_as_i64(value) {\n  F64[0] = value;\n  return i64_new(I32[0], I32[1]);\n};\n\nglobalThis.i64_as_f64 = function i64_as_f64(value) {\n  I32[0] = i64_low(value);\n  I32[1] = i64_high(value);\n  return F64[0];\n};\n", "/**\n * @fileoverview 64-bit integer glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nimport Long from \"long\";\n\nglobalThis.i64_zero    = Long.ZERO;\nglobalThis.i64_one     = Long.ONE;\nglobalThis.i64_neg_one = Long.fromInt(-1);\nglobalThis.i64_minimum = Long.MIN_VALUE;\nglobalThis.i64_maximum = Long.MAX_VALUE;\n\nglobalThis.i64_is = function i64_is(value) {\n  return Long.isLong(value);\n};\n\nglobalThis.i64_new = function i64_new(lo, hi) {\n  return Long.fromBits(lo, hi);\n};\n\nglobalThis.i64_low = function i64_low(value) {\n  return value.low;\n};\n\nglobalThis.i64_high = function i64_high(value) {\n  return value.high;\n};\n\nglobalThis.i64_not = function i64_not(value) {\n  return value.not();\n};\n\nglobalThis.i64_neg = function i64_neg(value) {\n  return value.neg();\n};\n\nglobalThis.i64_clz = function i64_clz(value) {\n  return value.clz();\n};\n\nglobalThis.i64_ctz = function i64_ctz(value) {\n  return value.ctz();\n};\n\nglobalThis.i64_add = function i64_add(left, right) {\n  return left.add(right);\n};\n\nglobalThis.i64_sub = function i64_sub(left, right) {\n  return left.sub(right);\n};\n\nglobalThis.i64_mul = function i64_mul(left, right) {\n  return left.mul(right);\n};\n\nglobalThis.i64_pow = function i64_pow(left, right) {\n  let rightLo = right.low;\n  let rightHi = right.high;\n  if (rightHi <= 0) {\n    if (rightHi < 0) {\n      if (left.eq(globalThis.i64_neg_one)) {\n        return rightLo & 1 ? left : Long.ONE;\n      }\n      return left.eq(Long.ONE) ? left : Long.ZERO;\n    }\n    if (rightLo == 0) return Long.ONE;\n    if (rightLo == 1) return left;\n    if (rightLo == 2) return left.mul(left);\n  }\n  let result = Long.ONE;\n  while (rightLo | rightHi) {\n    if (rightLo & 1) result = result.mul(left);\n    right = right.shru(1);\n    left  = left.mul(left);\n    rightLo = right.low;\n    rightHi = right.high;\n  }\n  return result;\n};\n\nglobalThis.i64_div = function i64_div(left, right) {\n  return left.div(right);\n};\n\nglobalThis.i64_div_u = function i64_div_u(left, right) {\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\n};\n\nglobalThis.i64_rem = function i64_rem(left, right) {\n  return left.mod(right);\n};\n\nglobalThis.i64_rem_u = function i64_rem_u(left, right) {\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\n};\n\nglobalThis.i64_and = function i64_and(left, right) {\n  return left.and(right);\n};\n\nglobalThis.i64_or = function i64_or(left, right) {\n  return left.or(right);\n};\n\nglobalThis.i64_xor = function i64_xor(left, right) {\n  return left.xor(right);\n};\n\nglobalThis.i64_shl = function i64_shl(left, right) {\n  return left.shl(right);\n};\n\nglobalThis.i64_shr = function i64_shr(left, right) {\n  return left.shr(right);\n};\n\nglobalThis.i64_shr_u = function i64_shr_u(left, right) {\n  return left.shru(right);\n};\n\nglobalThis.i64_eq = function i64_eq(left, right) {\n  return left.eq(right);\n};\n\nglobalThis.i64_ne = function i64_ne(left, right) {\n  return left.ne(right);\n};\n\nglobalThis.i64_ge = function i64_ge(left, right) {\n  return left.ge(right);\n};\n\nglobalThis.i64_ge_u = function i64_ge_u(left, right) {\n  return left.toUnsigned().ge(right.toUnsigned());\n};\n\nglobalThis.i64_gt = function i64_gt(left, right) {\n  return left.gt(right);\n};\n\nglobalThis.i64_gt_u = function i64_gt_u(left, right) {\n  return left.toUnsigned().gt(right.toUnsigned());\n};\n\nglobalThis.i64_le = function i64_le(left, right) {\n  return left.le(right);\n};\n\nglobalThis.i64_le_u = function i64_le_u(left, right) {\n  return left.toUnsigned().le(right.toUnsigned());\n};\n\nglobalThis.i64_lt = function i64_lt(left, right) {\n  return left.lt(right);\n};\n\nglobalThis.i64_lt_u = function i64_lt_u(left, right) {\n  return left.toUnsigned().lt(right.toUnsigned());\n};\n\nglobalThis.i64_align = function i64_align(value, alignment) {\n  assert(alignment && (alignment & (alignment - 1)) == 0);\n  let mask = Long.fromInt(alignment - 1);\n  return value.add(mask).and(mask.not());\n};\n\nglobalThis.i64_signbit = function i64_signbit(value) {\n  return Boolean(value.high >>> 31);\n};\n\nglobalThis.i64_is_i8 = function i64_is_i8(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\n};\n\nglobalThis.i64_is_i16 = function i64_is_i16(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\n};\n\nglobalThis.i64_is_i32 = function i64_is_i32(value) {\n  return (value.high === 0 && value.low >= 0)\n      || (value.high === -1 && value.low < 0);\n};\n\nglobalThis.i64_is_u8 = function i64_is_u8(value) {\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\n};\n\nglobalThis.i64_is_u16 = function i64_is_u16(value) {\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\n};\n\nglobalThis.i64_is_u32 = function i64_is_u32(value) {\n  return value.high === 0;\n};\n\nglobalThis.i64_is_bool = function i64_is_bool(value) {\n  return (value.high | (value.low & ~1)) === 0;\n};\n\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\n\nglobalThis.i64_is_f32 = function i64_is_f32(value) {\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\n};\n\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\n\nglobalThis.i64_is_f64 = function i64_is_f64(value) {\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\n};\n\nglobalThis.i64_to_f32 = function i64_to_f32(value) {\n  return globalThis.Math.fround(value.toNumber());\n};\n\nglobalThis.i64_to_f64 = function i64_to_f64(value) {\n  return value.toNumber();\n};\n\nglobalThis.i64_to_string = function i64_to_string(value, unsigned) {\n  return unsigned ? value.toUnsigned().toString() : value.toString();\n};\n\nglobalThis.i64_clone = function i64_clone(value) {\n  return Long.fromBits(value.low, value.high, value.unsigned);\n};\n", "/**\n * @fileoverview Collections glue code for JavaScript.\n * @license Apache-2.0\n */\n\nglobalThis.Map_keys = function Map_keys(map) {\n  return Array.from(map.keys());\n};\n\nglobalThis.Map_values = function Map_values(map) {\n  return Array.from(map.values());\n};\n\nglobalThis.Set_values = function Set_values(set) {\n  return Array.from(set.values());\n};\n", "// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  None = 0,\n  /** Sign extension operations. */\n  SignExtension = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MutableGlobals = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NontrappingF2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BulkMemory = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  Simd = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  Threads = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  ExceptionHandling = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TailCalls = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  ReferenceTypes = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MultiValue = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  Memory64 = 1 << 11, // see: https://github.com/WebAssembly/memory64\n  /** Relaxed SIMD. */\n  RelaxedSimd = 1 << 12, // see: https://github.com/WebAssembly/relaxed-simd\n  /** Extended const expressions. */\n  ExtendedConst = 1 << 13, // see: https://github.com/WebAssembly/extended-const\n  /** Reference typed strings. */\n  Stringref = 1 << 14, // see: https://github.com/WebAssembly/stringref\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SignExtension: return \"sign-extension\";\n    case Feature.MutableGlobals: return \"mutable-globals\";\n    case Feature.NontrappingF2I: return \"nontrapping-f2i\";\n    case Feature.BulkMemory: return \"bulk-memory\";\n    case Feature.Simd: return \"simd\";\n    case Feature.Threads: return \"threads\";\n    case Feature.ExceptionHandling: return \"exception-handling\";\n    case Feature.TailCalls: return \"tail-calls\";\n    case Feature.ReferenceTypes: return \"reference-types\";\n    case Feature.MultiValue: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.Memory64: return \"memory64\";\n    case Feature.RelaxedSimd: return \"relaxed-simd\";\n    case Feature.ExtendedConst: return \"extended-const\";\n    case Feature.Stringref: return \"stringref\";\n  }\n  assert(false);\n  return \"\";\n}\n", "// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  Js = 0,\n  /** WebAssembly with 32-bit pointers. */\n  Wasm32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  Wasm64 = 2,\n}\n", "// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n", "// This file is shared with the compiler and must remain portable\n\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Typeinfo interpretation \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524 \u25C4\u2500 __rtti_base\n// \u2502                             count                             \u2502\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2510\n// \u2502                      Typeinfo#flags [id=0]                    \u2502 id < count\n// \u251C \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2524\n// \u2502                      Typeinfo#base  [id=0]                    \u2502\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502                              ...                              \u2502\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n", "/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport const enum CommonFlags {\n  /** No flags set. */\n  None = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  Import = 1 << 0,\n  /** Has an `export` modifier. */\n  Export = 1 << 1,\n  /** Has a `declare` modifier. */\n  Declare = 1 << 2,\n  /** Has a `const` modifier. */\n  Const = 1 << 3,\n  /** Has a `let` modifier. */\n  Let = 1 << 4,\n  /** Has a `static` modifier. */\n  Static = 1 << 5,\n  /** Has a `readonly` modifier. */\n  Readonly = 1 << 6,\n  /** Has an `abstract` modifier. */\n  Abstract = 1 << 7,\n  /** Has a `public` modifier. */\n  Public = 1 << 8,\n  /** Has a `private` modifier. */\n  Private = 1 << 9,\n  /** Has a `protected` modifier. */\n  Protected = 1 << 10,\n  /** Has a `get` modifier. */\n  Get = 1 << 11,\n  /** Has a `set` modifier. */\n  Set = 1 << 12,\n  /** Has a `override` modifier.  */\n  Override = 1 << 13,\n\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DefinitelyAssigned = 1 << 14,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  Ambient = 1 << 15,\n  /** Is generic. */\n  Generic = 1 << 16,\n  /** Is part of a generic context. */\n  GenericContext = 1 << 17,\n  /** Is an instance member. */\n  Instance = 1 << 18,\n  /** Is a constructor. */\n  Constructor = 1 << 19,\n  /** Is a module export. */\n  ModuleExport = 1 << 20,\n  /** Is a module import. */\n  ModuleImport = 1 << 21,\n\n  // Compilation states\n\n  /** Is resolved. */\n  Resolved = 1 << 22,\n  /** Is compiled. */\n  Compiled = 1 << 23,\n  /** Did error. */\n  Errored = 1 << 24,\n  /** Has a constant value and is therefore inlined. */\n  Inlined = 1 << 25,\n  /** Is scoped. */\n  Scoped = 1 << 26,\n  /** Is a stub. */\n  Stub = 1 << 27,\n  /** Is a virtual method. */\n  Virtual = 1 << 28,\n  /** Is (part of) a closure. */\n  Closure = 1 << 29,\n\n  // Other\n\n  /** Is quoted. */\n  Quoted = 1 << 30\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const Empty = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const funcref = \"funcref\";\n  export const externref = \"externref\";\n  export const anyref = \"anyref\";\n  export const eqref = \"eqref\";\n  export const i31ref = \"i31ref\";\n  export const dataref = \"dataref\";\n  export const arrayref = \"arrayref\";\n  export const stringref = \"stringref\";\n  export const stringview_wtf8 = \"stringview_wtf8\";\n  export const stringview_wtf16 = \"stringview_wtf16\";\n  export const stringview_iter = \"stringview_iter\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  export const nonnull = \"nonnull\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_RUNTIME = \"ASC_RUNTIME\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_EXPORT_RUNTIME = \"ASC_EXPORT_RUNTIME\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  export const ASC_FEATURE_RELAXED_SIMD = \"ASC_FEATURE_RELAXED_SIMD\";\n  export const ASC_FEATURE_EXTENDED_CONST = \"ASC_FEATURE_EXTENDED_CONST\";\n  export const ASC_FEATURE_STRINGREF = \"ASC_FEATURE_STRINGREF\";\n  export const ASC_VERSION_MAJOR = \"ASC_VERSION_MAJOR\";\n  export const ASC_VERSION_MINOR = \"ASC_VERSION_MINOR\";\n  export const ASC_VERSION_PATCH = \"ASC_VERSION_PATCH\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const Funcref = \"Funcref\";\n  export const Externref = \"Externref\";\n  export const Anyref = \"Anyref\";\n  export const Eqref = \"Eqref\";\n  export const I31ref = \"I31ref\";\n  export const Dataref = \"Dataref\";\n  export const Arrayref = \"Arrayref\";\n  export const String = \"String\";\n  export const RegExp = \"RegExp\";\n  export const Object = \"Object\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const TemplateStringsArray = \"TemplateStringsArray\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const _g = \"_g\";\n  export const max_iterations = \"max_iterations\";\n  export const accept = \"$accept\";\n  export const emit = \"$emit\";\n  export const etxn_details = \"$etxn_details\";\n  export const etxn_fee_base = \"$etxn_fee_base\";\n  export const etxn_reserve = \"$etxn_reserve\";\n  export const float_compare = \"$float_compare\";\n  export const float_divide = \"$float_divide\";\n  export const float_int = \"$float_int\";\n  export const float_mulratio = \"$float_mulratio\";\n  export const float_multiply = \"$float_multiply\";\n  export const float_negate = \"$float_negate\";\n  export const float_set = \"$float_set\";\n  export const float_sto = \"$float_sto\";\n  export const float_sto_set = \"$float_sto_set\";\n  export const float_sum = \"$float_sum\";\n  export const hook_account = \"$hook_account\";\n  export const hook_param = \"$hook_param\";\n  export const ledger_seq = \"ledger_seq\";\n  export const otxn_field = \"otxn_field\";\n  export const otxn_slot = \"$otxn_slot\";\n  export const rollback = \"$rollback\";\n  export const slot = \"$slot\";\n  export const slot_count = \"$slot_count\";\n  export const slot_float = \"$slot_float\";\n  export const slot_set = \"$slot_set\";\n  export const slot_subarray = \"$slot_subarray\";\n  export const slot_subfield = \"$slot_subfield\";\n  export const slot_type = \"$slot_type\";\n  export const state = \"$state\";\n  export const state_foreign = \"$state_foreign\";\n  export const state_set = \"$state_set\";\n  export const sto_emplace = \"$sto_emplace\";\n  export const sto_erase = \"$sto_erase\";\n  export const sto_subarray = \"$sto_subarray\";\n  export const sto_subfield = \"$sto_subfield\";\n  export const trace = \"trace\";\n  export const trace_float = \"$trace_float\";\n  export const trace_num = \"$trace_num\";\n  export const util_accid = \"$util_accid\";\n  export const util_keylet = \"$util_keylet\";\n  export const util_sha512h = \"$util_sha512h\";\n  export const util_verify = \"$util_verify\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const link = \"__link\";\n  export const collect = \"__collect\";\n  export const typeinfo = \"__typeinfo\";\n  export const instanceof_ = \"__instanceof\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n  // memory & table\n  export const DefaultMemory = \"0\";\n  export const DefaultTable = \"0\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Runtime } from \"../std/assembly/shared/runtime\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n", "// GENERATED FILE. DO NOT EDIT.\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Transform_0_1 = 109,\n  Start_function_name_0_is_invalid_or_conflicts_with_another_export = 110,\n  Element_0_not_found = 111,\n  Exchange_of_0_values_is_not_supported_by_all_embeddings = 112,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Expression_does_not_compile_to_a_value_at_runtime = 234,\n  Only_variables_functions_and_enums_become_WebAssembly_module_exports = 235,\n  Literal_0_does_not_fit_into_i64_or_u64_types = 236,\n  Index_signature_accessors_in_type_0_differ_in_types = 237,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  _NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead = 907,\n  Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters = 908,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  _0_modifier_cannot_appear_on_class_elements_of_this_kind = 1031,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  A_default_export_can_only_be_used_in_a_module = 1319,\n  An_expression_of_type_0_cannot_be_tested_for_truthiness = 1345,\n  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Property_0_is_private_in_type_1_but_not_in_type_2 = 2325,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _this_cannot_be_referenced_in_constructor_arguments = 2333,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  _super_cannot_be_referenced_in_constructor_arguments = 2336,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 = 2416,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Types_have_separate_declarations_of_a_private_property_0 = 2442,\n  Property_0_is_protected_in_type_1_but_public_in_type_2 = 2444,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  Cannot_redeclare_block_scoped_variable_0 = 2451,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Type_alias_0_circularly_references_itself = 2456,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0 = 4117,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 109: return \"Transform '{0}': {1}\";\n    case 110: return \"Start function name '{0}' is invalid or conflicts with another export.\";\n    case 111: return \"Element '{0}' not found.\";\n    case 112: return \"Exchange of '{0}' values is not supported by all embeddings\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 234: return \"Expression does not compile to a value at runtime.\";\n    case 235: return \"Only variables, functions and enums become WebAssembly module exports.\";\n    case 236: return \"Literal '{0}' does not fit into 'i64' or 'u64' types.\";\n    case 237: return \"Index signature accessors in type '{0}' differ in types.\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 907: return \"'NaN' does not compare equal to any other value including itself. Use isNaN(x) instead.\";\n    case 908: return \"Comparison with -0.0 is sign insensitive. Use Object.is(x, -0.0) if the sign matters.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1031: return \"'{0}' modifier cannot appear on class elements of this kind.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 1319: return \"A default export can only be used in a module.\";\n    case 1345: return \"An expression of type '{0}' cannot be tested for truthiness.\";\n    case 1351: return \"An identifier or keyword cannot immediately follow a numeric literal.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2325: return \"Property '{0}' is private in type '{1}' but not in type '{2}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2333: return \"'this' cannot be referenced in constructor arguments.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2336: return \"'super' cannot be referenced in constructor arguments.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2416: return \"Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2442: return \"Types have separate declarations of a private property '{0}'.\";\n    case 2444: return \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2451: return \"Cannot redeclare block-scoped variable '{0}'\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2456: return \"Type alias '{0}' circularly references itself.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 4117: return \"This member cannot have an 'override' modifier because it is not declared in the base class '{0}'.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n", "/**\n * @fileoverview Various utility.\n * @license Apache-2.0\n */\n\nexport * from \"./util/binary\";\nexport * from \"./util/collections\";\nexport * from \"./util/math\";\nexport * from \"./util/path\";\nexport * from \"./util/terminal\";\nexport * from \"./util/text\";\nexport * from \"./util/vector\";\n", "/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8\n       | i32(buffer[offset + 2]) << 16\n       | i32(buffer[offset + 3]) << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  let lo = readI32(buffer, offset);\n  let hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  let valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n\n/** Reads a 128-bit vector from the specified buffer. */\nexport function readV128(buffer: Uint8Array, offset: i32): Uint8Array {\n  return buffer.slice(offset, offset + 16);\n}\n\n/** Writes a 128-bit vector to the specified buffer. */\nexport function writeV128(value: Uint8Array, buffer: Uint8Array, offset: i32): void {\n  assert(value.length == 16);\n  buffer.set(value, offset);\n}\n", "/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Clone map. Typically used to track contextual type arguments. */\nexport function cloneMap<K,V>(map: Map<K,V> | null): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    // fast path for js target\n    return new Map<K,V>(map);\n  } else {\n    let out = new Map<K,V>();\n    if (map) {\n      // TODO: for (let [k, v] of map) {\n      for (let _keys = Map_keys(map), i = 0, k = _keys.length; i < k; ++i) {\n        let k = unchecked(_keys[i]);\n        let v = assert(map.get(k));\n        out.set(k, v);\n      }\n    }\n    return out;\n  }\n}\n\n/** Merge two maps in into new one. */\nexport function mergeMaps<K,V>(map1: Map<K,V>, map2: Map<K,V>): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    let out = new Map<K,V>(map1);\n    map2.forEach((v, k) => out.set(k, v));\n    return out;\n  } else {\n    let out = new Map<K,V>();\n    // TODO: for (let [k, v] of map1) {\n    for (let _keys = Map_keys(map1), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map1.get(k));\n      out.set(k, v);\n    }\n    // TODO: for (let [k, v] of map2) {\n    for (let _keys = Map_keys(map2), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map2.get(k));\n      out.set(k, v);\n    }\n    return out;\n  }\n}\n\n/** BitSet represent growable sequence of N bits. It's faster alternative of Set<i32> when elements\n * are not too much sparsed. Also it's more memory and cache efficient than Array<bool>.\n * The best way to use it for short bit sequences (less than 32*(2**16)).\n */\nexport class BitSet {\n  words!: Uint32Array;\n\n  constructor() {\n    this.clear();\n  }\n\n  get size(): i32 {\n    let count = 0;\n    let words = this.words;\n    for (let i = 0, len = words.length; i < len; i++) {\n      let word = unchecked(words[i]);\n      if (word) count += popcnt(word);\n    }\n    return count;\n  }\n\n  add(index: i32): this {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) { // resize\n      this.words = new Uint32Array(idx + 16);\n      this.words.set(words);\n      words = this.words;\n    }\n    unchecked(words[idx] |= 1 << index);\n    return this;\n  }\n\n  delete(index: i32): void {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return;\n    unchecked(words[idx] &= ~(1 << index));\n  }\n\n  has(index: i32): bool {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return false;\n    return (unchecked(words[index >>> 5]) & (1 << index)) !== 0;\n  }\n\n  clear(): void {\n    this.words = new Uint32Array(16);\n  }\n\n  toArray(): i32[] {\n    let res = new Array<i32>(this.size);\n    for (let i = 0, p = 0, len = this.words.length; i < len; ++i) {\n      let word = unchecked(this.words[i]);\n      while (word) {\n        let mask = word & -word;\n        unchecked(res[p++] = (i << 5) + popcnt(mask - 1));\n        word ^= mask;\n      }\n    }\n    return res;\n  }\n\n  toString(): string {\n    return `BitSet { ${this.toArray()} }`;\n  }\n}\n", "/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n\nexport function accuratePow64(x: f64, y: f64): f64 {\n  if (!ASC_TARGET) { // ASC_TARGET == JS\n    // Engines like V8, WebKit and SpiderMonkey uses powi fast path if exponent is integer\n    // This speculative optimization leads to loose precisions like 10 ** 208 != 1e208\n    // or/and 10 ** -5 != 1e-5 anymore. For avoid this behaviour we are forcing exponent\n    // to fractional form and compensate this afterwards.\n    if (isFinite(y) && Math.abs(y) >= 2 && Math.trunc(y) == y) {\n      if (y < 0) {\n        return Math.pow(x, y + 0.5) / Math.pow(x, 0.5);\n      } else {\n        return Math.pow(x, y - 0.5) * Math.pow(x, 0.5);\n      }\n    }\n  }\n  return Math.pow(x, y);\n}\n", "/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  Null = 0,\n  LineFeed = 0x0A,\n  CarriageReturn = 0x0D,\n  LineSeparator = 0x2028,\n  ParagraphSeparator = 0x2029,\n  NextLine = 0x0085,\n\n  Space = 0x20,\n  NonBreakingSpace = 0xA0,\n  EnQuad = 0x2000,\n  EmQuad = 0x2001,\n  EnSpace = 0x2002,\n  EmSpace = 0x2003,\n  ThreePerEmSpace = 0x2004,\n  FourPerEmSpace = 0x2005,\n  SixPerEmSpace = 0x2006,\n  FigureSpace = 0x2007,\n  PunctuationSpace = 0x2008,\n  ThinSpace = 0x2009,\n  HairSpace = 0x200A,\n  ZeroWidthSpace = 0x200B,\n  NarrowNoBreakSpace = 0x202F,\n  IdeographicSpace = 0x3000,\n  MathematicalSpace = 0x205F,\n  Ogham = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  Ampersand = 0x26,\n  Asterisk = 0x2A,\n  At = 0x40,\n  Backslash = 0x5C,\n  Backtick = 0x60,\n  Bar = 0x7C,\n  Caret = 0x5E,\n  CloseBrace = 0x7D,\n  CloseBracket = 0x5D,\n  CloseParen = 0x29,\n  Colon = 0x3A,\n  Comma = 0x2C,\n  Dollar = 0x24,\n  Dot = 0x2E,\n  DoubleQuote = 0x22,\n  Equals = 0x3D,\n  Exclamation = 0x21,\n  GreaterThan = 0x3E,\n  Hash = 0x23,\n  LessThan = 0x3C,\n  Minus = 0x2D,\n  OpenBrace = 0x7B,\n  OpenBracket = 0x5B,\n  OpenParen = 0x28,\n  Percent = 0x25,\n  Plus = 0x2B,\n  Question = 0x3F,\n  Semicolon = 0x3B,\n  SingleQuote = 0x27,\n  Slash = 0x2F,\n  Tilde = 0x7E,\n\n  Backspace = 0x08,\n  FormFeed = 0x0C,\n  ByteOrderMark = 0xFEFF,\n  Tab = 0x09,\n  VerticalTab = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: i32): bool {\n  switch (c) {\n    case CharCode.LineFeed:\n    case CharCode.CarriageReturn:\n    case CharCode.LineSeparator:\n    case CharCode.ParagraphSeparator: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  // NOTE: Calling code assumes that there are no supplementary whitespaces.\n  // If Unicode ever adds one, uses of this function must be updated to\n  // conditionally advance by two code units, i.e. using `numCodeUnits`.\n  switch (c) {\n    case CharCode.Space:\n    case CharCode.Tab:\n    case CharCode.VerticalTab:\n    case CharCode.FormFeed:\n    case CharCode.NonBreakingSpace:\n    case CharCode.NextLine:\n    case CharCode.Ogham:\n    case CharCode.NarrowNoBreakSpace:\n    case CharCode.MathematicalSpace:\n    case CharCode.IdeographicSpace:\n    case CharCode.ByteOrderMark: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.EnQuad && c <= CharCode.ZeroWidthSpace;\n    }\n  }\n}\n\n/** First high (lead) surrogate. */\nexport const SURROGATE_HIGH = 0xD800;\n\n/** First low (trail) surrogate. */\nexport const SURROGATE_LOW = 0xDC00;\n\n/** Tests if a code unit or code point is a surrogate. */\nexport function isSurrogate(c: i32): bool {\n  // F800: 11111 0 0000000000 Mask\n  // D800: 11011 X XXXXXXXXXX Any surrogate\n  return (c & 0xF800) == SURROGATE_HIGH;\n}\n\n/** Tests if a surrogate is a high (lead) surrogate. */\nexport function isSurrogateHigh(c: i32): bool {\n  // D800-DBFF\n  return c < SURROGATE_LOW;\n}\n\n/** Tests if a surrogate is a low (trail) surrogate. */\nexport function isSurrogateLow(c: i32): bool {\n  // DC00-DFFF\n  return c >= SURROGATE_LOW;\n}\n\n/** Tests if a code unit or code point is a high (lead) surrogate. */\nexport function isHighSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // D800: 11011 0 XXXXXXXXXX High/Lead surrogate\n  return (c & 0xFC00) == SURROGATE_HIGH;\n}\n\n/** Tests if a code unit or code point is a low (trail) surrogate. */\nexport function isLowSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // DC00: 11011 1 XXXXXXXXXX Low/Trail surrogate\n  return (c & 0xFC00) == SURROGATE_LOW;\n}\n\n/** Converts a surrogate pair to its respective code point. */\nexport function combineSurrogates(hi: i32, lo: i32): i32 {\n  return 0x10000 + ((hi & 0x3FF) << 10) | (lo & 0x3FF);\n}\n\n/** Gets the number of UTF-16 code units of the specified code point. */\nexport function numCodeUnits(cp: i32): i32 {\n  return 1 + i32(cp > 0xffff);\n}\n\nexport function isAlpha(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z;\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is a valid hexadecimal symbol [a-f]. */\nexport function isHexBase(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - f|F\n  return c0 >= CharCode.a && c0 <= CharCode.f;\n}\n\n/** Tests if the specified character code is a valid hexadecimal digit. */\nexport function isHexOrDecimal(c: i32): bool {\n  return isDecimal(c) || isHexBase(c);\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isAlphaOrDecimal(c: i32): bool {\n  return isAlpha(c) || isDecimal(c);\n}\n\n/** Tests if the specified code point is a valid start of an identifier. */\nexport function isIdentifierStart(cp: i32): bool {\n  return isAlpha(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierStartMin && cp <= unicodeIdentifierStartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierStart);\n}\n\n/** Tests if the specified code point is a valid part of an identifier. */\nexport function isIdentifierPart(cp: i32): bool {\n  return isAlphaOrDecimal(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierPartMin && cp <= unicodeIdentifierPartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierPart);\n}\n\n/** Tests if the specified string is a valid identifer. */\nexport function isIdentifier(str: string): bool {\n  let len = str.length;\n  if (!len) return false;\n  let cp = <i32>str.codePointAt(0);\n  if (!isIdentifierStart(cp)) return false;\n  let i = numCodeUnits(cp);\n  while (i < len) {\n    cp = <i32>str.codePointAt(i);\n    if (!isIdentifierPart(cp)) return false;\n    i += numCodeUnits(cp);\n  }\n  return true;\n}\n\n/** Unicode 14.0 ID_Start/Other_ID_Start ranges */\nconst unicodeIdentifierStart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 186   , 186   , 192   , 214   ,\n  216   , 246   , 248   , 705   , 710   , 721   , 736   , 740   ,\n  748   , 748   , 750   , 750   , 880   , 884   , 886   , 887   ,\n  890   , 893   , 895   , 895   , 902   , 902   , 904   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1162  , 1327  , 1329  , 1366  , 1369  , 1369  , 1376  , 1416  ,\n  1488  , 1514  , 1519  , 1522  , 1568  , 1610  , 1646  , 1647  ,\n  1649  , 1747  , 1749  , 1749  , 1765  , 1766  , 1774  , 1775  ,\n  1786  , 1788  , 1791  , 1791  , 1808  , 1808  , 1810  , 1839  ,\n  1869  , 1957  , 1969  , 1969  , 1994  , 2026  , 2036  , 2037  ,\n  2042  , 2042  , 2048  , 2069  , 2074  , 2074  , 2084  , 2084  ,\n  2088  , 2088  , 2112  , 2136  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2208  , 2249  , 2308  , 2361  , 2365  , 2365  ,\n  2384  , 2384  , 2392  , 2401  , 2417  , 2432  , 2437  , 2444  ,\n  2447  , 2448  , 2451  , 2472  , 2474  , 2480  , 2482  , 2482  ,\n  2486  , 2489  , 2493  , 2493  , 2510  , 2510  , 2524  , 2525  ,\n  2527  , 2529  , 2544  , 2545  , 2556  , 2556  , 2565  , 2570  ,\n  2575  , 2576  , 2579  , 2600  , 2602  , 2608  , 2610  , 2611  ,\n  2613  , 2614  , 2616  , 2617  , 2649  , 2652  , 2654  , 2654  ,\n  2674  , 2676  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2749  , 2749  ,\n  2768  , 2768  , 2784  , 2785  , 2809  , 2809  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2877  , 2877  , 2908  , 2909  , 2911  , 2913  ,\n  2929  , 2929  , 2947  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3024  , 3024  ,\n  3077  , 3084  , 3086  , 3088  , 3090  , 3112  , 3114  , 3129  ,\n  3133  , 3133  , 3160  , 3162  , 3165  , 3165  , 3168  , 3169  ,\n  3200  , 3200  , 3205  , 3212  , 3214  , 3216  , 3218  , 3240  ,\n  3242  , 3251  , 3253  , 3257  , 3261  , 3261  , 3293  , 3294  ,\n  3296  , 3297  , 3313  , 3314  , 3332  , 3340  , 3342  , 3344  ,\n  3346  , 3386  , 3389  , 3389  , 3406  , 3406  , 3412  , 3414  ,\n  3423  , 3425  , 3450  , 3455  , 3461  , 3478  , 3482  , 3505  ,\n  3507  , 3515  , 3517  , 3517  , 3520  , 3526  , 3585  , 3632  ,\n  3634  , 3635  , 3648  , 3654  , 3713  , 3714  , 3716  , 3716  ,\n  3718  , 3722  , 3724  , 3747  , 3749  , 3749  , 3751  , 3760  ,\n  3762  , 3763  , 3773  , 3773  , 3776  , 3780  , 3782  , 3782  ,\n  3804  , 3807  , 3840  , 3840  , 3904  , 3911  , 3913  , 3948  ,\n  3976  , 3980  , 4096  , 4138  , 4159  , 4159  , 4176  , 4181  ,\n  4186  , 4189  , 4193  , 4193  , 4197  , 4198  , 4206  , 4208  ,\n  4213  , 4225  , 4238  , 4238  , 4256  , 4293  , 4295  , 4295  ,\n  4301  , 4301  , 4304  , 4346  , 4348  , 4680  , 4682  , 4685  ,\n  4688  , 4694  , 4696  , 4696  , 4698  , 4701  , 4704  , 4744  ,\n  4746  , 4749  , 4752  , 4784  , 4786  , 4789  , 4792  , 4798  ,\n  4800  , 4800  , 4802  , 4805  , 4808  , 4822  , 4824  , 4880  ,\n  4882  , 4885  , 4888  , 4954  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5905  , 5919  , 5937  ,\n  5952  , 5969  , 5984  , 5996  , 5998  , 6000  , 6016  , 6067  ,\n  6103  , 6103  , 6108  , 6108  , 6176  , 6264  , 6272  , 6312  ,\n  6314  , 6314  , 6320  , 6389  , 6400  , 6430  , 6480  , 6509  ,\n  6512  , 6516  , 6528  , 6571  , 6576  , 6601  , 6656  , 6678  ,\n  6688  , 6740  , 6823  , 6823  , 6917  , 6963  , 6981  , 6988  ,\n  7043  , 7072  , 7086  , 7087  , 7098  , 7141  , 7168  , 7203  ,\n  7245  , 7247  , 7258  , 7293  , 7296  , 7304  , 7312  , 7354  ,\n  7357  , 7359  , 7401  , 7404  , 7406  , 7411  , 7413  , 7414  ,\n  7418  , 7418  , 7424  , 7615  , 7680  , 7957  , 7960  , 7965  ,\n  7968  , 8005  , 8008  , 8013  , 8016  , 8023  , 8025  , 8025  ,\n  8027  , 8027  , 8029  , 8029  , 8031  , 8061  , 8064  , 8116  ,\n  8118  , 8124  , 8126  , 8126  , 8130  , 8132  , 8134  , 8140  ,\n  8144  , 8147  , 8150  , 8155  , 8160  , 8172  , 8178  , 8180  ,\n  8182  , 8188  , 8305  , 8305  , 8319  , 8319  , 8336  , 8348  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11502 , 11506 , 11507 ,\n  11520 , 11557 , 11559 , 11559 , 11565 , 11565 , 11568 , 11623 ,\n  11631 , 11631 , 11648 , 11670 , 11680 , 11686 , 11688 , 11694 ,\n  11696 , 11702 , 11704 , 11710 , 11712 , 11718 , 11720 , 11726 ,\n  11728 , 11734 , 11736 , 11742 , 12293 , 12295 , 12321 , 12329 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12443 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42527 , 42538 , 42539 ,\n  42560 , 42606 , 42623 , 42653 , 42656 , 42735 , 42775 , 42783 ,\n  42786 , 42888 , 42891 , 42954 , 42960 , 42961 , 42963 , 42963 ,\n  42965 , 42969 , 42994 , 43009 , 43011 , 43013 , 43015 , 43018 ,\n  43020 , 43042 , 43072 , 43123 , 43138 , 43187 , 43250 , 43255 ,\n  43259 , 43259 , 43261 , 43262 , 43274 , 43301 , 43312 , 43334 ,\n  43360 , 43388 , 43396 , 43442 , 43471 , 43471 , 43488 , 43492 ,\n  43494 , 43503 , 43514 , 43518 , 43520 , 43560 , 43584 , 43586 ,\n  43588 , 43595 , 43616 , 43638 , 43642 , 43642 , 43646 , 43695 ,\n  43697 , 43697 , 43701 , 43702 , 43705 , 43709 , 43712 , 43712 ,\n  43714 , 43714 , 43739 , 43741 , 43744 , 43754 , 43762 , 43764 ,\n  43777 , 43782 , 43785 , 43790 , 43793 , 43798 , 43808 , 43814 ,\n  43816 , 43822 , 43824 , 43866 , 43868 , 43881 , 43888 , 44002 ,\n  44032 , 55203 , 55216 , 55238 , 55243 , 55291 , 63744 , 64109 ,\n  64112 , 64217 , 64256 , 64262 , 64275 , 64279 , 64285 , 64285 ,\n  64287 , 64296 , 64298 , 64310 , 64312 , 64316 , 64318 , 64318 ,\n  64320 , 64321 , 64323 , 64324 , 64326 , 64433 , 64467 , 64829 ,\n  64848 , 64911 , 64914 , 64967 , 65008 , 65019 , 65136 , 65140 ,\n  65142 , 65276 , 65313 , 65338 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66176 , 66204 , 66208 , 66256 , 66304 , 66335 , 66349 , 66378 ,\n  66384 , 66421 , 66432 , 66461 , 66464 , 66499 , 66504 , 66511 ,\n  66513 , 66517 , 66560 , 66717 , 66736 , 66771 , 66776 , 66811 ,\n  66816 , 66855 , 66864 , 66915 , 66928 , 66938 , 66940 , 66954 ,\n  66956 , 66962 , 66964 , 66965 , 66967 , 66977 , 66979 , 66993 ,\n  66995 , 67001 , 67003 , 67004 , 67072 , 67382 , 67392 , 67413 ,\n  67424 , 67431 , 67456 , 67461 , 67463 , 67504 , 67506 , 67514 ,\n  67584 , 67589 , 67592 , 67592 , 67594 , 67637 , 67639 , 67640 ,\n  67644 , 67644 , 67647 , 67669 , 67680 , 67702 , 67712 , 67742 ,\n  67808 , 67826 , 67828 , 67829 , 67840 , 67861 , 67872 , 67897 ,\n  67968 , 68023 , 68030 , 68031 , 68096 , 68096 , 68112 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68192 , 68220 , 68224 , 68252 ,\n  68288 , 68295 , 68297 , 68324 , 68352 , 68405 , 68416 , 68437 ,\n  68448 , 68466 , 68480 , 68497 , 68608 , 68680 , 68736 , 68786 ,\n  68800 , 68850 , 68864 , 68899 , 69248 , 69289 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69445 , 69488 , 69505 ,\n  69552 , 69572 , 69600 , 69622 , 69635 , 69687 , 69745 , 69746 ,\n  69749 , 69749 , 69763 , 69807 , 69840 , 69864 , 69891 , 69926 ,\n  69956 , 69956 , 69959 , 69959 , 69968 , 70002 , 70006 , 70006 ,\n  70019 , 70066 , 70081 , 70084 , 70106 , 70106 , 70108 , 70108 ,\n  70144 , 70161 , 70163 , 70187 , 70272 , 70278 , 70280 , 70280 ,\n  70282 , 70285 , 70287 , 70301 , 70303 , 70312 , 70320 , 70366 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70461 , 70461 , 70480 , 70480 ,\n  70493 , 70497 , 70656 , 70708 , 70727 , 70730 , 70751 , 70753 ,\n  70784 , 70831 , 70852 , 70853 , 70855 , 70855 , 71040 , 71086 ,\n  71128 , 71131 , 71168 , 71215 , 71236 , 71236 , 71296 , 71338 ,\n  71352 , 71352 , 71424 , 71450 , 71488 , 71494 , 71680 , 71723 ,\n  71840 , 71903 , 71935 , 71942 , 71945 , 71945 , 71948 , 71955 ,\n  71957 , 71958 , 71960 , 71983 , 71999 , 71999 , 72001 , 72001 ,\n  72096 , 72103 , 72106 , 72144 , 72161 , 72161 , 72163 , 72163 ,\n  72192 , 72192 , 72203 , 72242 , 72250 , 72250 , 72272 , 72272 ,\n  72284 , 72329 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72750 , 72768 , 72768 , 72818 , 72847 , 72960 , 72966 ,\n  72968 , 72969 , 72971 , 73008 , 73030 , 73030 , 73056 , 73061 ,\n  73063 , 73064 , 73066 , 73097 , 73112 , 73112 , 73440 , 73458 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92784 , 92862 , 92880 , 92909 , 92928 , 92975 ,\n  92992 , 92995 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94032 , 94032 , 94099 , 94111 , 94176 , 94177 ,\n  94179 , 94179 , 94208 , 100343, 100352, 101589, 101632, 101640,\n  110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882,\n  110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770,\n  113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892,\n  119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974,\n  119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003,\n  120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092,\n  120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134,\n  120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538,\n  120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654,\n  120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770,\n  120772, 120779, 122624, 122654, 123136, 123180, 123191, 123197,\n  123214, 123214, 123536, 123565, 123584, 123627, 124896, 124902,\n  124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124,\n  125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791,\n  173824, 177976, 177984, 178205, 178208, 183969, 183984, 191456,\n  194560, 195101, 196608, 201546,\n];\nconst unicodeIdentifierStartMin = 170;\nconst unicodeIdentifierStartMax = 201546;\n\n/** Unicode 14.0 ID_Continue/Other_ID_Continue + ID_Start/Other_ID_Start ranges*/\nconst unicodeIdentifierPart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 183   , 183   , 186   , 186   ,\n  192   , 214   , 216   , 246   , 248   , 705   , 710   , 721   ,\n  736   , 740   , 748   , 748   , 750   , 750   , 768   , 884   ,\n  886   , 887   , 890   , 893   , 895   , 895   , 902   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1155  , 1159  , 1162  , 1327  , 1329  , 1366  , 1369  , 1369  ,\n  1376  , 1416  , 1425  , 1469  , 1471  , 1471  , 1473  , 1474  ,\n  1476  , 1477  , 1479  , 1479  , 1488  , 1514  , 1519  , 1522  ,\n  1552  , 1562  , 1568  , 1641  , 1646  , 1747  , 1749  , 1756  ,\n  1759  , 1768  , 1770  , 1788  , 1791  , 1791  , 1808  , 1866  ,\n  1869  , 1969  , 1984  , 2037  , 2042  , 2042  , 2045  , 2045  ,\n  2048  , 2093  , 2112  , 2139  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2200  , 2273  , 2275  , 2403  , 2406  , 2415  ,\n  2417  , 2435  , 2437  , 2444  , 2447  , 2448  , 2451  , 2472  ,\n  2474  , 2480  , 2482  , 2482  , 2486  , 2489  , 2492  , 2500  ,\n  2503  , 2504  , 2507  , 2510  , 2519  , 2519  , 2524  , 2525  ,\n  2527  , 2531  , 2534  , 2545  , 2556  , 2556  , 2558  , 2558  ,\n  2561  , 2563  , 2565  , 2570  , 2575  , 2576  , 2579  , 2600  ,\n  2602  , 2608  , 2610  , 2611  , 2613  , 2614  , 2616  , 2617  ,\n  2620  , 2620  , 2622  , 2626  , 2631  , 2632  , 2635  , 2637  ,\n  2641  , 2641  , 2649  , 2652  , 2654  , 2654  , 2662  , 2677  ,\n  2689  , 2691  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2748  , 2757  ,\n  2759  , 2761  , 2763  , 2765  , 2768  , 2768  , 2784  , 2787  ,\n  2790  , 2799  , 2809  , 2815  , 2817  , 2819  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2876  , 2884  , 2887  , 2888  , 2891  , 2893  ,\n  2901  , 2903  , 2908  , 2909  , 2911  , 2915  , 2918  , 2927  ,\n  2929  , 2929  , 2946  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3006  , 3010  ,\n  3014  , 3016  , 3018  , 3021  , 3024  , 3024  , 3031  , 3031  ,\n  3046  , 3055  , 3072  , 3084  , 3086  , 3088  , 3090  , 3112  ,\n  3114  , 3129  , 3132  , 3140  , 3142  , 3144  , 3146  , 3149  ,\n  3157  , 3158  , 3160  , 3162  , 3165  , 3165  , 3168  , 3171  ,\n  3174  , 3183  , 3200  , 3203  , 3205  , 3212  , 3214  , 3216  ,\n  3218  , 3240  , 3242  , 3251  , 3253  , 3257  , 3260  , 3268  ,\n  3270  , 3272  , 3274  , 3277  , 3285  , 3286  , 3293  , 3294  ,\n  3296  , 3299  , 3302  , 3311  , 3313  , 3314  , 3328  , 3340  ,\n  3342  , 3344  , 3346  , 3396  , 3398  , 3400  , 3402  , 3406  ,\n  3412  , 3415  , 3423  , 3427  , 3430  , 3439  , 3450  , 3455  ,\n  3457  , 3459  , 3461  , 3478  , 3482  , 3505  , 3507  , 3515  ,\n  3517  , 3517  , 3520  , 3526  , 3530  , 3530  , 3535  , 3540  ,\n  3542  , 3542  , 3544  , 3551  , 3558  , 3567  , 3570  , 3571  ,\n  3585  , 3642  , 3648  , 3662  , 3664  , 3673  , 3713  , 3714  ,\n  3716  , 3716  , 3718  , 3722  , 3724  , 3747  , 3749  , 3749  ,\n  3751  , 3773  , 3776  , 3780  , 3782  , 3782  , 3784  , 3789  ,\n  3792  , 3801  , 3804  , 3807  , 3840  , 3840  , 3864  , 3865  ,\n  3872  , 3881  , 3893  , 3893  , 3895  , 3895  , 3897  , 3897  ,\n  3902  , 3911  , 3913  , 3948  , 3953  , 3972  , 3974  , 3991  ,\n  3993  , 4028  , 4038  , 4038  , 4096  , 4169  , 4176  , 4253  ,\n  4256  , 4293  , 4295  , 4295  , 4301  , 4301  , 4304  , 4346  ,\n  4348  , 4680  , 4682  , 4685  , 4688  , 4694  , 4696  , 4696  ,\n  4698  , 4701  , 4704  , 4744  , 4746  , 4749  , 4752  , 4784  ,\n  4786  , 4789  , 4792  , 4798  , 4800  , 4800  , 4802  , 4805  ,\n  4808  , 4822  , 4824  , 4880  , 4882  , 4885  , 4888  , 4954  ,\n  4957  , 4959  , 4969  , 4977  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5909  , 5919  , 5940  ,\n  5952  , 5971  , 5984  , 5996  , 5998  , 6000  , 6002  , 6003  ,\n  6016  , 6099  , 6103  , 6103  , 6108  , 6109  , 6112  , 6121  ,\n  6155  , 6157  , 6159  , 6169  , 6176  , 6264  , 6272  , 6314  ,\n  6320  , 6389  , 6400  , 6430  , 6432  , 6443  , 6448  , 6459  ,\n  6470  , 6509  , 6512  , 6516  , 6528  , 6571  , 6576  , 6601  ,\n  6608  , 6618  , 6656  , 6683  , 6688  , 6750  , 6752  , 6780  ,\n  6783  , 6793  , 6800  , 6809  , 6823  , 6823  , 6832  , 6845  ,\n  6847  , 6862  , 6912  , 6988  , 6992  , 7001  , 7019  , 7027  ,\n  7040  , 7155  , 7168  , 7223  , 7232  , 7241  , 7245  , 7293  ,\n  7296  , 7304  , 7312  , 7354  , 7357  , 7359  , 7376  , 7378  ,\n  7380  , 7418  , 7424  , 7957  , 7960  , 7965  , 7968  , 8005  ,\n  8008  , 8013  , 8016  , 8023  , 8025  , 8025  , 8027  , 8027  ,\n  8029  , 8029  , 8031  , 8061  , 8064  , 8116  , 8118  , 8124  ,\n  8126  , 8126  , 8130  , 8132  , 8134  , 8140  , 8144  , 8147  ,\n  8150  , 8155  , 8160  , 8172  , 8178  , 8180  , 8182  , 8188  ,\n  8255  , 8256  , 8276  , 8276  , 8305  , 8305  , 8319  , 8319  ,\n  8336  , 8348  , 8400  , 8412  , 8417  , 8417  , 8421  , 8432  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11507 , 11520 , 11557 ,\n  11559 , 11559 , 11565 , 11565 , 11568 , 11623 , 11631 , 11631 ,\n  11647 , 11670 , 11680 , 11686 , 11688 , 11694 , 11696 , 11702 ,\n  11704 , 11710 , 11712 , 11718 , 11720 , 11726 , 11728 , 11734 ,\n  11736 , 11742 , 11744 , 11775 , 12293 , 12295 , 12321 , 12335 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12441 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42539 , 42560 , 42607 ,\n  42612 , 42621 , 42623 , 42737 , 42775 , 42783 , 42786 , 42888 ,\n  42891 , 42954 , 42960 , 42961 , 42963 , 42963 , 42965 , 42969 ,\n  42994 , 43047 , 43052 , 43052 , 43072 , 43123 , 43136 , 43205 ,\n  43216 , 43225 , 43232 , 43255 , 43259 , 43259 , 43261 , 43309 ,\n  43312 , 43347 , 43360 , 43388 , 43392 , 43456 , 43471 , 43481 ,\n  43488 , 43518 , 43520 , 43574 , 43584 , 43597 , 43600 , 43609 ,\n  43616 , 43638 , 43642 , 43714 , 43739 , 43741 , 43744 , 43759 ,\n  43762 , 43766 , 43777 , 43782 , 43785 , 43790 , 43793 , 43798 ,\n  43808 , 43814 , 43816 , 43822 , 43824 , 43866 , 43868 , 43881 ,\n  43888 , 44010 , 44012 , 44013 , 44016 , 44025 , 44032 , 55203 ,\n  55216 , 55238 , 55243 , 55291 , 63744 , 64109 , 64112 , 64217 ,\n  64256 , 64262 , 64275 , 64279 , 64285 , 64296 , 64298 , 64310 ,\n  64312 , 64316 , 64318 , 64318 , 64320 , 64321 , 64323 , 64324 ,\n  64326 , 64433 , 64467 , 64829 , 64848 , 64911 , 64914 , 64967 ,\n  65008 , 65019 , 65024 , 65039 , 65056 , 65071 , 65075 , 65076 ,\n  65101 , 65103 , 65136 , 65140 , 65142 , 65276 , 65296 , 65305 ,\n  65313 , 65338 , 65343 , 65343 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66045 , 66045 , 66176 , 66204 , 66208 , 66256 , 66272 , 66272 ,\n  66304 , 66335 , 66349 , 66378 , 66384 , 66426 , 66432 , 66461 ,\n  66464 , 66499 , 66504 , 66511 , 66513 , 66517 , 66560 , 66717 ,\n  66720 , 66729 , 66736 , 66771 , 66776 , 66811 , 66816 , 66855 ,\n  66864 , 66915 , 66928 , 66938 , 66940 , 66954 , 66956 , 66962 ,\n  66964 , 66965 , 66967 , 66977 , 66979 , 66993 , 66995 , 67001 ,\n  67003 , 67004 , 67072 , 67382 , 67392 , 67413 , 67424 , 67431 ,\n  67456 , 67461 , 67463 , 67504 , 67506 , 67514 , 67584 , 67589 ,\n  67592 , 67592 , 67594 , 67637 , 67639 , 67640 , 67644 , 67644 ,\n  67647 , 67669 , 67680 , 67702 , 67712 , 67742 , 67808 , 67826 ,\n  67828 , 67829 , 67840 , 67861 , 67872 , 67897 , 67968 , 68023 ,\n  68030 , 68031 , 68096 , 68099 , 68101 , 68102 , 68108 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68152 , 68154 , 68159 , 68159 ,\n  68192 , 68220 , 68224 , 68252 , 68288 , 68295 , 68297 , 68326 ,\n  68352 , 68405 , 68416 , 68437 , 68448 , 68466 , 68480 , 68497 ,\n  68608 , 68680 , 68736 , 68786 , 68800 , 68850 , 68864 , 68903 ,\n  68912 , 68921 , 69248 , 69289 , 69291 , 69292 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69456 , 69488 , 69509 ,\n  69552 , 69572 , 69600 , 69622 , 69632 , 69702 , 69734 , 69749 ,\n  69759 , 69818 , 69826 , 69826 , 69840 , 69864 , 69872 , 69881 ,\n  69888 , 69940 , 69942 , 69951 , 69956 , 69959 , 69968 , 70003 ,\n  70006 , 70006 , 70016 , 70084 , 70089 , 70092 , 70094 , 70106 ,\n  70108 , 70108 , 70144 , 70161 , 70163 , 70199 , 70206 , 70206 ,\n  70272 , 70278 , 70280 , 70280 , 70282 , 70285 , 70287 , 70301 ,\n  70303 , 70312 , 70320 , 70378 , 70384 , 70393 , 70400 , 70403 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70459 , 70468 , 70471 , 70472 ,\n  70475 , 70477 , 70480 , 70480 , 70487 , 70487 , 70493 , 70499 ,\n  70502 , 70508 , 70512 , 70516 , 70656 , 70730 , 70736 , 70745 ,\n  70750 , 70753 , 70784 , 70853 , 70855 , 70855 , 70864 , 70873 ,\n  71040 , 71093 , 71096 , 71104 , 71128 , 71133 , 71168 , 71232 ,\n  71236 , 71236 , 71248 , 71257 , 71296 , 71352 , 71360 , 71369 ,\n  71424 , 71450 , 71453 , 71467 , 71472 , 71481 , 71488 , 71494 ,\n  71680 , 71738 , 71840 , 71913 , 71935 , 71942 , 71945 , 71945 ,\n  71948 , 71955 , 71957 , 71958 , 71960 , 71989 , 71991 , 71992 ,\n  71995 , 72003 , 72016 , 72025 , 72096 , 72103 , 72106 , 72151 ,\n  72154 , 72161 , 72163 , 72164 , 72192 , 72254 , 72263 , 72263 ,\n  72272 , 72345 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72758 , 72760 , 72768 , 72784 , 72793 , 72818 , 72847 ,\n  72850 , 72871 , 72873 , 72886 , 72960 , 72966 , 72968 , 72969 ,\n  72971 , 73014 , 73018 , 73018 , 73020 , 73021 , 73023 , 73031 ,\n  73040 , 73049 , 73056 , 73061 , 73063 , 73064 , 73066 , 73102 ,\n  73104 , 73105 , 73107 , 73112 , 73120 , 73129 , 73440 , 73462 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92768 , 92777 , 92784 , 92862 , 92864 , 92873 ,\n  92880 , 92909 , 92912 , 92916 , 92928 , 92982 , 92992 , 92995 ,\n  93008 , 93017 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94031 , 94087 , 94095 , 94111 , 94176 , 94177 ,\n  94179 , 94180 , 94192 , 94193 , 94208 , 100343, 100352, 101589,\n  101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590,\n  110592, 110882, 110928, 110930, 110948, 110951, 110960, 111355,\n  113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817,\n  113821, 113822, 118528, 118573, 118576, 118598, 119141, 119145,\n  119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213,\n  119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967,\n  119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993,\n  119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074,\n  120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126,\n  120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485,\n  120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596,\n  120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712,\n  120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831,\n  121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476,\n  121499, 121503, 121505, 121519, 122624, 122654, 122880, 122886,\n  122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922,\n  123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214,\n  123536, 123566, 123584, 123641, 124896, 124902, 124904, 124907,\n  124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142,\n  125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041,\n  131072, 173791, 173824, 177976, 177984, 178205, 178208, 183969,\n  183984, 191456, 194560, 195101, 196608, 201546, 917760, 917999,\n];\nconst unicodeIdentifierPartMin = 170;\nconst unicodeIdentifierPartMax = 917999;\n\nfunction lookupInUnicodeMap(code: i32, map: i32[]): bool {\n  let lo = 0;\n  let hi = map.length;\n  while (lo + 1 < hi) {\n    let mid = lo + ((hi - lo) >>> 1);\n    mid -= (mid & 1);\n    let midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\n/** Creates an indentation matching the number of specified levels. */\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX3 = \"      \";\nconst indentX4 = \"        \";\nconst indentCache = new Map<i32,string>();\n\nexport function indent(sb: string[], level: i32): void {\n  if (level <= 4) {\n    switch (level) {\n      case 1: sb.push(indentX1); break;\n      case 2: sb.push(indentX2); break;\n      case 3: sb.push(indentX3); break;\n      case 4: sb.push(indentX4); break;\n    }\n  } else {\n    let indents: string;\n    // Limit number of indent entries to 1024 for avoiding unnecessary\n    // memory consumetion\n    if (indentCache.size <= 1024) {\n      if (indentCache.has(level)) {\n        indents = assert(indentCache.get(level));\n      } else {\n        indentCache.set(level, (indents = indentX1.repeat(level)));\n      }\n    } else {\n      indents = indentX1.repeat(level);\n    }\n    sb.push(indents);\n  }\n}\n\n/** Escapes a string using the specified kind of quote. */\nexport function escapeString(str: string, quote: CharCode): string {\n  let sb = new Array<string>();\n  let off = 0;\n  let i = 0;\n  for (let k = str.length; i < k;) {\n    switch (str.charCodeAt(i)) {\n      case CharCode.Null: {\n        if (i > off) sb.push(str.substring(off, off = i + 1));\n        sb.push(\"\\\\0\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backspace: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\b\");\n        break;\n      }\n      case CharCode.Tab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\t\");\n        break;\n      }\n      case CharCode.LineFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\n\");\n        break;\n      }\n      case CharCode.VerticalTab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\v\");\n        break;\n      }\n      case CharCode.FormFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\f\");\n        break;\n      }\n      case CharCode.CarriageReturn: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\r\");\n        off = ++i;\n        break;\n      }\n      case CharCode.DoubleQuote: {\n        if (quote == CharCode.DoubleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\"\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.SingleQuote: {\n        if (quote == CharCode.SingleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\'\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.Backslash: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\\\\\\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backtick: {\n        if (quote == CharCode.Backtick) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\`\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      default: {\n        ++i;\n        break;\n      }\n    }\n  }\n  if (i > off) sb.push(str.substring(off, i));\n  return sb.join(\"\");\n}\n", "/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.Slash;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  let pos = 0;\n  let len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.Dot &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  let atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.Dot\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.Dot ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.Dot &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.Dot ||\n              path.charCodeAt(ipos + 2) != CharCode.Dot\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.Dot ||\n            path.charCodeAt(1) != CharCode.Dot\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  let pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n", "/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\n/** Gray terminal color code. */\nexport const COLOR_GRAY = \"\\u001b[90m\";\n/** Red terminal color code. */\nexport const COLOR_RED = \"\\u001b[91m\";\n/** Green terminal color code. */\nexport const COLOR_GREEN = \"\\u001b[92m\";\n/** Yellow terminal color code. */\nexport const COLOR_YELLOW = \"\\u001b[93m\";\n/** Blue terminal color code. */\nexport const COLOR_BLUE = \"\\u001b[94m\";\n/** Magenta terminal color code. */\nexport const COLOR_MAGENTA = \"\\u001b[95m\";\n/** Cyan terminal color code. */\nexport const COLOR_CYAN = \"\\u001b[96m\";\n/** White terminal color code. */\nexport const COLOR_WHITE = \"\\u001b[97m\";\n/** Terminal color reset code. */\nexport const COLOR_RESET = \"\\u001b[0m\";\n\n/** Whether terminal colors are enabled or not. */\nlet colorsEnabled = true;\n\n/** Checks whether terminal colors are enabled or not. */\nexport function isColorsEnabled(): bool {\n  return colorsEnabled;\n}\n\n/** Sets whether terminal colors are enabled or not. */\nexport function setColorsEnabled(isEnabled: bool): bool {\n  let wasEnabled = isEnabled;\n  colorsEnabled = isEnabled;\n  return wasEnabled;\n}\n\n/** Wraps the specified text in the specified terminal color code. */\nexport function colorize(text: string, color: string): string {\n  return colorsEnabled ? color + text + COLOR_RESET : text;\n}\n", "/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n/** v128 all ones constant. */\nexport const v128_ones = new Uint8Array(16).fill(0xFF);\n", "/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak,\n  isWhiteSpace,\n  COLOR_CYAN,\n  COLOR_YELLOW,\n  COLOR_RED,\n  COLOR_MAGENTA,\n  COLOR_RESET,\n  isColorsEnabled,\n  setColorsEnabled,\n  CharCode\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport const enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  Pedantic,\n  /** Informatory message. */\n  Info,\n  /** Warning message. */\n  Warning,\n  /** Error message. */\n  Error\n}\n\nexport class Range {\n\n  source!: Source;\n  debugInfoRef: usize = 0;\n\n  constructor(public start: i32, public end: i32) {}\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return (\n      this.source == other.source &&\n      this.start == other.start &&\n      this.end == other.end\n    );\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return \"PEDANTIC\";\n    case DiagnosticCategory.Info: return \"INFO\";\n    case DiagnosticCategory.Warning: return \"WARNING\";\n    case DiagnosticCategory.Error: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return COLOR_MAGENTA;\n    case DiagnosticCategory.Info: return COLOR_CYAN;\n    case DiagnosticCategory.Warning: return COLOR_YELLOW;\n    case DiagnosticCategory.Error: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    let message = diagnosticCodeToString(code);\n    if (arg0 != null) message = message.replace(\"{0}\", arg0);\n    if (arg1 != null) message = message.replace(\"{1}\", arg1);\n    if (arg2 != null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    let thisRange = this.range;\n    let otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    let thisRelatedRange = this.relatedRange;\n    let otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRelatedRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    let category = diagnosticCategoryToString(this.category);\n    let range = this.range;\n    let code = this.code;\n    let message = this.message;\n    if (range) {\n      let source = range.source;\n      let path = source.normalizedPath;\n      let line = source.lineAt(range.start);\n      let column = source.columnAt();\n      let len = range.end - range.start;\n      return `${category} ${code}: \"${message}\" in ${path}(${line},${column}+${len})`;\n    }\n    return `${category} ${code}: ${message}`;\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n  let wasColorsEnabled = setColorsEnabled(useColors);\n\n  // general information\n  let sb: string[] = [];\n  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  let range = message.range;\n  if (range) {\n    let source = range.source;\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range));\n    } else {\n      sb.push(\"\\n in \");\n      sb.push(source.normalizedPath);\n    }\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    let relatedRange = message.relatedRange;\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange));\n      } else {\n        sb.push(\"\\n in \");\n        sb.push(relatedSource.normalizedPath);\n      }\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  setColorsEnabled(wasColorsEnabled);\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nfunction formatDiagnosticContext(range: Range): string {\n  let source = range.source;\n  let text = source.text;\n  let len = text.length;\n  let start = range.start;\n  let end = start;\n  let lineNumber = source.lineAt(start).toString();\n  let lineSpace = \" \".repeat(lineNumber.length);\n  // Find preceeding line break\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  // Skip leading whitespace (assume no supplementary whitespaces)\n  while (start < len && isWhiteSpace(text.charCodeAt(start))) start++;\n  // Find next line break\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  let sb: string[] = [\n    lineSpace,\n    \"  :\\n \",\n    lineNumber,\n    \" \u2502 \",\n    text.substring(start, end).replaceAll(\"\\t\", \"  \"),\n    \"\\n \",\n    lineSpace,\n    \" \u2502 \"\n  ];\n  while (start < range.start) {\n    if (text.charCodeAt(start) == CharCode.Tab) {\n      sb.push(\"  \");\n      start += 2;\n    } else {\n      sb.push(\" \");\n      start++;\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      let cc = text.charCodeAt(start);\n      if (cc == CharCode.Tab) {\n        sb.push(\"~~\");\n      } else if (isLineBreak(cc)) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      } else {\n        sb.push(\"~\");\n      }\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(\"\\n \");\n  sb.push(lineSpace);\n  sb.push(\" \u2514\u2500 in \");\n  sb.push(source.normalizedPath);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    let message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n", "/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Range\n} from \"./diagnostics\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode\n} from \"./util\";\n\nimport {\n  ExpressionRef\n} from \"./module\";\n\nimport {\n  Type\n} from \"./types\";\n\n/** Indicates the kind of a node. */\nexport const enum NodeKind {\n\n  Source,\n\n  // types\n  NamedType,\n  FunctionType,\n  TypeName,\n  TypeParameter,\n  Parameter,\n\n  // expressions\n  Identifier,\n  Assertion,\n  Binary,\n  Call,\n  Class,\n  Comma,\n  ElementAccess,\n  False,\n  Function,\n  InstanceOf,\n  Literal,\n  New,\n  Null,\n  Omitted,\n  Parenthesized,\n  PropertyAccess,\n  Ternary,\n  Super,\n  This,\n  True,\n  Constructor,\n  UnaryPostfix,\n  UnaryPrefix,\n  Compiled,\n\n  // statements\n  Block,\n  Break,\n  Continue,\n  Do,\n  Empty,\n  Export,\n  ExportDefault,\n  ExportImport,\n  Expression,\n  For,\n  ForOf,\n  If,\n  Import,\n  Return,\n  Switch,\n  Throw,\n  Try,\n  Variable,\n  Void,\n  While,\n  Module,\n\n  // declaration statements\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  // special\n  Decorator,\n  ExportMember,\n  SwitchCase,\n  IndexSignature,\n  Comment\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createTemplateLiteralExpression(\n    tag: Expression | null,\n    parts: string[],\n    rawParts: string[],\n    expressions: Expression[],\n    exprLengths: i64[],\n    range: Range\n  ): TemplateLiteralExpression {\n    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, exprLengths, range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  static createCompiledExpression(\n    expr: ExpressionRef,\n    type: Type,\n    range: Range\n  ): Expression {\n    return new CompiledExpression(expr, type, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    body: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(body, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    body: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, body, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    body: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, body, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    bodyStatements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(bodyStatements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createModuleDeclaration(\n    name: string,\n    flags: CommonFlags,\n    range: Range\n  ): ModuleDeclaration {\n    return new ModuleDeclaration(name, flags, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.Literal\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.Literal) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.Float:\n        case LiteralKind.Integer: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.Literal: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.Float:\n          case LiteralKind.Integer:\n          case LiteralKind.String: return true;\n        }\n        break;\n      }\n      case NodeKind.Null:\n      case NodeKind.True:\n      case NodeKind.False: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.Call) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PropertyAccess) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.This);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.Super);\n  }\n\n  get isEmpty(): bool {\n    return this.kind == NodeKind.Empty;\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FunctionType) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeName, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamedType, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    let typeArguments = this.typeArguments;\n    return typeArguments != null && typeArguments.length > 0;\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionType, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeParameter, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport const enum ParameterKind {\n  /** No specific flags. */\n  Default,\n  /** Is an optional parameter. */\n  Optional,\n  /** Is a rest parameter. */\n  Rest\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parameter, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  Custom,\n  Global,\n  Operator,\n  OperatorBinary,\n  OperatorPrefix,\n  OperatorPostfix,\n  Unmanaged,\n  Final,\n  Inline,\n  External,\n  ExternalJs,\n  Builtin,\n  Lazy,\n  Unsafe\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.Identifier) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.Builtin;\n          break;\n        }\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.External;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.Final;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.Global;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.Inline;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.Lazy;\n          break;\n        }\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.Operator;\n          break;\n        }\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.Unmanaged;\n          if (nameStr == \"unsafe\") return DecoratorKind.Unsafe;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PropertyAccess) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.Identifier) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OperatorBinary;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OperatorPrefix;\n              if (propStr == \"postfix\") return DecoratorKind.OperatorPostfix;\n              break;\n            }\n          }\n        } else if (nameStr == \"external\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.j: {\n              if (propStr == \"js\") return DecoratorKind.ExternalJs;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.Custom;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Decorator, range);\n  }\n}\n\n/** Comment kinds. */\nexport const enum CommentKind {\n  /** Line comment. */\n  Line,\n  /** Triple-slash line comment. */\n  Triple,\n  /** Block comment. */\n  Block\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comment, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Identifier, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport const enum LiteralKind {\n  Float,\n  Integer,\n  String,\n  Template,\n  RegExp,\n  Array,\n  Object\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Literal, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Array, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport const enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  Prefix,\n  /** An as assertion, i.e. `expr as T`. */\n  As,\n  /** A non-null assertion, i.e. `!expr`. */\n  NonNull,\n  /** A const assertion, i.e. `expr as const`. */\n  Const\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Assertion, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Binary, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Call, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.Class, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comma, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.Constructor;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ElementAccess, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Float, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.Function, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.InstanceOf, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Integer, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.New, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.Null;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Object, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Omitted, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parenthesized, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PropertyAccess, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.RegExp, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Ternary, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.String, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.Super;\n  }\n}\n\n/** Represents a template literal expression. */\nexport class TemplateLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Tag expression, if any. */\n    public tag: Expression | null,\n    /** String parts. */\n    public parts: string[],\n    /** Raw string parts. */\n    public rawParts: string[],\n    /** Expression parts. */\n    public expressions: Expression[],\n    /** Explicit lengths of expression parts. */\n    public exprLengths: i64[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Template, range);\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.This;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.True;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.False;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPostfix, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPrefix, operator, operand, range);\n  }\n}\n\n/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */\nexport class CompiledExpression extends Expression {\n  constructor(\n    /** Compiled expression. */\n    public expr: ExpressionRef,\n    /** Type of the compiled expression. */\n    public type: Type,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Compiled, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport const enum SourceKind {\n  /** User-provided file. */\n  User = 0,\n  /** User-provided entry file. */\n  UserEntry = 1,\n  /** Library-provided file. */\n  Library = 2,\n  /** Library-provided entry file. */\n  LibraryEntry = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.Source, new Range(0, text.length));\n    let internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    let pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    let kind = this.sourceKind;\n    return kind == SourceKind.Library || kind == SourceKind.LibraryEntry;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    let lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LineFeed) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    let l = 0;\n    let r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n  /** Overridden module name from preceeding `module` statement. */\n  public overriddenModuleName: string | null = null;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IndexSignature, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Block, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Break, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ClassDeclaration, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Continue, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Do, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Empty, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumValueDeclaration, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportImport, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportMember, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Export, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportDefault, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.Expression, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FieldDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.For, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ForOf, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  None,\n  /** Parenthesized parameter list. */\n  Parenthesized,\n  /** Single parameter without parenthesis. */\n  Single\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionDeclaration, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.If, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ImportDeclaration, name, null, CommonFlags.None, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Import, range);\n    let normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = mangleInternalPath(normalizedPath);\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.InterfaceDeclaration;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.None, range);\n    this.kind = NodeKind.MethodDeclaration;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamespaceDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Return, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SwitchCase, range);\n  }\n\n  get isDefault(): bool {\n    return this.label == null;\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Switch, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Throw, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public bodyStatements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Try, range);\n  }\n}\n\n/** Represents a `module` statement. */\nexport class ModuleDeclaration extends Statement {\n  constructor(\n    /** Module name. */\n    public moduleName: string,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Module, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VariableDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Variable, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Void, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.While, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  if (path.endsWith(\"/\")) {\n    path += \"index\";\n  } else if (path.endsWith(\".ts\")) {\n    path = path.substring(0, path.length - 3);\n  }\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NamedType) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next || name.identifier.text.length > 0);\n  }\n  return false;\n}\n", "/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimal,\n  isOctal,\n  isHexBase,\n  isHighSurrogate,\n  combineSurrogates,\n  numCodeUnits\n} from \"./util\";\n\n/** Named token types. */\nexport const enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  Abstract,\n  As,\n  Async,\n  Await,        // ES2017\n  Break,        // ES2017\n  Case,         // ES2017\n  Catch,        // ES2017\n  Class,        // ES2017\n  Const,        // ES2017\n  Continue,     // ES2017\n  Constructor,\n  Debugger,     // ES2017\n  Declare,\n  Default,      // ES2017\n  Delete,       // ES2017\n  Do,           // ES2017\n  Else,         // ES2017\n  Enum,         // ES2017 future\n  Export,       // ES2017\n  Extends,      // ES2017\n  False,        // ES\n  Finally,      // ES2017\n  For,          // ES2017\n  From,         // AS possible identifier\n  Function,     // ES2017\n  Get,\n  If,           // ES2017\n  Implements,   // ES2017 non-lexical\n  Import,       // ES2017\n  In,           // ES2017\n  InstanceOf,   // ES2017\n  Interface,    // ES2017 non-lexical\n  Is,\n  KeyOf,\n  Let,          // ES2017 non-lexical\n  Module,       // AS possible identifier\n  Namespace,    // AS possible identifier\n  New,          // ES2017\n  Null,         // ES\n  Of,\n  Override,\n  Package,      // ES2017 non-lexical\n  Private,      // ES2017 non-lexical\n  Protected,    // ES2017 non-lexical\n  Public,       // ES2017 non-lexical\n  Readonly,\n  Return,       // ES2017\n  Set,\n  Static,       // ES2017 non-lexical\n  Super,        // ES2017\n  Switch,       // ES2017\n  This,         // ES2017\n  Throw,        // ES2017\n  True,         // ES\n  Try,          // ES2017\n  Type,         // AS possible identifier\n  TypeOf,       // ES2017\n  Var,          // ES2017\n  Void,         // ES2017\n  While,        // ES2017\n  With,         // ES2017\n  Yield,        // ES2017\n\n  // punctuation\n\n  OpenBrace,\n  CloseBrace,\n  OpenParen,\n  CloseParen,\n  OpenBracket,\n  CloseBracket,\n  Dot,\n  Dot_Dot_Dot,\n  Semicolon,\n  Comma,\n  LessThan,\n  GreaterThan,\n  LessThan_Equals,\n  GreaterThan_Equals,\n  Equals_Equals,\n  Exclamation_Equals,\n  Equals_Equals_Equals,\n  Exclamation_Equals_Equals,\n  Equals_GreaterThan,\n  Plus,\n  Minus,\n  Asterisk_Asterisk,\n  Asterisk,\n  Slash,\n  Percent,\n  Plus_Plus,\n  Minus_Minus,\n  LessThan_LessThan,\n  GreaterThan_GreaterThan,\n  GreaterThan_GreaterThan_GreaterThan,\n  Ampersand,\n  Bar,\n  Caret,\n  Exclamation,\n  Tilde,\n  Ampersand_Ampersand,\n  Bar_Bar,\n  Question,\n  Colon,\n  Equals,\n  Plus_Equals,\n  Minus_Equals,\n  Asterisk_Equals,\n  Asterisk_Asterisk_Equals,\n  Slash_Equals,\n  Percent_Equals,\n  LessThan_LessThan_Equals,\n  GreaterThan_GreaterThan_Equals,\n  GreaterThan_GreaterThan_GreaterThan_Equals,\n  Ampersand_Equals,\n  Bar_Equals,\n  Caret_Equals,\n  At,\n\n  // literals\n\n  Identifier,\n  StringLiteral,\n  IntegerLiteral,\n  FloatLiteral,\n  TemplateLiteral,\n\n  // meta\n\n  Invalid,\n  EndOfFile\n}\n\nexport const enum IdentifierHandling {\n  Default,\n  Prefer,\n  Always\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  let len = text.length;\n  assert(len);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (len == 5) {\n        if (text == \"async\") return Token.Async;\n        if (text == \"await\") return Token.Await;\n        break;\n      }\n      if (text == \"as\") return Token.As;\n      if (text == \"abstract\") return Token.Abstract;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.Break;\n      break;\n    }\n    case CharCode.c: {\n      if (len == 5) {\n        if (text == \"const\") return Token.Const;\n        if (text == \"class\") return Token.Class;\n        if (text == \"catch\") return Token.Catch;\n        break;\n      }\n      if (text == \"case\") return Token.Case;\n      if (text == \"continue\") return Token.Continue;\n      if (text == \"constructor\") return Token.Constructor;\n      break;\n    }\n    case CharCode.d: {\n      if (len == 7) {\n        if (text == \"default\") return Token.Default;\n        if (text == \"declare\") return Token.Declare;\n        break;\n      }\n      if (text == \"do\") return Token.Do;\n      if (text == \"delete\") return Token.Delete;\n      if (text == \"debugger\") return Token.Debugger;\n      break;\n    }\n    case CharCode.e: {\n      if (len == 4) {\n        if (text == \"else\") return Token.Else;\n        if (text == \"enum\") return Token.Enum;\n        break;\n      }\n      if (text == \"export\") return Token.Export;\n      if (text == \"extends\") return Token.Extends;\n      break;\n    }\n    case CharCode.f: {\n      if (len <= 5) {\n        if (text == \"false\") return Token.False;\n        if (text == \"for\") return Token.For;\n        if (text == \"from\") return Token.From;\n        break;\n      }\n      if (text == \"function\") return Token.Function;\n      if (text == \"finally\") return Token.Finally;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.Get;\n      break;\n    }\n    case CharCode.i: {\n      if (len == 2) {\n        if (text == \"if\") return Token.If;\n        if (text == \"in\") return Token.In;\n        if (text == \"is\") return Token.Is;\n        break;\n      }\n      switch (text.charCodeAt(3)) {\n        case CharCode.l: {\n          if (text == \"implements\") return Token.Implements;\n          break;\n        }\n        case CharCode.o: {\n          if (text == \"import\") return Token.Import;\n          break;\n        }\n        case CharCode.t: {\n          if (text == \"instanceof\") return Token.InstanceOf;\n          break;\n        }\n        case CharCode.e: {\n          if (text == \"interface\") return Token.Interface;\n          break;\n        }\n      }\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KeyOf;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.Let;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.Module;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"new\") return Token.New;\n      if (text == \"null\") return Token.Null;\n      if (text == \"namespace\") return Token.Namespace;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.Of;\n      if (text == \"override\") return Token.Override;\n      break;\n    }\n    case CharCode.p: {\n      if (len == 7) {\n        if (text == \"private\") return Token.Private;\n        if (text == \"package\") return Token.Package;\n        break;\n      }\n      if (text == \"public\") return Token.Public;\n      if (text == \"protected\") return Token.Protected;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"return\") return Token.Return;\n      if (text == \"readonly\") return Token.Readonly;\n      break;\n    }\n    case CharCode.s: {\n      if (len == 6) {\n        if (text == \"switch\") return Token.Switch;\n        if (text == \"static\") return Token.Static;\n        break;\n      }\n      if (text == \"set\") return Token.Set;\n      if (text == \"super\") return Token.Super;\n      break;\n    }\n    case CharCode.t: {\n      if (len == 4) {\n        if (text == \"true\") return Token.True;\n        if (text == \"this\") return Token.This;\n        if (text == \"type\") return Token.Type;\n        break;\n      }\n      if (text == \"try\") return Token.Try;\n      if (text == \"throw\") return Token.Throw;\n      if (text == \"typeof\") return Token.TypeOf;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.Var;\n      if (text == \"void\") return Token.Void;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.While;\n      if (text == \"with\") return Token.With;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.Yield;\n      break;\n    }\n  }\n  return Token.Invalid;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.Abstract:\n    case Token.As:\n    case Token.Constructor:\n    case Token.Declare:\n    case Token.Delete:\n    case Token.From:\n    case Token.For:\n    case Token.Get:\n    case Token.InstanceOf:\n    case Token.Is:\n    case Token.KeyOf:\n    case Token.Module:\n    case Token.Namespace:\n    case Token.Null:\n    case Token.Readonly:\n    case Token.Set:\n    case Token.Type:\n    case Token.Void: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.Delete: return \"delete\";\n    case Token.In: return \"in\";\n    case Token.InstanceOf: return \"instanceof\";\n    case Token.New: return \"new\";\n    case Token.TypeOf: return \"typeof\";\n    case Token.Void: return \"void\";\n    case Token.Yield: return \"yield\";\n    case Token.Dot_Dot_Dot: return \"...\";\n    case Token.Comma: return \",\";\n    case Token.LessThan: return \"<\";\n    case Token.GreaterThan: return \">\";\n    case Token.LessThan_Equals: return \"<=\";\n    case Token.GreaterThan_Equals: return \">=\";\n    case Token.Equals_Equals: return \"==\";\n    case Token.Exclamation_Equals: return \"!=\";\n    case Token.Equals_Equals_Equals: return \"===\";\n    case Token.Exclamation_Equals_Equals: return \"!==\";\n    case Token.Plus: return \"+\";\n    case Token.Minus: return \"-\";\n    case Token.Asterisk_Asterisk: return \"**\";\n    case Token.Asterisk: return \"*\";\n    case Token.Slash: return \"/\";\n    case Token.Percent: return \"%\";\n    case Token.Plus_Plus: return \"++\";\n    case Token.Minus_Minus: return \"--\";\n    case Token.LessThan_LessThan: return \"<<\";\n    case Token.GreaterThan_GreaterThan: return \">>\";\n    case Token.GreaterThan_GreaterThan_GreaterThan: return \">>>\";\n    case Token.Ampersand: return \"&\";\n    case Token.Bar: return \"|\";\n    case Token.Caret: return \"^\";\n    case Token.Exclamation: return \"!\";\n    case Token.Tilde: return \"~\";\n    case Token.Ampersand_Ampersand: return \"&&\";\n    case Token.Bar_Bar: return \"||\";\n    case Token.Equals: return \"=\";\n    case Token.Plus_Equals: return \"+=\";\n    case Token.Minus_Equals: return \"-=\";\n    case Token.Asterisk_Equals: return \"*=\";\n    case Token.Asterisk_Asterisk_Equals: return \"**=\";\n    case Token.Slash_Equals: return \"/=\";\n    case Token.Percent_Equals: return \"%=\";\n    case Token.LessThan_LessThan_Equals: return \"<<=\";\n    case Token.GreaterThan_GreaterThan_Equals: return \">>=\";\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return \">>>=\";\n    case Token.Ampersand_Equals: return \"&=\";\n    case Token.Bar_Equals: return \"|=\";\n    case Token.Caret_Equals: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: bool = false;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    let text = source.text;\n    let end = text.length;\n    let pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.ByteOrderMark\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.Hash &&\n      text.charCodeAt(pos + 1) == CharCode.Exclamation\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LineFeed\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.Default): Token {\n    this.nextToken = -1;\n    let token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.Invalid);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CarriageReturn: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LineFeed\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LineFeed:\n        case CharCode.Tab:\n        case CharCode.VerticalTab:\n        case CharCode.FormFeed:\n        case CharCode.Space: {\n          ++pos;\n          break;\n        }\n        case CharCode.Exclamation: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.Equals\n            ) {\n              this.pos = pos + 1;\n              return Token.Exclamation_Equals_Equals;\n            }\n            this.pos = pos;\n            return Token.Exclamation_Equals;\n          }\n          this.pos = pos;\n          return Token.Exclamation;\n        }\n        case CharCode.DoubleQuote:\n        case CharCode.SingleQuote: {\n          this.pos = pos;\n          return Token.StringLiteral;\n        }\n        case CharCode.Backtick: {\n          this.pos = pos;\n          return Token.TemplateLiteral;\n        }\n        case CharCode.Percent: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Percent_Equals;\n          }\n          this.pos = pos;\n          return Token.Percent;\n        }\n        case CharCode.Ampersand: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Ampersand) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Ampersand;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Ampersand;\n        }\n        case CharCode.OpenParen: {\n          this.pos = pos + 1;\n          return Token.OpenParen;\n        }\n        case CharCode.CloseParen: {\n          this.pos = pos + 1;\n          return Token.CloseParen;\n        }\n        case CharCode.Asterisk: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Asterisk_Equals;\n            }\n            if (chr == CharCode.Asterisk) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Asterisk_Asterisk_Equals;\n              }\n              this.pos = pos;\n              return Token.Asterisk_Asterisk;\n            }\n          }\n          this.pos = pos;\n          return Token.Asterisk;\n        }\n        case CharCode.Plus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Plus) {\n              this.pos = pos + 1;\n              return Token.Plus_Plus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Plus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Plus;\n        }\n        case CharCode.Comma: {\n          this.pos = pos + 1;\n          return Token.Comma;\n        }\n        case CharCode.Minus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Minus) {\n              this.pos = pos + 1;\n              return Token.Minus_Minus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Minus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Minus;\n        }\n        case CharCode.Dot: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimal(chr)) {\n              this.pos = pos - 1;\n              return Token.FloatLiteral; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.Dot &&\n              text.charCodeAt(pos + 1) == CharCode.Dot\n            ) {\n              this.pos = pos + 2;\n              return Token.Dot_Dot_Dot;\n            }\n          }\n          this.pos = pos;\n          return Token.Dot;\n        }\n        case CharCode.Slash: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Slash) { // single-line\n              let commentKind = CommentKind.Line;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.Slash\n              ) {\n                ++pos;\n                commentKind = CommentKind.Triple;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LineFeed) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Asterisk) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.Asterisk &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.Slash\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.Block,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Slash_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Slash;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.IntegerLiteral // expects a call to readInteger\n            : Token.FloatLiteral;  // expects a call to readFloat\n        }\n        case CharCode.Colon: {\n          this.pos = pos + 1;\n          return Token.Colon;\n        }\n        case CharCode.Semicolon: {\n          this.pos = pos + 1;\n          return Token.Semicolon;\n        }\n        case CharCode.LessThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LessThan) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.LessThan_LessThan_Equals;\n              }\n              this.pos = pos;\n              return Token.LessThan_LessThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.LessThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.LessThan;\n        }\n        case CharCode.Equals: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Equals_Equals_Equals;\n              }\n              this.pos = pos;\n              return Token.Equals_Equals;\n            }\n            if (chr == CharCode.GreaterThan) {\n              this.pos = pos + 1;\n              return Token.Equals_GreaterThan;\n            }\n          }\n          this.pos = pos;\n          return Token.Equals;\n        }\n        case CharCode.GreaterThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GreaterThan) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GreaterThan) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.Equals\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GreaterThan_GreaterThan_GreaterThan_Equals;\n                  }\n                  this.pos = pos;\n                  return Token.GreaterThan_GreaterThan_GreaterThan;\n                }\n                if (chr == CharCode.Equals) {\n                  this.pos = pos + 1;\n                  return Token.GreaterThan_GreaterThan_Equals;\n                }\n              }\n              this.pos = pos;\n              return Token.GreaterThan_GreaterThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.GreaterThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.GreaterThan;\n        }\n        case CharCode.Question: {\n          this.pos = pos + 1;\n          return Token.Question;\n        }\n        case CharCode.OpenBracket: {\n          this.pos = pos + 1;\n          return Token.OpenBracket;\n        }\n        case CharCode.CloseBracket: {\n          this.pos = pos + 1;\n          return Token.CloseBracket;\n        }\n        case CharCode.Caret: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Caret_Equals;\n          }\n          this.pos = pos;\n          return Token.Caret;\n        }\n        case CharCode.OpenBrace: {\n          this.pos = pos + 1;\n          return Token.OpenBrace;\n        }\n        case CharCode.Bar: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Bar) {\n              this.pos = pos + 1;\n              return Token.Bar_Bar;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Bar_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Bar;\n        }\n        case CharCode.CloseBrace: {\n          this.pos = pos + 1;\n          return Token.CloseBrace;\n        }\n        case CharCode.Tilde: {\n          this.pos = pos + 1;\n          return Token.Tilde;\n        }\n        case CharCode.At: {\n          this.pos = pos + 1;\n          return Token.At;\n        }\n        default: {\n          // Unicode-aware from here on\n          if (isHighSurrogate(c) && pos + 1 < end) {\n            c = combineSurrogates(c, text.charCodeAt(pos + 1));\n          }\n          if (isIdentifierStart(c)) {\n            let posBefore = pos;\n            while (\n              (pos += numCodeUnits(c)) < end &&\n              isIdentifierPart(c = <i32>text.codePointAt(pos))\n            ) { /* nop */ }\n            if (identifierHandling != IdentifierHandling.Always) {\n              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));\n              if (\n                maybeKeywordToken != Token.Invalid &&\n                !(\n                  identifierHandling == IdentifierHandling.Prefer &&\n                  tokenIsAlsoIdentifier(maybeKeywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return maybeKeywordToken;\n              }\n            }\n            this.pos = posBefore;\n            return Token.Identifier;\n          } else if (isWhiteSpace(c)) {\n            ++pos; // assume no supplementary whitespaces\n            break;\n          }\n          let start = pos;\n          pos += numCodeUnits(c);\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.Invalid;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.EndOfFile;\n  }\n\n  peek(\n    checkOnNewLine: bool = false,\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let text = this.source.text;\n    if (this.nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      let nextToken: Token;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.Invalid);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      if (checkOnNewLine) {\n        this.nextTokenOnNewLine = false;\n        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {\n          if (isLineBreak(text.charCodeAt(pos))) {\n            this.nextTokenOnNewLine = true;\n            break;\n          }\n        }\n      }\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return this.nextToken;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.Prefer): bool {\n    return this.skip(Token.Identifier, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.Default): bool {\n    let posBefore = this.pos;\n    let tokenBefore = this.token;\n    let tokenPosBefore = this.tokenPos;\n    let maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GreaterThan) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    let nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.Invalid);\n    if (nextToken == token) {\n      this.token = token;\n      this.nextToken = -1;\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    let state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.nextToken = -1;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    let start = pos;\n    let c = <i32>text.codePointAt(pos);\n    assert(isIdentifierStart(c));\n    while (\n      (pos += numCodeUnits(c)) < end &&\n      isIdentifierPart(c = <i32>text.codePointAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readingTemplateString: bool = false;\n  readStringStart: i32 = 0;\n  readStringEnd: i32 = 0;\n\n  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    if (!quote) quote = text.charCodeAt(pos++);\n    let start = pos;\n    this.readStringStart = start;\n    let result = \"\";\n\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        this.readStringEnd = end;\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        this.readStringEnd = pos;\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.Backslash) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence(isTaggedTemplate);\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (quote == CharCode.Backtick) {\n        if (c == CharCode.Dollar && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OpenBrace) {\n          result += text.substring(start, pos);\n          this.readStringEnd = pos;\n          this.pos = pos + 2;\n          this.readingTemplateString = true;\n          return result;\n        }\n      } else if (isLineBreak(c)) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        this.readStringEnd = pos;\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    this.readingTemplateString = false;\n    return result;\n  }\n\n  readEscapeSequence(isTaggedTemplate: bool = false): string {\n    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/\n    let start = this.pos;\n    let end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    let text = this.source.text;\n    let c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: {\n        if (isTaggedTemplate && this.pos < end && isDecimal(text.charCodeAt(this.pos))) {\n          ++this.pos;\n          return text.substring(start, this.pos);\n        }\n        return \"\\0\";\n      }\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SingleQuote: return \"'\";\n      case CharCode.DoubleQuote: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OpenBrace\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \\xDD\n      }\n      case CharCode.CarriageReturn: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LineFeed\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LineFeed:\n      case CharCode.LineSeparator:\n      case CharCode.ParagraphSeparator: return \"\";\n      default: return String.fromCodePoint(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.Backslash) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.Slash) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.Dot || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctal(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_4 = i64_new(4);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // (value << 4) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (isHexBase(c)) {\n        // (value << 4) + (c | 32) + (10 - CharCode.a)\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new((c | 32) + (10 - CharCode.a))\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_10 = i64_new(10);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // value = value * 10 + c - CharCode._0;\n        nextValue = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start, pos),\n        this.source.text.substring(start, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_3 = i64_new(3);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isOctal(c)) {\n        // (value << 3) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value << 1 | 0\n        nextValue = i64_shl(value, i64_one);\n      } else if (c == CharCode._1) {\n        // value << 1 | 1\n        nextValue = i64_or(\n          i64_shl(value, i64_one),\n          i64_one\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt(value, nextValue)) {\n        // Overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // let text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    let text = this.source.text;\n    let end = this.end;\n    let start = this.pos;\n    let sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.Dot) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.Minus || c == CharCode.Plus &&\n          isDecimal(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let start = pos;\n    let end = this.end;\n    let sepEnd = start;\n    let sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimal(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {\n    let value = 0;\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (isDecimal(c)) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (isHexBase(c)) {\n        value = (value << 4) + (c | 32) + (10 - CharCode.a);\n      } else if (~startIfTaggedTemplate) {\n        this.pos = --pos;\n        return text.substring(startIfTaggedTemplate, pos);\n      } else {\n        this.pos = pos;\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) { // invalid\n      this.pos = pos;\n      if (~startIfTaggedTemplate) {\n        return text.substring(startIfTaggedTemplate, pos);\n      }\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCodePoint(value);\n  }\n\n  checkForIdentifierStartAfterNumericLiteral(): void {\n    // TODO: BigInt n\n    let pos = this.pos;\n    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {\n      this.error(\n        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,\n        this.range(pos)\n      );\n    }\n  }\n\n  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    return this.readHexadecimalEscape(4, startIfTaggedTemplate);\n  }\n\n  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    let start = this.pos;\n    let value = this.readHexInteger();\n    let value32 = i64_low(value);\n    let invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    let end = this.end;\n    let text = this.source.text;\n    if (this.pos >= end) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unexpected_end_of_text,\n          this.range(start, end)\n        );\n      }\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CloseBrace) {\n      ++this.pos;\n    } else {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unterminated_Unicode_escape_sequence,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    if (invalid) {\n      return ~startIfTaggedTemplate\n        ? text.substring(startIfTaggedTemplate, this.pos)\n        : \"\";\n    }\n    return String.fromCodePoint(value32);\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nlet reusableState: State | null = null;\n", "/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { BuiltinNames } from \"./builtins\";\nimport { CommonNames, Target } from \"./common\";\nimport {\n  isHighSurrogate,\n  isLowSurrogate,\n  combineSurrogates,\n  SURROGATE_HIGH,\n  SURROGATE_LOW\n} from \"./util\";\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\nimport {\n  ElementKind,\n  Field\n} from \"./program\";\nimport * as binaryen from \"./glue/binaryen\";\n\n/** A Binaryen-compatible index. */\nexport type Index = binaryen.Index;\n/** Reference to a Binaryen-compatible string. */\nexport type StringRef = binaryen.StringRef;\n/** Reference to a Binaryen module. */\nexport type ModuleRef = binaryen.ModuleRef;\n/** Reference to a Binaryen function. */\nexport type FunctionRef = binaryen.FunctionRef;\n/** Reference to a Binaryen expression. */\nexport type ExpressionRef = binaryen.ExpressionRef;\n/** Reference to a Binaryen global. */\nexport type GlobalRef = binaryen.GlobalRef;\n/** Reference to a Binaryen tag. */\nexport type TagRef = binaryen.TagRef;\n/** Reference to a Binaryen import. */\nexport type ImportRef = binaryen.ImportRef;\n/** Reference to a Binaryen export. */\nexport type ExportRef = binaryen.ExportRef;\n/** Reference to a Binaryen relooper. */\nexport type RelooperRef = binaryen.RelooperRef;\n/** Reference to a Binaryen relooper block. */\nexport type RelooperBlockRef = binaryen.RelooperBlockRef;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\n/** Reference to a Binaryen type. */\nexport type TypeRef = binaryen.TypeRef;\nexport namespace TypeRef {\n  // special types\n  export const None: TypeRef = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;\n  // value types\n  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;\n  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;\n  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;\n  // reference/gc types\n  export const Funcref = binaryen._BinaryenTypeFuncref();\n  export const Externref = binaryen._BinaryenTypeExternref();\n  export const Anyref = binaryen._BinaryenTypeAnyref();\n  export const Eqref = binaryen._BinaryenTypeEqref();\n  export const I31ref = binaryen._BinaryenTypeI31ref();\n  export const Dataref = binaryen._BinaryenTypeDataref();\n  export const Arrayref = binaryen._BinaryenTypeArrayref();\n  export const Stringref = binaryen._BinaryenTypeStringref();\n  export const StringviewWTF8 = binaryen._BinaryenTypeStringviewWTF8();\n  export const StringviewWTF16 = binaryen._BinaryenTypeStringviewWTF16();\n  export const StringviewIter = binaryen._BinaryenTypeStringviewIter();\n  export const Noneref = binaryen._BinaryenTypeNullref();\n  export const Nofuncref = binaryen._BinaryenTypeNullFuncref();\n  export const Noexternref = binaryen._BinaryenTypeNullExternref();\n}\n\n/** Reference to a Binaryen heap type. */\nexport type HeapTypeRef = binaryen.HeapTypeRef;\nexport namespace HeapTypeRef {\n\n  //        any                  extern      func\n  //         |                      |          |\n  //     __ eq __          ?     noextern    (...)\n  //    /    |   \\         |                   |\n  // i31  struct  array  string              nofunc\n  //  |      |      |      |\n  // none  (...)  (...)    ?\n  //         |      |\n  //        none   none\n  //\n  // where (...) represents the concrete subtypes\n\n  export const Extern: HeapTypeRef = 0 /* _BinaryenHeapTypeExt */;\n  export const Func: HeapTypeRef = 1 /* _BinaryenHeapTypeFunc */;\n  export const Any: HeapTypeRef = 2 /* _BinaryenHeapTypeAny */;\n  export const Eq: HeapTypeRef = 3 /* _BinaryenHeapTypeEq */;\n  export const I31: HeapTypeRef = 4 /* _BinaryenHeapTypeI31 */;\n  export const Data: HeapTypeRef = 5 /* _BinaryenHeapTypeData */;\n  export const Array: HeapTypeRef = 6 /* _BinaryenHeapTypeArray */;\n  export const String: HeapTypeRef = 7 /* _BinaryenHeapTypeString */;\n  export const StringviewWTF8: HeapTypeRef = 8 /* _BinaryenHeapTypeStringviewWTF8 */;\n  export const StringviewWTF16: HeapTypeRef = 9 /* _BinaryenHeapTypeStringviewWTF16 */;\n  export const StringviewIter: HeapTypeRef = 10 /* _BinaryenHeapTypeStringviewIter */;\n  export const None: HeapTypeRef = 11 /* _BinaryenHeapTypeNone */;\n  export const Noextern: HeapTypeRef = 12 /* _BinaryenHeapTypeNoext */;\n  export const Nofunc: HeapTypeRef = 13 /* _BinaryenHeapTypeNofunc */;\n\n  export function isBottom(ht: HeapTypeRef): bool {\n    return binaryen._BinaryenHeapTypeIsBottom(ht);\n  }\n\n  export function getBottom(ht: HeapTypeRef): HeapTypeRef {\n    return binaryen._BinaryenHeapTypeGetBottom(ht);\n  }\n}\n\n/** Packed array element respectively struct field types. */\nexport type PackedType = binaryen.PackedType;\nexport namespace PackedType {\n  export const NotPacked: PackedType = 0 /* _BinaryenPackedTypeNotPacked */;\n  export const I8: PackedType = 1 /* _BinaryenPackedTypeInt8 */;\n  export const I16: PackedType = 2 /* _BinaryenPackedTypeInt16 */;\n}\n\n/** Type builder error reasons. */\nexport type TypeBuilderErrorReason = binaryen.TypeBuilderErrorReason;\nexport namespace TypeBuilderErrorReason {\n  /** Indicates a cycle in the supertype relation. */\n  export const SelfSupertype: TypeBuilderErrorReason = 0 /* _TypeBuilderErrorReasonSelfSupertype */;\n  /** Indicates that the declared supertype of a type is invalid. */\n  export const InvalidSupertype: TypeBuilderErrorReason = 1 /* _TypeBuilderErrorReasonInvalidSupertype */;\n  /** Indicates that the declared supertype is an invalid forward reference. */\n  export const ForwardSupertypeReference: TypeBuilderErrorReason = 2 /* _TypeBuilderErrorReasonForwardSupertypeReference */;\n  /** Indicates that a child of a type is an invalid forward reference. */\n  export const ForwardChildReference: TypeBuilderErrorReason = 3 /* _TypeBuilderErrorReasonForwardChildReference */;\n  /** Converts a type builder error reason to a string. */\n  export function toString(reason: TypeBuilderErrorReason): string {\n    switch (reason) {\n      case SelfSupertype: return \"SelfSupertype\";\n      case InvalidSupertype: return \"InvalidSupertype\";\n      case ForwardSupertypeReference: return \"ForwardSupertypeReference\";\n      case ForwardChildReference: return \"ForwardChildReference\";\n    }\n    assert(false);\n    return \"\";\n  }\n}\n\n/** Type system constants. */\nexport type TypeSystem = binaryen.TypeSystem;\nexport namespace TypeSystem {\n  export const Equirecursive: TypeSystem = 0 /* _BinaryenTypeSystemEquirecursive */;\n  export const Nominal: TypeSystem = 1 /* _BinaryenTypeSystemNominal */;\n  export const Isorecursive: TypeSystem = 2 /* _BinaryenTypeSystemIsorecursive */;\n}\n\n/** Binaryen feature constants. */\nexport const enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGlobals = 2 /* _BinaryenFeatureMutableGlobals */,\n  TruncSat = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,\n  RelaxedSIMD = 8192 /* _BinaryenFeatureRelaxedSIMD */,\n  ExtendedConst = 16384 /* _BinaryenFeatureExtendedConst */,\n  Stringref = 32768 /* _BinaryenFeatureStrings */,\n  MultiMemory = 65536 /* _BinaryenFeatureMultiMemories */,\n  All = 126975 /* _BinaryenFeatureAll */\n}\n\n/** Binaryen expression id constants. */\nexport const enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIs = 42 /* _BinaryenRefIsId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  TableGet = 45 /* _BinaryenTableGetId */,\n  TableSet = 46 /* _BinaryenTableSetId */,\n  TableSize = 47 /* _BinaryenTableSizeId */,\n  TableGrow = 48 /* _BinaryenTableGrowId */,\n  Try = 49 /* _BinaryenTryId */,\n  Throw = 50 /* _BinaryenThrowId */,\n  Rethrow = 51 /* _BinaryenRethrowId */,\n  TupleMake = 52 /* _BinaryenTupleMakeId */,\n  TupleExtract = 53 /* _BinaryenTupleExtractId */,\n  I31New = 54 /* _BinaryenI31NewId */,\n  I31Get = 55 /* _BinaryenI31GetId */,\n  CallRef = 56 /* _BinaryenCallRefId */,\n  RefTest = 57 /* _BinaryenRefTestId */,\n  RefCast = 58 /* _BinaryenRefCastId */,\n  BrOn = 59 /* _BinaryenBrOnId */,\n  StructNew = 60 /* _BinaryenStructNewId */,\n  StructGet = 61 /* _BinaryenStructGetId */,\n  StructSet = 62 /* _BinaryenStructSetId */,\n  ArrayNew = 63 /* _BinaryenArrayNewId */,\n  ArrayInit = 64 /* _BinaryenArrayInitId */,\n  ArrayGet = 65 /* _BinaryenArrayGetId */,\n  ArraySet = 66 /* _BinaryenArraySetId */,\n  ArrayLen = 67 /* _BinaryenArrayLenId */,\n  ArrayCopy = 68 /* _BinaryenArrayCopyId */,\n  RefAs = 69 /* _BinaryenRefAsId */,\n  StringNew = 70 /* _BinaryenStringNewId */,\n  StringConst = 71 /* _BinaryenStringConstId */,\n  StringMeasure = 72 /* _BinaryenStringMeasureId */,\n  StringEncode = 73 /* _BinaryenStringEncodeId */,\n  StringConcat = 74 /* _BinaryenStringConcatId */,\n  StringEq = 75 /* _BinaryenStringEqId */,\n  StringAs = 76 /* _BinaryenStringAsId */,\n  StringWTF8Advance = 77 /* _BinaryenStringWTF8AdvanceId */,\n  StringWTF16Get = 78 /* _BinaryenStringWTF16GetId */,\n  StringIterNext = 79 /* _BinaryenStringIterNextId */,\n  StringIterMove = 80 /* _BinaryenStringIterMoveId */,\n  StringSliceWTF = 81 /* _BinaryenStringSliceWTFId */,\n  StringSliceIter = 82 /* _BinaryenStringSliceIterId */\n}\n\n/** Binaryen external kind constants. */\nexport const enum ExternalKind {\n  Function = 0 /* _BinaryenExternalFunction */,\n  Table = 1 /* _BinaryenExternalTable */,\n  Memory = 2 /* _BinaryenExternalMemory */,\n  Global = 3 /* _BinaryenExternalGlobal */,\n  Tag = 4 /* _BinaryenExternalTag */\n}\n\n/** Binaryen unary operation constants. */\nexport const enum UnaryOp {\n  /** i32.clz */\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  /** i64.clz */\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  /** i32.ctz */\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  /** i64.ctz */\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  /** i32.popcnt */\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  /** i64.popcnt */\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  /** f32.neg */\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  /** f64.neg */\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  /** f32.abs */\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  /** f64.abs */\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  /** f32.ceil */\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  /** f64.ceil */\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  /** f32.floor */\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  /** f64.floor */\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  /** f32.trunc */\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  /** f64.trunc */\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  /** f32.nearest */\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  /** f64.nearest */\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  /** f32.sqrt */\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  /** f64.sqrt */\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  /** i32.eqz */\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  /** i64.eqz */\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  /** i64.extend_i32_s */\n  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,\n  /** i64.extend_i32_u */\n  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,\n  /** i32.wrap_i64 */\n  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,\n  /** i32.trunc_f32_s */\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  /** i64.trunc_f32_s */\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  /** i32.trunc_f32_u */\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  /** i64.trunc_f32_u */\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  /** i32.trunc_f64_s */\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  /** i64.trunc_f64_s */\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  /** i32.trunc_f64_u */\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  /** i64.trunc_f64_u */\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  /** i32.reinterpret_f32 */\n  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,\n  /** i64.reinterpret_f64 */\n  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,\n  /** f32.convert_i32_s */\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  /** f64.convert_i32_s */\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  /** f32.convert_i32_u */\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  /** f64.convert_i32_u */\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  /** f32.convert_i64_s */\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  /** f64.convert_i64_s */\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  /** f32.convert_i64_u */\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  /** f64.convert_i64_u */\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  /** f64.promote.f32 */\n  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,\n  /** f32.demote_f64 */\n  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,\n  /** f32.reinterpret_i32 */\n  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,\n  /** f64.reinterpret_i64 */\n  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n\n  /** i32.extend8_s */\n  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,\n  /** i32.extend16_s */\n  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,\n  /** i64.extend8_s */\n  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,\n  /** i64.extend16_s */\n  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,\n  /** i64.extend32_s (i64 in, i64 out) */\n  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n\n  /** i32.trunc_sat_f32_s */\n  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  /** i32.trunc_sat_f32_u */\n  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  /** i32.trunc_sat_f64_s */\n  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  /** i32.trunc_sat_f64_u */\n  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  /** i64.trunc_sat_f32_s */\n  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  /** i64.trunc_sat_f32_u */\n  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  /** i64.trunc_sat_f64_s */\n  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  /** i64.trunc_sat_f64_u */\n  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.splat */\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  /** i16x8.splat */\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  /** i32x4.splat */\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  /** i64x2.splat */\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  /** f32x4.splat */\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  /** f64x2.splat */\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  /** v128.not */\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  /** v128.any_true */\n  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,\n  /** i8x16.abs */\n  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,\n  /** i8x16.neg */\n  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,\n  /** i8x16.all_true */\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  /** i8x16.bitmask */\n  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,\n  /** i8x16.popcnt */\n  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,\n  /** i16x8.abs */\n  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,\n  /** i16x8.neg */\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  /** i16x8.all_true */\n  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,\n  /** i16x8.bitmask */\n  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,\n  /** i32x4.abs */\n  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,\n  /** i32x4.neg */\n  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,\n  /** i32x4.all_true */\n  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,\n  /** i32x4.bitmask */\n  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,\n  /** i64x2.abs */\n  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,\n  /** i64x2.neg */\n  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,\n  /** i64x2.all_true */\n  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,\n  /** i64x2.bitmask */\n  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,\n  /** f32x4.abs */\n  AbsF32x4 = 85 /* _BinaryenAbsVecF32x4 */,\n  /** f32x4.neg */\n  NegF32x4 = 86 /* _BinaryenNegVecF32x4 */,\n  /** f32x4.sqrt */\n  SqrtF32x4 = 87 /* _BinaryenSqrtVecF32x4 */,\n  /** f32x4.ceil */\n  CeilF32x4 = 88 /* _BinaryenCeilVecF32x4 */,\n  /** f32x4.floor */\n  FloorF32x4 = 89 /* _BinaryenFloorVecF32x4 */,\n  /** f32x4.trunc */\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\n  /** f32x4.nearest */\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\n  /** f64x2.abs */\n  AbsF64x2 = 92 /* _BinaryenAbsVecF64x2 */,\n  /** f64x2.neg */\n  NegF64x2 = 93 /* _BinaryenNegVecF64x2 */,\n  /** f64x2.sqrt */\n  SqrtF64x2 = 94 /* _BinaryenSqrtVecF64x2 */,\n  /** f64x2.ceil */\n  CeilF64x2 = 95 /* _BinaryenCeilVecF64x2 */,\n  /** f64x2.floor */\n  FloorF64x2 = 96 /* _BinaryenFloorVecF64x2 */,\n  /** f64x2.trunc */\n  TruncF64x2 = 97 /* _BinaryenTruncVecF64x2 */,\n  /** f64x2.nearest */\n  NearestF64x2 = 98 /* _BinaryenNearestVecF64x2 */,\n  /** i16x8.extadd_pairwise_i8x16_s */\n  ExtaddPairwiseI8x16ToI16x8 = 99 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,\n  /** i16x8.extadd_pairwise.i8x16_u */\n  ExtaddPairwiseU8x16ToU16x8 = 100 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,\n  /** i32x4.extadd_pairwise.i16x8_s */\n  ExtaddPairwiseI16x8ToI32x4 = 101 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,\n  /** i32x4.extadd_pairwise.i64x8_u */\n  ExtaddPairwiseU16x8ToU32x4 = 102 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,\n  /** i32x4.trunc_sat_f32x4_s */\n  TruncSatF32x4ToI32x4 = 103 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  /** i32x4.trunc_sat_f32x4_u */\n  TruncSatF32x4ToU32x4 = 104 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertI32x4ToF32x4 = 105 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertU32x4ToF32x4 = 106 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  /** i16x8.extend_low_i8x16_s */\n  ExtendLowI8x16ToI16x8 = 107 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_s */\n  ExtendHighI8x16ToI16x8 = 108 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_low_i8x16_u */\n  ExtendLowU8x16ToU16x8 = 109 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_u */\n  ExtendHighU8x16ToU16x8 = 110 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,\n  /** i32x4.extend_low_i16x8_s */\n  ExtendLowI16x8ToI32x4 = 111 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_s */\n  ExtendHighI16x8ToI32x4 = 112 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_low_i16x8_u */\n  ExtendLowU16x8ToU32x4 = 113 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_u */\n  ExtendHighU16x8ToU32x4 = 114 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,\n  /** i64x2.extend_low_i32x4_s */\n  ExtendLowI32x4ToI64x2 = 115 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_s */\n  ExtendHighI32x4ToI64x2 = 116 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_low_i32x4_u */\n  ExtendLowU32x4ToU64x2 = 117 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_u */\n  ExtendHighU32x4ToU64x2 = 118 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertLowI32x4ToF64x2 = 119 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertLowU32x4ToF64x2 = 120 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,\n  /** i32x4.trunc_sat_f64x2_s_zero */\n  TruncSatF64x2ToI32x4Zero = 121 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.trunc_sat_f64x2_u_zero */\n  TruncSatF64x2ToU32x4Zero = 122 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,\n  /** f32x4.demote_f64x2_zero */\n  DemoteZeroF64x2ToF32x4 = 123 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,\n  /** f64x2.promote_low_f32x4 */\n  PromoteLowF32x4ToF64x2 = 124 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,\n\n  _last = PromoteLowF32x4ToF64x2,\n\n  // Target dependent\n\n  /** i32.clz or i64.clz, depending on target word size */\n  ClzSize,\n  /** i32.ctz or i64.ctz, depending on target word size */\n  CtzSize,\n  /** i32.popcnt or i64.popcnt, depending on target word size */\n  PopcntSize,\n  /** i32.eqz or i64.eqz, depending on target word size */\n  EqzSize\n}\n\n/** Binaryen binary operation constants. */\nexport const enum BinaryOp {\n  /** i32.add */\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  /** i32.sub */\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  /** i32.mul */\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  /** i32.div_s */\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  /** i32.div_u */\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  /** i32.rem_s */\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  /** i32.rem_u */\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  /** i32.and */\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  /** i32.or */\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  /** i32.xor */\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  /** i32.shl */\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  /** i32.shr_s */\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  /** i32.shr_u */\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  /** i32.rotl */\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  /** i32.rotr */\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  /** i32.eq */\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  /** i32.ne */\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  /** i32.lt_s */\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  /** i32.lt_u */\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  /** i32.le_s */\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  /** i32.le_u */\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  /** i32.gt_s */\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  /** i32.gt_u */\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  /** i32.ge_s */\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  /** i32.ge_u */\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  /** i64.add */\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  /** i64.sub */\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  /** i64.mul */\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  /** i64.div_s */\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  /** i64.div_u */\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  /** i64.rem_s */\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  /** i64.rem_u */\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  /** i64.and */\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  /** i64.or */\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  /** i64.xor */\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  /** i64.shl */\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  /** i64.shr_s */\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  /** i64.shr_u */\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  /** i64.rotl */\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  /** i64.rotr */\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  /** i64.eq */\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  /** i64.ne */\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  /** i64.lt_s */\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  /** i64.lt_u */\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  /** i64.le_s */\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  /** i64.le_u */\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  /** i64.gt_s */\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  /** i64.gt_u */\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  /** i64.ge_s */\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  /** i64.ge_u */\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  /** f32.add */\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  /** f32.sub */\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  /** f32.mul */\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  /** f32.div */\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  /** f32.copysign */\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  /** f32.min */\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  /** f32.max */\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  /** f32.eq */\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  /** f32.ne */\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  /** f32.lt */\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  /** f32.le */\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  /** f32.gt */\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  /** f32.ge */\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  /** f64.add */\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  /** f64.sub */\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  /** f64.mul */\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  /** f64.div */\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  /** f64.copysign */\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  /** f64.min */\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  /** f64.max */\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  /** f64.eq */\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  /** f64.ne */\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  /** f64.lt */\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  /** f64.le */\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  /** f64.gt */\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  /** f64.ge */\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.eq */\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  /** i8x16.he */\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  /** i8x16.lt_s */\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  /** i8x16.lt_u */\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  /** i8x16.gt_s */\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  /** i8x16.gt_u */\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  /** i8x16.le_s */\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  /** i8x16.le_u */\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  /** i8x16.ge_s */\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  /** i8x16.ge_u */\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  /** i16x8.eq */\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  /** i16x8.ne */\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  /** i16x8.lt_s */\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  /** i16x8.lt_u */\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  /** i16x8.gt_s */\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  /** i16x8.gt_u */\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  /** i16x8.le_s */\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  /** i16x8.le_u */\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  /** i16x8.ge_s */\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  /** i16x8.ge_u */\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  /** i32x4.eq */\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  /** i32x4.ne */\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  /** i32x4.lt_s */\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  /** i32x4.lt_u */\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  /** i32x4.gt_s */\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  /** i32x4.gt_u */\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  /** i32x4.le_s */\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  /** i32x4.le_u */\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  /** i32x4.ge_s */\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  /** i32x4.ge_u */\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  /** i64x2.eq */\n  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,\n  /** i64x2.ne */\n  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,\n  /** i64x2.lt_s */\n  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,\n  /** i64x2.gt_s */\n  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,\n  /** i64x2.le_s */\n  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,\n  /** i64x2.ge_s */\n  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,\n  /** f32x4.eq */\n  EqF32x4 = 112 /* _BinaryenEqVecF32x4 */,\n  /** f32x4.ne */\n  NeF32x4 = 113 /* _BinaryenNeVecF32x4 */,\n  /** f32x4.lt */\n  LtF32x4 = 114 /* _BinaryenLtVecF32x4 */,\n  /** f32x4.gt */\n  GtF32x4 = 115 /* _BinaryenGtVecF32x4 */,\n  /** f32x4.le */\n  LeF32x4 = 116 /* _BinaryenLeVecF32x4 */,\n  /** f32x4.ge */\n  GeF32x4 = 117 /* _BinaryenGeVecF32x4 */,\n  /** f64x2.eq */\n  EqF64x2 = 118 /* _BinaryenEqVecF64x2 */,\n  /** f64x2.ne */\n  NeF64x2 = 119 /* _BinaryenNeVecF64x2 */,\n  /** f64x2.lt */\n  LtF64x2 = 120 /* _BinaryenLtVecF64x2 */,\n  /** f64x2.gt */\n  GtF64x2 = 121 /* _BinaryenGtVecF64x2 */,\n  /** f64x2.le */\n  LeF64x2 = 122 /* _BinaryenLeVecF64x2 */,\n  /** f64x2.ge */\n  GeF64x2 = 123 /* _BinaryenGeVecF64x2 */,\n  /** v128.and */\n  AndV128 = 124 /* _BinaryenAndVec128 */,\n  /** v128.or */\n  OrV128 = 125 /* _BinaryenOrVec128 */,\n  /** v128.xor */\n  XorV128 = 126 /* _BinaryenXorVec128 */,\n  /** v128.andnot */\n  AndnotV128 = 127 /* _BinaryenAndNotVec128 */,\n  /** i8x16.add */\n  AddI8x16 = 128 /* _BinaryenAddVecI8x16 */,\n  /** i8x16.add_sat_s */\n  AddSatI8x16 = 129 /* _BinaryenAddSatSVecI8x16 */,\n  /** i8x16.add_sat_u */\n  AddSatU8x16 = 130 /* _BinaryenAddSatUVecI8x16 */,\n  /** i8x16.sub */\n  SubI8x16 = 131 /* _BinaryenSubVecI8x16 */,\n  /** i8x16.sub_sat_s */\n  SubSatI8x16 = 132 /* _BinaryenSubSatSVecI8x16 */,\n  /** i8x16.sub_sat_u */\n  SubSatU8x16 = 133 /* _BinaryenSubSatUVecI8x16 */,\n  /** i8x16.min_s */\n  MinI8x16 = 134 /* _BinaryenMinSVecI8x16 */,\n  /** i8x16.min_u */\n  MinU8x16 = 135 /* _BinaryenMinUVecI8x16 */,\n  /** i8x16.max_s */\n  MaxI8x16 = 136 /* _BinaryenMaxSVecI8x16 */,\n  /** i8x16.max_u */\n  MaxU8x16 = 137 /* _BinaryenMaxUVecI8x16 */,\n  /** i8x16.avgr_u */\n  AvgrU8x16 = 138 /* _BinaryenAvgrUVecI8x16 */,\n  /** i16x8.add */\n  AddI16x8 = 139 /* _BinaryenAddVecI16x8 */,\n  /** i16x8.add_sat_s */\n  AddSatI16x8 = 140 /* _BinaryenAddSatSVecI16x8 */,\n  /** i16x8.add_sat_u */\n  AddSatU16x8 = 141 /* _BinaryenAddSatUVecI16x8 */,\n  /** i16x8.sub */\n  SubI16x8 = 142 /* _BinaryenSubVecI16x8 */,\n  /** i16x8.sub_sat_s */\n  SubSatI16x8 = 143 /* _BinaryenSubSatSVecI16x8 */,\n  /** i16x8.sub_sat_u */\n  SubSatU16x8 = 144 /* _BinaryenSubSatUVecI16x8 */,\n  /** i16x8.mul */\n  MulI16x8 = 145 /* _BinaryenMulVecI16x8 */,\n  /** i16x8.min_s */\n  MinI16x8 = 146 /* _BinaryenMinSVecI16x8 */,\n  /** i16x8.min_u */\n  MinU16x8 = 147 /* _BinaryenMinUVecI16x8 */,\n  /** i16x8.max_s */\n  MaxI16x8 = 148 /* _BinaryenMaxSVecI16x8 */,\n  /** i16x8.max_u */\n  MaxU16x8 = 149 /* _BinaryenMaxUVecI16x8 */,\n  /** i16x8.avgr_u */\n  AvgrU16x8 = 150 /* _BinaryenAvgrUVecI16x8 */,\n  /** i16x8.q15mulr_sat_s */\n  Q15mulrSatI16x8 = 151 /* _BinaryenQ15MulrSatSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_s */\n  ExtmulLowI16x8 = 152 /* _BinaryenExtMulLowSVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_s */\n  ExtmulHighI16x8 = 153 /* _BinaryenExtMulHighSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_u */\n  ExtmulLowU16x8 = 154 /* _BinaryenExtMulLowUVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_u */\n  ExtmulHighU16x8 = 155 /* _BinaryenExtMulHighUVecI16x8 */,\n  /** i32x4.add */\n  AddI32x4 = 156 /* _BinaryenAddVecI32x4 */,\n  /** i32x4.sub */\n  SubI32x4 = 157 /* _BinaryenSubVecI32x4 */,\n  /** i32x4.mul */\n  MulI32x4 = 158 /* _BinaryenMulVecI32x4 */,\n  /** i32x4.min_s */\n  MinI32x4 = 159 /* _BinaryenMinSVecI32x4 */,\n  /** i32x4.min_u */\n  MinU32x4 = 160 /* _BinaryenMinUVecI32x4 */,\n  /** i32x4.max_s */\n  MaxI32x4 = 161 /* _BinaryenMaxSVecI32x4 */,\n  /** i32x4.max_u */\n  MaxU32x4 = 162 /* _BinaryenMaxUVecI32x4 */,\n  /** i32x4.dot_i16x8_s */\n  DotI16x8 = 163 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_s */\n  ExtmulLowI32x4 = 164 /* _BinaryenExtMulLowSVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_s */\n  ExtmulHighI32x4 = 165 /* _BinaryenExtMulHighSVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_u */\n  ExtmulLowU32x4 = 166 /* _BinaryenExtMulLowUVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_u */\n  ExtmulHighU32x4 = 167 /* _BinaryenExtMulHighUVecI32x4 */,\n  /** i64x2.add */\n  AddI64x2 = 168 /* _BinaryenAddVecI64x2 */,\n  /** i64x2.sub */\n  SubI64x2 = 169 /* _BinaryenSubVecI64x2 */,\n  /** i64x2.mul */\n  MulI64x2 = 170 /* _BinaryenMulVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_s */\n  ExtmulLowI64x2 = 171 /* _BinaryenExtMulLowSVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_s */\n  ExtmulHighI64x2 = 172 /* _BinaryenExtMulHighSVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_u */\n  ExtmulLowU64x2 = 173 /* _BinaryenExtMulLowUVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_u */\n  ExtmulHighU64x2 = 174 /* _BinaryenExtMulHighUVecI64x2 */,\n  /** f32x4.add */\n  AddF32x4 = 175 /* _BinaryenAddVecF32x4 */,\n  /** f32x4.sub */\n  SubF32x4 = 176 /* _BinaryenSubVecF32x4 */,\n  /** f32x4.mul */\n  MulF32x4 = 177 /* _BinaryenMulVecF32x4 */,\n  /** f32x4.div */\n  DivF32x4 = 178 /* _BinaryenDivVecF32x4 */,\n  /** f32x4.min */\n  MinF32x4 = 179 /* _BinaryenMinVecF32x4 */,\n  /** f32x4.max */\n  MaxF32x4 = 180 /* _BinaryenMaxVecF32x4 */,\n  /** f32x4.pmin */\n  PminF32x4 = 181 /* _BinaryenPMinVecF32x4 */,\n  /** f32x4.pmax */\n  PmaxF32x4 = 182 /* _BinaryenPMaxVecF32x4 */,\n  /** f64x2.add */\n  AddF64x2 = 183 /* _BinaryenAddVecF64x2 */,\n  /** f64x2.sub */\n  SubF64x2 = 184 /* _BinaryenSubVecF64x2 */,\n  /** f64x2.mul */\n  MulF64x2 = 185 /* _BinaryenMulVecF64x2 */,\n  /** f64x2.div */\n  DivF64x2 = 186 /* _BinaryenDivVecF64x2 */,\n  /** f64x2.min */\n  MinF64x2 = 187 /* _BinaryenMinVecF64x2 */,\n  /** f64x2.max */\n  MaxF64x2 = 188 /* _BinaryenMaxVecF64x2 */,\n  /** f64x2.pmin */\n  PminF64x2 = 189 /* _BinaryenPMinVecF64x2 */,\n  /** f64x2.pmax */\n  PmaxF64x2 = 190 /* _BinaryenPMaxVecF64x2 */,\n  /** i8x16.narrow_i16x8_s */\n  NarrowI16x8ToI8x16 = 191 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  /** i8x16.narrow_i16x8_u */\n  NarrowU16x8ToU8x16 = 192 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  /** i16x8.narrow_i32x4_s */\n  NarrowI32x4ToI16x8 = 193 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  /** i16x8.narrow_i32x4_u */\n  NarrowU32x4ToU16x8 = 194 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  /** i8x16.swizzle */\n  SwizzleI8x16 = 195 /* _BinaryenSwizzleVecI8x16 */,\n\n  _last = SwizzleI8x16,\n\n  // Target dependent\n\n  /** i32.add or i64.add, depending on target word size */\n  AddSize,\n  /** i32.sub or i64.sub, depending on target word size */\n  SubSize,\n  /** i32.mul or i64.mul, depending on target word size */\n  MulSize,\n  /** i32.div_s or i64.div_s, depending on target word size */\n  DivISize,\n  /** i32.div_u or i64.div_u, depending on target word size */\n  DivUSize,\n  /** i32.rem_s or i64.rem_s, depending on target word size */\n  RemISize,\n  /** i32.rem_u or i64.rem_u, depending on target word size */\n  RemUSize,\n  /** i32.and or i64.and, depending on target word size */\n  AndSize,\n  /** i32.or or i64.or, depending on target word size */\n  OrSize,\n  /** i32.xor or i64.xor, depending on target word size */\n  XorSize,\n  /** i32.shl or i64.shl, depending on target word size */\n  ShlSize,\n  /** i32.shr_s or i64.shr_s, depending on target word size */\n  ShrISize,\n  /** i32.shr_u or i64.shr_u, depending on target word size */\n  ShrUSize,\n  /** i32.rotl or i64.rotl, depending on target word size */\n  RotlSize,\n  /** i32.rotr or i64.rotr, depending on target word size */\n  RotrSize,\n  /** i32.eq or i64.eq, depending on target word size */\n  EqSize,\n  /** i32.ne or i64.ne, depending on target word size */\n  NeSize,\n  /** i32.lt_s or i64.lt_s, depending on target word size */\n  LtISize,\n  /** i32.lt_u or i64.lt_u, depending on target word size */\n  LtUSize,\n  /** i32.le_s or i64.le_s, depending on target word size */\n  LeISize,\n  /** i32.le_u or i64.le_u, depending on target word size */\n  LeUSize,\n  /** i32.gt_s or i64.gt_s, depending on target word size */\n  GtISize,\n  /** i32.gt_u or i64.gt_u, depending on target word size */\n  GtUSize,\n  /** i32.ge_s or i64.ge_s, depending on target word size */\n  GeISize,\n  /** i32.ge_u or i64.ge_u, depending on target word size */\n  GeUSize\n}\n\n/** Binaryen atomic read-modify-write operation constants. */\nexport const enum AtomicRMWOp {\n  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\n/** Binaryen SIMD extract operation constants. */\nexport const enum SIMDExtractOp {\n  /** i8x16.extract_lane_s */\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  /** i8x16.extract_lane_u */\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  /** i16x8.extract_lane_s */\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  /** i16x8.extract_lane_u */\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  /** i32x4.extract_lane_s */\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  /** i32x4.extract_lane_u */\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  /** i64x2.extract_lane_s */\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\n  /** i64x2.extract_lane_u */\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\n/** Binaryen SIMD replace operation constants. */\nexport const enum SIMDReplaceOp {\n  /** i8x16.replace_lane */\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  /** i16x8.replace_lane */\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  /** i32x4.replace_lane */\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  /** i64x2.replace_lane */\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  /** f32x4.replace_lane */\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\n  /** f64x2.replace_lane */\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\n/** Binaryen SIMD shift operation constants. */\nexport const enum SIMDShiftOp {\n  /** i8x16.shl */\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  /** i8x16.shr_s */\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  /** i8x16.shr_u */\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  /** i16x8.shl */\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  /** i16x8.shr_s */\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  /** i16x8.shr_u */\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  /** i16x8.shl */\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  /** i32x4.shr_s */\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  /** i32x4.shr_u */\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  /** i64x2.shl */\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\n/** Binaryen SIMD load operation constants. */\nexport const enum SIMDLoadOp {\n  /** v128.load8_splat */\n  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,\n  /** v128.load16_splat */\n  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,\n  /** v128.load32_splat */\n  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,\n  /** v128.load64_splat */\n  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,\n  /** v128.load8x8_s */\n  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,\n  /** v128.load8x8_u */\n  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,\n  /** v128.load16x4_s */\n  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,\n  /** v128.load16x4_u */\n  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,\n  /** v128.load32x2_s */\n  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,\n  /** v128.load32x2_u */\n  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,\n  /** v128.load32_zero */\n  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,\n  /** v128.load64_zero */\n  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,\n}\n\n/** Binaryen SIMD load/store lane operation constants. */\nexport const enum SIMDLoadStoreLaneOp {\n  /** v128.load8_lane */\n  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,\n  /** v128.load16_lane */\n  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,\n  /** v128.load32_lane */\n  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,\n  /** v128.load64_lane */\n  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,\n  /** v128.store8_lane */\n  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,\n  /** v128.store16_lane */\n  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,\n  /** v128.store32_lane */\n  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,\n  /** v128.store64_lane */\n  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,\n}\n\n/** Binaryen SIMD ternary operation constants. */\nexport const enum SIMDTernaryOp {\n  /** v128.bitselect */\n  Bitselect = 0 /* _BinaryenBitselectVec128 */\n}\n\n/** Binaryen RefIs operation constants. */\nexport const enum RefIsOp {\n  /** ref.is_null */\n  Null = 0 /* _BinaryenRefIsNull */,\n  /** ref.is_func */\n  Func = 1 /* _BinaryenRefIsFunc */,\n  /** ref.is_data */\n  Data = 2 /* _BinaryenRefIsData */,\n  /** ref.is_i31 */\n  I31 = 3 /* _BinaryenRefIsI31 */\n}\n\n/** Binaryen RefAs operation constants. */\nexport const enum RefAsOp {\n  /** ref.as_non_null */\n  NonNull = 0 /* _BinaryenRefAsNonNull */,\n  /** ref.as_func */\n  Func = 1 /* _BinaryenRefAsFunc */,\n  /** ref.as_data */\n  Data = 2 /* _BinaryenRefAsData */,\n  /** ref.as_i31 */\n  I31 = 3 /* _BinaryenRefAsI31 */,\n  /** extern.internalize */\n  ExternInternalize = 4 /* _BinaryenRefAsExternInternalize */,\n  /** extern.externalize */\n  ExternExternalize = 5 /* _BinaryenRefAsExternExternalize */\n}\n\n/** Binaryen BrOn operation constants. */\nexport const enum BrOnOp {\n  /** br_on_null */\n  Null = 0 /* _BinaryenBrOnNull */,\n  /** br_on_non_null */\n  NonNull = 1 /* _BinaryenBrOnNonNull */,\n  /** br_on_cast */\n  Cast = 2 /* _BinaryenBrOnCast */,\n  /** br_on_cast_fail */\n  CastFail = 3 /* _BinaryenBrOnCastFail */,\n  /** br_on_func */\n  Func = 4 /* _BinaryenBrOnFunc */,\n  /** br_on_non_func */\n  NonFunc = 5 /* _BinaryenBrOnNonFunc */,\n  /** br_on_data */\n  Data = 6 /* _BinaryenBrOnData */,\n  /** br_on_non_data */\n  NonData = 7 /* _BinaryenBrOnNonData */,\n  /** br_on_i31 */\n  I31 = 8 /* _BinaryenBrOnI31 */,\n  /** br_on_non_i32 */\n  NonI31 = 9 /* _BinaryenBrOnNonI31 */\n}\n\n/** Binaryen StringNew operation constants. */\nexport const enum StringNewOp {\n  /** string.new_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringNewUTF8 */,\n  /** string.new_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringNewWTF8 */,\n  /** string.new_wtf8 replace */\n  Replace = 2 /* _BinaryenStringNewReplace */,\n  /** string.new_wtf16 */\n  WTF16 = 3 /* _BinaryenStringNewWTF16 */,\n  /** string.new_wtf8_array utf8 */\n  UTF8Array = 4 /* _BinaryenStringNewUTF8Array */,\n  /** string.new_wtf8_array wtf8 */\n  WTF8Array = 5 /* _BinaryenStringNewWTF8Array */,\n  /** string.new_wtf8_array replace */\n  ReplaceArray = 6 /* _BinaryenStringNewReplaceArray */,\n  /** string.new_wtf16_array */\n  WTF16Array = 7 /* _BinaryenStringNewWTF16Array */\n}\n\n/** Binaryen StringMeasure operation constants. */\nexport const enum StringMeasureOp {\n  /** string.measure_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringMeasureUTF8 */,\n  /** string.measure_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringMeasureWTF8 */,\n  /** string.measure_wtf16 */\n  WTF16 = 2 /* _BinaryenStringMeasureWTF16 */,\n  /** string.is_usv_sequence */\n  IsUSV = 3 /* _BinaryenStringMeasureIsUSV */,\n  /** stringview_wtf16.length */\n  WTF16View = 4 /* _BinaryenStringMeasureWTF16View */\n}\n\n/** Binaryen StringEncode operation constants. */\nexport const enum StringEncodeOp {\n  /** string.encode_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringEncodeUTF8 */,\n  /** string.encode_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringEncodeWTF8 */,\n  /** string.encode_wtf16 */\n  WTF16 = 2 /* _BinaryenStringEncodeWTF16 */,\n  /** string.encode_wtf8_array utf8 */\n  UTF8Array = 3 /* _BinaryenStringEncodeUTF8Array */,\n  /** string.encode_wtf8_array wtf8 */\n  WTF8Array = 4 /* _BinaryenStringEncodeWTF8Array */,\n  /** string.encode_wtf16_array */\n  WTF16Array = 5 /* _BinaryenStringEncodeWTF16Array */\n}\n\n/** Binaryen StringAs operation constants. */\nexport const enum StringAsOp {\n  /** string.as_wtf8 */\n  WTF8 = 0 /* _BinaryenStringAsWTF8 */,\n  /** string.as_wtf16 */\n  WTF16 = 1 /* _BinaryenStringAsWTF16 */,\n  /** string.as_iter */\n  Iter = 2 /* _BinaryenStringAsIter */\n}\n\n/** Binaryen StringIterMove operation constants. */\nexport const enum StringIterMoveOp {\n  /** stringview_iter.advance */\n  Advance = 0 /* _BinaryenStringIterMoveAdvance */,\n  /** stringview_iter.rewind */\n  Rewind = 1 /* _BinaryenStringIterMoveRewind */\n}\n\n/** Binaryen StringSlice operation constants. */\nexport const enum StringSliceWTFOp {\n  /** stringview_wtf8.slice */\n  WTF8 = 0 /* _BinaryenStringSliceWTF8 */,\n  /** stringview_wtf16.slice */\n  WTF16 = 1 /* _BinaryenStringSliceWTF16 */\n}\n\n/** Binaryen expression runner flags. */\nexport const enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef,\n    /** Whether a shadow stack is used. */\n    public useShadowStack: bool,\n    /** Architecture-dependent size type. */\n    public sizeType: TypeRef\n  ) {\n    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n    binaryen._BinaryenSetTypeSystem(TypeSystem.Nominal);\n  }\n\n  private lit: usize;\n\n  static create(useShadowStack: bool, sizeType: TypeRef): Module {\n    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);\n  }\n\n  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {\n    let cArr = allocU8Array(buffer);\n    let module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  // isize<T>(value: T): ExpressionRef {\n  //   if (i64_is(value)) {\n  //     if (this.sizeType == TypeRef.I64) {\n  //       return this.i64(i64_low(value), i64_high(value));\n  //     }\n  //     assert(i64_is_i32(value));\n  //     return this.i32(i64_low(value));\n  //   }\n  //   return this.sizeType == TypeRef.I64\n  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)\n  //     : this.i32(i32(value));\n  // }\n\n  usize<T>(value: T): ExpressionRef {\n    if (i64_is(value)) {\n      if (this.sizeType == TypeRef.I64) {\n        return this.i64(i64_low(value), i64_high(value));\n      }\n      assert(i64_is_u32(value));\n      return this.i32(i64_low(value));\n    }\n    return this.sizeType == TypeRef.I64\n      ? this.i64(i32(value))\n      : this.i32(i32(value));\n  }\n\n  f32(value: f32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    let out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, unchecked(bytes[i]));\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: TypeRef): ExpressionRef {\n    // TODO: Provide the desired bottom type directly? Currently, Binaryen does\n    // this under the hood, but this API could change to take a heap type.\n    // type = binaryen._BinaryenTypeFromHeapType(\n    //   binaryen._BinaryenHeapTypeGetBottom(\n    //     binaryen._BinaryenTypeGetHeapType(type)\n    //   ),\n    //   true\n    // );\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenRefEq(this.ref, left, right);\n  }\n\n  string_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenStringEq(this.ref, left, right);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    value: ExpressionRef\n  ): ExpressionRef {\n    if (op > UnaryOp._last) {\n      let isWam64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case UnaryOp.ClzSize:    op = isWam64 ? UnaryOp.ClzI64    : UnaryOp.ClzI32; break;\n        case UnaryOp.CtzSize:    op = isWam64 ? UnaryOp.CtzI64    : UnaryOp.CtzI32; break;\n        case UnaryOp.PopcntSize: op = isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32; break;\n        case UnaryOp.EqzSize:    op = isWam64 ? UnaryOp.EqzI64    : UnaryOp.EqzI32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenUnary(this.ref, op, value);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    if (op > BinaryOp._last) {\n      let isWasm64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case BinaryOp.AddSize:  op = isWasm64 ? BinaryOp.AddI64  : BinaryOp.AddI32; break;\n        case BinaryOp.SubSize:  op = isWasm64 ? BinaryOp.SubI64  : BinaryOp.SubI32; break;\n        case BinaryOp.MulSize:  op = isWasm64 ? BinaryOp.MulI64  : BinaryOp.MulI32; break;\n        case BinaryOp.DivISize: op = isWasm64 ? BinaryOp.DivI64  : BinaryOp.DivI32; break;\n        case BinaryOp.DivUSize: op = isWasm64 ? BinaryOp.DivU64  : BinaryOp.DivU32; break;\n        case BinaryOp.RemISize: op = isWasm64 ? BinaryOp.RemI64  : BinaryOp.RemI32; break;\n        case BinaryOp.RemUSize: op = isWasm64 ? BinaryOp.RemU64  : BinaryOp.RemU32; break;\n        case BinaryOp.AndSize:  op = isWasm64 ? BinaryOp.AndI64  : BinaryOp.AndI32; break;\n        case BinaryOp.OrSize:   op = isWasm64 ? BinaryOp.OrI64   : BinaryOp.OrI32; break;\n        case BinaryOp.XorSize:  op = isWasm64 ? BinaryOp.XorI64  : BinaryOp.XorI32; break;\n        case BinaryOp.ShlSize:  op = isWasm64 ? BinaryOp.ShlI64  : BinaryOp.ShlI32; break;\n        case BinaryOp.ShrISize: op = isWasm64 ? BinaryOp.ShrI64  : BinaryOp.ShrI32; break;\n        case BinaryOp.ShrUSize: op = isWasm64 ? BinaryOp.ShrU64  : BinaryOp.ShrU32; break;\n        case BinaryOp.RotlSize: op = isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32; break;\n        case BinaryOp.RotrSize: op = isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32; break;\n        case BinaryOp.EqSize:   op = isWasm64 ? BinaryOp.EqI64   : BinaryOp.EqI32; break;\n        case BinaryOp.NeSize:   op = isWasm64 ? BinaryOp.NeI64   : BinaryOp.NeI32; break;\n        case BinaryOp.LtISize:  op = isWasm64 ? BinaryOp.LtI64   : BinaryOp.LtI32; break;\n        case BinaryOp.LtUSize:  op = isWasm64 ? BinaryOp.LtU64   : BinaryOp.LtU32; break;\n        case BinaryOp.LeISize:  op = isWasm64 ? BinaryOp.LeI64   : BinaryOp.LeI32; break;\n        case BinaryOp.LeUSize:  op = isWasm64 ? BinaryOp.LeU64   : BinaryOp.LeU32; break;\n        case BinaryOp.GtISize:  op = isWasm64 ? BinaryOp.GtI64   : BinaryOp.GtI32; break;\n        case BinaryOp.GtUSize:  op = isWasm64 ? BinaryOp.GtU64   : BinaryOp.GtU32; break;\n        case BinaryOp.GeISize:  op = isWasm64 ? BinaryOp.GeI64   : BinaryOp.GeI32; break;\n        case BinaryOp.GeUSize:  op = isWasm64 ? BinaryOp.GeU64   : BinaryOp.GeU32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemorySize(this.ref, cStr, is64);\n  }\n\n  memory_grow(delta: ExpressionRef, name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryGrow(this.ref, delta, cStr, is64);\n  }\n\n  table_size(name: string): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSize(this.ref, cStr);\n  }\n\n  table_grow(name: string, delta: ExpressionRef, value: ExpressionRef = 0): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGrow(this.ref, cStr, value, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  tostack(value: ExpressionRef): ExpressionRef {\n    if (this.useShadowStack) {\n      let type = binaryen._BinaryenExpressionGetType(value);\n      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);\n      return this.call(BuiltinNames.tostack, [ value ], type);\n    }\n    return value;\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    isManaged: bool,\n    type: TypeRef = -1,\n  ): ExpressionRef {\n    if (type == -1) type = binaryen._BinaryenExpressionGetType(value);\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  table_get(\n    name: string,\n    index: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGet(this.ref, cStr, index, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr, cStr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type, cStr);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr, cStr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type, cStr);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType, cStr);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount, cStr);\n  }\n\n  atomic_fence(name: string | null = null): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicFence(this.ref, cStr);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef,\n    isManaged: bool\n  ): ExpressionRef {\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  table_set(\n    name: string,\n    index: ExpressionRef,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSet(this.ref, cStr, index, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    let cArr = allocPtrArray(children);\n    let ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      if (singleType != TypeRef.Unreachable && singleType != type) {\n        // can happen when there was a diagnostic prior\n        return this.unreachable();\n      }\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  /** Drops an expression if it evaluates to a value. */\n  maybeDrop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    let type = binaryen._BinaryenExpressionGetType(expression);\n    if (type != TypeRef.None && type != TypeRef.Unreachable) {\n      return binaryen._BinaryenDrop(this.ref, expression);\n    }\n    return expression;\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition, this.ref) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let numNames = names.length;\n    let strs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(strs[i] = this.allocStringCached(names[i]));\n    }\n    let cArr = allocPtrArray(strs);\n    let cStr = this.allocStringCached(defaultName);\n    let ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tableName != null\n      ? tableName\n      : CommonNames.DefaultTable\n    );\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef\n  ): ExpressionRef {\n    return this.call_indirect(tableName, index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef,\n    destName: string = CommonNames.DefaultMemory,\n    sourceName: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr1 = this.allocStringCached(destName);\n    let cStr2 = this.allocStringCached(sourceName);\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size, cStr1, cStr2);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size, cStr);\n  }\n\n  // exception handling\n\n  try(\n    name: string | null,\n    body: ExpressionRef,\n    catchTags: string[],\n    catchBodies: ExpressionRef[],\n    delegateTarget: string | null = null\n  ): ExpressionRef {\n    let numCatchTags = catchTags.length;\n    let strs = new Array<TagRef>(numCatchTags);\n    for (let i = 0; i < numCatchTags; ++i) {\n      strs[i] = this.allocStringCached(catchTags[i]);\n    }\n    let cArr1 = allocPtrArray(strs);\n    let cArr2 = allocPtrArray(catchBodies);\n    let cStr1 = this.allocStringCached(name);\n    let cStr2 = this.allocStringCached(delegateTarget);\n    let ret = binaryen._BinaryenTry(\n      this.ref, cStr1, body, cArr1, numCatchTags, cArr2, catchBodies.length, cStr2\n    );\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    return ret;\n  }\n\n  throw(\n    tagName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tagName);\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    target: string\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    return binaryen._BinaryenRethrow(this.ref, cStr);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    let cArr = allocU8Array(mask);\n    let ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr, cStr);\n  }\n\n  simd_loadstorelane(\n    op: SIMDLoadStoreLaneOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    index: u8,\n    vec: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec, cStr);\n  }\n\n  // reference types / gc\n\n  ref_is(\n    op: RefIsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIs(this.ref, op, expr);\n  }\n\n  ref_is_null(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    if (isNullableType(getExpressionType(expr))) {\n      return binaryen._BinaryenRefIs(this.ref, RefIsOp.Null, expr);\n    } else {\n      return this.i32(0); // false literal\n    }\n  }\n\n  ref_as(\n    op: RefAsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefAs(this.ref, op, expr);\n  }\n\n  ref_as_nonnull(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    if (isNullableType(getExpressionType(expr))) {\n      return binaryen._BinaryenRefAs(this.ref, RefAsOp.NonNull, expr);\n    } else {\n      return expr;\n    }\n  }\n\n  ref_func(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr, type);\n  }\n\n  i31_new(\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenI31New(this.ref, value);\n  }\n\n  i31_get(\n    expr: ExpressionRef,\n    signed: bool\n  ): ExpressionRef {\n    return binaryen._BinaryenI31Get(this.ref, expr, signed);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: TypeRef,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n  }\n\n  // tags\n\n  addTag(\n    name: string,\n    params: TypeRef,\n    results: TypeRef\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);\n  }\n\n  getTag(\n    name: string\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetTag(this.ref, cStr);\n  }\n\n  removeTag(\n    name: string\n  ): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveTag(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: TypeRef,\n    results: TypeRef,\n    varTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocPtrArray(varTypes);\n    let ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  setLocalName(funcRef: FunctionRef, index: u32, name: string): void {\n    binaryen._BinaryenFunctionSetLocalName(funcRef, index, this.allocStringCached(name));\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  hasFunction(name: string): bool {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: TypeRef,\n    paramTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    let cArr = allocPtrArray(paramTypes);\n    let ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addTagExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    let cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  hasExport(externalName: string): bool {\n    let cStr = this.allocStringCached(externalName);\n    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: TypeRef,\n    mutable: bool = false\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addTagImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTagImport(\n      this.ref, cStr1, cStr2, cStr3, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    name: string = CommonNames.DefaultMemory,\n    shared: bool = false\n  ): void {\n    let cStr1 = this.allocStringCached(exportName);\n    let cStr2 = this.allocStringCached(name);\n    let k = segments.length;\n    let segs = new Array<usize>(k);\n    let psvs = new Uint8Array(k);\n    let offs = new Array<ExpressionRef>(k);\n    let sizs = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = unchecked(segments[i]);\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      unchecked(segs[i] = allocU8Array(buffer));\n      unchecked(psvs[i] = 0); // no passive segments currently\n      unchecked(offs[i] = target == Target.Wasm64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset))\n      );\n      unchecked(sizs[i] = buffer.length);\n    }\n    let cArr1 = allocPtrArray(segs);\n    let cArr2 = allocU8Array(psvs);\n    let cArr3 = allocPtrArray(offs);\n    let cArr4 = allocU32Array(sizs);\n    binaryen._BinaryenSetMemory(\n      this.ref, initial, maximum, cStr1, cArr1, cArr2, cArr3, cArr4, k, shared, false, cStr2\n    );\n    binaryen._free(cArr4);\n    binaryen._free(cArr3);\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(unchecked(segs[i]));\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  addFunctionTable(\n    name: string,\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let cStr = this.allocStringCached(name);\n    let numNames = funcs.length;\n    let names = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(names[i] = this.allocStringCached(funcs[i]));\n    }\n    let cArr = allocPtrArray(names);\n    let tableRef = binaryen._BinaryenGetTable(this.ref, cStr);\n    if (!tableRef) {\n      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum, TypeRef.Funcref);\n    } else {\n      binaryen._BinaryenTableSetInitial(tableRef, initial);\n      binaryen._BinaryenTableSetMax(tableRef, maximum);\n    }\n    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);\n    binaryen._free(cArr);\n  }\n\n  /* setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let numNames = funcs.length;\n    let names = new Array<CString>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    let cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  } */\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getZeroFilledMemory(): bool {\n    return binaryen._BinaryenGetZeroFilledMemory();\n  }\n\n  setZeroFilledMemory(on: bool): void {\n    binaryen._BinaryenSetZeroFilledMemory(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    let cStr = this.allocStringCached(key);\n    let ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    let cStr1 = this.allocStringCached(key);\n    let cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    let numNames = passes.length;\n    let cStrs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    let cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(\n    optimizeLevel: i32,\n    shrinkLevel: i32,\n    debugInfo: bool = false,\n    zeroFilledMemory: bool = false\n  ): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setZeroFilledMemory(zeroFilledMemory);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n      if (optimizeLevel >= 2) {\n        passes.push(\"once-reduction\");\n        passes.push(\"inlining\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"local-cse\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"gufa-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"simplify-locals-nostructure\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"vacuum\");\n        passes.push(\"licm\");\n        passes.push(\"merge-locals\");\n        passes.push(\"reorder-locals\");\n      }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n      }\n      passes.push(\"simplify-locals-notee-nostructure\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"local-cse\");\n      }\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 && (this.getFeatures() & FeatureFlags.GC) != 0) {\n        passes.push(\"heap2local\");\n        passes.push(\"merge-locals\");\n        passes.push(\"local-subtyping\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n          passes.push(\"local-cse\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"rse\");\n          passes.push(\"vacuum\");\n          passes.push(\"ssa-nomerge\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"optimize-instructions\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"optimize-instructions\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      if (shrinkLevel >= 2) {\n        passes.push(\"merge-similar-functions\");\n      }\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    assert(\n      binaryen._BinaryenSizeofLiteral() >=\n      binaryen._BinaryenSizeofAllocateAndWriteResult()\n    );\n\n    // now safely reuse lit buffer for BinaryenModuleAllocateAndWriteResult\n    let resPtr = this.lit;\n    let urlPtr = allocString(sourceMapUrl);\n\n    binaryen._BinaryenModuleAllocateAndWrite(resPtr, this.ref, urlPtr);\n\n    // read BinaryenModuleAllocateAndWriteResult struct\n    let binaryPtr = binaryen.__i32_load(resPtr + 0) as usize; // non-nullabe\n    let binaryLen = binaryen.__i32_load(resPtr + 4);\n    let srcMapPtr = binaryen.__i32_load(resPtr + 8) as usize; // nullable\n\n    let binary = new BinaryModule(\n      readBuffer(assert(binaryPtr), binaryLen),\n      readString(srcMapPtr)\n    );\n\n    if (urlPtr) binaryen._free(urlPtr);\n    if (srcMapPtr) binaryen._free(srcMapPtr);\n    binaryen._free(binaryPtr);\n\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    let textPtr = watFormat\n      ? binaryen._BinaryenModuleAllocateAndWriteStackIR(this.ref, true)\n      : binaryen._BinaryenModuleAllocateAndWriteText(this.ref);\n    let text = readString(textPtr);\n    if (textPtr) binaryen._free(textPtr);\n    return text || \"\";\n  }\n\n  private cachedStringsToPointers: Map<string,usize> = new Map();\n  private cachedPointersToStrings: Map<usize,string | null> = new Map();\n\n  allocStringCached(str: string | null): usize {\n    if (str == null) return 0;\n    let cached = this.cachedStringsToPointers;\n    if (cached.has(str)) return changetype<usize>(cached.get(str));\n    let ptr = allocString(str);\n    cached.set(str, ptr);\n    return ptr;\n  }\n\n  readStringCached(ptr: usize): string | null {\n    // Binaryen internalizes names, so using this method where it's safe can\n    // avoid quite a bit of unnecessary garbage.\n    if (ptr == 0) return null;\n    let cached = this.cachedPointersToStrings;\n    if (cached.has(ptr)) return changetype<string>(cached.get(ptr));\n    let str = readString(ptr);\n    cached.set(ptr, str);\n    return str;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStringsToPointers.clear();\n    this.cachedPointersToStrings.clear();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  /** Makes a copy of a trivial expression (doesn't contain subexpressions). Returns `0` if non-trivial. */\n  tryCopyTrivialExpression(expr: ExpressionRef): ExpressionRef {\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.LocalGet:\n      case ExpressionId.GlobalGet:\n      case ExpressionId.Const:\n      case ExpressionId.MemorySize:\n      case ExpressionId.Nop:\n      case ExpressionId.Unreachable:\n      case ExpressionId.DataDrop:\n      case ExpressionId.RefNull: return this.copyExpression(expr);\n    }\n    return 0;\n  }\n\n  /** Makes a copy of any expression including all subexpressions. */\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    // TODO: Copy debug location as well (needs Binaryen support)\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    let runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    let precomp = binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      if (!this.isConstExpression(precomp)) return 0;\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  isConstExpression(expr: ExpressionRef): bool {\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Const:\n      case ExpressionId.RefNull:\n      case ExpressionId.RefFunc:\n      case ExpressionId.I31New: return true;\n      case ExpressionId.Binary: {\n        if (this.getFeatures() & FeatureFlags.ExtendedConst) {\n          switch (getBinaryOp(expr)) {\n            case BinaryOp.AddI32:\n            case BinaryOp.SubI32:\n            case BinaryOp.MulI32:\n            case BinaryOp.AddI64:\n            case BinaryOp.SubI64:\n            case BinaryOp.MulI64:\n              return (\n                this.isConstExpression(getBinaryLeft(expr)) &&\n                this.isConstExpression(getBinaryRight(expr))\n              );\n          }\n        }\n        break;\n      }\n    }\n    return false;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    let cStr = allocString(name);\n    let ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: TypeRef[] | null): TypeRef {\n  if (!types) return TypeRef.None;\n  switch (types.length) {\n    case 0: return TypeRef.None;\n    case 1: return types[0];\n  }\n  let cArr = allocPtrArray(types);\n  let ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: TypeRef): TypeRef[] {\n  let arity = binaryen._BinaryenTypeArity(type);\n  let cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  let types = new Array<TypeRef>(arity);\n  for (let i: u32 = 0; i < arity; ++i) {\n    unchecked(types[i] = binaryen.__i32_load(cArr + (<usize>i << 2)));\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\nexport function isNullableType(type: TypeRef): bool {\n  return binaryen._BinaryenTypeIsNullable(type);\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): TypeRef {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function getConstValueV128(expr: ExpressionRef): Uint8Array {\n  let cArr = binaryen._malloc(16);\n  binaryen._BinaryenConstGetValueV128(expr, cArr);\n  let out = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    out[i] = binaryen.__i32_load8_u(cArr + i);\n  }\n  binaryen._free(cArr);\n  return out;\n}\n\nexport function isConstZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) == 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;\n  return false;\n}\n\nexport function isConstNonZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) != 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) != 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) != 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) != 0;\n  return false;\n}\n\nexport function isConstNegZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) {\n    let d = getConstValueF32(expr);\n    return d == 0 && f32_as_i32(d) < 0;\n  }\n  if (type == TypeRef.F64) {\n    let d = getConstValueF64(expr);\n    return d == 0 && i64_signbit(f64_as_i64(d));\n  }\n  return false;\n}\n\nexport function isConstNaN(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) return isNaN(getConstValueF32(expr));\n  if (type == TypeRef.F64) return isNaN(getConstValueF64(expr));\n  return false;\n}\n\nexport function isConstExpressionNaN(module: Module, expr: ExpressionRef): bool {\n  let id = getExpressionId(expr);\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32 || type == TypeRef.F64) {\n    if (id == ExpressionId.Const) {\n      return isNaN(\n        type == TypeRef.F32\n          ? getConstValueF32(expr)\n          : getConstValueF64(expr)\n      );\n    } else if (id == ExpressionId.GlobalGet) {\n      let precomp = module.runExpression(expr, ExpressionRunnerFlags.Default, 8);\n      if (precomp) {\n        return isNaN(\n          type == TypeRef.F32\n            ? getConstValueF32(precomp)\n            : getConstValueF64(precomp)\n        );\n      }\n    }\n  }\n  return false;\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): TypeRef[] {\n  let count = binaryen._BinaryenFunctionGetNumVars(func);\n  let types = new Array<TypeRef>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    unchecked(types[i] = binaryen._BinaryenFunctionGetVar(func, i));\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): TypeRef {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// tags\n\nexport function getTagName(tag: TagRef): string | null {\n  return readString(binaryen._BinaryenTagGetName(tag));\n}\n\nexport function getTagParams(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetParams(tag);\n}\n\nexport function getTagResults(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetResults(tag);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    let cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    let cases = this.cases;\n    let index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    this.values.push(value);\n    this.indexes.push(index);\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    let cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    let module = this.module;\n    let cases = this.cases;\n    let numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    let values = this.values;\n    let numValues = values.length;\n    let indexes = this.indexes;\n    let entry = new Array<ExpressionRef>(1 + numValues + 1);\n    let labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      unchecked(labels[i] = `case${i}${labelPostfix}`);\n    }\n    entry[0] = module.local_set(localIndex, this.condition, false); // u32\n    for (let i = 0; i < numValues; ++i) {\n      let index = unchecked(indexes[i]);\n      unchecked(entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, TypeRef.I32),\n          module.i32(values[i])\n        )\n      ));\n    }\n    let defaultIndex = this.defaultIndex;\n    let defaultLabel = `default${labelPostfix}`;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    let current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(unchecked(labels[i]), block);\n    }\n    let lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport const enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ReadsTable = 256 /* _BinaryenSideEffectReadsTable */,\n  WritesTable = 512 /* _BinaryenSideEffectWritesTable */,\n  ImplicitTrap = 1024 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 2048 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 4096 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 8192 /* _BinaryenSideEffectDanglingPop */,\n  TrapsNeverHappen = 16384 /* _BinaryenSideEffectTrapsNeverHappen */,\n  Any = 32767 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, module: ModuleRef): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, module);\n}\n\nexport function mustPreserveSideEffects(expr: ExpressionRef, module: ModuleRef): bool {\n  return (getSideEffects(expr, module) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  let len = u8s.length;\n  let ptr = binaryen._malloc(len);\n  for (let i = 0; i < len; ++i) {\n    binaryen.__i32_store8(ptr + i, unchecked(u8s[i]));\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  let len = i32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(i32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  let len = u32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(u32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nexport function allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.Wasm64);\n  let len = ptrs.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0, k = len; i < k; ++i) {\n    let val = unchecked(ptrs[i]);\n    binaryen.__i32_store(idx, <i32>val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  let len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let c1 = str.charCodeAt(i) >>> 0;\n    if (c1 <= 0x7F) {\n      len += 1;\n    } else if (c1 <= 0x7FF) {\n      len += 2;\n    } else if (\n      isHighSurrogate(c1) && i + 1 < k &&\n      isLowSurrogate(str.charCodeAt(i + 1))\n    ) {\n      i++;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str == null) return 0;\n  let len = stringLengthUTF8(str);\n  let ptr = binaryen._malloc(len + 1) >>> 0;\n  let idx = ptr;\n  if (len == str.length) {\n    // fast path when all chars are ascii\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let u = str.charCodeAt(i) >>> 0;\n      binaryen.__i32_store8(idx++, u as u8);\n    }\n  } else {\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let c1 = str.charCodeAt(i) >>> 0, c2: i32;\n      if (c1 <= 0x7F) {\n        binaryen.__i32_store8(idx++, c1 as u8);\n      } else if (c1 <= 0x7FF) {\n        binaryen.__i32_store8(idx++, (0xC0 |  (c1 >>> 6)       ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else if (\n        isHighSurrogate(c1) && i + 1 < k &&\n        isLowSurrogate(c2 = str.charCodeAt(i + 1))\n      ) {\n        c1 = combineSurrogates(c1, c2);\n        ++i;\n        binaryen.__i32_store8(idx++, (0xF0 |  (c1 >>> 18)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>> 12) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else {\n        binaryen.__i32_store8(idx++, (0xE0 |  (c1 >>> 12)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      }\n    }\n  }\n  binaryen.__i32_store8(idx, 0); // \\0\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  let ret = new Uint8Array(len);\n  for (let i = 0; i < len; ++i) {\n    unchecked(ret[i] = binaryen.__i32_load8_u(ptr + <usize>i));\n  }\n  return ret;\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  let arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  let cp: u32;\n  let u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(SURROGATE_HIGH | (ch >>> 10));\n      arr.push(SURROGATE_LOW | (ch & 0x3FF));\n    }\n  }\n  // TODO: implement and use String.fromCodePoints\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */\nexport function needsExplicitUnreachable(expr: ExpressionRef): bool {\n  // not applicable if pushing a value to the stack\n  if (binaryen._BinaryenExpressionGetType(expr) != TypeRef.Unreachable) {\n    return false;\n  }\n\n  switch (binaryen._BinaryenExpressionGetId(expr)) {\n    case ExpressionId.Unreachable:\n    case ExpressionId.Return: return false;\n    case ExpressionId.Break: {\n      return binaryen._BinaryenBreakGetCondition(expr) != 0;\n    }\n    case ExpressionId.Block: {\n      if (!binaryen._BinaryenBlockGetName(expr)) { // can't break out of it\n        let numChildren = binaryen._BinaryenBlockGetNumChildren(expr); // last child needs unreachable\n        return (\n          numChildren > 0 &&\n          needsExplicitUnreachable(binaryen._BinaryenBlockGetChildAt(expr, numChildren - 1))\n        );\n      }\n    }\n  }\n  return true;\n}\n\n// TypeBuilder\n\nconst DEBUG_TYPEBUILDER = false;\n\n/** Ensures that the given potentially complex type has a corresponding GC type. */\nexport function ensureType(type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  // From here on we are dealing with heap types independent of nullability.\n  // Nullability is applied again when returning the final type.\n  let originalType = type;\n  type = type.nonNullableType;\n\n  // Obtain cached type if already built. Guaranteed to be not a temp type.\n  if (typeRef = type.ref) {\n    return binaryen._BinaryenTypeFromHeapType(\n      binaryen._BinaryenTypeGetHeapType(typeRef),\n      originalType.is(TypeFlags.Nullable) // apply nullability\n    );\n  }\n\n  // Otherwise use a type builder\n  if (ASC_TARGET) {\n    // @ts-ignore: Wasm only\n    assert(sizeof<usize>() == 4); // ABI code below assumes 32-bit pointers\n  }\n  assert(binaryen._BinaryenGetTypeSystem() == TypeSystem.Nominal);\n  let builder = binaryen._TypeBuilderCreate(0);\n  let seen = new Map<Type,HeapTypeRef>();\n  prepareType(builder, seen, type); // drop temp return\n  let size = binaryen._TypeBuilderGetSize(builder);\n  let out = binaryen._malloc(max(4 * size, 8)); // either each heap type or index + reason\n  if (!binaryen._TypeBuilderBuildAndDispose(builder, out, out, out + 4)) {\n    let errorIndex = binaryen.__i32_load(out);\n    let errorReason = binaryen.__i32_load(out + 4);\n    binaryen._free(out);\n    throw new Error(`type builder error at index ${errorIndex}: ${TypeBuilderErrorReason.toString(errorReason)}`);\n  }\n\n  // Assign all the built types to their respective non-nullable type\n  for (let _keys = Map_keys(seen), i = 0, k = _keys.length; i < k; ++i) {\n    let seenType = _keys[i];\n    assert(!seenType.is(TypeFlags.Nullable)); // non-nullable only\n    let heapType = <HeapTypeRef>binaryen.__i32_load(out + 4 * i);\n    let fullType = binaryen._BinaryenTypeFromHeapType(heapType, false);\n    assert(!seenType.ref);\n    seenType.ref = fullType;\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` set ${seenType.toString()}`);\n    }\n  }\n  binaryen._free(out);\n\n  // Initial type should now exist in its non-nullable variant\n  if (DEBUG_TYPEBUILDER) {\n    console.log(` finalize ${type.toString()}`);\n  }\n  typeRef = assert(type.ref);\n  return binaryen._BinaryenTypeFromHeapType(\n    binaryen._BinaryenTypeGetHeapType(typeRef),\n    originalType.is(TypeFlags.Nullable) // apply nullability\n  );\n}\n\n/** Obtains the basic type of the given type, if any. */\nfunction tryEnsureBasicType(type: Type): TypeRef {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8:\n    case TypeKind.I16:\n    case TypeKind.U16:\n    case TypeKind.I32:\n    case TypeKind.U32: return TypeRef.I32;\n    case TypeKind.I64:\n    case TypeKind.U64: return TypeRef.I64;\n    case TypeKind.Isize:\n    case TypeKind.Usize: {\n      if (type.isInternalReference) break; // non-basic\n      return type.size == 64 ? TypeRef.I64 : TypeRef.I32;\n    }\n    case TypeKind.F32: return TypeRef.F32;\n    case TypeKind.F64: return TypeRef.F64;\n    case TypeKind.V128: return TypeRef.V128;\n    case TypeKind.Funcref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Externref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Anyref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Eqref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.I31ref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Dataref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Data, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Arrayref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Stringref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewWTF8: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF8, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewWTF16: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF16, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewIter: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewIter, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Void: assert(false); // invalid here\n  }\n  return 0; // non-basic\n}\n\n/** Determines the packed GC type of the given type, if applicable. */\nfunction determinePackedType(type: Type): PackedType {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8: return PackedType.I8;\n    case TypeKind.I16:\n    case TypeKind.U16: return PackedType.I16;\n  }\n  return PackedType.NotPacked;\n}\n\n/** Recursively prepares the given GC type, potentially returning a temporary type. */\nfunction prepareType(builder: binaryen.TypeBuilderRef, seen: Map<Type,HeapTypeRef>, type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  assert(!type.is(TypeFlags.Nullable)); // operating on non-nullable types only\n\n  // Reuse existing type\n  if (typeRef = type.ref) return typeRef;\n\n  // Reuse seen temporary type if it exists\n  if (seen.has(type)) {\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` prepare ${type.toString()} (seen)`);\n    }\n    return changetype<HeapTypeRef>(seen.get(type));\n  }\n\n  if (DEBUG_TYPEBUILDER) {\n    console.log(`prepare ${type.toString()}`);\n  }\n\n  // Otherwise construct a new class type. Note that arrays are not supported, as these would\n  // have to involve a Wasm-level `array`, either wrapped in `Array` or `Uint8Array` etc., or\n  // directly representing an `ArrayBuffer` or `StaticArray`. TBD.\n  let classReference = type.getClass();\n  if (classReference) {\n    // Make sure the base type has been built prior, at a lower index\n    let base = classReference.base;\n    let baseRef: HeapTypeRef = 0;\n    if (base) baseRef = prepareType(builder, seen, base.type); // might be temporary, is non-nullable\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` block [${index}]: ${type.toString()}`);\n    }\n    let heapTypeRef = binaryen._TypeBuilderGetTempHeapType(builder, index);\n    typeRef = binaryen._TypeBuilderGetTempRefType(builder, heapTypeRef, false);\n    seen.set(type, typeRef);\n\n    // Populate the struct type (TODO: names)\n    let fieldTypes = new Array<TypeRef>();\n    let packedTypes = new Array<PackedType>();\n    let fieldMutables = new Array<u32>();\n    let members = classReference.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind != ElementKind.Field) continue;\n        let field = <Field>member;\n        let fieldType = field.type;\n        if (DEBUG_TYPEBUILDER) {\n          console.log(`  field ${fieldType.toString()}`);\n        }\n        if (fieldType.is(TypeFlags.Nullable)) {\n          fieldTypes.push(\n            binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, fieldType.nonNullableType)\n              ),\n              true\n            )\n          );\n        } else {\n          fieldTypes.push(prepareType(builder, seen, fieldType));\n        }\n        packedTypes.push(determinePackedType(fieldType));\n        fieldMutables.push(1);\n      }\n    }\n    let cArrFT = allocPtrArray(fieldTypes);\n    let cArrPT = allocU32Array(packedTypes);\n    let cArrFM = allocU32Array(fieldMutables);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetStructType(builder, index, cArrFT, cArrPT, cArrFM, fieldTypes.length);\n    if (base) {\n      if (DEBUG_TYPEBUILDER) {\n        console.log(` set super [${index}]: ${type.toString()} <: ${base.type.toString()} ${baseRef == base.type.ref ? \" (known)\" : \"\"}`);\n      }\n      binaryen._TypeBuilderSetSubType(builder, index, binaryen._BinaryenTypeGetHeapType(baseRef));\n    }\n    binaryen._free(cArrFM);\n    binaryen._free(cArrPT);\n    binaryen._free(cArrFT);\n    return typeRef;\n  }\n\n  // Respectively a new signature type\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    let tempTypeRef = binaryen._TypeBuilderGetTempRefType(\n      builder,\n      binaryen._TypeBuilderGetTempHeapType(builder, index),\n      false\n    );\n    seen.set(type, tempTypeRef);\n\n    let paramTypes = new Array<TypeRef>();\n    let resultTypes = new Array<TypeRef>();\n    let parameterTypes = signatureReference.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let paramType = parameterTypes[i];\n      if (paramType.is(TypeFlags.Nullable)) {\n        paramTypes.push(\n          binaryen._TypeBuilderGetTempRefType(\n            builder,\n            binaryen._BinaryenTypeGetHeapType(\n              prepareType(builder, seen, paramType.nonNullableType)\n            ),\n            true\n          )\n        );\n      } else {\n        paramTypes.push(prepareType(builder, seen, paramType));\n      }\n    }\n    let returnType = signatureReference.returnType;\n    resultTypes.push(\n      returnType == Type.void\n        ? TypeRef.None\n        : returnType.is(TypeFlags.Nullable)\n          ? binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, returnType.nonNullableType)\n              ),\n              true\n            )\n          : prepareType(builder, seen, returnType)\n    );\n    let tempParamType: TypeRef;\n    if (paramTypes.length > 1) {\n      let cArrPT = allocPtrArray(paramTypes);\n      tempParamType = binaryen._TypeBuilderGetTempTupleType(builder, cArrPT, paramTypes.length);\n      binaryen._free(cArrPT);\n    } else {\n      tempParamType = paramTypes.length ? paramTypes[0] : TypeRef.None;\n    }\n    let tempResultType: TypeRef;\n    if (resultTypes.length > 1) {\n      let cArrRT = allocPtrArray(resultTypes);\n      tempResultType = binaryen._TypeBuilderGetTempTupleType(builder, cArrRT, resultTypes.length);\n      binaryen._free(cArrRT);\n    } else {\n      tempResultType = resultTypes[0];\n    }\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetSignatureType(builder, index, tempParamType, tempResultType);\n    return tempTypeRef;\n  }\n\n  throw new Error(`unexpected complex type: ${type.toString()}`);\n}\n", "/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Program,\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Field,\n  Class,\n  TypedElement,\n  mangleInternalName\n} from \"./program\";\n\nimport {\n  TypeRef,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getUnaryValue,\n  getCallOperandAt,\n  getCallOperandCount,\n  isConstZero,\n  isConstNonZero\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  cloneMap\n} from \"./util\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  Returns = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  ReturnsWrapped = 1 << 1,\n  /** This flow always returns a non-null value. */\n  ReturnsNonNull = 1 << 2,\n  /** This flow always throws. */\n  Throws = 1 << 3,\n  /** This flow always breaks. */\n  Breaks = 1 << 4,\n  /** This flow always continues. */\n  Continues = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  AccessesThis = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CallsSuper = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  Terminates = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  ConditionallyReturns = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  ConditionallyThrows = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  ConditionallyBreaks = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  ConditionallyContinues = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  ConditionallyAccessesThis = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MayReturnNonThis = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UncheckedContext = 1 << 15,\n  /** This is a flow compiling a constructor parameter. */\n  CtorParamContext = 1 << 16,\n\n  // masks\n\n  /** Any categorical flag. */\n  AnyCategorical = FlowFlags.Returns\n                 | FlowFlags.ReturnsWrapped\n                 | FlowFlags.ReturnsNonNull\n                 | FlowFlags.Throws\n                 | FlowFlags.Breaks\n                 | FlowFlags.Continues\n                 | FlowFlags.AccessesThis\n                 | FlowFlags.CallsSuper\n                 | FlowFlags.Terminates,\n\n  /** Any conditional flag. */\n  AnyConditional = FlowFlags.ConditionallyReturns\n                 | FlowFlags.ConditionallyThrows\n                 | FlowFlags.ConditionallyBreaks\n                 | FlowFlags.ConditionallyContinues\n                 | FlowFlags.ConditionallyAccessesThis\n}\n\n/** Flags indicating the current state of a local. */\nexport const enum LocalFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  /** Local is constant. */\n  Constant = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  Wrapped = 1 << 1,\n  /** Local is non-null. */\n  NonNull = 1 << 2,\n  /** Local is initialized. */\n  Initialized = 1 << 3\n}\n\n/** Flags indicating the current state of a field. */\nexport const enum FieldFlags {\n  None = 0,\n  Initialized = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  Unknown,\n  /** Condition is always true. */\n  True,\n  /** Condition is always false. */\n  False\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the default top-level flow of the specified function. */\n  static createDefault(targetFunction: Function): Flow {\n    let flow = new Flow(targetFunction);\n    if (targetFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow, compiling `inlineFunction` into `targetFunction`. */\n  static createInline(targetFunction: Function, inlineFunction: Function): Flow {\n    // Note that `targetFunction` and `inlineFunction` can be the same function\n    // when it is inlined into itself.\n    let flow = new Flow(targetFunction, inlineFunction);\n    flow.inlineReturnLabel = `${inlineFunction.internalName}|inlined.${(inlineFunction.nextInlineId++)}`;\n    if (inlineFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Target function this flow generates code into. */\n    public targetFunction: Function,\n    /** Inline function this flow generates code from, if any. */\n    public inlineFunction: Function | null = null\n  ) {\n    // Setup is performed above so inline ids and field flags are not reset\n    // when forking flows, which also uses the constructor.\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Outer flow. Only relevant for first-class functions. */\n  outer: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.None;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Field,FieldFlags> | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction != null;\n  }\n\n  /** Gets the source function being compiled. Differs from target when inlining. */\n  get sourceFunction(): Function {\n    // Obtaining the source function is useful when resolving elements relative\n    // to their source location. Note that the source function does not necessarily\n    // materialize in the binary, as it might be inlined. Code, locals, etc. must\n    // always be added to / maintained in the materializing target function instead.\n    let inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.targetFunction;\n  }\n\n  /** Gets the program this flow belongs to. */\n  get program(): Program {\n    return this.targetFunction.program;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.sourceFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.sourceFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  deriveConditionalFlags(): FlowFlags {\n    let condiFlags = this.flags & FlowFlags.AnyConditional;\n    if (this.is(FlowFlags.Returns)) {\n      condiFlags |= FlowFlags.ConditionallyReturns;\n    }\n    if (this.is(FlowFlags.Throws)) {\n      condiFlags |= FlowFlags.ConditionallyThrows;\n    }\n    if (this.is(FlowFlags.Breaks)) {\n      condiFlags |= FlowFlags.ConditionallyBreaks;\n    }\n    if (this.is(FlowFlags.Continues)) {\n      condiFlags |= FlowFlags.ConditionallyContinues;\n    }\n    if (this.is(FlowFlags.AccessesThis)) {\n      condiFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n    return condiFlags;\n  }\n\n  /** Forks this flow to a child flow. */\n  fork(resetBreakContext: bool = false): Flow {\n    let branch = new Flow(this.targetFunction, this.inlineFunction);\n    branch.parent = this;\n    branch.outer = this.outer;\n    if (resetBreakContext) {\n      branch.flags = this.flags & ~(\n        FlowFlags.Breaks |\n        FlowFlags.ConditionallyBreaks |\n        FlowFlags.Continues |\n        FlowFlags.ConditionallyContinues\n      );\n    } else {\n      branch.flags = this.flags;\n      branch.continueLabel = this.continueLabel;\n      branch.breakLabel = this.breakLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.sourceFunction.is(CommonFlags.Constructor)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = cloneMap(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type): Local {\n    let local = this.targetFunction.addLocal(type);\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    let scopedLocals = this.scopedLocals;\n    if (scopedLocals && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type): Local {\n    let scopedLocal = this.getTempLocal(type);\n    scopedLocal.name = name;\n    scopedLocal.internalName = mangleInternalName(name, scopedLocal.parent, false);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type, declarationNode: Node): Local {\n    let scopedDummy = new Local(name, -1, type, this.targetFunction);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else if (scopedLocals.has(name)) {\n      this.program.error(\n        DiagnosticCode.Cannot_redeclare_block_scoped_variable_0,\n        declarationNode.range, name\n      );\n    }\n    scopedDummy.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) {\n      this.scopedLocals = scopedLocals = new Map();\n    } else if (scopedLocals.has(name)) {\n      let existingLocal = assert(scopedLocals.get(name));\n      if (reportNode) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range,\n            existingLocal.declaration.name.range,\n            name\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range, name\n          );\n        }\n      }\n      return existingLocal;\n    }\n    assert(index < this.targetFunction.localsByIndex.length);\n    let scopedAlias = new Local(name, index, type, this.targetFunction);\n    scopedAlias.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    let scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    let current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    let element = this.lookupLocal(name);\n    if (element) return element;\n    return this.sourceFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    let sourceFunction = this.sourceFunction;\n    assert(sourceFunction.is(CommonFlags.Constructor));\n    let parent = sourceFunction.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    this.thisFieldFlags = new Map();\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind == ElementKind.Field) {\n          let field = <Field>member;\n          if (\n            // guaranteed by super\n            field.parent != classInstance ||\n            // has field initializer\n            field.initializerNode ||\n            // is initialized as a ctor parameter\n            field.prototype.parameterIndex != -1 ||\n            // is safe to initialize with zero\n            field.type.isAny(TypeFlags.Value | TypeFlags.Nullable)\n          ) {\n            this.setThisFieldFlag(field, FieldFlags.Initialized);\n          }\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Field, flag: FieldFlags): bool {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Field, flag: FieldFlags): void {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.sourceFunction.is(CommonFlags.Constructor));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.sourceFunction.is(CommonFlags.Constructor));\n    }\n  }\n\n  /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */\n  pushBreakLabel(): string {\n    let targetFunction = this.targetFunction;\n    let id = targetFunction.nextBreakId++;\n    let stack = targetFunction.breakStack;\n    if (!stack) targetFunction.breakStack = [ id ];\n    else stack.push(id);\n    let label = id.toString();\n    targetFunction.breakLabel = label;\n    return label;\n  }\n\n  /** Pops the most recent break label from the stack. */\n  popBreakLabel(): void {\n    let targetFunction = this.targetFunction;\n    let stack = assert(targetFunction.breakStack);\n    let length = assert(stack.length);\n    stack.pop();\n    if (length > 1) {\n      targetFunction.breakLabel = stack[length - 2].toString();\n    } else {\n      targetFunction.breakLabel = null;\n      targetFunction.breakStack = null;\n    }\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.targetFunction == this.targetFunction);\n    assert(other.parent == this); // currently the case, but might change\n    let otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.Breaks | FlowFlags.ConditionallyBreaks)) {\n        otherFlags &= ~FlowFlags.Terminates;\n      }\n      otherFlags &= ~(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n  /** Inherits flags of a conditional branch joining again with this one, i.e. then without else. */\n  inheritBranch(other: Flow, conditionKind: ConditionKind = ConditionKind.Unknown): void {\n    assert(other.targetFunction == this.targetFunction);\n    switch (conditionKind) {\n      case ConditionKind.True: this.inherit(other); // always executes\n      case ConditionKind.False: return;             // never executes\n    }\n\n    // Note that flags in `this` flow have already happened. For instance,\n    // a return cannot be undone no matter what'd happen in subsequent branches,\n    // but an allocation, which doesn't terminate, can become conditional. Not\n    // all flags have a corresponding conditional flag that's tracked.\n\n    let thisFlags = this.flags;\n    let otherFlags = other.flags;\n    let newFlags = FlowFlags.None;\n\n    if (thisFlags & FlowFlags.Returns) { // nothing can change that\n      newFlags |= FlowFlags.Returns;\n    } else if (otherFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsWrapped;\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsNonNull;\n\n    if (thisFlags & FlowFlags.Throws) { // nothing can change that\n      newFlags |= FlowFlags.Throws;\n    } else if (otherFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (thisFlags & FlowFlags.Breaks) { // nothing can change that\n      newFlags |= FlowFlags.Breaks;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyBreaks;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (thisFlags & FlowFlags.Continues) { // nothing can change that\n      newFlags |= FlowFlags.Continues;\n    } else if (other.continueLabel == this.continueLabel) {\n      if (otherFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyContinues;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyContinues;\n    }\n\n    if (thisFlags & FlowFlags.AccessesThis) { // can become conditional\n      if (otherFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (otherFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MayReturnNonThis;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CallsSuper;\n\n    if (thisFlags & FlowFlags.Terminates) { // nothing can change that\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (thisFlags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n\n    // local flags\n    let thisLocalFlags = this.localFlags;\n    let numThisLocalFlags = thisLocalFlags.length;\n    let otherLocalFlags = other.localFlags;\n    let numOtherLocalFlags = otherLocalFlags.length;\n    let maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      thisLocalFlags[i] = thisFlags & otherFlags & (\n        LocalFlags.Constant  |\n        LocalFlags.Wrapped   |\n        LocalFlags.NonNull   |\n        LocalFlags.Initialized\n      );\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits mutual flags of two alternate branches becoming this one, i.e. then with else. */\n  inheritMutual(left: Flow, right: Flow): void {\n    assert(left.targetFunction == right.targetFunction);\n    assert(left.targetFunction == this.targetFunction);\n    // This differs from the previous method in that no flags are guaranteed\n    // to happen unless it is the case in both flows.\n\n    let leftFlags = left.flags;\n    let rightFlags = right.flags;\n    let newFlags = FlowFlags.None;\n\n    if (leftFlags & FlowFlags.Returns) {\n      if (rightFlags & FlowFlags.Returns) {\n        newFlags |= FlowFlags.Returns;\n      } else {\n        newFlags |= FlowFlags.ConditionallyReturns;\n      }\n    } else if (rightFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsWrapped) && (rightFlags & FlowFlags.ReturnsWrapped)) {\n      newFlags |= FlowFlags.ReturnsWrapped;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsNonNull) && (rightFlags & FlowFlags.ReturnsNonNull)) {\n      newFlags |= FlowFlags.ReturnsNonNull;\n    }\n\n    if (leftFlags & FlowFlags.Throws) {\n      if (rightFlags & FlowFlags.Throws) {\n        newFlags |= FlowFlags.Throws;\n      } else {\n        newFlags |= FlowFlags.ConditionallyThrows;\n      }\n    } else if (rightFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (leftFlags & FlowFlags.Breaks) {\n      if (rightFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.Breaks;\n      } else {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      }\n    } else if (rightFlags & FlowFlags.Breaks) {\n      newFlags |= FlowFlags.ConditionallyBreaks;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (leftFlags & FlowFlags.Continues) {\n      if (rightFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.Continues;\n      } else {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      }\n    } else if (rightFlags & FlowFlags.Continues) {\n      newFlags |= FlowFlags.ConditionallyContinues;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyContinues;\n    }\n\n    if (leftFlags & FlowFlags.AccessesThis) {\n      if (rightFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (rightFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyAccessesThis;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MayReturnNonThis;\n\n    if ((leftFlags & FlowFlags.CallsSuper) && (rightFlags & FlowFlags.CallsSuper)) {\n      newFlags |= FlowFlags.CallsSuper;\n    }\n\n    if ((leftFlags & FlowFlags.Terminates) && (rightFlags & FlowFlags.Terminates)) {\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (this.flags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n\n    // local flags\n    let thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.Terminates) {\n      if (!(rightFlags & FlowFlags.Terminates)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.Terminates) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        thisLocalFlags[i] = leftFlags & rightFlags & (\n          LocalFlags.Constant  |\n          LocalFlags.Wrapped   |\n          LocalFlags.NonNull   |\n          LocalFlags.Initialized\n        );\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    let leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Field,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.Initialized) != 0 && rightFieldFlags.has(key) &&\n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.Initialized)\n        ) {\n          newFieldFlags.set(key, FieldFlags.Initialized);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if recompilation is needed due to incompatible local flags between loops, and resets if necessary. */\n  resetIfNeedsRecompile(\n    /** Resulting flow of the current compilation attempt. */\n    other: Flow,\n    /** Number of locals before the compilation attempt. */\n    numLocalsBefore: i32\n  ): bool {\n    let numThisLocalFlags = this.localFlags.length;\n    let numOtherLocalFlags = other.localFlags.length;\n    let targetFunction = this.targetFunction;\n    assert(targetFunction == other.targetFunction);\n    let localsByIndex = targetFunction.localsByIndex;\n    assert(localsByIndex == other.targetFunction.localsByIndex);\n    let needsRecompile = false;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (this.isLocalFlag(i, LocalFlags.Wrapped) && !other.isLocalFlag(i, LocalFlags.Wrapped)) {\n          this.unsetLocalFlag(i, LocalFlags.Wrapped); // assume not wrapped\n          needsRecompile = true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (this.isLocalFlag(i, LocalFlags.NonNull) && !other.isLocalFlag(i, LocalFlags.NonNull)) {\n          this.unsetLocalFlag(i, LocalFlags.NonNull); // assume possibly null\n          needsRecompile = true;\n        }\n      }\n    }\n    if (needsRecompile) {\n      // Reset function locals to state before the compilation attempt\n      assert(localsByIndex.length >= numLocalsBefore);\n      localsByIndex.length = numLocalsBefore;\n      if (this.localFlags.length > numLocalsBefore) {\n        this.localFlags.length = numLocalsBefore;\n      }\n    }\n    return needsRecompile;\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NonNull), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstZero(ifFalse)) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n          this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff); // !value -> value must have been false\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstNonZero(ifTrue)) {\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n          this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff); // !(!value) -> value must have been true\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    let operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.Wrapped, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.Global || global.kind == ElementKind.EnumValue);\n        return canConversionOverflow((<TypedElement>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n\n          // sign extensions overflow if result can have high garbage bits in the target type\n          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);\n          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);\n          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);\n          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);\n          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }\n          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }\n          case <u32>TypeRef.V128: return false;\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.Bool: return (value & ~1) != 0;\n          case TypeKind.I8:   return value < <i32>i8.MIN_VALUE  || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16:  return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8:   return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16:  return value < 0 || value > <i32>u16.MAX_VALUE;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.Function);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.ReturnsWrapped)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    let levels = 0;\n    let parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    let sb = new Array<string>();\n    if (this.is(FlowFlags.Returns)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.ReturnsWrapped)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.ReturnsNonNull)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.Throws)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.Breaks)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.Continues)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.AccessesThis)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CallsSuper)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.Terminates)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.ConditionallyReturns)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.ConditionallyThrows)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.ConditionallyBreaks)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.ConditionallyContinues)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.ConditionallyAccessesThis)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MayReturnNonThis)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return `Flow(${this.sourceFunction})[${levels}] ${sb.join(\" \")}`;\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n", "/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Field,\n  FieldPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression,\n  ArrowKind,\n  ExpressionStatement\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  cloneMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport const enum ReportMode {\n  /** Report errors. */\n  Report,\n  /** Swallow errors. */\n  Swallow\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n  /** Whether a new overload has been discovered. */\n  discoveredOverload: bool = false;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.NamedType: {\n        return this.resolveNamedType(\n          <NamedTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      case NodeKind.FunctionType: {\n        return this.resolveFunctionType(\n          <FunctionTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let nameNode = node.name;\n    let typeArgumentNodes = node.typeArguments;\n    let isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    let element = this.resolveTypeName(nameNode, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    let shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.Enum) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, `${element.name}/i32`\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.ClassPrototype ||\n        element.kind == ElementKind.InterfacePrototype\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          ctxElement,\n          cloneMap(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TypeDefinition) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.Resolved)) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native)   return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof)  return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof)  return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.nonnull)  return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          ctxElement,\n          ctxTypes = cloneMap(ctxTypes), // update\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isInternalReference) return type.asNullable();\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let explicitThisType = node.explicitThisType;\n    let thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    let parameterNodes = node.parameters;\n    let numParameters = parameterNodes.length;\n    let parameterTypes = new Array<Type>(numParameters);\n    let requiredParameters = 0;\n    let hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.Default: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.Rest: {\n          assert(i == numParameters);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    let returnTypeNode = node.returnType;\n    let returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    let signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n    signature.hasRest = hasRest;\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:  return Type.i32;\n      case TypeKind.Isize: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64:  return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.Bool: return Type.u32;\n      case TypeKind.Usize: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64:  return Type.u64;\n      case TypeKind.F32:  return Type.f32;\n      case TypeKind.F64:  return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.Void: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNode.range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n    if (overload) {\n      let parameterTypes = overload.signature.parameterTypes;\n      if (overload.is(CommonFlags.Static)) {\n        assert(parameterTypes.length == 2);\n        return parameterTypes[1];\n      } else {\n        assert(parameterTypes.length == 1);\n        return parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinNotNullableType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    if (!typeArgument.isNullableReference) return typeArgument;\n    return typeArgument.nonNullableType;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element = ctxElement.lookup(node.identifier.text, true);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    let prev = node;\n    let next = node.next;\n    while (next) {\n      if (!(element = element.getMember(next.identifier.text))) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type[] | null {\n    var\n      minParameterCount = 0,\n      maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    let argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    let typeArguments = new Array<Type>(maxParameterCount);\n    let oldCtxTypes = cloneMap(ctxTypes);\n    ctxTypes.clear();\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            ctxElement,\n            oldCtxTypes, // update\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            ctxElement,\n            cloneMap(ctxTypes), // don't update\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.Generic)) {\n      let contextualTypeArguments = cloneMap(ctxFlow.contextualTypeArguments);\n\n      // fill up contextual types with auto for each generic component\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let typeParameterNames = new Set<string>();\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        contextualTypeArguments.set(name, Type.auto);\n        typeParameterNames.add(name);\n      }\n\n      let parameterNodes = prototype.functionTypeNode.parameters;\n      let numParameters = parameterNodes.length;\n      let argumentNodes = node.args;\n      let numArguments = argumentNodes.length;\n\n      // infer types with generic components while updating contextual types\n      for (let i = 0; i < numParameters; ++i) {\n        let argumentExpression = i < numArguments\n          ? argumentNodes[i]\n          : parameterNodes[i].initializer;\n        if (!argumentExpression) {\n          // optional but not have initializer should be handled in the other place\n          if (parameterNodes[i].parameterKind == ParameterKind.Optional) {\n            continue;\n          }\n          // missing initializer -> too few arguments\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n          return null;\n        }\n        let typeNode = parameterNodes[i].type;\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.Swallow);\n          if (type) {\n            this.propagateInferredGenericTypes(\n              typeNode,\n              type,\n              prototype,\n              contextualTypeArguments,\n              typeParameterNames\n            );\n          }\n        }\n      }\n\n      // apply concrete types to the generic function signature\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let typeParameterNode = typeParameterNodes[i];\n        let name = typeParameterNode.name.text;\n        if (contextualTypeArguments.has(name)) {\n          let inferredType = assert(contextualTypeArguments.get(name));\n          if (inferredType != Type.auto) {\n            resolvedTypeArguments[i] = inferredType;\n            continue;\n          }\n          let defaultType = typeParameterNode.defaultType;\n          if (defaultType) {\n            // Default parameters are resolved in context of the called function, not the calling function\n            let parent = prototype.parent;\n            let defaultTypeContextualTypeArguments: Map<string, Type> | null = null;\n            if (parent.kind == ElementKind.Class) {\n              defaultTypeContextualTypeArguments = (<Class>parent).contextualTypeArguments;\n            } else if (parent.kind == ElementKind.Function) {\n              defaultTypeContextualTypeArguments = (<Function>parent).contextualTypeArguments;\n            }\n            let resolvedDefaultType = this.resolveType(\n              defaultType,\n              prototype,\n              defaultTypeContextualTypeArguments,\n              reportMode\n            );\n            if (!resolvedDefaultType) return null;\n            resolvedTypeArguments[i] = resolvedDefaultType;\n            continue;\n          }\n        }\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n        // invalid because the type is effectively unknown inside the function body\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            node.expression.range.atEnd\n          );\n        }\n        return null;\n      }\n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, new Map(), reportMode);\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxElement);\n          if (!classPrototype || classPrototype.kind != ElementKind.ClassPrototype) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(\n                  typeArgumentNodes[i],\n                  typeArguments[i],\n                  ctxElement,\n                  ctxTypes,\n                  typeParameterNames\n                );\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (\n            currentType == Type.auto ||\n            (typeParameterNames.has(name) && currentType.isAssignableTo(type))\n          ) ctxTypes.set(name, type);\n        }\n      }\n    } else if (node.kind == NodeKind.FunctionType) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      let signatureReference = type.signatureReference;\n      if (signatureReference) {\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = min(parameterTypes.length, parameterNodes.length) ; i < k; ++i) {\n          this.propagateInferredGenericTypes(\n            parameterNodes[i].type,\n            parameterTypes[i],\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let returnType = signatureReference.returnType;\n        if (returnType != Type.void) {\n          this.propagateInferredGenericTypes(\n            functionTypeNode.returnType,\n            returnType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let thisType = signatureReference.thisType;\n        let explicitThisType = functionTypeNode.explicitThisType;\n        if (thisType && explicitThisType) {\n          this.propagateInferredGenericTypes(\n            explicitThisType,\n            thisType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        return;\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    let kind = element.kind;\n    if (kind == ElementKind.Global) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.Swallow)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** resolving expressions */\n  private resolvingExpressions: Set<Expression> = new Set();\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const resolvingExpressions = this.resolvingExpressions;\n    if (resolvingExpressions.has(node)) return null;\n    resolvingExpressions.add(node);\n    const resolved = this.doResolveExpression(node, ctxFlow, ctxType, reportMode);\n    resolvingExpressions.delete(node);\n    return resolved;\n  }\n\n  /** Resolves an expression to its static type. (may cause stack overflow) */\n  private doResolveExpression(\n    node: Expression,\n    ctxFlow: Flow,\n    ctxType: Type = Type.auto,\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False:\n      case NodeKind.Null: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    let name = node.text;\n    let element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    let outerFlow = ctxFlow.outer;\n    if (outerFlow) {\n      if (element = outerFlow.lookup(name)) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return element;\n      }\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False: return Type.bool;\n      case NodeKind.Null: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    let element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FunctionPrototype) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, new Map(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.Report): bool {\n    if (global.is(CommonFlags.Resolved)) return true;\n    let typeNode = global.typeNode;\n    let type = typeNode\n      ? this.resolveType(typeNode, global.parent, null, reportMode)\n      : this.resolveExpression(\n          assert(global.initializerNode),\n          global.file.startFunction.flow,\n          Type.auto,\n          reportMode\n        );\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetNode = node.expression;\n    let target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    let propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.Global: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.EnumValue:\n      case ElementKind.Local:\n      case ElementKind.Field: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        assert(type != Type.void);\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PropertyPrototype: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.IndexSignature: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FunctionPrototype: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.Resolved)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.Generic)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let ownMember = target.getMember(propertyName);\n          if (!ownMember) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, new Map(), ReportMode.Swallow);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.ClassPrototype:\n      case ElementKind.InterfacePrototype:\n      case ElementKind.Class:\n      case ElementKind.Interface: {\n        do {\n          let member = target.getMember(propertyName);\n          if (member) {\n            if (member.kind == ElementKind.PropertyPrototype) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.Static)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          // traverse inherited static members on the base prototype if target is a class prototype\n          if (\n            target.kind == ElementKind.ClassPrototype ||\n            target.kind == ElementKind.InterfacePrototype\n          ) {\n            let classPrototype = <ClassPrototype>target;\n            let basePrototype = classPrototype.basePrototype;\n            if (basePrototype) {\n              target = basePrototype;\n            } else {\n              break;\n            }\n          // traverse inherited instance members on the base class if target is a class instance\n          } else if (\n            target.kind == ElementKind.Class ||\n            target.kind == ElementKind.Interface\n          ) {\n            let classInstance = <Class>target;\n            let baseInstance = classInstance.base;\n            if (baseInstance) {\n              target = baseInstance;\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        } while (true);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let lookupName = (target.internalName == \"~lib/params/Params\") ? \"__get\" : propertyName;\n        let member = target.getMember(lookupName);\n        if (member) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return member; // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetExpression = node.expression;\n    let targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    expr: IntegerLiteralExpression,\n    /** Has unary minus before literal. */\n    negate: bool,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    let intValue = expr.value;\n    if (negate) {\n      // x + i64.min > 0   ->   underflow\n      if (i64_gt(i64_add(intValue, i64_minimum), i64_zero)) {\n        let range = expr.range;\n        this.error(\n          DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n          range, range.source.text.substring(range.start - 1, range.end)\n        );\n      } else if (i64_eq(intValue, i64_zero)) {\n        // Special handling for -0\n        if (ctxType.isFloatValue) {\n          return ctxType.kind == TypeKind.F32\n            ? Type.f32\n            : Type.f64;\n        } else if (!ctxType.isIntegerValue) {\n          // If it's unknown just always assume this is f64\n          return Type.f64;\n        }\n      }\n      intValue = i64_neg(intValue);\n    }\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.Bool: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.Isize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.Usize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NonNull: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.Class && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        return this.resolveType(\n          assert(node.toType),\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NonNull: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.Const: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operand = node.operand;\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Minus: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.Integer)) {\n          return this.determineIntegerLiteralType(\n            <IntegerLiteralExpression>operand,\n            true,\n            ctxType\n          );\n        }\n        // fall-through\n      }\n      case Token.Plus:\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.Exclamation: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.Tilde: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      case Token.Dot_Dot_Dot: {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            node.range, \"Spread operator\"\n          );\n        }\n        return null;\n      }\n      case Token.TypeOf: {\n        return this.program.stringInstance.type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let left = node.left;\n    let right = node.right;\n    let operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.Equals:\n      case Token.Plus_Equals:\n      case Token.Minus_Equals:\n      case Token.Asterisk_Equals:\n      case Token.Asterisk_Asterisk_Equals:\n      case Token.Slash_Equals:\n      case Token.Percent_Equals:\n      case Token.LessThan_LessThan_Equals:\n      case Token.GreaterThan_GreaterThan_Equals:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n      case Token.Ampersand_Equals:\n      case Token.Bar_Equals:\n      case Token.Caret_Equals: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LessThan:\n      case Token.GreaterThan:\n      case Token.LessThan_Equals:\n      case Token.GreaterThan_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.Equals_Equals:\n      case Token.Exclamation_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.Equals_Equals_Equals:\n      case Token.Exclamation_Equals_Equals: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.Plus:\n      case Token.Minus:\n      case Token.Asterisk:\n      case Token.Slash:\n      case Token.Percent: // mod has special logic, but also behaves like this\n      case Token.Asterisk_Asterisk: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LessThan_LessThan:\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.Ampersand:\n      case Token.Bar:\n      case Token.Caret: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical: result is LHS (RHS is converted to LHS), not supporting overloads\n\n      case Token.Ampersand_Ampersand:\n      case Token.Bar_Bar: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    let parent = ctxFlow.sourceFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    let parent: Element | null = ctxFlow.sourceFunction.parent;\n    if (parent && parent.kind == ElementKind.Class) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.Integer: {\n        let intType = this.determineIntegerLiteralType(\n          <IntegerLiteralExpression>node,\n          false,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.Float: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.String:\n      case LiteralKind.Template: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.RegExp: {\n        return this.program.regexpInstance;\n      }\n      case LiteralKind.Array: {\n        let classReference = ctxType.getClass();\n        if (classReference && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.u8; // we want ByteArray, if the elements fit\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.Null && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = Type.u8;\n              if (expression.kind != NodeKind.Omitted) {\n                currentType = this.resolveExpression(expression, ctxFlow, elementType);\n                if (!currentType) return null;\n              }\n              if (currentType != elementType) {\n                let commonType = Type.commonDenominator(elementType, currentType, false);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.u8) {\n          if (numNullLiterals > 0) {\n            if (reportMode == ReportMode.Report) {\n              this.error(\n                DiagnosticCode.Type_0_cannot_be_nullable,\n                node.range, \"u8\"\n              );\n            }\n            return null;\n          }\n          return assert(this.resolveClass(this.program.byteArrayPrototype));\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n      case LiteralKind.Object: {\n        if (ctxType.isClass) return ctxType.classReference;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            node.range\n          );\n        }\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let targetExpression = node.expression;\n    let target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let instance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!instance) return null;\n        return instance.signature.returnType;\n      }\n      case ElementKind.Global:\n      case ElementKind.Local:\n      case ElementKind.Field: {\n        let varType = (<VariableLikeElement>target).type;\n        let varElement = this.getElementOfType(varType);\n        if (!varElement || varElement.kind != ElementKind.Class) {\n          break;\n        }\n        target = varElement;\n        // fall-through\n      }\n      case ElementKind.Class: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          let signatureReference = assert(ftype.signatureReference);\n          return signatureReference.returnType;\n        }\n        break;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    let elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    let commonType = Type.commonDenominator(thenType, elseType, false);\n    if (!commonType) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element = this.resolveTypeName(node.typeName, ctxFlow.sourceFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.ClassPrototype) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const declaration = node.declaration;\n    const signature = declaration.signature;\n    const body = declaration.body;\n    let functionType = this.resolveFunctionType(signature, ctxFlow.sourceFunction, ctxFlow.contextualTypeArguments, reportMode);\n    if (\n      functionType &&\n      declaration.arrowKind != ArrowKind.None &&\n      body && body.kind == NodeKind.Expression &&\n      isTypeOmitted(signature.returnType)\n    ) {\n      // (x) => ret, infer return type accordingt to `ret`\n      const expr = (<ExpressionStatement>body).expression;\n      let signatureReference = assert(functionType.getSignature());\n      // create a temp flow to resolve expression\n      let tempFlow = Flow.createDefault(ctxFlow.sourceFunction);\n      let parameters = signature.parameters;\n      // return type of resolveFunctionType should have same parameter length with signature\n      assert(signatureReference.parameterTypes.length == parameters.length);\n      for (let i = 0, k = parameters.length; i < k; i++) {\n        const parameter = parameters[i];\n        const type = signatureReference.parameterTypes[i];\n        tempFlow.addScopedDummyLocal(parameter.name.text, type, parameter);\n      }\n      const type = this.resolveExpression(expr, tempFlow, ctxType, reportMode);\n      if (type) {\n        signatureReference.returnType = type;\n      }\n    }\n    return functionType;\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let actualParent = prototype.parent.kind == ElementKind.PropertyPrototype\n      ? prototype.parent.parent\n      : prototype.parent;\n    let classInstance: Class | null = null; // if an instance method\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.Instance)) {\n      assert(actualParent.kind == ElementKind.Class || actualParent.kind == ElementKind.Interface);\n      classInstance = <Class>actualParent;\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          // override contextual\n          ctxTypes.set(classTypeParameterName, classTypeArguments[i]);\n        }\n      }\n    } else {\n      assert(actualParent.kind != ElementKind.Class); // must not be pre-bound\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    let signatureNode = prototype.functionTypeNode;\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let numFunctionTypeArguments: i32;\n    if (typeArguments && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    let thisType: Type | null = null;\n    let explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    let signatureParameters = signatureNode.parameters;\n    let numSignatureParameters = signatureParameters.length;\n    let parameterTypes = new Array<Type>(numSignatureParameters);\n    let requiredParameters = 0;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.Default) {\n        requiredParameters = i + 1;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    let returnType: Type;\n    if (prototype.is(CommonFlags.Set)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.Constructor)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    let signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    let instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n\n    // remember discovered overloads for virtual stub finalization\n    if (classInstance) {\n      let methodOrPropertyName = instance.declaration.name.text;\n      let baseClass = classInstance.base;\n      while (baseClass) {\n        let baseMembers = baseClass.members;\n        if (baseMembers && baseMembers.has(methodOrPropertyName)) {\n          this.discoveredOverload = true;\n          break;\n        }\n        baseClass = baseClass.base;\n      }\n    }\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let actualParent = prototype.parent.kind == ElementKind.PropertyPrototype\n      ? prototype.parent.parent\n      : prototype.parent;\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.Instance)) {\n        assert(actualParent.kind == ElementKind.Class);\n        let classInstance = <Class>actualParent;\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves reachable overloads of the given instance method. */\n  resolveOverloads(instance: Function): Function[] | null {\n    let overloadPrototypes = instance.prototype.overloads;\n    if (!overloadPrototypes) return null;\n\n    let parentClassInstance = assert(instance.getClassOrInterface());\n    let overloads = new Set<Function>();\n\n    // A method's `overloads` property contains its unbound overload prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved.\n    for (let _values = Set_values(overloadPrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverloadPrototype = _values[i];\n      assert(!unboundOverloadPrototype.isBound);\n      let unboundOverloadParent = unboundOverloadPrototype.parent;\n      let isProperty = unboundOverloadParent.kind == ElementKind.PropertyPrototype;\n      let classInstances: Map<string,Class> | null;\n      if (isProperty) {\n        let propertyParent = (<PropertyPrototype>unboundOverloadParent).parent;\n        assert(propertyParent.kind == ElementKind.ClassPrototype);\n        classInstances = (<ClassPrototype>propertyParent).instances;\n      } else {\n        assert(unboundOverloadParent.kind == ElementKind.ClassPrototype);\n        classInstances = (<ClassPrototype>unboundOverloadParent).instances;\n      }\n      if (!classInstances) continue;\n      for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n        let classInstance = _values[j];\n        // Check if the parent class is a subtype of instance's class\n        if (!classInstance.isAssignableTo(parentClassInstance)) continue;\n        let overloadInstance: Function | null;\n        if (isProperty) {\n          let boundProperty = assert(classInstance.members!.get(unboundOverloadParent.name));\n          assert(boundProperty.kind == ElementKind.PropertyPrototype);\n          let boundPropertyInstance = this.resolveProperty(<PropertyPrototype>boundProperty);\n          if (!boundPropertyInstance) continue;\n          if (instance.is(CommonFlags.Get)) {\n            overloadInstance = boundPropertyInstance.getterInstance;\n          } else {\n            assert(instance.is(CommonFlags.Set));\n            overloadInstance = boundPropertyInstance.setterInstance;\n          }\n        } else {\n          let boundPrototype = assert(classInstance.members!.get(unboundOverloadPrototype.name));\n          assert(boundPrototype.kind == ElementKind.FunctionPrototype);\n          overloadInstance = this.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n        }\n        if (overloadInstance) overloads.add(overloadInstance);\n      }\n    }\n    return Set_values(overloads);\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    let instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    if (prototype.kind == ElementKind.InterfacePrototype) {\n      instance = new Interface(nameInclTypeParameters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParameters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    let pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    let anyPending = false;\n\n    // Resolve base class if applicable\n    let basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        prototype.parent, // relative to derived class\n        cloneMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n    }\n\n    // Resolve interfaces if applicable\n    let interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          prototype.parent,\n          cloneMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.Interface);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    let members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    let pendingClasses = this.resolveClassPending;\n    let unimplemented = new Map<string,DeclaredElement>();\n\n    // Alias interface members\n    let interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(ifaceMembers.get(memberName));\n            if (members.has(memberName)) {\n              let existing = assert(members.get(memberName));\n              if (!member.isCompatibleOverride(existing)) {\n                this.errorRelated(\n                  DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                  member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n                );\n                continue;\n              }\n            }\n            members.set(memberName, member);\n            unimplemented.set(memberName, member);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    let memoryOffset: u32 = 0;\n    let base = instance.base;\n    if (base) {\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(baseMembers.get(memberName));\n          if (members.has(memberName)) {\n            let existing = assert(members.get(memberName));\n            if (!member.isCompatibleOverride(existing)) {\n              this.errorRelated(\n                DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n              );\n              continue;\n            }\n          }\n          members.set(memberName, member);\n          if (member.is(CommonFlags.Abstract)) {\n            unimplemented.set(memberName, member);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    let prototype = instance.prototype;\n    let instanceMemberPrototypes = prototype.instanceMembers;\n    let properties = new Array<Property>();\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        switch (member.kind) {\n\n          case ElementKind.FieldPrototype: {\n            let fieldPrototype = <FieldPrototype>member;\n            let fieldTypeNode = fieldPrototype.typeNode;\n            let fieldType: Type | null = null;\n            let existingField: Field | null = null;\n            if (base) {\n              let baseMembers = base.members;\n              if (baseMembers && baseMembers.has(fieldPrototype.name)) {\n                let baseField = assert(baseMembers.get(fieldPrototype.name));\n                if (baseField.kind == ElementKind.Field) {\n                  existingField = <Field>baseField;\n                } else {\n                  this.errorRelated(\n                    DiagnosticCode.Duplicate_identifier_0,\n                    fieldPrototype.identifierNode.range, baseField.identifierNode.range,\n                    fieldPrototype.name\n                  );\n                }\n              }\n            }\n            if (!fieldTypeNode) {\n              if (existingField && !existingField.is(CommonFlags.Private)) {\n                fieldType = existingField.type;\n              }\n              if (!fieldType) {\n                if (reportMode == ReportMode.Report) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldPrototype.identifierNode.range.atEnd\n                  );\n                }\n              }\n            } else {\n              fieldType = this.resolveType(\n                fieldTypeNode,\n                prototype.parent, // relative to class\n                instance.contextualTypeArguments,\n                reportMode\n              );\n              if (fieldType == Type.void) {\n                if (reportMode == ReportMode.Report) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldTypeNode.range\n                  );\n                }\n                break;\n              }\n            }\n            if (!fieldType) break; // did report above\n            if (existingField) {\n              // visibility checks\n              /*\n                          existingField visibility on top\n                +==================+=========+===========+=========+\n                | Visibility Table | Private | Protected | Public  |\n                +==================+=========+===========+=========+\n                | Private          | error   | error     | error   |\n                +------------------+---------+-----------+---------+\n                | Protected        | error   | allowed   | error   |\n                +------------------+---------+-----------+---------+\n                | Public           | error   | allowed   | allowed |\n                +------------------+---------+-----------+---------+\n              */\n\n              let baseClass = <Class>base;\n\n              // handle cases row-by-row\n              if (fieldPrototype.is(CommonFlags.Private)) {\n                if (existingField.is(CommonFlags.Private)) {\n                  this.errorRelated(\n                    DiagnosticCode.Types_have_separate_declarations_of_a_private_property_0,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name\n                  );\n                } else {\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, instance.internalName, baseClass.internalName\n                  );\n                }\n              } else if (fieldPrototype.is(CommonFlags.Protected)) {\n                if (existingField.is(CommonFlags.Private)) {\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, baseClass.internalName, instance.internalName\n                  );\n                } else if (!existingField.is(CommonFlags.Protected)) {\n                  // may be implicitly public\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, instance.internalName, baseClass.internalName\n                  );\n                }\n              } else {\n                // fieldPrototype is public here\n                if (existingField.is(CommonFlags.Private)) {\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, baseClass.internalName, instance.internalName\n                  );\n                }\n              }\n\n              // assignability (to guarantee soundness, field types must be invariant)\n              // see also Wasm GC, where mutable fields are invariant for this reason\n              //\n              //  class Animal { sibling: Animal; }\n              //  class Cat extends Animal { sibling: Cat; } // covariance\n              //  class Dog extends Animal { sibling: Dog; } // is unsound\n              //  (<Animal>new Cat()).sibling = new Dog();   // \u2192 Cat with Dog sibling\n              //\n              if (fieldType != existingField.type) {\n                this.errorRelated(\n                  DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n                  fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                  fieldPrototype.name, instance.internalName, baseClass.internalName\n                );\n                fieldType = existingField.type; // recover (typebuilder would otherwise error)\n              }\n            }\n            let fieldInstance = new Field(fieldPrototype, instance, fieldType);\n            assert(isPowerOf2(fieldType.byteSize));\n            if (existingField) {\n              fieldInstance.memoryOffset = existingField.memoryOffset;\n            } else {\n              let mask = fieldType.byteSize - 1;\n              if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n              fieldInstance.memoryOffset = memoryOffset;\n              memoryOffset += fieldType.byteSize;\n            }\n            instance.add(memberName, fieldInstance); // reports\n            break;\n          }\n          case ElementKind.FunctionPrototype: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PropertyPrototype: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.Abstract)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    // Check that property getters and setters match\n    for (let i = 0, k = properties.length; i < k; ++i) {\n      let property = properties[i];\n      let propertyGetter = property.getterInstance;\n      if (!propertyGetter) {\n        this.error(\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n          property.identifierNode.range, property.name\n        );\n      } else {\n        let propertySetter = property.setterInstance;\n        if (propertySetter && !propertyGetter.visibilityEquals(propertySetter)) {\n          this.errorRelated(\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\n          );\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.Interface) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.Abstract) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.getMember(CommonNames.constructor);\n        if (ctorPrototype && ctorPrototype.parent == instance) {\n          assert(ctorPrototype.kind == ElementKind.FunctionPrototype);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    let overloadPrototypes = prototype.overloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.Invalid);\n      if (overloadPrototype.is(CommonFlags.Generic)) {\n        // Already errored during initialization: AS212: Decorator '@operator' is not valid here\n        continue;\n      }\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.Instance)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.overloads;\n      if (!overloads) instance.overloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.Instance)) {\n        switch (overloadKind) {\n          case OperatorKind.PrefixInc:\n          case OperatorKind.PrefixDec:\n          case OperatorKind.PostfixInc:\n          case OperatorKind.PostfixDec: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.Report) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.IndexedGet || overloadKind == OperatorKind.IndexedSet) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.IndexedGet) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base == instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface == instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes), // must be present if generic\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Property | null {\n    let instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(prototype, prototype);\n    let getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    let setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.Resolved)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    return instance;\n  }\n\n  private ensureOneTypeArgument(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): TypeNode | null {\n    let typeArgumentNodes = node.typeArguments;\n    let numTypeArguments = 0;\n    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    return typeArgumentNodes[0];\n  }\n}\n", "/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  CharCode,\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n  ModuleDeclaration,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n  /** Current overridden module name. */\n  currentModuleName: string | null = null;\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] = []\n  ) {\n    super(diagnostics);\n    this.sources = sources;\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    let normalizedPath = normalizePath(path);\n    let internalPath = mangleInternalPath(normalizedPath);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text == null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    let source = new Source(\n      isEntry\n        ? SourceKind.UserEntry\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LibraryEntry\n            : SourceKind.Library\n          : SourceKind.User,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n    this.currentModuleName = null;\n\n    // tokenize and parse\n    let tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    let statements = source.statements;\n    while (!tn.skip(Token.EndOfFile)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    let flags = namespace ? namespace.flags & CommonFlags.Ambient : CommonFlags.None;\n    let startPos = -1;\n\n    // check decorators\n    let decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.At)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    let exportStart = 0;\n    let exportEnd = 0;\n    let defaultStart = 0;\n    let defaultEnd = 0;\n    if (tn.skip(Token.Export)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.Export;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.Default)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = namespace != null && namespace.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.Declare | CommonFlags.Ambient;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    // parse the statement\n    let statement: Statement | null = null;\n\n    // handle declarations\n    let first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.Const: {\n        tn.next();\n        flags |= CommonFlags.Const;\n        if (tn.skip(Token.Enum)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.Let: flags |= CommonFlags.Let;\n      case Token.Var: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Enum: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Function: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        // might have added export flag\n        if (statement && ((<FunctionDeclaration>statement).flags & CommonFlags.Export))\n          flags |= CommonFlags.Export;\n        decorators = null;\n        break;\n      }\n      case Token.Abstract: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        let next = tn.peek(true);\n        if (tn.nextTokenOnNewLine) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        if (next != Token.Class) {\n          if (next == Token.Interface) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.Abstract;\n        // fall through\n      }\n      case Token.Class:\n      case Token.Interface: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Namespace: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Import: {\n        tn.next();\n        flags |= CommonFlags.Import;\n        if (flags & CommonFlags.Export) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.Type: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Module: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(true) == Token.StringLiteral && !tn.nextTokenOnNewLine) {\n          tn.discard(state);\n          statement = this.parseModuleDeclaration(tn, flags);\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.Export) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.Prefer)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.Declare) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (!namespace) {\n            statement = this.parseStatement(tn, true);\n          } // TODO: else?\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement != null) {\n      switch (statement.kind) {\n        case NodeKind.EnumDeclaration:\n        case NodeKind.FunctionDeclaration:\n        case NodeKind.ClassDeclaration:\n        case NodeKind.InterfaceDeclaration:\n        case NodeKind.NamespaceDeclaration: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    let backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    let dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    let first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    let current = first;\n    while (tn.skip(Token.Dot)) {\n      if (tn.skip(Token.Identifier)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    let token = tn.next();\n    let startPos = tn.tokenPos;\n\n    let type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OpenParen) {\n\n      // '(' FunctionSignature ')' '|' 'null'?\n      let isNullableSignature = tn.skip(Token.OpenParen);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isNullableSignature) {\n          if (!tn.skip(Token.CloseParen)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \")\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Bar)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"|\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Null)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          signature.isNullable = true;\n        }\n        return signature;\n      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n      // Type (',' Type)* ')'\n      if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.Void) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.This) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.True || token == Token.False) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.Null) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.StringLiteral) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.Identifier) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LessThan)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.Comma));\n        if (!tn.skip(Token.GreaterThan)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | null\n    while (tn.skip(Token.Bar)) {\n      if (tn.skip(Token.Null)) {\n        type.isNullable = true;\n      } else {\n        let notNullStart = tn.pos;\n        let notNull = this.parseType(tn, false, true);\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            notNull ? notNull.range : tn.range(notNullStart), \"null\"\n          );\n        }\n        return null;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OpenBracket)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CloseBracket)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.Bar)) {\n        if (tn.skip(Token.Null)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    let state = tn.mark();\n    let startPos = tn.tokenPos;\n    let parameters: ParameterNode[] | null = null;\n    let thisType: NamedTypeNode | null = null;\n    let isSignature: bool = false;\n    let firstParamNameNoType: IdentifierExpression | null = null;\n    let firstParamKind: ParameterKind = ParameterKind.Default;\n\n    if (tn.skip(Token.CloseParen)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.Default;\n        if (tn.skip(Token.Dot_Dot_Dot)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.Rest;\n        }\n        if (tn.skip(Token.This)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NamedType) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.Question)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.Rest) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.Optional;\n            }\n          }\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.Comma) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.Comma));\n      if (!tn.skip(Token.CloseParen)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    let returnType: TypeNode | null;\n    if (tn.skip(Token.Equals_GreaterThan)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n\n    if (!parameters) parameters = [];\n\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    let startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.Dot)) {\n        if (tn.skipIdentifier(IdentifierHandling.Prefer)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OpenParen)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    let declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declaration.overriddenModuleName = this.currentModuleName;\n      declarations.push(declaration);\n    } while (tn.skip(Token.Comma));\n\n    let ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    let flags = parentFlags;\n    if (tn.skip(Token.Exclamation)) {\n      flags |= CommonFlags.DefinitelyAssigned;\n    }\n\n    let type: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      type = this.parseType(tn, true);\n    }\n\n    let initializer: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!initializer) return null;\n    } else if (!isFor) {\n      if (flags & CommonFlags.Const) {\n        if (!(flags & CommonFlags.Ambient)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    let range = Range.join(identifier.range, tn.range());\n    if (initializer && (flags & CommonFlags.DefinitelyAssigned) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.Identifier) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OpenBrace) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    let members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let member = this.parseEnumValue(tn, CommonFlags.None);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseBrace)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    let ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    let value: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      value = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    let startPos = tn.tokenPos;\n    let expr: Expression | null = null;\n    if (\n      tn.peek(true) != Token.Semicolon &&\n      tn.nextToken != Token.CloseBrace &&\n      !tn.nextTokenOnNewLine\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    let ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    let typeParameters = new Array<TypeParameterNode>();\n    let seenOptional = false;\n    let start = tn.tokenPos;\n    while (!tn.skip(Token.GreaterThan)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.GreaterThan)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.Identifier) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Extends)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Equals)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    let parameters = new Array<ParameterNode>();\n    let seenRest: ParameterNode | null = null;\n    let seenOptional = false;\n    let reportedRest = false;\n    let thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.This)) {\n      if (tn.skip(Token.Colon)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NamedType) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CloseParen)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.Optional: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.Rest: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    let isRest = false;\n    let isOptional = false;\n    let startRange: Range | null = null;\n    let accessFlags: CommonFlags = CommonFlags.None;\n    if (isConstructor) {\n      if (tn.skip(Token.Public)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Public;\n      } else if (tn.skip(Token.Protected)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Protected;\n      } else if (tn.skip(Token.Private)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Private;\n      }\n      if (tn.peek() == Token.Readonly) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.Colon) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.Readonly;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.Dot_Dot_Dot)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.Question)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.Comma + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.Rest\n          : isOptional\n            ? ParameterKind.Optional\n            : ParameterKind.Default,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    // hook entry points are always exported\n    if ((name.text == 'hook') || (name.text == 'cbak'))\n      flags |= CommonFlags.Export;\n    let signatureStart = -1;\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    if (!tn.skip(Token.OpenParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    let thisType = this.parseParametersThis;\n\n    let isSetter = (flags & CommonFlags.Set) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.Get) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    let returnType: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      if (isSetter) {\n        returnType = Node.createOmittedType(\n          tn.range(tn.pos)\n        );\n      } else {\n        returnType = Node.createNamedType(\n          Node.createSimpleTypeName(\"i64\", tn.range()), [], false, tn.range(tn.pos)\n        );\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (tn.skip(Token.OpenBrace)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n      if ((name.text == 'hook') || (name.text == 'cbak')) {\n        body.statements.push(\n          Node.createReturnStatement(\n            Node.createIntegerLiteralExpression(0, tn.range()),\n            tn.range(tn.pos))\n        );\n      }\n    } else if (!(flags & CommonFlags.Ambient)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    let ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.None,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n    let arrowKind = ArrowKind.None;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.Function) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OpenParen)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.Parenthesized;\n      assert(tn.token == Token.OpenParen);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    let signatureStart = tn.pos;\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    let returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.Single && tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.Equals_GreaterThan)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OpenBrace)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.Comma + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OpenBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    let declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    let isInterface = tn.token == Token.Interface;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    let identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    let extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.Extends)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NamedType) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    let implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.Implements)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.Comma));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    declaration.overriddenModuleName = this.currentModuleName;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   'declare'?\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'override'?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    let isInterface = parent.kind == NodeKind.InterfaceDeclaration;\n    let startPos = 0;\n    let decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.At)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.At));\n      if (isInterface && decorators) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    let flags = parent.flags & CommonFlags.Ambient;\n\n    // implemented methods are virtual\n    if (isInterface) flags |= CommonFlags.Virtual;\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = parent.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"declare\"\n        );\n      } else {\n        if (contextIsAmbient) {\n          this.error(\n            DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n            tn.range()\n          ); // recoverable\n        } else {\n          flags |= CommonFlags.Declare | CommonFlags.Ambient;\n          declareStart = tn.tokenPos;\n          declareEnd = tn.pos;\n        }\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    let accessStart = 0;\n    let accessEnd = 0;\n    if (tn.skip(Token.Public)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.Public;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Private)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.Private;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Protected)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.Protected;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let staticStart = 0;\n    let staticEnd = 0;\n    let abstractStart = 0;\n    let abstractEnd = 0;\n    if (tn.skip(Token.Static)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.Static;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.Instance;\n      if (tn.skip(Token.Abstract)) {\n        if (isInterface || !parent.is(CommonFlags.Abstract)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.Abstract;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.Generic) flags |= CommonFlags.GenericContext;\n    }\n\n    let overrideStart = 0;\n    let overrideEnd = 0;\n    if (tn.skip(Token.Override)) {\n      if (isInterface || parent.extendsType == null) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"override\"\n        );\n      } else {\n        flags |= CommonFlags.Override;\n        overrideStart = tn.tokenPos;\n        overrideEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let readonlyStart = 0;\n    let readonlyEnd = 0;\n    if (tn.peek() == Token.Readonly) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.Colon) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.Readonly;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    let state = tn.mark();\n    let isConstructor = false;\n    let isGetter = false;\n    let getStart = 0;\n    let getEnd = 0;\n    let isSetter = false;\n    let setStart = 0;\n    let setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.Get)) {\n        if (tn.peek(true, IdentifierHandling.Prefer) == Token.Identifier && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.Get;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Set)) {\n        if (tn.peek(true, IdentifierHandling.Prefer) == Token.Identifier && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.Set;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Constructor)) {\n        flags |= CommonFlags.Constructor;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Readonly) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    let isGetterOrSetter = isGetter || isSetter;\n    let name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OpenBracket)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.Public) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Protected) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Private) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"private\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Override) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(overrideStart, overrideEnd), \"override\"\n          );\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.Semicolon);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.Always)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.Generic;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OpenParen)) {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_appear_on_class_elements_of_this_kind,\n          tn.range(declareStart, declareEnd), \"declare\"\n        ); // recoverable\n      }\n\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.Public |\n            CommonFlags.Protected |\n            CommonFlags.Private |\n            CommonFlags.Readonly\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.Instance,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.Colon)) {\n        if (name.kind == NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.Constructor);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OpenBrace)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.Ambient | CommonFlags.Abstract))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(declareStart, declareEnd), \"Ambient fields\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Abstract) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Get) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Set) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.Question)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.Exclamation)) {\n        flags |= CommonFlags.DefinitelyAssigned;\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        }\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n      }\n      let range = tn.range(startPos, tn.pos);\n      if (\n        (flags & CommonFlags.DefinitelyAssigned) != 0 &&\n        (isInterface || initializer || (flags & CommonFlags.Static) != 0)\n      ) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    let start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.Colon)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NamedType) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CloseBracket)) {\n            if (tn.skip(Token.Colon)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NamedType) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OpenBrace)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CloseBrace)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) {\n            if (member.kind == NodeKind.Export) {\n              this.error(\n                DiagnosticCode.A_default_export_can_only_be_used_in_a_module,\n                member.range,\n              );\n              return null;\n            }\n            members.push(member);\n          } else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.EndOfFile)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        declaration.overriddenModuleName = this.currentModuleName;\n        tn.skip(Token.Semicolon);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    let path: StringLiteralExpression | null = null;\n    let currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OpenBrace)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else if (tn.skip(Token.Asterisk)) {\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier(IdentifierHandling.Always)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    let name = tn.readIdentifier();\n    let range = tn.range();\n    let ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    let members: ImportDeclaration[] | null = null;\n    let namespaceName: IdentifierExpression | null = null;\n    let skipFrom = false;\n    if (tn.skip(Token.OpenBrace)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.Asterisk)) { // import * from \"file\"\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.Identifier, IdentifierHandling.Prefer)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.Comma)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.From)) {\n      if (tn.skip(Token.StringLiteral)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.Equals)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    let state = tn.mark();\n    let token = tn.next();\n    let statement: Statement | null = null;\n    switch (token) {\n      case Token.Break: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.Const: {\n        statement = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos);\n        break;\n      }\n      case Token.Continue: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.Do: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.For: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.If: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.Let: {\n        statement = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos);\n        break;\n      }\n      case Token.Var: {\n        statement = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos);\n        break;\n      }\n      case Token.OpenBrace: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.Return: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.Semicolon: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.Switch: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.Throw: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.Try: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.Void: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.While: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.Type: { // also identifier\n        if (tn.peek(false, IdentifierHandling.Prefer) == Token.Identifier) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.None, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    let statements = new Array<Statement>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.EndOfFile) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    let ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.Identifier && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.Identifier && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    let startPos = tn.tokenPos;\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.While)) {\n\n      if (tn.skip(Token.OpenParen)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CloseParen)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    let expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    let ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    let startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OpenParen)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.Const)) {\n        initializer = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Let)) {\n        initializer = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Var)) {\n        initializer = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.Semicolon)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.Of)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.Expression) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.Identifier) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.Variable) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.Variable) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.Const) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.Semicolon) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.Semicolon)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.Semicolon) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CloseParen)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CloseParen)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    let iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CloseParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.Else)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        if (tn.skip(Token.OpenBrace)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CloseBrace)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    let startPos = tn.tokenPos;\n    let statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.Case)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.Default)) {\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn);\n    if (!expression) return null;\n    let ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    let startPos = tn.tokenPos;\n    let stmt: Statement | null;\n    if (tn.skip(Token.OpenBrace)) {\n      let bodyStatements = new Array<Statement>();\n      while (!tn.skip(Token.CloseBrace)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        bodyStatements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.Catch)) {\n        if (!tn.skip(Token.OpenParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.Finally)) {\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        bodyStatements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  private getRecursiveDepthForTypeDeclaration(\n    identifierName: string,\n    type: TypeNode,\n    depth: i32 = 0\n  ): i32 {\n    switch (type.kind) {\n      case NodeKind.NamedType: {\n        let typeArguments = (<NamedTypeNode>type).typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; i++) {\n            let res = this.getRecursiveDepthForTypeDeclaration(identifierName, typeArguments[i], depth + 1);\n            if (res != -1) return res;\n          }\n        }\n        if ((<NamedTypeNode>type).name.identifier.text == identifierName) {\n          return depth;\n        }\n        break;\n      }\n      case NodeKind.FunctionType: {\n        let fnType = <FunctionTypeNode>type;\n        let res = this.getRecursiveDepthForTypeDeclaration(identifierName, fnType.returnType, depth + 1);\n        if (res != -1) return res;\n        let params = fnType.parameters;\n        for (let i = 0, k = params.length; i < k; i++) {\n          res = this.getRecursiveDepthForTypeDeclaration(identifierName, params[i].type, depth + 1);\n          if (res != -1) return res;\n        }\n        break;\n      }\n    }\n    return -1;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' '|'? Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LessThan)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.Generic;\n      }\n      if (tn.skip(Token.Equals)) {\n        tn.skip(Token.Bar);\n        let type = this.parseType(tn);\n        if (!type) return null;\n        let depth = this.getRecursiveDepthForTypeDeclaration(name.text, type);\n        if (depth >= 0) {\n          if (depth == 0) {\n            this.error(\n              DiagnosticCode.Type_alias_0_circularly_references_itself,\n              tn.range(), name.text\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Not_implemented_0,\n              tn.range(), \"Recursion in type aliases\"\n            );\n          }\n          return null;\n        }\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.Semicolon);\n        ret.overriddenModuleName = this.currentModuleName;\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseModuleDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags\n  ): ModuleDeclaration | null {\n\n    // at 'module': StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    assert(tn.next() == Token.StringLiteral); // checked earlier\n    let moduleName = tn.readString();\n    let ret = Node.createModuleDeclaration(moduleName, flags, tn.range(startPos, tn.pos));\n    this.currentModuleName = moduleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn, Precedence.Grouping);\n    if (!expression) return null;\n    let ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    let token = tn.next(IdentifierHandling.Prefer);\n    let startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.Dot_Dot_Dot:\n      case Token.Yield: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.Exclamation:\n      case Token.Tilde:\n      case Token.Plus:\n      case Token.Minus:\n      case Token.TypeOf:\n      case Token.Void:\n      case Token.Delete: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.Identifier:\n          case NodeKind.ElementAccess:\n          case NodeKind.PropertyAccess: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.New: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OpenParen) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.Null: return Node.createNullExpression(tn.range());\n      case Token.True: return Node.createTrueExpression(tn.range());\n      case Token.False: return Node.createFalseExpression(tn.range());\n      case Token.This: return Node.createThisExpression(tn.range());\n      case Token.Constructor: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OpenParen: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CloseParen)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.Parenthesized\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.Prefer)) {\n\n            // function expression\n            case Token.Dot_Dot_Dot: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.Identifier: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CloseParen: {\n                  if (\n                    !tn.skip(Token.Colon) &&\n                    !tn.skip(Token.Equals_GreaterThan)\n                  ) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.Colon: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.Question: {\n                  if (\n                    tn.skip(Token.Colon) ||   // optional parameter with type\n                    tn.skip(Token.Comma) ||   // optional parameter without type\n                    tn.skip(Token.CloseParen) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.Comma: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OpenBracket: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CloseBracket)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.Comma) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBracket)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OpenBrace: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CloseBrace)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.StringLiteral)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.Colon)) {\n            let value = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBrace)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LessThan: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GreaterThan)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.Call);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.Prefix,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Identifier: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.skip(Token.TemplateLiteral)) {\n          return this.parseTemplateLiteral(tn, identifier);\n        }\n        if (tn.peek(true) == Token.Equals_GreaterThan && !tn.nextTokenOnNewLine) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.Single,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.Super: {\n        if (tn.peek() != Token.Dot && tn.nextToken != Token.OpenParen) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.StringLiteral: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.TemplateLiteral: {\n        return this.parseTemplateLiteral(tn);\n      }\n      case Token.IntegerLiteral: {\n        let value = tn.readInteger();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      case Token.FloatLiteral: {\n        let value = tn.readFloat();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.Slash: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.Slash)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Function: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.Class: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.EndOfFile) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    let state = tn.mark();\n    if (!tn.skip(Token.LessThan)) return null;\n    let start = tn.tokenPos;\n    let typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() == Token.GreaterThan) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.Comma));\n    if (tn.skip(Token.GreaterThan)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OpenParen)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    let args = new Array<Expression>();\n    while (!tn.skip(Token.CloseParen)) {\n      let expr = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.Comma\n  ): Expression | null {\n    assert(precedence != Precedence.None);\n    let expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    let startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    let nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.As: {\n          if (tn.skip(Token.Const)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.Const,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.As,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.Exclamation: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NonNull,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.InstanceOf: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OpenBracket: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CloseBracket)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.Plus_Plus:\n        case Token.Minus_Minus: {\n          if (\n            expr.kind != NodeKind.Identifier &&\n            expr.kind != NodeKind.ElementAccess &&\n            expr.kind != NodeKind.PropertyAccess\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.Question: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.Colon)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.Comma\n            ? Precedence.Comma + 1\n            : Precedence.Comma\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.Comma: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.Comma));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.Dot: {\n          if (tn.skipIdentifier(IdentifierHandling.Always)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.Call) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          if (tn.skip(Token.TemplateLiteral)) {\n            expr = this.parseTemplateLiteral(tn, expr);\n            if (!expr) return null;\n          } else {\n            expr = this.maybeParseCallExpression(tn, expr, true);\n          }\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.Equals:\n        case Token.Plus_Equals:\n        case Token.Minus_Equals:\n        case Token.Asterisk_Asterisk_Equals:\n        case Token.Asterisk_Equals:\n        case Token.Slash_Equals:\n        case Token.Percent_Equals:\n        case Token.LessThan_LessThan_Equals:\n        case Token.GreaterThan_GreaterThan_Equals:\n        case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n        case Token.Ampersand_Equals:\n        case Token.Caret_Equals:\n        case Token.Bar_Equals:\n        case Token.Asterisk_Asterisk: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LessThan:\n        case Token.GreaterThan:\n        case Token.LessThan_Equals:\n        case Token.GreaterThan_Equals:\n        case Token.Equals_Equals:\n        case Token.Equals_Equals_Equals:\n        case Token.Exclamation_Equals_Equals:\n        case Token.Exclamation_Equals:\n        case Token.Plus:\n        case Token.Minus:\n        case Token.Asterisk:\n        case Token.Slash:\n        case Token.Percent:\n        case Token.LessThan_LessThan:\n        case Token.GreaterThan_GreaterThan:\n        case Token.GreaterThan_GreaterThan_GreaterThan:\n        case Token.Ampersand:\n        case Token.Bar:\n        case Token.Caret:\n        case Token.Ampersand_Ampersand:\n        case Token.Bar_Bar: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {\n    // at '`': ... '`'\n    let startPos = tag ? tag.range.start : tn.tokenPos;\n    let parts = new Array<string>();\n    let rawParts = new Array<string>();\n    let exprs = new Array<Expression>();\n    let exprLengths = new Array<i64>();\n    parts.push(tn.readString(0, tag != null));\n    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    while (tn.readingTemplateString) {\n      let expr = this.parseExpression(tn);\n      if (!expr) return null;\n      exprs.push(expr);\n      if (!tn.skip(Token.Colon)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      let length = tn.readInteger();\n      if (length <= 0) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"length\"\n        );\n        return null;\n      }\n      exprLengths.push(length);\n      if (!tn.skip(Token.CloseBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"}\"\n        );\n        return null;\n      }\n      parts.push(tn.readString(CharCode.Backtick, tag != null));\n      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    }\n    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, exprLengths, tn.range(startPos, tn.pos));\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    let callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.Identifier: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.Call: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    let typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OpenParen) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    tn.peek(true);\n    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek(true);\n      if (\n        nextToken == Token.EndOfFile ||   // next step should handle this\n        nextToken == Token.Semicolon      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:\n        case Token.TemplateLiteral: {\n          tn.readString();\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.OpenBrace: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n    tn.readingTemplateString = false;\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    let depth = 1;\n    let again = true;\n    do {\n      switch (tn.next()) {\n        case Token.EndOfFile: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OpenBrace: {\n          ++depth;\n          break;\n        }\n        case Token.CloseBrace: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:{\n          tn.readString();\n          break;\n        }\n        case Token.TemplateLiteral: {\n          tn.readString();\n          while(tn.readingTemplateString){\n            this.skipBlock(tn);\n            tn.readString(CharCode.Backtick);\n          }\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  None,\n  Comma,\n  Spread,\n  Yield,\n  Assignment,\n  Conditional,\n  LogicalOr,\n  LogicalAnd,\n  BitwiseOr,\n  BitwiseXor,\n  BitwiseAnd,\n  Equality,\n  Relational,\n  Shift,\n  Additive,\n  Multiplicative,\n  Exponentiated,\n  UnaryPrefix,\n  UnaryPostfix,\n  Call,\n  MemberAccess,\n  Grouping\n}\n\n/** Determines the precende of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.Comma: return Precedence.Comma;\n    case Token.Equals:\n    case Token.Plus_Equals:\n    case Token.Minus_Equals:\n    case Token.Asterisk_Asterisk_Equals:\n    case Token.Asterisk_Equals:\n    case Token.Slash_Equals:\n    case Token.Percent_Equals:\n    case Token.LessThan_LessThan_Equals:\n    case Token.GreaterThan_GreaterThan_Equals:\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n    case Token.Ampersand_Equals:\n    case Token.Caret_Equals:\n    case Token.Bar_Equals: return Precedence.Assignment;\n    case Token.Question: return Precedence.Conditional;\n    case Token.Bar_Bar: return Precedence.LogicalOr;\n    case Token.Ampersand_Ampersand: return Precedence.LogicalAnd;\n    case Token.Bar: return Precedence.BitwiseOr;\n    case Token.Caret: return Precedence.BitwiseXor;\n    case Token.Ampersand: return Precedence.BitwiseAnd;\n    case Token.Equals_Equals:\n    case Token.Exclamation_Equals:\n    case Token.Equals_Equals_Equals:\n    case Token.Exclamation_Equals_Equals: return Precedence.Equality;\n    case Token.As:\n    case Token.In:\n    case Token.InstanceOf:\n    case Token.LessThan:\n    case Token.GreaterThan:\n    case Token.LessThan_Equals:\n    case Token.GreaterThan_Equals: return Precedence.Relational;\n    case Token.LessThan_LessThan:\n    case Token.GreaterThan_GreaterThan:\n    case Token.GreaterThan_GreaterThan_GreaterThan: return Precedence.Shift;\n    case Token.Plus:\n    case Token.Minus: return Precedence.Additive;\n    case Token.Asterisk:\n    case Token.Slash:\n    case Token.Percent: return Precedence.Multiplicative;\n    case Token.Asterisk_Asterisk: return Precedence.Exponentiated;\n    case Token.Plus_Plus:\n    case Token.Minus_Minus: return Precedence.UnaryPostfix;\n    case Token.Dot:\n    case Token.OpenBracket:\n    case Token.Exclamation: return Precedence.MemberAccess;\n  }\n  return Precedence.None;\n}\n", "/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// \u251C\u2500DeclaredElement          Base class of elements with a declaration\n// \u2502 \u251C\u2500TypedElement           Base class of elements resolving to a type\n// \u2502 \u2502 \u251C\u2500TypeDefinition       Type alias declaration\n// \u2502 \u2502 \u251C\u2500VariableLikeElement  Base class of all variable-like elements\n// \u2502 \u2502 \u2502 \u251C\u2500EnumValue          Enum value\n// \u2502 \u2502 \u2502 \u251C\u2500Global             File global\n// \u2502 \u2502 \u2502 \u251C\u2500Local              Function local\n// \u2502 \u2502 \u2502 \u251C\u2500Field              Class field (instance only)\n// \u2502 \u2502 \u2502 \u2514\u2500Property           Class property\n// \u2502 \u2502 \u251C\u2500IndexSignature       Class index signature\n// \u2502 \u2502 \u251C\u2500Function             Concrete function instance\n// \u2502 \u2502 \u2514\u2500Class                Concrete class instance\n// \u2502 \u251C\u2500Namespace              Namespace with static members\n// \u2502 \u251C\u2500FunctionPrototype      Prototype of concrete function instances\n// \u2502 \u251C\u2500FieldPrototype         Prototype of concrete field instances\n// \u2502 \u251C\u2500PropertyPrototype      Prototype of concrete property instances\n// \u2502 \u2514\u2500ClassPrototype         Prototype of concrete classe instances\n// \u2514\u2500File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  LIBRARY_PREFIX,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind\n} from \"./ast\";\n\nimport {\n  Module,\n  FunctionRef,\n  MemorySegment,\n  getFunctionName\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n// Memory manager constants\nconst AL_SIZE = 16;\nconst AL_MASK = AL_SIZE - 1;\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  Invalid,\n\n  // indexed access\n  IndexedGet,          // a[]\n  IndexedSet,          // a[]=b\n  UncheckedIndexedGet, // unchecked(a[])\n  UncheckedIndexedSet, // unchecked(a[]=b)\n\n  // binary\n  Add,                 // a + b\n  Sub,                 // a - b\n  Mul,                 // a * b\n  Div,                 // a / b\n  Rem,                 // a % b\n  Pow,                 // a ** b\n  BitwiseAnd,          // a & b\n  BitwiseOr,           // a | b\n  BitwiseXor,          // a ^ b\n  BitwiseShl,          // a << b\n  BitwiseShr,          // a >> b\n  BitwiseShrU,         // a >>> b\n  Eq,                  // a == b, a === b\n  Ne,                  // a != b, a !== b\n  Gt,                  // a > b\n  Ge,                  // a >= b\n  Lt,                  // a < b\n  Le,                  // a <= b\n\n  // unary prefix\n  Plus,                // +a\n  Minus,               // -a\n  Not,                 // !a\n  BitwiseNot,          // ~a\n  PrefixInc,           // ++a\n  PrefixDec,           // --a\n\n  // unary postfix\n  PostfixInc,          // a++\n  PostfixDec           // a--\n\n  // not overridable:\n  // LogicalAnd        // a && b\n  // LogicalOr         // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OpenBracket: {\n            if (arg == \"[]\") return OperatorKind.IndexedGet;\n            if (arg == \"[]=\") return OperatorKind.IndexedSet;\n            break;\n          }\n          case CharCode.OpenBrace: {\n            if (arg == \"{}\") return OperatorKind.UncheckedIndexedGet;\n            if (arg == \"{}=\") return OperatorKind.UncheckedIndexedSet;\n            break;\n          }\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Add;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Sub;\n            break;\n          }\n          case CharCode.Asterisk: {\n            if (arg == \"*\") return OperatorKind.Mul;\n            if (arg == \"**\") return OperatorKind.Pow;\n            break;\n          }\n          case CharCode.Slash: {\n            if (arg == \"/\") return OperatorKind.Div;\n            break;\n          }\n          case CharCode.Percent: {\n            if (arg == \"%\") return OperatorKind.Rem;\n            break;\n          }\n          case CharCode.Ampersand: {\n            if (arg == \"&\") return OperatorKind.BitwiseAnd;\n            break;\n          }\n          case CharCode.Bar: {\n            if (arg == \"|\") return OperatorKind.BitwiseOr;\n            break;\n          }\n          case CharCode.Caret: {\n            if (arg == \"^\") return OperatorKind.BitwiseXor;\n            break;\n          }\n          case CharCode.Equals: {\n            if (arg == \"==\") return OperatorKind.Eq;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!=\") return OperatorKind.Ne;\n            break;\n          }\n          case CharCode.GreaterThan: {\n            if (arg == \">\") return OperatorKind.Gt;\n            if (arg == \">=\") return OperatorKind.Ge;\n            if (arg == \">>\") return OperatorKind.BitwiseShr;\n            if (arg == \">>>\") return OperatorKind.BitwiseShrU;\n            break;\n          }\n          case CharCode.LessThan: {\n            if (arg == \"<\") return OperatorKind.Lt;\n            if (arg == \"<=\") return OperatorKind.Le;\n            if (arg == \"<<\") return OperatorKind.BitwiseShl;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPrefix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Plus;\n            if (arg == \"++\") return OperatorKind.PrefixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Minus;\n            if (arg == \"--\") return OperatorKind.PrefixDec;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!\") return OperatorKind.Not;\n            break;\n          }\n          case CharCode.Tilde: {\n            if (arg == \"~\") return OperatorKind.BitwiseNot;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPostfix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"++\") return OperatorKind.PostfixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"--\") return OperatorKind.PostfixDec;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus:\n      case Token.Plus_Equals: return OperatorKind.Add;\n      case Token.Minus:\n      case Token.Minus_Equals: return OperatorKind.Sub;\n      case Token.Asterisk:\n      case Token.Asterisk_Equals: return OperatorKind.Mul;\n      case Token.Slash:\n      case Token.Slash_Equals: return OperatorKind.Div;\n      case Token.Percent:\n      case Token.Percent_Equals: return OperatorKind.Rem;\n      case Token.Asterisk_Asterisk:\n      case Token.Asterisk_Asterisk_Equals: return OperatorKind.Pow;\n      case Token.Ampersand:\n      case Token.Ampersand_Equals: return OperatorKind.BitwiseAnd;\n      case Token.Bar:\n      case Token.Bar_Equals: return OperatorKind.BitwiseOr;\n      case Token.Caret:\n      case Token.Caret_Equals: return OperatorKind.BitwiseXor;\n      case Token.LessThan_LessThan:\n      case Token.LessThan_LessThan_Equals: return OperatorKind.BitwiseShl;\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShr;\n      case Token.GreaterThan_GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShrU;\n      case Token.Equals_Equals: return OperatorKind.Eq;\n      case Token.Exclamation_Equals: return OperatorKind.Ne;\n      case Token.GreaterThan: return OperatorKind.Gt;\n      case Token.GreaterThan_Equals: return OperatorKind.Ge;\n      case Token.LessThan: return OperatorKind.Lt;\n      case Token.LessThan_Equals: return OperatorKind.Le;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus: return OperatorKind.Plus;\n      case Token.Minus: return OperatorKind.Minus;\n      case Token.Exclamation: return OperatorKind.Not;\n      case Token.Tilde: return OperatorKind.BitwiseNot;\n      case Token.Plus_Plus: return OperatorKind.PrefixInc;\n      case Token.Minus_Minus: return OperatorKind.PrefixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus_Plus: return OperatorKind.PostfixInc;\n      case Token.Minus_Minus: return OperatorKind.PostfixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    let nativeSource = new Source(SourceKind.LibraryEntry, LIBRARY_PREFIX + \"native.ts\", \"[native code]\");\n    this.nativeSource = nativeSource;\n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    let nativeFile = new File(this, nativeSource);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Parser instance. */\n  parser: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code source. */\n  nativeSource: Source;\n  /** Special native code range. */\n  get nativeRange(): Range { return this.nativeSource.range; }\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Signature[] = new Array<Signature>(0);\n  /** Module exports. */\n  moduleExports: Map<string,Element> = new Map();\n  /** Module imports. */\n  moduleImports: Map<string,Map<string,Element>> = new Map();\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    let cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    let cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    let cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    let cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `ByteArray` prototype. */\n  get byteArrayPrototype(): ClassPrototype {\n    let cached = this._byteArrayPrototype;\n    if (!cached) this._byteArrayPrototype = cached = <ClassPrototype>this.require(\"ByteArray\", ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _byteArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    let cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    let cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    let cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    let cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    let cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    let cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    let cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    let cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    let cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    let cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    let cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    let cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    let cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `RegExp` instance. */\n  get regexpInstance(): Class {\n    let cached = this._regexpInstance;\n    if (!cached) this._regexpInstance = cached = this.requireClass(CommonNames.RegExp);\n    return cached;\n  }\n  private _regexpInstance: Class | null = null;\n\n  /** Gets the standard `Object` instance. */\n  get objectInstance(): Class {\n    let cached = this._objectInstance;\n    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);\n    return cached;\n  }\n  private _objectInstance: Class | null = null;\n\n  /** Gets the standard `TemplateStringsArray` instance. */\n  get templateStringsArrayInstance(): Class {\n    let cached = this._templateStringsArrayInstance;\n    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);\n    return cached;\n  }\n  private _templateStringsArrayInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    let prototype = this.lookup(CommonNames.abort);\n    if (!prototype || prototype.kind != ElementKind.FunctionPrototype) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    let cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    let cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    let cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    let cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    let cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */\n  get linkInstance(): Function {\n    let cached = this._linkInstance;\n    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);\n    return cached;\n  }\n  private _linkInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    let cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    let cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__typeinfo(id: u32): RTTIFlags` instance. */\n  get typeinfoInstance(): Function {\n    let cached = this._typeinfoInstance;\n    if (!cached) this._typeinfoInstance = cached = this.requireFunction(CommonNames.typeinfo);\n    return cached;\n  }\n  private _typeinfoInstance: Function | null = null;\n\n  /** Gets the runtime `__instanceof(ptr: usize, superId: u32): bool` instance. */\n  get instanceofInstance(): Function {\n    let cached = this._instanceofInstance;\n    if (!cached) this._instanceofInstance = cached = this.requireFunction(CommonNames.instanceof_);\n    return cached;\n  }\n  private _instanceofInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    let cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    let cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    let cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    let cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    let sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the overhead of a memory manager block. */\n  get blockOverhead(): i32 {\n    // BLOCK | data...\n    //       ^ 16b alignment\n    return this.BLOCKInstance.nextMemoryOffset;\n  }\n\n  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */\n  get objectOverhead(): i32 {\n    // OBJECT+align | data...\n    //        \u2514 0 \u2518 ^ 16b alignment\n    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;\n  }\n\n  /** Gets the total overhead of a managed object, incl. block overhead. */\n  get totalOverhead(): i32 {\n    // BLOCK | OBJECT+align | data...\n    // \u2514     = TOTAL      \u2518 ^ 16b alignment\n    return this.blockOverhead + this.objectOverhead;\n  }\n\n  searchFunctionByRef(ref: FunctionRef): Function | null {\n    const modifiedFunctionName = getFunctionName(ref);\n    if (modifiedFunctionName) {\n      const instancesByName = this.instancesByName;\n      if (instancesByName.has(modifiedFunctionName)) {\n        const element = assert(instancesByName.get(modifiedFunctionName));\n        if (element.kind == ElementKind.Function) {\n          return <Function>element;\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart(currentOffset: i32): i32 {\n    let blockOverhead = this.blockOverhead;\n    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart64(currentOffset: i64): i64 {\n    let blockOverhead = i64_new(this.blockOverhead);\n    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);\n  }\n\n  /** Computes the size of a memory manager block, excl. block overhead. */\n  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {\n    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo\n    if (isManaged) payloadSize += this.objectOverhead;\n    // we know that payload must be aligned, and that block sizes must be chosen\n    // so that blocks are adjacent with the next payload aligned. hence, block\n    // size is payloadSize rounded up to where the next block would start:\n    let blockSize = this.computeBlockStart(payloadSize);\n    // make sure that block size is valid according to TLSF requirements\n    let blockOverhead = this.blockOverhead;\n    let blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n    if (blockSize < blockMinsize) blockSize = blockMinsize;\n    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive\n    const tagsMask = 3;\n    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {\n      throw new Error(\"invalid block size\");\n    }\n    return blockSize;\n  }\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.None\n  ): VariableDeclaration {\n    let range = this.nativeSource.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None\n  ): TypeDeclaration {\n    let range = this.nativeSource.range;\n    let identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.None\n  ): FunctionDeclaration {\n    let range = this.nativeSource.range;\n    let signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.None, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.None\n  ): NamespaceDeclaration {\n    let range = this.nativeSource.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    let elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    let options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(\n      CommonNames.nonnull,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\n    this.registerNativeType(CommonNames.externref, Type.externref);\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\n    this.registerNativeType(CommonNames.eqref, Type.eqref);\n    this.registerNativeType(CommonNames.i31ref, Type.i31ref);\n    this.registerNativeType(CommonNames.dataref, Type.dataref);\n    this.registerNativeType(CommonNames.arrayref, Type.arrayref);\n    this.registerNativeType(CommonNames.stringref, Type.stringref);\n    this.registerNativeType(CommonNames.stringview_wtf8, Type.stringview_wtf8);\n    this.registerNativeType(CommonNames.stringview_wtf16, Type.stringview_wtf16);\n    this.registerNativeType(CommonNames.stringview_iter, Type.stringview_iter);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.Wasm64 : Target.Wasm32));\n    this.registerConstantInteger(CommonNames.ASC_RUNTIME, Type.i32,\n      i64_new(options.runtime));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,\n      i64_new(options.exportRuntime ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,\n      i64_new(options.bundleMajorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,\n      i64_new(options.bundleMinorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,\n      i64_new(options.bundlePatchVersion));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SignExtension) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MutableGlobals) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NontrappingF2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BulkMemory) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.Simd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.Threads) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.ExceptionHandling) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TailCalls) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.ReferenceTypes) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MultiValue) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.Memory64) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_RELAXED_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.RelaxedSimd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXTENDED_CONST, Type.bool,\n      i64_new(options.hasFeature(Feature.ExtendedConst) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_STRINGREF, Type.bool,\n      i64_new(options.hasFeature(Feature.Stringref) ? 1 : 0, 0));\n\n    // remember deferred elements\n    let queuedImports = new Array<QueuedImport>();\n    let queuedExports = new Map<File,Map<string,QueuedExport>>();\n    let queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    let queuedExtends = new Array<ClassPrototype>();\n    let queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.Export: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.ExportDefault: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.Import: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.Variable: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.ClassDeclaration: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.EnumDeclaration: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FunctionDeclaration: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.InterfaceDeclaration: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NamespaceDeclaration: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TypeDeclaration: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        // File must be found here, as it would otherwise already have been reported by the parser\n        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            foreignFile,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let localFile = queuedImport.localFile;\n          let localName = localIdentifier.text;\n          localFile.add(\n            localName,\n            foreignFile.asAliasNamespace(\n              localName,\n              localFile,\n              localIdentifier\n            ),\n            localIdentifier // isImport\n          );\n          queuedImports.splice(i, 1);\n          madeProgress = true;\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          // File must be found here, as it would otherwise already have been reported by the parser\n          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));\n          let element = this.lookupForeign(localName, foreignFile, queuedExports);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.getMember(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookup(localName);\n            if (globalElement && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)\n    assert(this.arrayBufferInstance.id == 0);\n    assert(this.stringInstance.id == 1);\n    assert(this.arrayBufferViewInstance.id == 2);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.Simd)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.ReferenceTypes)) {\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\n        this.registerWrapperClass(Type.eqref, CommonNames.Eqref);\n        this.registerWrapperClass(Type.i31ref, CommonNames.I31ref);\n        this.registerWrapperClass(Type.dataref, CommonNames.Dataref);\n        this.registerWrapperClass(Type.arrayref, CommonNames.Arrayref);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    let resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.ClassPrototype) {\n        if (baseElement.kind == ElementKind.ClassPrototype) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.Final)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.Unmanaged) !=\n            thisPrototype.hasDecorator(DecoratorFlags.Unmanaged)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.InterfacePrototype) {\n        if (baseElement.kind == ElementKind.InterfacePrototype) {\n          const basePrototype = <InterfacePrototype>baseElement;\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // check override\n    for (let i = 0, k = queuedExtends.length; i < k; i++) {\n      let prototype = queuedExtends[i];\n      let instanesMembers = prototype.instanceMembers;\n      if (instanesMembers) {\n        let members = Map_values(instanesMembers);\n        for (let j = 0, k = members.length; j < k; j++) {\n          let member = members[j];\n          let declaration = member.declaration;\n          if (declaration.is(CommonFlags.Override)) {\n            let basePrototype = prototype.basePrototype;\n            let hasOverride = false;\n            while (basePrototype) {\n              let instanceMembers = basePrototype.instanceMembers;\n              if (instanceMembers) {\n                if (instanceMembers.has(member.name)) {\n                  hasOverride = true;\n                  break;\n                }\n              }\n              basePrototype = basePrototype.basePrototype;\n            }\n            if (!hasOverride) {\n              let basePrototype = assert(prototype.basePrototype);\n              this.error(\n                DiagnosticCode.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,\n                declaration.name.range,\n                basePrototype.name\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.InterfacePrototype) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // check for virtual overloads in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.markVirtuals(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort, BuiltinNames.abort);\n      }\n      if (!globalAliases.has(CommonNames._g)) {\n        globalAliases.set(CommonNames._g, BuiltinNames._g);\n      }\n      if (!globalAliases.has(CommonNames.max_iterations)) {\n        globalAliases.set(CommonNames.max_iterations, BuiltinNames.max_iterations);\n      }\n      if (!globalAliases.has(CommonNames.accept)) {\n        globalAliases.set(CommonNames.accept, BuiltinNames.accept);\n      }\n      if (!globalAliases.has(CommonNames.emit)) {\n        globalAliases.set(CommonNames.emit, BuiltinNames.emit);\n      }\n      if (!globalAliases.has(CommonNames.etxn_details)) {\n        globalAliases.set(CommonNames.etxn_details, BuiltinNames.etxn_details);\n      }\n      if (!globalAliases.has(CommonNames.etxn_fee_base)) {\n        globalAliases.set(CommonNames.etxn_fee_base, BuiltinNames.etxn_fee_base);\n      }\n      if (!globalAliases.has(CommonNames.etxn_reserve)) {\n        globalAliases.set(CommonNames.etxn_reserve, BuiltinNames.etxn_reserve);\n      }\n      if (!globalAliases.has(CommonNames.float_compare)) {\n        globalAliases.set(CommonNames.float_compare, BuiltinNames.float_compare);\n      }\n      if (!globalAliases.has(CommonNames.float_divide)) {\n        globalAliases.set(CommonNames.float_divide, BuiltinNames.float_divide);\n      }\n      if (!globalAliases.has(CommonNames.float_int)) {\n        globalAliases.set(CommonNames.float_int, BuiltinNames.float_int);\n      }\n      if (!globalAliases.has(CommonNames.float_mulratio)) {\n        globalAliases.set(CommonNames.float_mulratio, BuiltinNames.float_mulratio);\n      }\n      if (!globalAliases.has(CommonNames.float_multiply)) {\n        globalAliases.set(CommonNames.float_multiply, BuiltinNames.float_multiply);\n      }\n      if (!globalAliases.has(CommonNames.float_negate)) {\n        globalAliases.set(CommonNames.float_negate, BuiltinNames.float_negate);\n      }\n      if (!globalAliases.has(CommonNames.float_set)) {\n        globalAliases.set(CommonNames.float_set, BuiltinNames.float_set);\n      }\n      if (!globalAliases.has(CommonNames.float_sto)) {\n        globalAliases.set(CommonNames.float_sto, BuiltinNames.float_sto);\n      }\n      if (!globalAliases.has(CommonNames.float_sto_set)) {\n        globalAliases.set(CommonNames.float_sto_set, BuiltinNames.float_sto_set);\n      }\n      if (!globalAliases.has(CommonNames.float_sum)) {\n        globalAliases.set(CommonNames.float_sum, BuiltinNames.float_sum);\n      }\n      if (!globalAliases.has(CommonNames.hook_account)) {\n        globalAliases.set(CommonNames.hook_account, BuiltinNames.hook_account);\n      }\n      if (!globalAliases.has(CommonNames.hook_param)) {\n        globalAliases.set(CommonNames.hook_param, BuiltinNames.hook_param);\n      }\n      if (!globalAliases.has(CommonNames.ledger_seq)) {\n        globalAliases.set(CommonNames.ledger_seq, BuiltinNames.ledger_seq);\n      }\n      if (!globalAliases.has(CommonNames.otxn_field)) {\n        globalAliases.set(CommonNames.otxn_field, BuiltinNames.otxn_field);\n      }\n      if (!globalAliases.has(CommonNames.otxn_slot)) {\n        globalAliases.set(CommonNames.otxn_slot, BuiltinNames.otxn_slot);\n      }\n      if (!globalAliases.has(CommonNames.rollback)) {\n        globalAliases.set(CommonNames.rollback, BuiltinNames.rollback);\n      }\n      if (!globalAliases.has(CommonNames.slot)) {\n        globalAliases.set(CommonNames.slot, BuiltinNames.slot);\n      }\n      if (!globalAliases.has(CommonNames.slot_count)) {\n        globalAliases.set(CommonNames.slot_count, BuiltinNames.slot_count);\n      }\n      if (!globalAliases.has(CommonNames.slot_float)) {\n        globalAliases.set(CommonNames.slot_float, BuiltinNames.slot_float);\n      }\n      if (!globalAliases.has(CommonNames.slot_set)) {\n        globalAliases.set(CommonNames.slot_set, BuiltinNames.slot_set);\n      }\n      if (!globalAliases.has(CommonNames.slot_subarray)) {\n        globalAliases.set(CommonNames.slot_subarray, BuiltinNames.slot_subarray);\n      }\n      if (!globalAliases.has(CommonNames.slot_subfield)) {\n        globalAliases.set(CommonNames.slot_subfield, BuiltinNames.slot_subfield);\n      }\n      if (!globalAliases.has(CommonNames.slot_type)) {\n        globalAliases.set(CommonNames.slot_type, BuiltinNames.slot_type);\n      }\n      if (!globalAliases.has(CommonNames.state)) {\n        globalAliases.set(CommonNames.state, BuiltinNames.state);\n      }\n      if (!globalAliases.has(CommonNames.state_foreign)) {\n        globalAliases.set(CommonNames.state_foreign, BuiltinNames.state_foreign);\n      }\n      if (!globalAliases.has(CommonNames.state_set)) {\n        globalAliases.set(CommonNames.state_set, BuiltinNames.state_set);\n      }\n      if (!globalAliases.has(CommonNames.sto_emplace)) {\n        globalAliases.set(CommonNames.sto_emplace, BuiltinNames.sto_emplace);\n      }\n      if (!globalAliases.has(CommonNames.sto_erase)) {\n        globalAliases.set(CommonNames.sto_erase, BuiltinNames.sto_erase);\n      }\n      if (!globalAliases.has(CommonNames.sto_subarray)) {\n        globalAliases.set(CommonNames.sto_subarray, BuiltinNames.sto_subarray);\n      }\n      if (!globalAliases.has(CommonNames.sto_subfield)) {\n        globalAliases.set(CommonNames.sto_subfield, BuiltinNames.sto_subfield);\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace, BuiltinNames.trace);\n      }\n      if (!globalAliases.has(CommonNames.trace_float)) {\n        globalAliases.set(CommonNames.trace_float, BuiltinNames.trace_float);\n      }\n      if (!globalAliases.has(CommonNames.trace_num)) {\n        globalAliases.set(CommonNames.trace_num, BuiltinNames.trace_num);\n      }\n      if (!globalAliases.has(CommonNames.util_accid)) {\n        globalAliases.set(CommonNames.util_accid, BuiltinNames.util_accid);\n      }\n      if (!globalAliases.has(CommonNames.util_keylet)) {\n        globalAliases.set(CommonNames.util_keylet, BuiltinNames.util_keylet);\n      }\n      if (!globalAliases.has(CommonNames.util_sha512h)) {\n        globalAliases.set(CommonNames.util_sha512h, BuiltinNames.util_sha512h);\n      }\n      if (!globalAliases.has(CommonNames.util_verify)) {\n        globalAliases.set(CommonNames.util_verify, BuiltinNames.util_verify);\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed, BuiltinNames.seed);\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            this.error(DiagnosticCode.Element_0_not_found, null, name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Marks virtual members in a base class overloaded in this class. */\n  private markVirtuals(thisPrototype: ClassPrototype, basePrototype: ClassPrototype): void {\n    // TODO: make this work with interfaaces as well\n    let thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      let thisMembers = Map_values(thisInstanceMembers);\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let j = 0, l = thisMembers.length; j < l; ++j) {\n            let thisMember = thisMembers[j];\n            if (\n              !thisMember.isAny(CommonFlags.Constructor | CommonFlags.Private) &&\n              baseInstanceMembers.has(thisMember.name)\n            ) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              if (\n                thisMember.kind == ElementKind.FunctionPrototype &&\n                baseMember.kind == ElementKind.FunctionPrototype\n              ) {\n                let thisMethod = <FunctionPrototype>thisMember;\n                let baseMethod = <FunctionPrototype>baseMember;\n                if (!thisMethod.visibilityEquals(baseMethod)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisMethod.identifierNode.range, baseMethod.identifierNode.range\n                  );\n                }\n                baseMember.set(CommonFlags.Virtual);\n                let overloads = baseMethod.overloads;\n                if (!overloads) baseMethod.overloads = overloads = new Set();\n                overloads.add(<FunctionPrototype>thisMember);\n                let baseMethodInstances = baseMethod.instances;\n                if (baseMethodInstances) {\n                  for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n                    let baseMethodInstance = _values[a];\n                    baseMethodInstance.set(CommonFlags.Virtual);\n                  }\n                }\n              } else if (\n                thisMember.kind == ElementKind.PropertyPrototype &&\n                baseMember.kind == ElementKind.PropertyPrototype\n              ) {\n                let thisProperty = <PropertyPrototype>thisMember;\n                let baseProperty = <PropertyPrototype>baseMember;\n                if (!thisProperty.visibilityEquals(baseProperty)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisProperty.identifierNode.range, baseProperty.identifierNode.range\n                  );\n                }\n                baseProperty.set(CommonFlags.Virtual);\n                let baseGetter = baseProperty.getterPrototype;\n                if (baseGetter) {\n                  baseGetter.set(CommonFlags.Virtual);\n                  let thisGetter = thisProperty.getterPrototype;\n                  if (thisGetter) {\n                    let overloads = baseGetter.overloads;\n                    if (!overloads) baseGetter.overloads = overloads = new Set();\n                    overloads.add(thisGetter);\n                  }\n                  let baseGetterInstances = baseGetter.instances;\n                  if (baseGetterInstances) {\n                    for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseGetterInstance = _values[a];\n                      baseGetterInstance.set(CommonFlags.Virtual);\n                    }\n                  }\n                }\n                let baseSetter = baseProperty.setterPrototype;\n                if (baseSetter && thisProperty.setterPrototype) {\n                  baseSetter.set(CommonFlags.Virtual);\n                  let thisSetter = thisProperty.setterPrototype;\n                  if (thisSetter) {\n                    let overloads = baseSetter.overloads;\n                    if (!overloads) baseSetter.overloads = overloads = new Set();\n                    overloads.add(thisSetter);\n                  }\n                  let baseSetterInstances = baseSetter.instances;\n                  if (baseSetterInstances) {\n                    for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseSetterInstance = _values[a];\n                      baseSetterInstance.set(CommonFlags.Virtual);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookup(name: string): Element | null {\n    let elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    let element = this.lookup(name);\n    if (!element) throw new Error(`Missing standard library component: ${name}`);\n    if (element.kind != kind) throw Error(`Invalid standard library component kind: ${name}`);\n    return element;\n  }\n\n  /** Requires that a global variable is present and returns it. */\n  requireGlobal(name: string): Global {\n    return <Global>this.require(name, ElementKind.Global);\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  requireClass(name: string): Class {\n    let prototype = this.require(name, ElementKind.ClassPrototype);\n    let resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(`Invalid standard library class: ${name}`);\n    return resolved;\n  }\n\n  /** Requires that a global function is present and returns it. */\n  requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    let prototype = <FunctionPrototype>this.require(name, ElementKind.FunctionPrototype);\n    let resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(`Invalid standard library function: ${name}`);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.ModuleExport);\n    switch (element.kind) {\n      case ElementKind.ClassPrototype: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.Property:\n      case ElementKind.Function:\n      case ElementKind.Field:\n      case ElementKind.Class: assert(false); // assumes that there are no instances yet\n    }\n    let staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Marks an element as a module import. */\n  markModuleImport(moduleName: string, name: string, element: Element): void {\n    element.set(CommonFlags.ModuleImport);\n    let moduleImports = this.moduleImports;\n    let module: Map<string,Element>;\n    if (moduleImports.has(moduleName)) {\n      module = assert(moduleImports.get(moduleName));\n    } else {\n      module = new Map();\n      moduleImports.set(moduleName, module);\n    }\n    module.set(name, element);\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    let element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.Export),\n      DecoratorFlags.Builtin\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    let wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    let element = assert(this.lookup(className));\n    assert(element.kind == ElementKind.ClassPrototype);\n    let classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.None,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.None,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    let elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing != element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    let filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** The other file. */\n    foreignFile: File,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      // check if already resolved\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // follow queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n\n          // re-exported from another file\n          if (queuedExportForeignPath) {\n            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));\n            if (!otherFile) return null;\n            foreignName = queuedExport.localIdentifier.text;\n            foreignFile = otherFile;\n            continue;\n          }\n\n          // exported from this file\n          element = foreignFile.getMember(queuedExport.localIdentifier.text);\n          if (element) return element;\n        }\n      }\n      break;\n    } while (true);\n\n    // follow star exports\n    let exportsStar = foreignFile.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    let flags = DecoratorFlags.None;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (flag == DecoratorFlags.Builtin) {\n            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {\n              this.error(\n                DiagnosticCode.Decorator_0_is_not_valid_here,\n                decorator.range, decorator.name.range.toString()\n              );\n            } else {\n              flags |= flag;\n            }\n          } else if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    return flags;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    let name = declaration.name.text;\n    let element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Final |\n        DecoratorFlags.Unmanaged\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    let implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.Unmanaged)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    // initialize members\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method && methodDeclaration.name.kind == NodeKind.Constructor) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.IndexSignature: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let name = declaration.name.text;\n    let decorators = declaration.decorators;\n    let element: DeclaredElement;\n    let acceptedFlags: DecoratorFlags = DecoratorFlags.Unsafe;\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    if (declaration.is(CommonFlags.Static)) { // global variable\n      assert(parent.kind != ElementKind.InterfacePrototype);\n      acceptedFlags |= DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Readonly)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.Abstract | CommonFlags.Get | CommonFlags.Set));\n      element = new FieldPrototype(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let isStatic = declaration.is(CommonFlags.Static);\n    let acceptedFlags = DecoratorFlags.Inline | DecoratorFlags.Unsafe;\n    if (!declaration.is(CommonFlags.Generic)) {\n      acceptedFlags |= DecoratorFlags.OperatorBinary\n                    |  DecoratorFlags.OperatorPrefix\n                    |  DecoratorFlags.OperatorPostfix;\n    }\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.Constructor);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.Operator:\n          case DecoratorKind.OperatorBinary:\n          case DecoratorKind.OperatorPrefix:\n          case DecoratorKind.OperatorPostfix: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.String)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.Invalid) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.overloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    let name = declaration.name.text;\n    if (declaration.is(CommonFlags.Static)) {\n      let parentMembers = parent.members;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    let name = declaration.name.text;\n    let isGetter = declaration.is(CommonFlags.Get);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    let element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Inline | DecoratorFlags.Unsafe\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    let name = declaration.name.text;\n    let element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Inline |\n        DecoratorFlags.Lazy\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    let values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    let name = declaration.name.text;\n    let element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.None\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    let members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let localName = member.localName.text;\n    let foreignName = member.exportedName.text;\n\n    // check for duplicates\n    let element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath == null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.getMember(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    let declaration = statement.declaration;\n    let element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.EnumDeclaration: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.ClassDeclaration: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    let foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n    if (foreignFile) {\n      let element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);\n      if (element) {\n        parent.add(declaration.name.text, element, declaration.name /* isImport */);\n        return;\n      }\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let validDecorators = DecoratorFlags.Unsafe | DecoratorFlags.Builtin;\n    if (declaration.is(CommonFlags.Ambient)) {\n      validDecorators |= DecoratorFlags.External | DecoratorFlags.ExternalJs;\n    } else {\n      validDecorators |= DecoratorFlags.Inline;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.Export)) {\n        validDecorators |= DecoratorFlags.Lazy;\n      }\n    }\n    if (!declaration.is(CommonFlags.Instance)) {\n      if (parent.kind != ElementKind.ClassPrototype) {\n        validDecorators |= DecoratorFlags.Global;\n      }\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    let name = declaration.name.text;\n    let element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    let typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.Get,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.Readonly)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.Set,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    let name = declaration.name.text;\n    let original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.Global)\n    );\n    if (!parent.add(name, original)) return null;\n    let element = assert(parent.getMember(name)); // possibly merged\n    let members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.ClassDeclaration: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.EnumDeclaration: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FunctionDeclaration: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.InterfaceDeclaration: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NamespaceDeclaration: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TypeDeclaration: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.Variable: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // keep original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let name = declaration.name.text;\n    let element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.None)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.Global | DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Ambient)) {\n        acceptedFlags |= DecoratorFlags.External;\n      }\n      if (declaration.is(CommonFlags.Const)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   let current: Class | null = target;\n  //   let arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport const enum ElementKind {\n  /** A {@link Global}. */\n  Global,\n  /** A {@link Local}. */\n  Local,\n  /** An {@link Enum}. */\n  Enum,\n  /** An {@link EnumValue}. */\n  EnumValue,\n  /** A {@link FunctionPrototype}. */\n  FunctionPrototype,\n  /** A {@link Function}. */\n  Function,\n  /** A {@link ClassPrototype}. */\n  ClassPrototype,\n  /** A {@link Class}. */\n  Class,\n  /** An {@link InterfacePrototype}. */\n  InterfacePrototype,\n  /** An {@link Interface}. */\n  Interface,\n  /** A {@link FieldPrototype}. */\n  FieldPrototype,\n  /** A {@link Field}. */\n  Field,\n  /** A {@link PropertyPrototype}.  */\n  PropertyPrototype,\n  /** A {@link Property}. */\n  Property,\n  /** A {@link Namespace}. */\n  Namespace,\n  /** A {@link File}. */\n  File,\n  /** A {@link TypeDefinition}.  */\n  TypeDefinition,\n  /** An {@link IndexSignature}. */\n  IndexSignature\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  None = 0,\n  /** Is a program global. */\n  Global = 1 << 0,\n  /** Is a binary operator overload. */\n  OperatorBinary = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OperatorPrefix = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OperatorPostfix = 1 << 3,\n  /** Is an unmanaged class. */\n  Unmanaged = 1 << 4,\n  /** Is a final class. */\n  Final = 1 << 5,\n  /** Is always inlined. */\n  Inline = 1 << 6,\n  /** Is using a different external name. */\n  External = 1 << 7,\n  /** Has external JavaScript code. */\n  ExternalJs = 1 << 8,\n  /** Is a builtin. */\n  Builtin = 1 << 9,\n  /** Is compiled lazily. */\n  Lazy = 1 << 10,\n  /** Is considered unsafe code. */\n  Unsafe = 1 << 11\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.Global: return DecoratorFlags.Global;\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: return DecoratorFlags.OperatorBinary;\n      case DecoratorKind.OperatorPrefix: return DecoratorFlags.OperatorPrefix;\n      case DecoratorKind.OperatorPostfix: return DecoratorFlags.OperatorPostfix;\n      case DecoratorKind.Unmanaged: return DecoratorFlags.Unmanaged;\n      case DecoratorKind.Final: return DecoratorFlags.Final;\n      case DecoratorKind.Inline: return DecoratorFlags.Inline;\n      case DecoratorKind.External: return DecoratorFlags.External;\n      case DecoratorKind.ExternalJs: return DecoratorFlags.ExternalJs;\n      case DecoratorKind.Builtin: return DecoratorFlags.Builtin;\n      case DecoratorKind.Lazy: return DecoratorFlags.Lazy;\n      case DecoratorKind.Unsafe: return DecoratorFlags.Unsafe;\n      default: return DecoratorFlags.None;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.None;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.File);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    let current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.File) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n  /** Tests if this element has any of the specified decorator flags. */\n  hasAnyDecorator(flags: DecoratorFlags): bool { return (this.decoratorFlags & flags) != 0; }\n\n  /** Get the member with the specified name, if any. */\n  getMember(name: string): DeclaredElement | null {\n    let members = this.members;\n    if (members && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element. */\n  lookup(name: string, isType: bool = false): Element | null {\n    return this.parent.lookup(name, isType);\n  }\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    let originalDeclaration = element.declaration;\n    let members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent != this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    let program = this.program;\n    if (element.kind != ElementKind.FunctionPrototype || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.Private | CommonFlags.Protected);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.Public);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.Private | CommonFlags.Protected;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return `${this.internalName}, kind=${this.kind}`;\n  }\n}\n\n// Kinds of all declared elements\nlet declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    let declaration = this.declaration;\n    let identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FunctionDeclaration || declaration.kind == NodeKind.MethodDeclaration) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      return Range.join(identifierNode.range, signatureNode.range);\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n\n  /** Checks if this element is a compatible override of the specified. */\n  isCompatibleOverride(base: DeclaredElement): bool {\n    let self: DeclaredElement = this; // TS\n    let kind = self.kind;\n    let checkCompatibleOverride = false;\n    if (kind == base.kind) {\n      switch (kind) {\n        case ElementKind.FunctionPrototype : {\n          let selfFunction = this.program.resolver.resolveFunction(<FunctionPrototype>self, null);\n          if (!selfFunction) return false;\n          let baseFunction = this.program.resolver.resolveFunction(<FunctionPrototype>base, null);\n          if (!baseFunction) return false;\n          self = selfFunction;\n          base = baseFunction;\n          checkCompatibleOverride = true;\n          // fall-through\n        }\n        case ElementKind.Function: {\n          return (<Function>self).signature.isAssignableTo((<Function>base).signature, checkCompatibleOverride);\n        }\n        case ElementKind.PropertyPrototype: {\n          let selfProperty = this.program.resolver.resolveProperty(<PropertyPrototype>self);\n          if (!selfProperty) return false;\n          let baseProperty = this.program.resolver.resolveProperty(<PropertyPrototype>base);\n          if (!baseProperty) return false;\n          self = selfProperty;\n          base = baseProperty;\n          // fall-through\n        }\n        case ElementKind.Property: {\n          let selfProperty = <Property>self;\n          let baseProperty = <Property>base;\n          let selfGetter = selfProperty.getterInstance;\n          let baseGetter = baseProperty.getterInstance;\n          if (selfGetter) {\n            if (!baseGetter || !selfGetter.signature.isAssignableTo(baseGetter.signature, true)) {\n              return false;\n            }\n          } else if (baseGetter) {\n            return false;\n          }\n          let selfSetter = selfProperty.setterInstance;\n          let baseSetter = baseProperty.setterInstance;\n          if (selfSetter) {\n            if (!baseSetter || !selfSetter.signature.isAssignableTo(baseSetter.signature, true)) {\n              return false;\n            }\n          } else if (baseSetter) {\n            return false;\n          }\n          return true;\n        }\n        // TODO: Implement properties overriding fields and vice-versa. Challenge is that anything overridable requires\n        // a virtual stub, but fields aren't functions. Either all (such) fields should become property-like, with a\n        // getter and a setter that can participate as a virtual stub, or it's allowed one-way, with fields integrated\n        // into what can be a virtual stub as get=load and set=store, then not necessarily with own accessor functions.\n      }\n    }\n    return false;\n  }\n}\n\n// Kinds of all typed elements\nlet typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.Resolved));\n    this.type = type;\n    this.set(CommonFlags.Resolved);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.File,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    let startFunction = this.program.makeNativeFunction(\n      `start:${this.internalName}`,\n      new Signature(program, null, Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.Global)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.getMember(name)); // possibly merged locally\n    if (element.is(CommonFlags.Export) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  getMember(name: string): DeclaredElement | null {\n    let element = super.getMember(name);\n    if (element) return element;\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].getMember(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let element = this.getMember(name);\n    if (element) return element;\n    return this.program.lookup(name); // has no meaningful parent\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    let exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LibraryEntry) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    let exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    let exports = this.exports;\n    if (exports && exports.has(name)) return assert(exports.get(name));\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string,\n    parent: Element,\n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    let declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    let ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.Scoped);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    let exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.TypeDefinition,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Namespace,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Enum,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  None,\n  /** Constant integer value. */\n  Integer,\n  /** Constant float value. */\n  Float\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.None;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Integer;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Float;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.EnumValue,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Global,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Local,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.Invalid;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overloading this one, if any. These are unbound. */\n  overloads: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.FunctionPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    let parent = this.parent;\n    let parentKind = parent.kind;\n    if (parentKind == ElementKind.PropertyPrototype) parentKind = parent.parent.kind;\n    return parentKind == ElementKind.Class || parentKind == ElementKind.Interface;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let declaration = this.declaration;\n    assert(declaration.kind == NodeKind.MethodDeclaration);\n    let bound = new FunctionPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.overloads = this.overloads;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Remembered debug locations. */\n  debugLocations: Range[] = [];\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Virtual stub for calling overloads. */\n  virtualStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.Function,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.Resolved;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    let program = prototype.program;\n    this.type = signature.type;\n    this.flow = Flow.createDefault(this);\n    if (!prototype.is(CommonFlags.Ambient)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n      }\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the types of additional locals that are not parameters. */\n  getNonParameterLocalTypes(): Type[] {\n    let localsByIndex = this.localsByIndex;\n    let signature = this.signature;\n    let numTotal = localsByIndex.length;\n    let numFixed = signature.parameterTypes.length;\n    if (signature.thisType) ++numFixed;\n    let numAdditional = numTotal - numFixed;\n    let types = new Array<Type>(numAdditional);\n    for (let i = 0; i < numAdditional; ++i) {\n      types[i] = localsByIndex[numFixed + i].type;\n    }\n    return types;\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    let parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Gets the class or interface this function belongs to, if an instance method. */\n  getClassOrInterface(): Class | null {\n    let parent = this.parent;\n    if (parent.kind == ElementKind.Property) parent = parent.parent;\n    if (parent.kind == ElementKind.Class || parent.kind == ElementKind.Interface) {\n      return <Class>parent;\n    }\n    return null;\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or virtual calls. */\n  newStub(postfix: string): Function {\n    let stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.Compiled | CommonFlags.Stub);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    let localsByIndex = this.localsByIndex;\n    let localIndex = localsByIndex.length;\n    let localName = name != null ? name : localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    let local = new Local(localName, localIndex, type, this, declaration);\n    if (name) {\n      let defaultFlow = this.flow;\n      let scopedLocals = defaultFlow.scopedLocals;\n      if (!scopedLocals) defaultFlow.scopedLocals = scopedLocals = new Map();\n      if (scopedLocals.has(name)) throw new Error(\"duplicate local name\");\n      scopedLocals.set(name, local);\n    }\n    localsByIndex[localIndex] = local;\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    if (!isType) {\n      let scopedLocals = this.flow.scopedLocals;\n      if (scopedLocals && scopedLocals.has(name)) {\n        return assert(scopedLocals.get(name));\n      }\n    }\n    return super.lookup(name, isType);\n  }\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n  breakLabel: string | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    let breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // internal error\n    this.breakStack = breakStack = null;\n    this.breakLabel = null;\n    this.addDebugInfo(module, ref);\n  }\n\n  addDebugInfo(module: Module, ref: FunctionRef): void {\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\n        let range = debugLocations[i];\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          range.debugInfoRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n    if (this.program.options.debugInfo) {\n      let localNameMap = new Set<string>();\n      let localsByIndex = this.localsByIndex;\n      for (let i = 0, k = localsByIndex.length; i < k; i++) {\n        let localName = localsByIndex[i].name;\n        if (localNameMap.has(localName)) {\n          localName = `${localName}|${i}`;\n        }\n        localNameMap.add(localName);\n        module.setLocalName(ref, i, localName);\n      }\n    }\n  }\n}\n\n/** A yet unresolved instance field prototype. */\nexport class FieldPrototype extends DeclaredElement {\n\n  /** Constructs a new field prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent class. */\n    parent: ClassPrototype,\n    /** Declaration reference. */\n    declaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.FieldPrototype,\n      name,\n      mangleInternalName(name, parent, assert(declaration.is(CommonFlags.Instance))),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    return (<FieldDeclaration>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<FieldDeclaration>this.declaration).initializer;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    return (<FieldDeclaration>this.declaration).parameterIndex;\n  }\n}\n\n/** A resolved instance field. */\nexport class Field extends VariableLikeElement {\n\n  /** Field prototype reference. */\n  prototype: FieldPrototype;\n  /** Field memory offset, if an instance field. */\n  memoryOffset: i32 = -1;\n  /** Getter function reference, if compiled. */\n  getterRef: FunctionRef = 0;\n  /** Setter function reference, if compiled. */\n  setterRef: FunctionRef = 0;\n\n  /** Constructs a new field. */\n  constructor(\n    /** Respective field prototype. */\n    prototype: FieldPrototype,\n    /** Parent class. */\n    parent: Class,\n    /** Concrete type. */\n    type: Type\n  ) {\n    super(\n      ElementKind.Field,\n      prototype.name,\n      parent,\n      <VariableLikeDeclarationStatement>prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    assert(type != Type.void);\n    this.setType(type);\n    registerConcreteElement(this.program, this);\n  }\n\n  /** Gets the field's `this` type. */\n  get thisType(): Type {\n    let parent = this.parent;\n    assert(parent.kind == ElementKind.Class);\n    return (<Class>parent).type;\n  }\n\n  /** Gets the internal name of the respective getter function. */\n  get internalGetterName(): string {\n    let cached = this._internalGetterName;\n    if (cached == null) {\n      this._internalGetterName = cached = `${this.parent.internalName}${INSTANCE_DELIMITER}${GETTER_PREFIX}${this.name}`;\n    }\n    return cached;\n  }\n  private _internalGetterName: string | null = null;\n\n  /** Gets the internal name of the respective setter function. */\n  get internalSetterName(): string {\n    let cached = this._internalSetterName;\n    if (cached == null) {\n      this._internalSetterName = cached = `${this.parent.internalName}${INSTANCE_DELIMITER}${SETTER_PREFIX}${this.name}`;\n    }\n    return cached;\n  }\n  private _internalSetterName: string | null = null;\n\n  /** Gets the signature of the respective getter function. */\n  get internalGetterSignature(): Signature {\n    let cached = this._internalGetterSignature;\n    if (!cached) {\n      this._internalGetterSignature = cached = new Signature(this.program, null, this.type, this.thisType);\n    }\n    return cached;\n  }\n  private _internalGetterSignature: Signature | null = null;\n\n  /** Gets the signature of the respective setter function. */\n  get internalSetterSignature(): Signature {\n    let cached = this._internalSetterSignature;\n    if (!cached) {\n      this._internalSetterSignature = cached = new Signature(this.program, [ this.type ], Type.void, this.thisType);\n    }\n    return cached;\n  }\n  private _internalSetterSignature: Signature | null = null;\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PropertyPrototype,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.Get | CommonFlags.Set);\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    switch (this.parent.kind) {\n      case ElementKind.Class:\n      case ElementKind.Interface: return true;\n    }\n    return false;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.MethodDeclaration);\n    let bound = new PropertyPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    let getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    let setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.Property,\n      prototype.name,\n      parent,\n      Node.createVariableDeclaration(\n        prototype.identifierNode,\n        null,\n        prototype.is(CommonFlags.Instance)\n          ? CommonFlags.Instance\n          : CommonFlags.None,\n        null, null,\n        prototype.identifierNode.range\n      )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.Instance)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.IndexSignature,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  overloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extendees: Set<ClassPrototype> = new Set();\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.InterfacePrototype : ElementKind.ClassPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    let arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    let current: ClassPrototype | null = this;\n    let seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current == basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    let originalDeclaration = element.declaration;\n    let instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.Export) && this.is(CommonFlags.ModuleExport)) {\n      element.set(CommonFlags.ModuleExport); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if applicable. */\n  base: Class | null = null;\n  /** Implemented interfaces, if applicable. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  overloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly extending this class. */\n  extendees: Set<Class> | null = null;\n  /** Classes implementing this interface. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    let lengthField = this.getMember(\"length\");\n    if (!lengthField) return false;\n    return (\n      lengthField.kind == ElementKind.Field ||\n      (\n        lengthField.kind == ElementKind.PropertyPrototype &&\n        (<PropertyPrototype>lengthField).getterPrototype != null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.IndexedGet) != null ||\n      this.lookupOverload(OperatorKind.UncheckedIndexedGet) != null\n    );\n  }\n\n  /** Tests if this is an interface. */\n  get isInterface(): bool {\n    return this.kind == ElementKind.Interface;\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.Interface : ElementKind.Class,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    let program = this.program;\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    let usizeType = program.options.usizeType;\n    let type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    let typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n    let extendees = base.extendees;\n    if (!extendees) base.extendees = extendees = new Set();\n    extendees.add(this);\n\n    // Inherit contextual type arguments from base class\n    let inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    let interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n    let implementers = iface.implementers;\n    if (!implementers) iface.implementers = implementers = new Set();\n    implementers.add(this);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    let current: Class | null = this;\n    do {\n      if (current == target) return true;\n      if (target.kind == ElementKind.Interface) {\n        let interfaces = current.interfaces;\n        if (interfaces) {\n          for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n            let iface = _values[i];\n            if (iface.isAssignableTo(target)) return true;\n          }\n        }\n      }\n      current = current.base;\n    } while (current);\n    return false;\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.IndexedGet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedGet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.IndexedSet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedSet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    let instance: Class | null = this;\n    do {\n      let overloads = instance.overloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /** Gets the method of the specified name, resolved with the given type arguments. */\n  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.FunctionPrototype) {\n      return this.program.resolver.resolveFunction(<FunctionPrototype>member, typeArguments);\n    }\n    return null;\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    let member = assert(this.getMember(fieldName));\n    assert(member.kind == ElementKind.Field);\n    return (<Field>member).memoryOffset;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    let program = this.program;\n    let payloadSize = this.nextMemoryOffset + overhead;\n    let blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead\n    let buffer = new Uint8Array(program.blockOverhead + blockSize);\n    let OBJECT = program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", blockSize, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 0, buffer, 0);\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", payloadSize, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.Field) {\n      let fieldInstance = <Field>member;\n      let offset = baseOffset + fieldInstance.memoryOffset;\n      let typeKind = fieldInstance.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.Isize:\n        case TypeKind.Usize: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.Usize);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.Usize);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extends(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    let current: Class | null = this;\n    do {\n      if (current.prototype == extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    let current: Class = this;\n    let program = this.program;\n    let arrayPrototype = program.arrayPrototype;\n    if (this.extends(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    let staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extends(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    let abvInstance = program.arrayBufferViewInstance;\n    while (current.base != abvInstance) {\n      current = assert(current.base);\n    }\n    let prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is pointerfree. Useful to know for the GC. */\n  get isPointerfree(): bool {\n    let program = this.program;\n\n    let instanceMembers = this.members;\n    if (instanceMembers) {\n\n      // Check that there are no managed instance fields\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.Field) {\n          let fieldType = (<Field>member).type;\n          if (fieldType.isManaged) return false;\n        }\n      }\n\n      // Check that this isn't a managed collection\n      if (instanceMembers.has(CommonNames.visit)) {\n        let prototype = this.prototype;\n        if (\n          prototype == program.arrayPrototype ||\n          prototype == program.staticArrayPrototype ||\n          prototype == program.setPrototype ||\n          prototype == program.mapPrototype\n        ) {\n          // Note that we cannot know for sure anymore as soon as the collection\n          // is extended, because user code may implement a custom visitor.\n          let typeArguments = assert(this.getTypeArgumentsTo(prototype));\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (typeArguments[i].isManaged) return false;\n          }\n          return true;\n        }\n        return false; // has a custom __visit\n      }\n    }\n    return true;\n  }\n\n  /** Gets all extendees of this class (that do not have the specified instance member). */\n  getAllExtendees(exceptIfMember: string | null = null, out: Set<Class> = new Set()): Set<Class> {\n    let extendees = this.extendees;\n    if (extendees) {\n      for (let _values = Set_values(extendees), i = 0, k = _values.length; i < k; ++i) {\n        let extendee = _values[i];\n        if (exceptIfMember) {\n          let instanceMembers = extendee.prototype.instanceMembers;\n          if (instanceMembers && instanceMembers.has(exceptIfMember)) continue;\n        }\n        out.add(extendee);\n        extendee.getAllExtendees(exceptIfMember, out);\n      }\n    }\n    return out;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program == newer.program);\n  if (newer.members) return null;\n  let merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FunctionPrototype: {\n      switch (newer.kind) {\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.ClassPrototype:\n    case ElementKind.Enum: {\n      if (newer.kind == ElementKind.Namespace) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.Namespace: {\n      switch (newer.kind) {\n        case ElementKind.Enum:\n        case ElementKind.ClassPrototype:      // TS2434\n        case ElementKind.FunctionPrototype: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.Global: {\n      if (newer.kind == ElementKind.TypeDefinition) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TypeDefinition: {\n      switch (newer.kind) {\n        case ElementKind.Global:\n        case ElementKind.FunctionPrototype:\n        case ElementKind.Namespace: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.Export) || older.hasDecorator(DecoratorFlags.Global);\n    let newerIsExport = newer.is(CommonFlags.Export) || newer.hasDecorator(DecoratorFlags.Global);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  let srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(\n  name: string,\n  parent: Element,\n  isInstance: bool,\n  asGlobal: bool = false\n): string {\n  switch (parent.kind) {\n    case ElementKind.File: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.Function: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PropertyPrototype: // properties are just containers\n    case ElementKind.Property: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return (\n        mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.Instance), asGlobal) +\n        (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name\n      );\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nlet cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(`$${i}`);\n  }\n  return cachedDefaultParameterNames[index];\n}\n", "/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  CommonNames\n} from \"./common\";\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags\n} from \"./program\";\n\nimport {\n  TypeRef,\n  createType,\n  HeapTypeRef,\n  ensureType\n} from \"./module\";\n\nimport * as binaryen from \"./glue/binaryen\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n  /** A 1-bit unsigned integer. */\n  Bool,\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  Isize,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  Usize,\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references\n\n  /** Function reference. */\n  Funcref,\n  /** External reference. */\n  Externref,\n  /** Any reference. */\n  Anyref,\n  /** Equatable reference. */\n  Eqref,\n  /** 31-bit integer reference. */\n  I31ref,\n  /** Data reference. */\n  Dataref,\n  /** Array reference. */\n  Arrayref,\n  /** String reference. */\n  Stringref,\n  /** WTF8 string view. */\n  StringviewWTF8,\n  /** WTF16 string view. */\n  StringviewWTF16,\n  /** String iterator. */\n  StringviewIter,\n\n  // other\n\n  /** No return type. */\n  Void\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  None = 0,\n  /** Is a signed type that can represent negative values. */\n  Signed = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  Unsigned = 1 << 1,\n  /** Is an integer type. */\n  Integer = 1 << 2,\n  /** Is a floating point type. */\n  Float = 1 << 3,\n  /** Is a varying (in size) type. */\n  Varying = 1 << 4,\n  /** Is smaller than 32-bits. */\n  Short = 1 << 5,\n  /** Is larger than 32-bits. */\n  Long = 1 << 6,\n  /** Is a value type. */\n  Value = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  Reference = 1 << 8,\n  /** Is a nullable type. */\n  Nullable = 1 << 9,\n  /** Is a vector type. */\n  Vector = 1 << 10,\n  /** Is an external type. */\n  External = 1 << 11,\n  /** Is a class. */\n  Class = 1 << 12,\n  /** Is a function. */\n  Function = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null = null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null = null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n  /** Cached Binaryen type reference. */\n  ref: TypeRef = 0;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    if (!(flags & TypeFlags.Nullable)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I32:\n      case TypeKind.F32:   return Type.i32;\n      case TypeKind.I8:    return Type.i8;\n      case TypeKind.I16:   return Type.i16;\n      case TypeKind.F64:\n      case TypeKind.I64:   return Type.i64;\n      case TypeKind.Isize: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8:    return Type.u8;\n      case TypeKind.U16:   return Type.u16;\n      case TypeKind.U32:   return Type.u32;\n      case TypeKind.U64:   return Type.u64;\n      case TypeKind.Usize: return this.size == 64 ? Type.usize64 : Type.usize32;\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    return this.kind == TypeKind.Void ? Type.auto : this;\n  }\n\n  /** Size in bytes. */\n  get byteSize(): i32 {\n    // ceiled div by 8\n    return this.size + 7 >>> 3;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.Short | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.Long | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.Signed | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.Unsigned | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.Varying | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.Integer);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.Float | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.Vector | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.Nullable | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.External | TypeFlags.Reference);\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.getClass() != null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.getSignature() != null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.Unmanaged);\n      return this.signatureReference != null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    let classReference = this.classReference;\n    return classReference != null && classReference.hasDecorator(DecoratorFlags.Unmanaged);\n  }\n\n  get isMemory(): bool {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64:\n      case TypeKind.V128: return true;\n    }\n    return false;\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    if (this.isExternalReference) {\n      return this; // TODO\n    }\n    return assert(this._nonNullableType); // set either in ctor or asNullable\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this._nullableType; // set either in ctor or asNullable\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    let size = this.size;\n    if (!this.is(TypeFlags.Unsigned)) size -= 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isInternalReference);\n    let nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.Nullable, this.size);\n      nullableType.classReference = this.classReference;         // either a class reference\n      nullableType.signatureReference = this.signatureReference; // or a function reference\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Use unsigned type for according size if possible. */\n  toUnsigned(): Type {\n    switch (this.kind) {\n      case TypeKind.I8:    return Type.u8;\n      case TypeKind.I16:   return Type.u16;\n      case TypeKind.I32:   return Type.u32;\n      case TypeKind.I64:   return Type.u64;\n      case TypeKind.Isize: return this.size == 64 ? Type.usize64 : Type.usize32;\n    }\n    return this;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) return false;\n    if (this.isReference) {\n      return (\n        this.classReference == other.classReference &&\n        this.signatureReference == other.signatureReference &&\n        this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    let currentClass: Class | null;\n    let targetClass: Class | null;\n    let currentFunction: Signature | null;\n    let targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference) {\n            if (\n              this.kind == target.kind ||\n              (target.kind == TypeKind.Anyref && this.kind != TypeKind.Externref)\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.Integer) && target.is(TypeFlags.Integer)) {\n      let size = this.size;\n      return size == target.size && (\n        size >= 32 ||\n        this.is(TypeFlags.Signed) == target.is(TypeFlags.Signed)\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if this type can extend or implement the given type. */\n  canExtendOrImplement(base: Type): bool {\n    // Both must be class types\n    let thisClass = this.getClass();\n    let baseClass = base.getClass();\n    if (!thisClass || !baseClass) return false;\n    // Both types must be either managed or unmanaged\n    if (this.isManaged != base.isManaged) return false;\n    // Both types must be either internal or external references\n    if (this.isInternalReference) {\n      if (!base.isInternalReference) return false;\n    } else if (this.isExternalReference) {\n      if (!base.isExternalReference) return false;\n    } else {\n      return false;\n    }\n    // Interfaces can only extend interfaces\n    if (thisClass.isInterface && !baseClass.isInterface) return false;\n    return true;\n  }\n\n  /** Determines the common denominator type of two types, if there is any. */\n  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {\n    if (right.isAssignableTo(left, signednessIsImportant)) return left;\n    else if (left.isAssignableTo(right, signednessIsImportant)) return right;\n    return null;\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat ? \"|null\" : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? `(${signatureReference.toString(validWat)})${nullablePostfix}`\n            : signatureReference.toString(validWat);\n        }\n      }\n    }\n    switch (this.kind) {\n      case TypeKind.Bool: return CommonNames.bool;\n      case TypeKind.I8: return CommonNames.i8;\n      case TypeKind.I16: return CommonNames.i16;\n      case TypeKind.I32: return CommonNames.i32;\n      case TypeKind.I64: return CommonNames.i64;\n      case TypeKind.Isize: return CommonNames.isize;\n      case TypeKind.U8: return CommonNames.u8;\n      case TypeKind.U16: return CommonNames.u16;\n      case TypeKind.U32: return CommonNames.u32;\n      case TypeKind.U64: return CommonNames.u64;\n      case TypeKind.Usize: return CommonNames.usize;\n      case TypeKind.F32: return CommonNames.f32;\n      case TypeKind.F64: return CommonNames.f64;\n      case TypeKind.V128: return CommonNames.v128;\n      case TypeKind.Funcref: return CommonNames.funcref;\n      case TypeKind.Externref: return CommonNames.externref;\n      case TypeKind.Anyref: return CommonNames.anyref;\n      case TypeKind.Eqref: return CommonNames.eqref;\n      case TypeKind.I31ref: return CommonNames.i31ref;\n      case TypeKind.Dataref: return CommonNames.dataref;\n      case TypeKind.Arrayref: return CommonNames.arrayref;\n      case TypeKind.Stringref: return CommonNames.stringref;\n      case TypeKind.StringviewWTF8: return CommonNames.stringview_wtf8;\n      case TypeKind.StringviewWTF16: return CommonNames.stringview_wtf16;\n      case TypeKind.StringviewIter: return CommonNames.stringview_iter;\n      default: assert(false);\n      case TypeKind.Void: return CommonNames.void_;\n    }\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective type reference. */\n  toRef(): TypeRef {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return TypeRef.I32;\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (this.size != 64) return TypeRef.I32;\n      case TypeKind.I64:\n      case TypeKind.U64:  return TypeRef.I64;\n      case TypeKind.F32:  return TypeRef.F32;\n      case TypeKind.F64:  return TypeRef.F64;\n      case TypeKind.V128: return TypeRef.V128;\n      case TypeKind.Funcref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Externref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Anyref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Eqref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.I31ref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Dataref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Data, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Arrayref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Stringref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewWTF8: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF8, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewWTF16: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF16, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewIter: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewIter, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Void: return TypeRef.None;\n    }\n    // TODO: not used yet\n    assert(false);\n    return ensureType(this);\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.Bool,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.Signed   |\n    TypeFlags.Float    |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Float    |\n    TypeFlags.Value,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.Vector   |\n    TypeFlags.Value, 128\n  );\n\n  /** Function reference. */\n  static readonly funcref: Type = new Type(TypeKind.Funcref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** External reference. */\n  static readonly externref: Type = new Type(TypeKind.Externref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Any reference. */\n  static readonly anyref: Type = new Type(TypeKind.Anyref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Equatable reference. */\n  static readonly eqref: Type = new Type(TypeKind.Eqref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** 31-bit integer reference. */\n  static readonly i31ref: Type = new Type(TypeKind.I31ref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Data reference. */\n  static readonly dataref: Type = new Type(TypeKind.Dataref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Array reference. */\n  static readonly arrayref: Type = new Type(TypeKind.Arrayref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** String reference. */\n  static readonly stringref: Type = new Type(TypeKind.Stringref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** WTF8 string view. */\n  static readonly stringview_wtf8: Type = new Type(TypeKind.StringviewWTF8,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** WTF16 string view. */\n  static readonly stringview_wtf16: Type = new Type(TypeKind.StringviewWTF16,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** String iterator. */\n  static readonly stringview_iter: Type = new Type(TypeKind.StringviewIter,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.Void, TypeFlags.None, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of type references. */\nexport function typesToRefs(types: Type[]): TypeRef[] {\n  let numTypes = types.length;\n  let ret = new Array<TypeRef>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(ret[i] = types[i].toRef());\n  }\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  let numTypes = types.length;\n  if (!numTypes) return \"\";\n  let sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(sb[i] = types[i].toString(true));\n  }\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Unique id representing this signature. */\n  id: u32 = 0;\n  /** Parameter types, if any, excluding `this`. */\n  parameterTypes: Type[];\n  /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n  requiredParameters: i32;\n  /** Return type. */\n  returnType: Type;\n  /** This type, if an instance signature. */\n  thisType: Type | null;\n  /** Whether the last parameter is a rest parameter. */\n  hasRest: bool;\n  /** Respective function type. */\n  type: Type;\n  /** The program that created this signature. */\n  program: Program;\n\n  /** Constructs a new signature. */\n  constructor(\n    program: Program,\n    parameterTypes: Type[] | null = null,\n    returnType: Type | null = null,\n    thisType: Type | null = null\n  ) {\n    this.parameterTypes = parameterTypes ? parameterTypes : [];\n    this.requiredParameters = 0;\n    this.returnType = returnType ? returnType : Type.void;\n    this.thisType = thisType;\n    this.program = program;\n    this.hasRest = false;\n    let usizeType = program.options.usizeType;\n    let type = new Type(\n      usizeType.kind,\n      usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference,\n      usizeType.size\n    );\n    this.type = type;\n    type.signatureReference = this;\n\n    let signatureTypes = program.uniqueSignatures;\n    let length = signatureTypes.length;\n    for (let i = 0; i < length; i++) {\n      let compare = unchecked(signatureTypes[i]);\n      if (this.equals(compare)) {\n        this.id = compare.id;\n        return this;\n      }\n    }\n    this.id = program.nextSignatureId++;\n    signatureTypes.push(this);\n  }\n\n  get paramRefs(): TypeRef {\n    let thisType = this.thisType;\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      return thisType ? thisType.toRef() : TypeRef.None;\n    }\n    if (thisType) {\n      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);\n      unchecked(typeRefs[0] = thisType.toRef());\n      for (let i = 0; i < numParameterTypes; ++i) {\n        unchecked(typeRefs[i + 1] = parameterTypes[i].toRef());\n      }\n      return createType(typeRefs);\n    }\n    return createType(typesToRefs(parameterTypes));\n  }\n\n  get resultRefs(): TypeRef {\n    return this.returnType.toRef();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    let thisThisType = this.thisType;\n    let otherThisType = other.thisType;\n    if (thisThisType) {\n      if (!otherThisType || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check return type\n    if (!this.returnType.equals(other.returnType)) return false;\n\n    // check parameter types\n    let thisParameterTypes = this.parameterTypes;\n    let otherParameterTypes = other.parameterTypes;\n    let numParameters = thisParameterTypes.length;\n    if (numParameters != otherParameterTypes.length) return false;\n\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = unchecked(thisParameterTypes[i]);\n      let otherParameterType = unchecked(otherParameterTypes[i]);\n      if (!thisParameterType.equals(otherParameterType)) return false;\n    }\n    return true;\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, checkCompatibleOverride: bool = false): bool {\n    let thisThisType = this.thisType;\n    let targetThisType = target.thisType;\n    if (!checkCompatibleOverride) {\n      // check exact `this` type\n      if (thisThisType) {\n        if (!targetThisType || !thisThisType.isAssignableTo(targetThisType)) {\n          return false;\n        }\n      } else if (targetThisType) {\n        return false;\n      }\n    } else {\n      // check kind of `this` type\n      if (thisThisType) {\n        if (!targetThisType || !thisThisType.canExtendOrImplement(targetThisType)) {\n          return false;\n        }\n      } else if (targetThisType) {\n        return false;\n      }\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check return type\n    let thisReturnType = this.returnType;\n    let targetReturnType = target.returnType;\n    if (!(thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType))) {\n      return false;\n    }\n    // check parameter types\n    let thisParameterTypes = this.parameterTypes;\n    let targetParameterTypes = target.parameterTypes;\n    let numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = unchecked(thisParameterTypes[i]);\n      let targetParameterType = unchecked(targetParameterTypes[i]);\n      if (!thisParameterType.isAssignableTo(targetParameterType)) return false;\n    }\n    return true;\n  }\n\n  /** Tests if this signature has at least one managed operand. */\n  get hasManagedOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isManaged) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all managed operands. */\n  getManagedOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Tests if this signature has at least one v128 operand. */\n  get hasVectorValueOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isVectorValue) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all v128 operands. */\n  getVectorValueOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isVectorValue) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    let sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      assert(!thisType.signatureReference);\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    let parameters = this.parameterTypes;\n    let numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(): Signature {\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    let cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      unchecked(cloneParameterTypes[i] = parameterTypes[i]);\n    }\n    return new Signature(\n      this.program,\n      cloneParameterTypes,\n      this.returnType,\n      this.thisType\n    );\n  }\n}\n", "/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  CallExpression,\n  Node,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  SIMDLoadOp,\n  SIMDLoadStoreLaneOp,\n  RefIsOp,\n  TypeRef,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags,\n  mustPreserveSideEffects\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Field,\n  Global,\n  DecoratorFlags,\n  ClassPrototype,\n  Class\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  CommonNames,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const _g = \"~lib/builtins/_g\";\n  export const max_iterations = \"~lib/builtins/max_iterations\";\n  export const accept = \"~lib/builtins/$accept\";\n  export const emit = \"~lib/builtins/$emit\";\n  export const etxn_details = \"~lib/builtins/$etxn_details\";\n  export const etxn_fee_base = \"~lib/builtins/$etxn_fee_base\";\n  export const etxn_reserve = \"~lib/builtins/$etxn_reserve\";\n  export const float_compare = \"~lib/builtins/$float_compare\";\n  export const float_divide = \"~lib/builtins/$float_divide\";\n  export const float_int = \"~lib/builtins/$float_int\";\n  export const float_mulratio = \"~lib/builtins/$float_mulratio\";\n  export const float_multiply = \"~lib/builtins/$float_multiply\";\n  export const float_negate = \"~lib/builtins/$float_negate\";\n  export const float_set = \"~lib/builtins/$float_set\";\n  export const float_sto = \"~lib/builtins/$float_sto\";\n  export const float_sto_set = \"~lib/builtins/$float_sto_set\";\n  export const float_sum = \"~lib/builtins/$float_sum\";\n  export const hook_account = \"~lib/builtins/$hook_account\";\n  export const hook_param = \"~lib/builtins/$hook_param\";\n  export const ledger_seq = \"~lib/builtins/ledger_seq\";\n  export const otxn_field = \"~lib/builtins/otxn_field\";\n  export const otxn_slot = \"~lib/builtins/$otxn_slot\";\n  export const rollback = \"~lib/builtins/$rollback\";\n  export const slot = \"~lib/builtins/$slot\";\n  export const slot_count = \"~lib/builtins/$slot_count\";\n  export const slot_float = \"~lib/builtins/$slot_float\";\n  export const slot_set = \"~lib/builtins/$slot_set\";\n  export const slot_subarray = \"~lib/builtins/$slot_subarray\";\n  export const slot_subfield = \"~lib/builtins/$slot_subfield\";\n  export const slot_type = \"~lib/builtins/$slot_type\";\n  export const state = \"~lib/builtins/$state\";\n  export const state_foreign = \"~lib/builtins/$state_foreign\";\n  export const state_set = \"~lib/builtins/$state_set\";\n  export const sto_emplace = \"~lib/builtins/$sto_emplace\";\n  export const sto_erase = \"~lib/builtins/$sto_erase\";\n  export const sto_subarray = \"~lib/builtins/$sto_subarray\";\n  export const sto_subfield = \"~lib/builtins/$sto_subfield\";\n  export const trace = \"~lib/builtins/trace\";\n  export const trace_float = \"~lib/builtins/$trace_float\";\n  export const trace_num = \"~lib/builtins/$trace_num\";\n  export const util_accid = \"~lib/builtins/$util_accid\";\n  export const util_keylet = \"~lib/builtins/$util_keylet\";\n  export const util_sha512h = \"~lib/builtins/$util_sha512h\";\n  export const util_verify = \"~lib/builtins/$util_verify\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isVector = \"~lib/builtins/isVector\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const bswap = \"~lib/builtins/bswap\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const eq = \"~lib/builtins/eq\";\n  export const ne = \"~lib/builtins/ne\";\n  export const rem = \"~lib/builtins/rem\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_eq = \"~lib/builtins/i32.eq\";\n  export const i64_eq = \"~lib/builtins/i64.eq\";\n  export const f32_eq = \"~lib/builtins/f32.eq\";\n  export const f64_eq = \"~lib/builtins/f64.eq\";\n  export const i32_ne = \"~lib/builtins/i32.ne\";\n  export const i64_ne = \"~lib/builtins/i64.ne\";\n  export const f32_ne = \"~lib/builtins/f32.ne\";\n  export const f64_ne = \"~lib/builtins/f64.ne\";\n\n  export const i32_rem_s = \"~lib/builtins/i32.rem_s\";\n  export const i32_rem_u = \"~lib/builtins/i32.rem_u\";\n  export const i64_rem_s = \"~lib/builtins/i64.rem_s\";\n  export const i64_rem_u = \"~lib/builtins/i64.rem_u\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const i32_wait = \"~lib/builtins/i32.wait\";\n  export const i64_wait = \"~lib/builtins/i64.wait\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load_zero = \"~lib/builtins/v128.load_zero\";\n  export const v128_load_lane = \"~lib/builtins/v128.load_lane\";\n  export const v128_store_lane = \"~lib/builtins/v128.store_lane\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_load8x8_s = \"~lib/builtins/v128.load8x8_s\";\n  export const v128_load8x8_u = \"~lib/builtins/v128.load8x8_u\";\n  export const v128_load16x4_s = \"~lib/builtins/v128.load16x4_s\";\n  export const v128_load16x4_u = \"~lib/builtins/v128.load16x4_u\";\n  export const v128_load32x2_s = \"~lib/builtins/v128.load32x2_s\";\n  export const v128_load32x2_u = \"~lib/builtins/v128.load32x2_u\";\n  export const v128_load8_splat = \"~lib/builtins/v128.load8_splat\";\n  export const v128_load16_splat = \"~lib/builtins/v128.load16_splat\";\n  export const v128_load32_splat = \"~lib/builtins/v128.load32_splat\";\n  export const v128_load64_splat = \"~lib/builtins/v128.load64_splat\";\n  export const v128_load32_zero = \"~lib/builtins/v128.load32_zero\";\n  export const v128_load64_zero = \"~lib/builtins/v128.load64_zero\";\n  export const v128_load8_lane = \"~lib/builtins/v128.load8_lane\";\n  export const v128_load16_lane = \"~lib/builtins/v128.load16_lane\";\n  export const v128_load32_lane = \"~lib/builtins/v128.load32_lane\";\n  export const v128_load64_lane = \"~lib/builtins/v128.load64_lane\";\n  export const v128_store8_lane = \"~lib/builtins/v128.store8_lane\";\n  export const v128_store16_lane = \"~lib/builtins/v128.store16_lane\";\n  export const v128_store32_lane = \"~lib/builtins/v128.store32_lane\";\n  export const v128_store64_lane = \"~lib/builtins/v128.store64_lane\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_sat = \"~lib/builtins/v128.add_sat\";\n  export const v128_sub_sat = \"~lib/builtins/v128.sub_sat\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_popcnt = \"~lib/builtins/v128.popcnt\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_convert_low = \"~lib/builtins/v128.convert_low\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_trunc_sat_zero = \"~lib/builtins/v128.trunc_sat_zero\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_extend_low = \"~lib/builtins/v128.extend_low\";\n  export const v128_extend_high = \"~lib/builtins/v128.extend_high\";\n  export const v128_extadd_pairwise = \"~lib/builtins/v128.extadd_pairwise\";\n  export const v128_demote_zero = \"~lib/builtins/v128.demote_zero\";\n  export const v128_promote_low = \"~lib/builtins/v128.promote_low\";\n  export const v128_q15mulr_sat = \"~lib/builtins/v128.q15mulr_sat\";\n  export const v128_extmul_low = \"~lib/builtins/v128.extmul_low\";\n  export const v128_extmul_high = \"~lib/builtins/v128.extmul_high\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_sat_s = \"~lib/builtins/i8x16.add_sat_s\";\n  export const i8x16_add_sat_u = \"~lib/builtins/i8x16.add_sat_u\";\n  export const i8x16_sub_sat_s = \"~lib/builtins/i8x16.sub_sat_s\";\n  export const i8x16_sub_sat_u = \"~lib/builtins/i8x16.sub_sat_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_popcnt = \"~lib/builtins/i8x16.popcnt\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n  export const i8x16_shuffle = \"~lib/builtins/i8x16.shuffle\";\n  export const i8x16_swizzle = \"~lib/builtins/i8x16.swizzle\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_sat_s = \"~lib/builtins/i16x8.add_sat_s\";\n  export const i16x8_add_sat_u = \"~lib/builtins/i16x8.add_sat_u\";\n  export const i16x8_sub_sat_s = \"~lib/builtins/i16x8.sub_sat_s\";\n  export const i16x8_sub_sat_u = \"~lib/builtins/i16x8.sub_sat_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_extend_low_i8x16_s = \"~lib/builtins/i16x8.extend_low_i8x16_s\";\n  export const i16x8_extend_low_i8x16_u = \"~lib/builtins/i16x8.extend_low_i8x16_u\";\n  export const i16x8_extend_high_i8x16_s = \"~lib/builtins/i16x8.extend_high_i8x16_s\";\n  export const i16x8_extend_high_i8x16_u = \"~lib/builtins/i16x8.extend_high_i8x16_u\";\n  export const i16x8_extadd_pairwise_i8x16_s = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_s\";\n  export const i16x8_extadd_pairwise_i8x16_u = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_u\";\n  export const i16x8_q15mulr_sat_s = \"~lib/builtins/i16x8.q15mulr_sat_s\";\n  export const i16x8_extmul_low_i8x16_s = \"~lib/builtins/i16x8.extmul_low_i8x16_s\";\n  export const i16x8_extmul_low_i8x16_u = \"~lib/builtins/i16x8.extmul_low_i8x16_u\";\n  export const i16x8_extmul_high_i8x16_s = \"~lib/builtins/i16x8.extmul_high_i8x16_s\";\n  export const i16x8_extmul_high_i8x16_u = \"~lib/builtins/i16x8.extmul_high_i8x16_u\";\n  export const i16x8_shuffle = \"~lib/builtins/i16x8.shuffle\";\n  export const i16x8_swizzle = \"~lib/builtins/i16x8.swizzle\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_trunc_sat_f64x2_s_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_s_zero\";\n  export const i32x4_trunc_sat_f64x2_u_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_u_zero\";\n  export const i32x4_extend_low_i16x8_s = \"~lib/builtins/i32x4.extend_low_i16x8_s\";\n  export const i32x4_extend_low_i16x8_u = \"~lib/builtins/i32x4.extend_low_i16x8_u\";\n  export const i32x4_extend_high_i16x8_s = \"~lib/builtins/i32x4.extend_high_i16x8_s\";\n  export const i32x4_extend_high_i16x8_u = \"~lib/builtins/i32x4.extend_high_i16x8_u\";\n  export const i32x4_extadd_pairwise_i16x8_s = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_s\";\n  export const i32x4_extadd_pairwise_i16x8_u = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_u\";\n  export const i32x4_extmul_low_i16x8_s = \"~lib/builtins/i32x4.extmul_low_i16x8_s\";\n  export const i32x4_extmul_low_i16x8_u = \"~lib/builtins/i32x4.extmul_low_i16x8_u\";\n  export const i32x4_extmul_high_i16x8_s = \"~lib/builtins/i32x4.extmul_high_i16x8_s\";\n  export const i32x4_extmul_high_i16x8_u = \"~lib/builtins/i32x4.extmul_high_i16x8_u\";\n  export const i32x4_shuffle = \"~lib/builtins/i32x4.shuffle\";\n  export const i32x4_swizzle = \"~lib/builtins/i32x4.swizzle\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\";\n  export const i64x2_mul = \"~lib/builtins/i64x2.mul\";\n  export const i64x2_abs = \"~lib/builtins/i64x2.abs\";\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\";\n  export const i64x2_bitmask = \"~lib/builtins/i64x2.bitmask\";\n  export const i64x2_eq = \"~lib/builtins/i64x2.eq\";\n  export const i64x2_ne = \"~lib/builtins/i64x2.ne\";\n  export const i64x2_lt_s = \"~lib/builtins/i64x2.lt_s\";\n  export const i64x2_lt_u = \"~lib/builtins/i64x2.lt_u\";\n  export const i64x2_le_s = \"~lib/builtins/i64x2.le_s\";\n  export const i64x2_le_u = \"~lib/builtins/i64x2.le_u\";\n  export const i64x2_gt_s = \"~lib/builtins/i64x2.gt_s\";\n  export const i64x2_gt_u = \"~lib/builtins/i64x2.gt_u\";\n  export const i64x2_ge_s = \"~lib/builtins/i64x2.ge_s\";\n  export const i64x2_ge_u = \"~lib/builtins/i64x2.ge_u\";\n  export const i64x2_extend_low_i32x4_s = \"~lib/builtins/i64x2.extend_low_i32x4_s\";\n  export const i64x2_extend_low_i32x4_u = \"~lib/builtins/i64x2.extend_low_i32x4_u\";\n  export const i64x2_extend_high_i32x4_s = \"~lib/builtins/i64x2.extend_high_i32x4_s\";\n  export const i64x2_extend_high_i32x4_u = \"~lib/builtins/i64x2.extend_high_i32x4_u\";\n  export const i64x2_extmul_low_i32x4_s = \"~lib/builtins/i64x2.extmul_low_i32x4_s\";\n  export const i64x2_extmul_low_i32x4_u = \"~lib/builtins/i64x2.extmul_low_i32x4_u\";\n  export const i64x2_extmul_high_i32x4_s = \"~lib/builtins/i64x2.extmul_high_i32x4_s\";\n  export const i64x2_extmul_high_i32x4_u = \"~lib/builtins/i64x2.extmul_high_i32x4_u\";\n  export const i64x2_shuffle = \"~lib/builtins/i64x2.shuffle\";\n  export const i64x2_swizzle = \"~lib/builtins/i64x2.swizzle\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_demote_f64x2_zero = \"~lib/builtins/f32x4.demote_f64x2_zero\";\n  export const f32x4_shuffle = \"~lib/builtins/f32x4.shuffle\";\n  export const f32x4_swizzle = \"~lib/builtins/f32x4.swizzle\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_low_i32x4_s = \"~lib/builtins/f64x2.convert_low_i32x4_s\";\n  export const f64x2_convert_low_i32x4_u = \"~lib/builtins/f64x2.convert_low_i32x4_u\";\n  export const f64x2_promote_low_f32x4 = \"~lib/builtins/f64x2.promote_low_f32x4\";\n  export const f64x2_shuffle = \"~lib/builtins/f64x2.shuffle\";\n  export const f64x2_swizzle = \"~lib/builtins/f64x2.swizzle\";\n\n  export const i31_new = \"~lib/builtins/i31.new\";\n  export const i31_get = \"~lib/builtins/i31.get\";\n\n  // internals\n  export const data_end = \"~lib/memory/__data_end\";\n  export const stack_pointer = \"~lib/memory/__stack_pointer\";\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n  export const tostack = \"~lib/rt/__tostack\";\n\n  // std/number.ts\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/string.ts\n  export const String_raw = \"~lib/string/String.raw\";\n  export const String_eq = \"~lib/string/String.__eq\";\n  export const String_ne = \"~lib/string/String.__ne\";\n  export const String_not = \"~lib/string/String.__not\";\n}\n\n/** Builtin compilation context. */\nexport class BuiltinContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Global builtins map. */\nexport const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n/** Function builtins map. */\nexport const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\nlet guard_id_counter: u32 = 1 << 31;\n\n// === Static type evaluation =================================================================\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isBooleanValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isIntegerValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isSignedIntegerValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFloatValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isVector<T!>() / isVector<T?>(value: T) -> bool\nfunction builtin_isVector(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isVectorValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isVector, builtin_isVector);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isReference ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isAssignableTo(compiler.program.stringInstance)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltins.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.extends(compiler.program.arrayPrototype)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltins.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isArrayLike\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFunction ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isNullableReference ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinContext): ExpressionRef {\n  // Note that `isDefined` neither compiles nor evaluates the given expression\n  // but exclusively performs a check whether it can be compiled in theory.\n  // This is not exactly unsafe due to only seemingly having side effects which\n  // actually never happen, but may confuse tooling unaware of its semantics.\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.Swallow\n  );\n  return module.i32(element ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  if (!mustPreserveSideEffects(expr, module.ref)) {\n    return module.i32(module.isConstExpression(expr) ? 1 : 0);\n  }\n  return module.block(null, [\n    module.maybeDrop(expr),\n    module.i32(0)\n  ], getExpressionType(expr));\n}\nbuiltins.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isManaged ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.kind == TypeKind.Void ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return reifyConstantType(ctx, module.i32(signatureReference.parameterTypes.length));\n}\nbuiltins.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let type = ctx.typeArguments![0];\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.String)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let classMembers = classReference.members;\n    if (classMembers && classMembers.has(fieldName)) {\n      let member = assert(classMembers.get(fieldName));\n      if (member.kind == ElementKind.Field) {\n        return contextualUsize(compiler, i64_new((<Field>member).memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltins.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let resultType = checkConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  let value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return reifyConstantType(ctx, compiler.ensureStaticString(value));\n}\nbuiltins.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return reifyConstantType(ctx, module.i32(signatureReference.id));\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference && !classReference.hasDecorator(DecoratorFlags.Unmanaged)) {\n    return reifyConstantType(ctx, module.i32(classReference.id));\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.idof, builtin_idof);\n\n// bswap<T?>(value: T) -> T\nfunction builtin_bswap(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        ctx.operands[0],\n        typeArguments[0].toUnsigned(),\n        Constraints.ConvImplicit | Constraints.MustWrap\n      )\n    : compiler.compileExpression(\n        ctx.operands[0],\n        Type.u32,\n        Constraints.MustWrap\n      );\n\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.U8: return arg0;\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        // <T>(x << 8 | x >> 8)\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.Wrapped);\n\n        let res = module.binary(\n          BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp.index, arg0, false),\n            module.i32(8)\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp.index, TypeRef.I32),\n            module.i32(8)\n          )\n        );\n        // avoid wrapping for u16 due to it's already done for input arg\n        if (type.kind == TypeKind.I16) {\n          res = compiler.ensureSmallIntegerWrap(res, Type.i16);\n        }\n        return res;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (type.size == 32) {\n          // rotl(x & 0xFF00FF00, 8) | rotr(x & 0x00FF00FF, 8)\n          let flow = compiler.currentFlow;\n          let temp = flow.getTempLocal(type);\n          flow.setLocalFlag(temp.index, LocalFlags.Wrapped);\n\n          let res = module.binary(\n            BinaryOp.OrI32,\n            module.binary(\n              BinaryOp.RotlI32,\n              module.binary(\n                BinaryOp.AndI32,\n                module.local_tee(temp.index, arg0, false),\n                module.i32(0xFF00FF00)\n              ),\n              module.i32(8)\n            ),\n            module.binary(\n              BinaryOp.RotrI32,\n              module.binary(\n                BinaryOp.AndI32,\n                module.local_get(temp.index, TypeRef.I32),\n                module.i32(0x00FF00FF)\n              ),\n              module.i32(8)\n            ),\n          );\n          return res;\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        // let t =\n        //   ((x >>> 8) & 0x00FF00FF00FF00FF) |\n        //   ((x & 0x00FF00FF00FF00FF) << 8)\n        //\n        // let res =\n        //   ((t >>> 16) & 0x0000FFFF0000FFFF) |\n        //   ((t & 0x0000FFFF0000FFFF) << 16)\n        //\n        // rotr(res, 32)\n\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        // t = ((x >>> 8) & 0x00FF00FF00FF00FF) | ((x & 0x00FF00FF00FF00FF) << 8)\n        let expr = module.local_tee(\n          temp2.index,\n          module.binary(\n            BinaryOp.OrI64,\n            module.binary(\n              BinaryOp.AndI64,\n              module.binary(\n                BinaryOp.ShrU64,\n                module.local_tee(temp1.index, arg0, false),\n                module.i64(8)\n              ),\n              module.i64(0x00FF00FF, 0x00FF00FF)\n            ),\n            module.binary(\n              BinaryOp.ShlI64,\n              module.binary(\n                BinaryOp.AndI64,\n                module.local_get(temp1.index, TypeRef.I64),\n                module.i64(0x00FF00FF, 0x00FF00FF)\n              ),\n              module.i64(8)\n            ),\n          ),\n          false\n        );\n\n        // ((t >>> 16) & 0x0000FFFF0000FFFF) | ((t & 0x0000FFFF0000FFFF) << 16)\n        let res = module.binary(\n          BinaryOp.OrI64,\n          module.binary(\n            BinaryOp.AndI64,\n            module.binary(\n              BinaryOp.ShrU64,\n              expr,\n              module.i64(16)\n            ),\n            module.i64(0x0000FFFF, 0x0000FFFF)\n          ),\n          module.binary(\n            BinaryOp.ShlI64,\n            module.binary(\n              BinaryOp.AndI64,\n              module.local_get(temp2.index, TypeRef.I64),\n              module.i64(0x0000FFFF, 0x0000FFFF)\n            ),\n            module.i64(16)\n          ),\n        );\n\n        // rotr(res, 32)\n        res = module.binary(\n          BinaryOp.RotrI64,\n          res,\n          module.i64(32)\n        );\n        return res;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"bswap\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.bswap, builtin_bswap);\n\n// === Math ===================================================================================\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.ClzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.CtzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.PopcntSize, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotlSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotrSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32\n                module.i32(31)\n              ),\n              false // i32\n            ),\n            module.local_get(temp1.index, TypeRef.I32)\n          ),\n          module.local_get(temp2.index, TypeRef.I32)\n        );\n        return ret;\n      }\n      case TypeKind.Isize: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(BinaryOp.XorSize,\n          module.binary(BinaryOp.AddSize,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrISize,\n                module.local_tee(temp1.index, arg0, false), // i32/i64\n                compiler.options.isWasm64\n                  ? module.i64(63)\n                  : module.i32(31)\n              ),\n              false // i32/i64\n            ),\n            module.local_get(temp1.index, options.sizeTypeRef)\n          ),\n          module.local_get(temp2.index, options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0, false), // i64\n                module.i64(63)\n              ),\n              false // i64\n            ),\n            module.local_get(temp1.index, TypeRef.I64)\n          ),\n          module.local_get(temp2.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.GtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.GtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.GtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.GtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.LtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.LtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.LtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.LtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = compiler.options.isWasm64;\n        let arg0 = compiler.compileExpression(operands[0],\n          isWasm64 ? Type.f64 : Type.f32,\n          Constraints.ConvImplicit\n        );\n        compiler.currentType = type;\n        return module.unary(\n          isWasm64\n            ? UnaryOp.ReinterpretF64ToI64\n            : UnaryOp.ReinterpretF32ToI32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.ConvImplicit);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0, false), // f32\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0, false), // f64\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.local_get(temp.index, TypeRef.F32)\n          ),\n          module.f32(0)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.local_get(temp.index, TypeRef.F64)\n          ),\n          module.f64(0)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n\n  let outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n\n  if (!outType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"load\", outType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toRef(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltins.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void\nfunction builtin_store(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (!inType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"store\", inType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);\n}\nbuiltins.set(BuiltinNames.store, builtin_store);\n\n// rem<T?>(left: T, right: T) -> T\nfunction builtin_rem(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isIntegerValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isIntegerValue) {\n      return compiler.makeRem(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"rem\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rem, builtin_rem);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.div, builtin_div);\n\n// eq<T?>(left: T, right: T) -> i32\nfunction builtin_eq(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeEq(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"eq\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.eq, builtin_eq);\n\n// ne<T?>(left: T, right: T) -> i32\nfunction builtin_ne(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeNe(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"ne\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ne, builtin_ne);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toRef(),\n    immOffset\n  );\n}\nbuiltins.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);\n}\nbuiltins.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltins.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltins.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltins.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  let arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.ConvImplicit\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  let immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());\n}\nbuiltins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout?: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = operands.length == 3\n    ? compiler.compileExpression(operands[2], Type.i64, Constraints.ConvImplicit)\n    : module.i64(-1, -1); // Infinite timeout\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.Isize:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.Usize: return module.atomic_wait(arg0, arg1, arg2, type.toRef());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count?: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = operands.length == 2\n    ? compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit)\n    : module.i32(-1); // Inifinity count of waiters\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (!type.isAny(TypeFlags.Value | TypeFlags.Reference)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2, type.toRef());\n}\nbuiltins.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltins.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltins.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.ConvImplicit));\n}\nbuiltins.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let usizeType = compiler.options.usizeType;\n  let offset: i64;\n  if (typeArguments && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.Literal || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.Array) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltins.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === GC =====================================================================================\n\nfunction builtin_i31_new(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.i31ref;\n  return module.i31_new(arg0);\n}\nbuiltins.set(BuiltinNames.i31_new, builtin_i31_new);\n\nfunction builtin_i31_get(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i31ref, Constraints.ConvImplicit);\n  if (ctx.contextualType.is(TypeFlags.Unsigned)) {\n    compiler.currentType = Type.u32;\n    return module.i31_get(arg0, false);\n  } else {\n    compiler.currentType = Type.i32;\n    return module.i31_get(arg0, true);\n  }\n}\nbuiltins.set(BuiltinNames.i31_get, builtin_i31_get);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let toType = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.auto);\n  let fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltins.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MustWrap);\n  let type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  let evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>TypeRef.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  let abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.if(module.unary(UnaryOp.EqzSize, arg0), abort);\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: return module.if(module.ref_is(RefIsOp.Null, arg0), abort);\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.Wrapped); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0, false), // numeric\n          module.local_get(temp.index, TypeRef.I32),\n          abort\n        );\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0, false) // i64\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            UnaryOp.EqzSize,\n            module.local_tee(temp.index, arg0, type.isManaged)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is(RefIsOp.Null,\n            module.local_tee(temp.index, arg0, false) // ref\n          ),\n          abort,\n          module.local_get(temp.index, type.toRef())\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltins.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let flow = compiler.currentFlow;\n  let alreadyUnchecked = flow.is(FlowFlags.UncheckedContext);\n  flow.set(FlowFlags.UncheckedContext);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  let expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UncheckedContext);\n  return expr;\n}\nbuiltins.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  let indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  let numOperands = operands.length - 1;\n  let operandExprs = new Array<ExpressionRef>(numOperands);\n  let paramTypeRefs = new Array<TypeRef>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    paramTypeRefs[i] = compiler.currentType.toRef();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(null /* TODO */, indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());\n}\nbuiltins.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let typeArgument = typeArguments[0];\n  let classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  let ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.None, ctx.reportNode);\n}\nbuiltins.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  checkTypeAbsent(ctx);\n  let operands = ctx.operands;\n  let reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.Error\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Error);\n}\nbuiltins.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Warning);\n}\nbuiltins.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Info);\n}\nbuiltins.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.Class);\n  let classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  let typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  let ftype = typeArguments[0];\n  let signature = assert(ftype.getSignature());\n  let returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  let functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.ConvImplicit);\n  let thisOperand = assert(ctx.operands.shift());\n  let thisType = signature.thisType;\n  let thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.ConvImplicit);\n  } else if (thisOperand.kind != NodeKind.Null) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nfunction_builtins.set(\"call\", builtin_function_call);\n\n// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string\nfunction builtin_string_raw(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = ctx.compiler.program.stringInstance.type;\n  compiler.error(\n    DiagnosticCode.Not_implemented_0,\n    ctx.reportNode.range, \"String.raw\"\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.String_raw, builtin_string_raw);\n\nfunction builtin_max_iterations(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let maxiter = ctx.operands[0];\n  // we actually could tolerate a compile-time constant expression,\n  // but it isn't clear how to recognize it...\n  if ((maxiter.kind != NodeKind.Literal) || ((<LiteralExpression>maxiter).literalKind != LiteralKind.Integer)) {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      maxiter.range\n    );\n    return module.unreachable();\n  }\n  let args = new Array<Expression>();\n  let gid = Node.createIntegerLiteralExpression(i64_new(++guard_id_counter), maxiter.range);\n  args.push(gid);\n  // maxiter argument of _g is actually 1 + the argument of max_iterations\n  let value = <IntegerLiteralExpression>(maxiter).value;\n  let incremented = Node.createIntegerLiteralExpression(i64_new(++value));\n  args.push(incremented);\n  let name = Node.createIdentifierExpression(CommonNames._g, ctx.reportNode.expression.range);\n  let call = Node.createCallExpression(name, null, args, ctx.reportNode.range);\n  return compiler.compileCallExpression(call, Type.i32);\n}\nbuiltins.set(BuiltinNames.max_iterations, builtin_max_iterations);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {\n  let compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.ConvExplicit);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltins.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltins.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltins.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltins.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltins.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltins.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltins.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltins.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltins.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltins.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltins.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltins.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltins.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltins.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(16);\n  let numVars = 0;\n\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 16;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI8x16, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 16; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(8);\n  let numVars = 0;\n\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 8;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI16x8, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 8; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp),  bytes, off + 0);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  compiler.currentType = type;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(Number.isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.ConvImplicit);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);\n}\nbuiltins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_zero(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_load(\n          compiler.options.isWasm64\n            ? SIMDLoadOp.Load64Zero\n            : SIMDLoadOp.Load32Zero,\n          arg0,\n          immOffset,\n          immAlign\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);\n\n// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Load64Lane\n            : SIMDLoadStoreLaneOp.Load32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);\n\n// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_store_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Store64Lane\n            : SIMDLoadStoreLaneOp.Store32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.store_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);\n\n// v128.sub_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);\n      // no LtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);\n      // no LeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);\n      // no GtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);\n      // no GeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);\n      case TypeKind.Isize: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.convert_low<T!>(a: v128) -> v128\nfunction builtin_v128_convert_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.trunc_sat_zero<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat_zero(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);\n\n// v128.extend_low<T!>(a: v128) -> v128\nfunction builtin_v128_extend_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);\n\n// v128.extend_high<T!>(a: v128) -> v128\nfunction builtin_v128_extend_high(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.Isize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltins.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltins.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltins.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);\n}\nbuiltins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltins.set(BuiltinNames.v128_not, builtin_v128_not);\n\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  return module.simd_ternary(op, arg0, arg1, arg2);\n}\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\n}\nbuiltins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  return module.unary(UnaryOp.AnyTrueV128, arg0);\n}\nbuiltins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AllTrueI64x2\n            : UnaryOp.AllTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.BitmaskI64x2\n            : UnaryOp.BitmaskI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.popcnt<T!>(a: v128) -> v128\nfunction builtin_v128_popcnt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);\n\n// v128.extadd_pairwise<T!>(a: v128) -> v128\nfunction builtin_v128_extadd_pairwise(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extadd_pairwise\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);\n\n// v128.demote_zero<T?>(a: v128) -> v128\nfunction builtin_v128_demote_zero(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f64;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.demote_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);\n\n// v128.promote_low<T?>(a: v128) -> v128\nfunction builtin_v128_promote_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f32;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.promote_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);\n\n// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_q15mulr_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.q15mulr_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);\n\n// v128.extmul_low<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);\n\n// v128.extmul_high<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_high(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.rem_s -> rem<i32>\nfunction builtin_i32_rem_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rem_s, builtin_i32_rem_s);\n\n// i32.rem_u -> rem<u32>\nfunction builtin_i32_rem_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rem_u, builtin_i32_rem_u);\n\n// i64.rem_s -> rem<i64>\nfunction builtin_i64_rem_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rem_s, builtin_i64_rem_s);\n\n// i64.rem_u -> rem<u64>\nfunction builtin_i64_rem_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rem_u, builtin_i64_rem_u);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.eq -> eq<i32>\nfunction builtin_i32_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32_eq, builtin_i32_eq);\n\n// i64.eq -> eq<i64>\nfunction builtin_i64_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i64_eq, builtin_i64_eq);\n\n// f32.eq -> eq<f32>\nfunction builtin_f32_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32_eq, builtin_f32_eq);\n\n// f64.eq -> eq<f64>\nfunction builtin_f64_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64_eq, builtin_f64_eq);\n\n// i32.ne -> ne<i32>\nfunction builtin_i32_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ne, builtin_i32_ne);\n\n// i64.ne -> ne<i64>\nfunction builtin_i64_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ne, builtin_i64_ne);\n\n// f32.ne -> ne<f32>\nfunction builtin_f32_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ne, builtin_f32_ne);\n\n// f64.ne-> ne<f64>\nfunction builtin_f64_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ne, builtin_f64_ne);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// i32.wait -> atomic.wait<i32>\nfunction builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i32_wait, builtin_i32_wait);\n\n// i64.wait -> atomic.wait<i64>\nfunction builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i64_wait, builtin_i64_wait);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.load8x8_s -> v128.load_ext<i8>\nfunction builtin_v128_load8x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);\n\n// v128.load8x8_u -> v128.load_ext<u8>\nfunction builtin_v128_load8x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);\n\n// v128.load16x4_s -> v128.load_ext<i16>\nfunction builtin_v128_load16x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);\n\n// v128.load16x4_u -> v128.load_ext<u16>\nfunction builtin_v128_load16x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);\n\n// v128.load32x2_s -> v128.load_ext<i32>\nfunction builtin_v128_load32x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);\n\n// v128.load32x2_u -> v128.load_ext<u32>\nfunction builtin_v128_load32x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);\n\n// v128.load8_splat -> v128.load_splat<u8>\nfunction builtin_v128_load8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);\n\n// v128.load16_splat -> v128.load_splat<u16>\nfunction builtin_v128_load16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);\n\n// v128.load32_splat -> v128.load_splat<u32>\nfunction builtin_v128_load32_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);\n\n// v128.load64_splat -> v128.load_splat<u64>\nfunction builtin_v128_load64_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);\n\n// v128.load32_zero -> v128.load_zero<u32>\nfunction builtin_v128_load32_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);\n\n// v128.load64_zero -> v128.load_zero<u64>\nfunction builtin_v128_load64_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);\n\n// v128.load8_lane -> v128.load_lane<u8>\nfunction builtin_v128_load8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);\n\n// v128.load16_lane -> v128.load_lane<u16>\nfunction builtin_v128_load16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);\n\n// v128.load32_lane -> v128.load_lane<u32>\nfunction builtin_v128_load32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);\n\n// v128.load64_lane -> v128.load_lane<u64>\nfunction builtin_v128_load64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);\n\n// v128.store8_lane -> v128.store_lane<u8>\nfunction builtin_v128_store8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);\n\n// v128.store16_lane -> v128.store_lane<u16>\nfunction builtin_v128_store16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);\n\n// v128.store32_lane -> v128.store_lane<u32>\nfunction builtin_v128_store32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);\n\n// v128.store64_lane -> v128.store_lane<u64>\nfunction builtin_v128_store64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_sat_s -> v128.add_sat<i8>\nfunction builtin_i8x16_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);\n\n// i8x16.add_sat_u -> v128.add_sat<u8>\nfunction builtin_i8x16_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);\n\n// i8x16.sub_sat_s -> v128.sub_sat<i8>\nfunction builtin_i8x16_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);\n\n// i8x16.sub_sat_u -> v128.sub_sat<u8>\nfunction builtin_i8x16_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.popcnt -> v128.popcnt<i8>\nfunction builtin_i8x16_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_i8x16_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);\n\n// i8x16.swizzle -> v128.swizzle\nfunction builtin_i8x16_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_sat_s -> v128.add_sat<i16>\nfunction builtin_i16x8_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);\n\n// i16x8.add_sat_u -> v128.add_sat<u16>\nfunction builtin_i16x8_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);\n\n// i16x8.sub_sat_s -> v128.sub_sat<i16>\nfunction builtin_i16x8_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);\n\n// i16x8.sub_sat_u -> v128.sub_sat<u16>\nfunction builtin_i16x8_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>\nfunction builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);\n\n// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>\nfunction builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);\n\n// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>\nfunction builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);\n\n// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>\nfunction builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);\n\n// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);\n\n// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);\n\n// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>\nfunction builtin_i16x8_q15mulr_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_q15mulr_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);\n\n// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>\nfunction builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);\n\n// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>\nfunction builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);\n\n// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>\nfunction builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);\n\n// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>\nfunction builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);\n\n// i16x8.shuffle -> v128.shuffle<i16>\nfunction builtin_i16x8_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shuffle, builtin_i16x8_shuffle);\n\n// i16x8.swizzle -> v128.swizzle\nfunction builtin_i16x8_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_swizzle, builtin_i16x8_swizzle);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>\nfunction builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);\n\n// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>\nfunction builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);\n\n// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>\nfunction builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);\n\n// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>\nfunction builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);\n\n// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>\nfunction builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);\n\n// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>\nfunction builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);\n\n// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);\n\n// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);\n\n// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>\nfunction builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);\n\n// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>\nfunction builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);\n\n// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>\nfunction builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);\n\n// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>\nfunction builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);\n\n// i32x4.shuffle -> v128.shuffle<i32>\nfunction builtin_i32x4_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shuffle, builtin_i32x4_shuffle);\n\n// i32x4.swizzle -> v128.swizzle\nfunction builtin_i32x4_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_swizzle, builtin_i32x4_swizzle);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.mul -> v128.mul<i64>\nfunction builtin_i64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);\n\n// i64x2.abs -> v128.abs<i64>\nfunction builtin_i64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.bitmask -> v128.bitmask<i64>\nfunction builtin_i64x2_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);\n\n// i64x2.eq -> v128.eq<i64>\nfunction builtin_i64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);\n\n// i64x2.ne -> v128.ne<i64>\nfunction builtin_i64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);\n\n// i64x2.lt_s -> v128.lt<i64>\nfunction builtin_i64x2_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);\n\n// i64x2.le_s -> v128.le<i64>\nfunction builtin_i64x2_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);\n\n// i64x2.gt_s -> v128.gt<i64>\nfunction builtin_i64x2_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);\n\n// i64x2.ge_s -> v128.ge<i64>\nfunction builtin_i64x2_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);\n\n// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>\nfunction builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);\n\n// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>\nfunction builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);\n\n// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>\nfunction builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);\n\n// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>\nfunction builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);\n\n// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>\nfunction builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);\n\n// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>\nfunction builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);\n\n// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>\nfunction builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);\n\n// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>\nfunction builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);\n\n// i64x2.shuffle -> v128.shuffle<i64>\nfunction builtin_i64x2_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shuffle, builtin_i64x2_shuffle);\n\n// i64x2.swizzle -> v128.swizzle\nfunction builtin_i64x2_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_swizzle, builtin_i64x2_swizzle);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>\nfunction builtin_f32x4_demote_f64x2_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_demote_zero(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);\n\n// f32x4.shuffle -> v128.shuffle<f32>\nfunction builtin_f32x4_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_shuffle, builtin_f32x4_shuffle);\n\n// f32x4.swizzle -> v128.swizzle\nfunction builtin_f32x4_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_swizzle, builtin_f32x4_swizzle);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>\nfunction builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);\n\n// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>\nfunction builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);\n\n// f64x2.promote_low_f32x4 -> v128.promote_low<f32>\nfunction builtin_f64x4_promote_low_f32x4(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_promote_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);\n\n// f64x2.shuffle -> v128.shuffle<f32>\nfunction builtin_f64x2_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_shuffle, builtin_f64x2_shuffle);\n\n// f64x2.swizzle -> v128.swizzle\nfunction builtin_f64x2_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_swizzle, builtin_f64x2_swizzle);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  let module = compiler.module;\n  let exprs = new Array<ExpressionRef>();\n  let sizeTypeRef = compiler.options.sizeTypeRef;\n  let visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.Global) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference &&\n      !classReference.hasDecorator(DecoratorFlags.Unmanaged) &&\n      global.is(CommonFlags.Compiled)\n    ) {\n      if (global.is(CommonFlags.Inlined)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value)),\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, sizeTypeRef),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, sizeTypeRef), // tempRef != null\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    TypeRef.I32,  // cookie\n    TypeRef.None, // => void\n    [ sizeTypeRef ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let sizeTypeSize = usizeType.byteSize;\n  let visitInstance = assert(program.visitInstance);\n  let body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  let base = instance.base;\n  if (base) {\n    body.push(\n      module.call(`${base.internalName}~visit`, [\n        module.local_get(0, sizeTypeRef), // this\n        module.local_get(1, TypeRef.I32)  // cookie\n      ], TypeRef.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  let hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.getMember(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FunctionPrototype);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, sizeTypeRef), // this\n            module.local_get(1, TypeRef.I32)  // cookie\n          ], TypeRef.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  let needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind == ElementKind.Field) {\n          if ((<Field>member).parent == instance) {\n            let fieldType = (<Field>member).type;\n            if (fieldType.isManaged) {\n              let fieldOffset = (<Field>member).memoryOffset;\n              assert(fieldOffset >= 0);\n              needsTempValue = true;\n              body.push(\n                // if ($2 = value) __visit($2, $1)\n                module.if(\n                  module.local_tee(2,\n                    module.load(sizeTypeSize, false,\n                      module.local_get(0, sizeTypeRef),\n                      sizeTypeRef, fieldOffset\n                    ),\n                    false // internal\n                  ),\n                  module.call(visitInstance.internalName, [\n                    module.local_get(2, sizeTypeRef), // value\n                    module.local_get(1, TypeRef.I32)  // cookie\n                  ], TypeRef.None)\n                )\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(`${instance.internalName}~visit`,\n    createType([sizeTypeRef, TypeRef.I32]),\n    TypeRef.None,\n    needsTempValue ? [ sizeTypeRef ] : null,\n    module.flatten(body, TypeRef.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base && base.type.isManaged) {\n    // errored earlier if not managed\n    ensureVisitMembersOf(compiler, base);\n  }\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let managedClasses = program.managedClasses;\n  let visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  let names = new Array<string>();\n  let cases = new Array<ExpressionRef>();\n  let nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    if (instance.isPointerfree) {\n      cases[i] = module.return();\n    } else {\n      cases[i] = module.block(null, [\n        module.call(`${instance.internalName}~visit`, [\n          module.local_get(0, sizeTypeRef), // this\n          module.local_get(1, TypeRef.I32)  // cookie\n        ], TypeRef.None),\n        module.return()\n      ], TypeRef.None);\n      ensureVisitMembersOf(compiler, instance);\n    }\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  let current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        sizeTypeRef == TypeRef.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, sizeTypeRef),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, sizeTypeRef),\n              module.i32(8) // rtId is at -8\n            ),\n        TypeRef.I32, 0\n      )\n    )\n  ], TypeRef.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], TypeRef.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], TypeRef.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie\n    TypeRef.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  let flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.Signed))   flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.Float))    flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.Nullable)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged)              flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let managedClasses = program.managedClasses;\n  let count = managedClasses.size;\n  let size = 4 + 8 * count;\n  let data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  let off = 4;\n  let abvInstance = program.arrayBufferViewInstance;\n  let abvPrototype = abvInstance.prototype;\n  let arrayPrototype = program.arrayPrototype;\n  let setPrototype = program.setPrototype;\n  let mapPrototype = program.mapPrototype;\n  let staticArrayPrototype = program.staticArrayPrototype;\n  let lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;\n    if (instance != abvInstance && instance.extends(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extends(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0   * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extends(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n    let base = instance.base;\n    writeI32(base ? base.id : 0, data, off); off += 4;\n  }\n  assert(off == size);\n  let usizeType = program.options.usizeType;\n  let segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n/** Compiles a class-specific instanceof helper, checking a ref against all concrete instances. */\nexport function compileClassInstanceOf(compiler: Compiler, prototype: ClassPrototype): void {\n  let module = compiler.module;\n  let sizeTypeRef = compiler.options.sizeTypeRef;\n  let instanceofInstance = assert(prototype.program.instanceofInstance);\n  compiler.compileFunction(instanceofInstance);\n\n  let stmts = new Array<ExpressionRef>();\n\n  // if (!ref) return false\n  stmts.push(\n    module.if(\n      module.unary(\n        sizeTypeRef == TypeRef.I64\n          ? UnaryOp.EqzI64\n          : UnaryOp.EqzI32,\n        module.local_get(0, sizeTypeRef)\n      ),\n      module.return(\n        module.i32(0)\n      )\n    )\n  );\n\n  // if (__instanceof(ref, ID[i])) return true\n  let instances = prototype.instances;\n  if (instances && instances.size > 0) {\n    // TODO: for (let instance of instances.values()) {\n    for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n      let instance = unchecked(_values[i]);\n      stmts.push(\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(0, sizeTypeRef),\n            module.i32(instance.id)\n          ], TypeRef.I32),\n          module.return(\n            module.i32(1)\n          )\n        )\n      );\n    }\n  }\n\n  // return false\n  stmts.push(\n    module.return(\n      module.i32(0)\n    )\n  );\n\n  module.addFunction(\n    `${prototype.internalName}~instanceof`,\n    sizeTypeRef,\n    TypeRef.I32,\n    null,\n    module.flatten(stmts)\n  );\n}\n\n// Helpers\n\nlet checkConstantType_expr: ExpressionRef = 0;\n\n/** Checks the constant type of a type argument *or* expression. */\nfunction checkConstantType(ctx: BuiltinContext): Type | null {\n  let compiler = ctx.compiler;\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  checkConstantType_expr = 0;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      checkConstantType_expr = compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit);\n    } else {\n      checkConstantType_expr = compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Reifies a constant type check potentially involving an expression. */\nfunction reifyConstantType(ctx: BuiltinContext, expr: ExpressionRef): ExpressionRef {\n  let module = ctx.compiler.module;\n  if (checkConstantType_expr && mustPreserveSideEffects(checkConstantType_expr, module.ref)) {\n    expr = module.block(null, [\n      module.maybeDrop(checkConstantType_expr),\n      expr\n    ], getExpressionType(expr));\n  }\n  return expr;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  let module = compiler.module;\n  let value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  let align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {\n  let compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  let compiler = ctx.compiler;\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinContext): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {\n  let operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  let module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n", "/**\n * @fileoverview Infrastructure for custom Binaryen passes.\n * @license Apache-2.0\n */\n\nimport {\n  Module,\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  GlobalRef,\n  Index,\n  StringRef\n} from \"../module\";\n\nimport {\n  _BinaryenExpressionGetId,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenIfGetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenLoopGetBody,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n  _BinaryenFunctionGetBody,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenLocalSetGetValue,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalGetInitExpr,\n  _BinaryenLoadGetPtr,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenUnaryGetValue,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenDropGetValue,\n  _BinaryenBlockSetChildAt,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenReturnGetValue,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenRefIsGetValue,\n  _BinaryenRefAsGetValue,\n  _BinaryenTryGetBody,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenIfSetCondition,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfSetIfFalse,\n  _BinaryenLoopSetBody,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakSetValue,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchSetValue,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenLocalSetSetValue,\n  _BinaryenGlobalSetSetValue,\n  _BinaryenLoadSetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreSetValue,\n  _BinaryenUnarySetValue,\n  _BinaryenExpressionFinalize,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinarySetRight,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectSetCondition,\n  _BinaryenDropSetValue,\n  _BinaryenReturnSetValue,\n  _BinaryenMemoryGrowSetDelta,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWSetValue,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgSetReplacement,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceSetValue,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernarySetC,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftSetShift,\n  _BinaryenSIMDLoadSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitSetSize,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopySetSize,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillSetSize,\n  _BinaryenRefIsSetValue,\n  _BinaryenTrySetBody,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenBlockGetName,\n  _BinaryenLoopGetName,\n  _BinaryenBreakGetName,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenCallGetTarget,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalSetGetName,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenThrowGetTag,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqSetRight,\n  _BinaryenFunctionSetBody,\n  _BinaryenI31NewGetValue,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31NewSetValue,\n  _BinaryenI31GetSetI31,\n  _BinaryenCallRefGetNumOperands,\n  _BinaryenCallRefGetOperandAt,\n  _BinaryenCallRefGetTarget,\n  _BinaryenRefTestGetRef,\n  _BinaryenRefCastGetRef,\n  _BinaryenBrOnGetName,\n  _BinaryenBrOnGetRef,\n  _BinaryenStructNewGetNumOperands,\n  _BinaryenStructNewGetOperandAt,\n  _BinaryenStructGetGetRef,\n  _BinaryenStructSetGetRef,\n  _BinaryenStructSetGetValue,\n  _BinaryenStructSetGetIndex,\n  _BinaryenStructGetGetIndex,\n  _BinaryenArrayNewGetSize,\n  _BinaryenArrayNewGetInit,\n  _BinaryenArrayInitGetNumValues,\n  _BinaryenArrayInitGetValueAt,\n  _BinaryenArrayGetGetRef,\n  _BinaryenArrayGetGetIndex,\n  _BinaryenArraySetGetRef,\n  _BinaryenArraySetGetIndex,\n  _BinaryenArraySetGetValue,\n  _BinaryenArrayLenGetRef,\n  _BinaryenArrayCopyGetDestRef,\n  _BinaryenArrayCopyGetDestIndex,\n  _BinaryenArrayCopyGetSrcRef,\n  _BinaryenArrayCopyGetSrcIndex,\n  _BinaryenArrayCopyGetLength,\n  _BinaryenStringNewGetPtr,\n  _BinaryenStringNewGetLength,\n  _BinaryenStringNewGetStart,\n  _BinaryenStringNewGetEnd,\n  _BinaryenStringMeasureGetRef,\n  _BinaryenStringEncodeGetPtr,\n  _BinaryenStringEncodeGetRef,\n  _BinaryenStringEncodeGetStart,\n  _BinaryenStringConcatGetLeft,\n  _BinaryenStringConcatGetRight,\n  _BinaryenStringEqGetLeft,\n  _BinaryenStringEqGetRight,\n  _BinaryenStringAsGetRef,\n  _BinaryenStringWTF8AdvanceGetRef,\n  _BinaryenStringWTF8AdvanceGetPos,\n  _BinaryenStringWTF8AdvanceGetBytes,\n  _BinaryenStringWTF16GetGetRef,\n  _BinaryenStringWTF16GetGetPos,\n  _BinaryenStringIterNextGetRef,\n  _BinaryenStringIterMoveGetRef,\n  _BinaryenStringIterMoveGetNum,\n  _BinaryenStringSliceWTFGetRef,\n  _BinaryenStringSliceWTFGetStart,\n  _BinaryenStringSliceWTFGetEnd,\n  _BinaryenStringSliceIterGetRef,\n  _BinaryenStringSliceIterGetNum,\n  _BinaryenCallRefSetOperandAt,\n  _BinaryenCallRefSetTarget,\n  _BinaryenRefTestSetRef,\n  _BinaryenRefCastSetRef,\n  _BinaryenBrOnSetRef,\n  _BinaryenStructNewSetOperandAt,\n  _BinaryenStructGetSetRef,\n  _BinaryenStructSetSetRef,\n  _BinaryenStructSetSetValue,\n  _BinaryenArrayNewSetSize,\n  _BinaryenArrayNewSetInit,\n  _BinaryenArrayGetSetRef,\n  _BinaryenArrayGetSetIndex,\n  _BinaryenArraySetSetRef,\n  _BinaryenArraySetSetIndex,\n  _BinaryenArraySetSetValue,\n  _BinaryenArrayLenSetRef,\n  _BinaryenArrayCopySetDestRef,\n  _BinaryenArrayCopySetDestIndex,\n  _BinaryenArrayCopySetSrcRef,\n  _BinaryenArrayCopySetSrcIndex,\n  _BinaryenArrayCopySetLength,\n  _BinaryenRefAsSetValue,\n  _BinaryenStringNewSetPtr,\n  _BinaryenStringNewSetLength,\n  _BinaryenStringNewSetStart,\n  _BinaryenStringNewSetEnd,\n  _BinaryenStringMeasureSetRef,\n  _BinaryenStringEncodeSetRef,\n  _BinaryenStringEncodeSetPtr,\n  _BinaryenStringEncodeSetStart,\n  _BinaryenStringConcatSetLeft,\n  _BinaryenStringConcatSetRight,\n  _BinaryenStringEqSetLeft,\n  _BinaryenStringEqSetRight,\n  _BinaryenStringAsSetRef,\n  _BinaryenStringWTF8AdvanceSetRef,\n  _BinaryenStringWTF8AdvanceSetPos,\n  _BinaryenStringWTF8AdvanceSetBytes,\n  _BinaryenStringWTF16GetSetRef,\n  _BinaryenStringWTF16GetSetPos,\n  _BinaryenStringIterNextSetRef,\n  _BinaryenStringIterMoveSetRef,\n  _BinaryenStringIterMoveSetNum,\n  _BinaryenStringSliceWTFSetRef,\n  _BinaryenStringSliceWTFSetStart,\n  _BinaryenStringSliceWTFSetEnd,\n  _BinaryenStringSliceIterSetRef,\n  _BinaryenStringSliceIterSetNum,\n  _BinaryenArrayInitSetValueAt\n} from \"../glue/binaryen\";\n\n/** Base class of custom Binaryen visitors. */\nexport abstract class Visitor {\n  /** Expression stack. */\n  private stack: ExpressionRef[] = new Array<ExpressionRef>();\n\n  /** Gets the current expression being walked. */\n  get currentExpression(): ExpressionRef {\n    let currentExpression = this._currentExpression;\n    if (!currentExpression) throw new Error(\"not walking expressions\");\n    return currentExpression;\n  }\n  _currentExpression: ExpressionRef = 0;\n\n  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */\n  get parentExpressionOrNull(): ExpressionRef {\n    let stack = this.stack;\n    let length = stack.length;\n    return length ? stack[length - 1] : 0;\n  }\n\n  // Expressions\n\n  visitBlock(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitIf(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBreak(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSwitch(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCall(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirectPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStore(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBinary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSelect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitReturn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemorySize(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryGrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitNop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnreachable(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicRMW(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicCmpxchg(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicWait(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicNotify(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicFence(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDReplace(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShuffle(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDTernary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShift(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoadStoreLane(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDataDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryFill(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitPop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefIs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefFunc(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTry(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitThrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRethrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleMake(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31New(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallRef(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefTest(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefCast(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBrOn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArraySet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayLen(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringMeasure(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEncode(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConcat(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF8Advance(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF16Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterNext(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterMove(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceWTF(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceIter(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  // Immediates\n\n  visitName(name: StringRef): void {\n    // unimp\n  }\n\n  visitLabel(name: StringRef): void {\n    // unimp\n  }\n\n  visitIndex(index: Index): void {\n    // unimp\n  }\n\n  visitTag(name: StringRef): void {\n    // unimp\n  }\n\n  // Delegate\n\n  /** Visits any expression, delegating to the respective visitor methods. */\n  visit(expr: ExpressionRef): void {\n    let previousExpression = this._currentExpression;\n    this._currentExpression = assert(expr);\n    switch (_BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Block: {\n        this.stack.push(expr);\n        let name = _BinaryenBlockGetName(expr);\n        if (name) this.visitLabel(name);\n        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n          this.visit(_BinaryenBlockGetChildAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitBlock(expr);\n        break;\n      }\n      case ExpressionId.If: {\n        this.stack.push(expr);\n        this.visit(_BinaryenIfGetCondition(expr));\n        this.visit(_BinaryenIfGetIfTrue(expr));\n        let ifFalse = _BinaryenIfGetIfFalse(expr);\n        if (ifFalse) this.visit(ifFalse);\n        assert(this.stack.pop() == expr);\n        this.visitIf(expr);\n        break;\n      }\n      case ExpressionId.Loop: {\n        this.stack.push(expr);\n        let name = _BinaryenLoopGetName(expr);\n        if (name) this.visitLabel(name);\n        this.visit(_BinaryenLoopGetBody(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoop(expr);\n        break;\n      }\n      case ExpressionId.Break: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBreakGetName(expr));\n        let condition = _BinaryenBreakGetCondition(expr);\n        if (condition) this.visit(condition);\n        let value = _BinaryenBreakGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitBreak(expr);\n        break;\n      }\n      case ExpressionId.Switch: {\n        this.stack.push(expr);\n        let defaultName = _BinaryenSwitchGetDefaultName(expr);\n        if (defaultName) this.visitLabel(defaultName);\n        let numNames = _BinaryenSwitchGetNumNames(expr);\n        for (let i: Index = 0; i < numNames; ++i) {\n          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));\n        }\n        this.visit(_BinaryenSwitchGetCondition(expr));\n        let value = _BinaryenSwitchGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitSwitch(expr);\n        break;\n      }\n      case ExpressionId.Call: {\n        this.visitCallPre(expr);\n        this.stack.push(expr);\n        this.visitName(_BinaryenCallGetTarget(expr));\n        let numOperands = _BinaryenCallGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenCallGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCall(expr);\n        break;\n      }\n      case ExpressionId.CallIndirect: {\n        this.visitCallIndirectPre(expr);\n        this.stack.push(expr);\n        this.visit(_BinaryenCallIndirectGetTarget(expr));\n        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {\n          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCallIndirect(expr);\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalGet(expr);\n        break;\n      }\n      case ExpressionId.LocalSet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalSetGetIndex(expr));\n        this.visit(_BinaryenLocalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalSet(expr);\n        break;\n      }\n      case ExpressionId.GlobalGet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalGetGetName(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalGet(expr);\n        break;\n      }\n      case ExpressionId.GlobalSet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalSetGetName(expr));\n        this.visit(_BinaryenGlobalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalSet(expr);\n        break;\n      }\n      case ExpressionId.Load: {\n        this.stack.push(expr);\n        this.visit(_BinaryenLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoad(expr);\n        break;\n      }\n      case ExpressionId.Store: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStoreGetPtr(expr));\n        this.visit(_BinaryenStoreGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStore(expr);\n        break;\n      }\n      case ExpressionId.Const: {\n        this.visitConst(expr);\n        break;\n      }\n      case ExpressionId.Unary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenUnaryGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitUnary(expr);\n        break;\n      }\n      case ExpressionId.Binary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenBinaryGetLeft(expr));\n        this.visit(_BinaryenBinaryGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBinary(expr);\n        break;\n      }\n      case ExpressionId.Select: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSelectGetIfTrue(expr));\n        this.visit(_BinaryenSelectGetIfFalse(expr));\n        this.visit(_BinaryenSelectGetCondition(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSelect(expr);\n        break;\n      }\n      case ExpressionId.Drop: {\n        this.stack.push(expr);\n        this.visit(_BinaryenDropGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitDrop(expr);\n        break;\n      }\n      case ExpressionId.Return: {\n        let value = _BinaryenReturnGetValue(expr);\n        if (value) {\n          this.stack.push(expr);\n          this.visit(value);\n          assert(this.stack.pop() == expr);\n        }\n        this.visitReturn(expr);\n        break;\n      }\n      case ExpressionId.MemorySize: {\n        this.visitMemorySize(expr);\n        break;\n      }\n      case ExpressionId.MemoryGrow: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryGrowGetDelta(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryGrow(expr);\n        break;\n      }\n      case ExpressionId.Nop: {\n        this.visitNop(expr);\n        break;\n      }\n      case ExpressionId.Unreachable: {\n        this.visitUnreachable(expr);\n        break;\n      }\n      case ExpressionId.AtomicRMW: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicRMWGetPtr(expr));\n        this.visit(_BinaryenAtomicRMWGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicRMW(expr);\n        break;\n      }\n      case ExpressionId.AtomicCmpxchg: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicCmpxchg(expr);\n        break;\n      }\n      case ExpressionId.AtomicWait: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicWaitGetPtr(expr));\n        this.visit(_BinaryenAtomicWaitGetExpected(expr));\n        this.visit(_BinaryenAtomicWaitGetTimeout(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicWait(expr);\n        break;\n      }\n      case ExpressionId.AtomicNotify: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicNotifyGetPtr(expr));\n        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicNotify(expr);\n        break;\n      }\n      case ExpressionId.AtomicFence: {\n        this.visitAtomicFence(expr);\n        break;\n      }\n      case ExpressionId.SIMDExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDExtractGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDExtract(expr);\n        break;\n      }\n      case ExpressionId.SIMDReplace: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDReplaceGetVec(expr));\n        this.visit(_BinaryenSIMDReplaceGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDReplace(expr);\n        break;\n      }\n      case ExpressionId.SIMDShuffle: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShuffleGetLeft(expr));\n        this.visit(_BinaryenSIMDShuffleGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShuffle(expr);\n        break;\n      }\n      case ExpressionId.SIMDTernary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDTernaryGetA(expr));\n        this.visit(_BinaryenSIMDTernaryGetB(expr));\n        this.visit(_BinaryenSIMDTernaryGetC(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDTernary(expr);\n        break;\n      }\n      case ExpressionId.SIMDShift: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShiftGetVec(expr));\n        this.visit(_BinaryenSIMDShiftGetShift(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShift(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoad: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoad(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoadStoreLane: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));\n        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoadStoreLane(expr);\n        break;\n      }\n      case ExpressionId.MemoryInit: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryInitGetDest(expr));\n        this.visit(_BinaryenMemoryInitGetOffset(expr));\n        this.visit(_BinaryenMemoryInitGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryInit(expr);\n        break;\n      }\n      case ExpressionId.DataDrop: {\n        this.visitDataDrop(expr);\n        break;\n      }\n      case ExpressionId.MemoryCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryCopyGetDest(expr));\n        this.visit(_BinaryenMemoryCopyGetSource(expr));\n        this.visit(_BinaryenMemoryCopyGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryCopy(expr);\n        break;\n      }\n      case ExpressionId.MemoryFill: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryFillGetDest(expr));\n        this.visit(_BinaryenMemoryFillGetValue(expr));\n        this.visit(_BinaryenMemoryFillGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryFill(expr);\n        break;\n      }\n      case ExpressionId.Pop: {\n        this.visitPop(expr);\n        break;\n      }\n      case ExpressionId.RefNull: {\n        this.visitRefNull(expr);\n        break;\n      }\n      case ExpressionId.RefIs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefIsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefIs(expr);\n        break;\n      }\n      case ExpressionId.RefFunc: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenRefFuncGetFunc(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefFunc(expr);\n        break;\n      }\n      case ExpressionId.RefEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefEqGetLeft(expr));\n        this.visit(_BinaryenRefEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefEq(expr);\n        break;\n      }\n      case ExpressionId.Try: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTryGetBody(expr));\n        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);\n        for (let i: Index = 0; i < numCatchBodies; ++i) {\n          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitTry(expr);\n        break;\n      }\n      case ExpressionId.Throw: {\n        this.stack.push(expr);\n        this.visitTag(_BinaryenThrowGetTag(expr));\n        let numOperands = _BinaryenThrowGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenThrowGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitThrow(expr);\n        break;\n      }\n      case ExpressionId.Rethrow: {\n        this.visitRethrow(expr);\n        break;\n      }\n      case ExpressionId.TupleMake: {\n        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitTupleMake(expr);\n        break;\n      }\n      case ExpressionId.TupleExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTupleExtractGetTuple(expr));\n        assert(this.stack.pop() == expr);\n        this.visitTupleExtract(expr);\n        break;\n      }\n      case ExpressionId.I31New: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31NewGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31New(expr);\n        break;\n      }\n      case ExpressionId.I31Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31GetGetI31(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31Get(expr);\n        break;\n      }\n      case ExpressionId.CallRef: {\n        this.stack.push(expr);\n        let numOperands = _BinaryenCallRefGetNumOperands(expr);\n        if (numOperands) {\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenCallRefGetOperandAt(expr, i));\n          }\n        }\n        this.visit(_BinaryenCallRefGetTarget(expr));\n        assert(this.stack.pop() == expr);\n        this.visitCallRef(expr);\n        break;\n      }\n      case ExpressionId.RefTest: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefTestGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefTest(expr);\n        break;\n      }\n      case ExpressionId.RefCast: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefCastGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefCast(expr);\n        break;\n      }\n      case ExpressionId.BrOn: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBrOnGetName(expr));\n        this.visit(_BinaryenBrOnGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBrOn(expr);\n        break;\n      }\n      case ExpressionId.StructNew: {\n        let numOperands = _BinaryenStructNewGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenStructNewGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitStructNew(expr);\n        break;\n      }\n      case ExpressionId.StructGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructGetGetRef(expr));\n        this.visitIndex(_BinaryenStructGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructGet(expr);\n        break;\n      }\n      case ExpressionId.StructSet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructSetGetRef(expr));\n        this.visitIndex(_BinaryenStructSetGetIndex(expr));\n        this.visit(_BinaryenStructSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructSet(expr);\n        break;\n      }\n      case ExpressionId.ArrayNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayNewGetSize(expr));\n        let init = _BinaryenArrayNewGetInit(expr);\n        if (init) this.visit(init);\n        assert(this.stack.pop() == expr);\n        this.visitArrayNew(expr);\n        break;\n      }\n      case ExpressionId.ArrayInit: {\n        let numValues = _BinaryenArrayInitGetNumValues(expr);\n        if (numValues) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numValues; ++i) {\n            this.visit(_BinaryenArrayInitGetValueAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitArrayInit(expr);\n        break;\n      }\n      case ExpressionId.ArrayGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayGetGetRef(expr));\n        this.visit(_BinaryenArrayGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayGet(expr);\n        break;\n      }\n      case ExpressionId.ArraySet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArraySetGetRef(expr));\n        this.visit(_BinaryenArraySetGetIndex(expr));\n        this.visit(_BinaryenArraySetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArraySet(expr);\n        break;\n      }\n      case ExpressionId.ArrayLen: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayLenGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayLen(expr);\n        break;\n      }\n      case ExpressionId.ArrayCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayCopyGetDestRef(expr));\n        this.visit(_BinaryenArrayCopyGetDestIndex(expr));\n        this.visit(_BinaryenArrayCopyGetSrcRef(expr));\n        this.visit(_BinaryenArrayCopyGetSrcIndex(expr));\n        this.visit(_BinaryenArrayCopyGetLength(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayCopy(expr);\n        break;\n      }\n      case ExpressionId.RefAs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefAsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefAs(expr);\n        break;\n      }\n      case ExpressionId.StringNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringNewGetPtr(expr));\n        let length = _BinaryenStringNewGetLength(expr); // LM only\n        if (length) this.visit(length);\n        let start = _BinaryenStringNewGetStart(expr); // GC only\n        if (start) this.visit(start);\n        let end = _BinaryenStringNewGetEnd(expr); // GC only\n        if (end) this.visit(end);\n        assert(this.stack.pop() == expr);\n        this.visitStringNew(expr);\n        break;\n      }\n      case ExpressionId.StringConst: {\n        this.stack.push(expr);\n        assert(this.stack.pop() == expr);\n        this.visitStringConst(expr);\n        break;\n      }\n      case ExpressionId.StringMeasure: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringMeasureGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringMeasure(expr);\n        break;\n      }\n      case ExpressionId.StringEncode: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEncodeGetRef(expr));\n        this.visit(_BinaryenStringEncodeGetPtr(expr));\n        let start = _BinaryenStringEncodeGetStart(expr); // GC only\n        if (start) this.visit(start);\n        assert(this.stack.pop() == expr);\n        this.visitStringEncode(expr);\n        break;\n      }\n      case ExpressionId.StringConcat: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringConcatGetLeft(expr));\n        this.visit(_BinaryenStringConcatGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringConcat(expr);\n        break;\n      }\n      case ExpressionId.StringEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEqGetLeft(expr));\n        this.visit(_BinaryenStringEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringEq(expr);\n        break;\n      }\n      case ExpressionId.StringAs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringAsGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringAs(expr);\n        break;\n      }\n      case ExpressionId.StringWTF8Advance: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringWTF8AdvanceGetRef(expr));\n        this.visit(_BinaryenStringWTF8AdvanceGetPos(expr));\n        this.visit(_BinaryenStringWTF8AdvanceGetBytes(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringWTF8Advance(expr);\n        break;\n      }\n      case ExpressionId.StringWTF16Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringWTF16GetGetRef(expr));\n        this.visit(_BinaryenStringWTF16GetGetPos(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringWTF16Get(expr);\n        break;\n      }\n      case ExpressionId.StringIterNext: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringIterNextGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringIterNext(expr);\n        break;\n      }\n      case ExpressionId.StringIterMove: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringIterMoveGetRef(expr));\n        this.visit(_BinaryenStringIterMoveGetNum(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringIterMove(expr);\n        break;\n      }\n      case ExpressionId.StringSliceWTF: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringSliceWTFGetRef(expr));\n        this.visit(_BinaryenStringSliceWTFGetStart(expr));\n        this.visit(_BinaryenStringSliceWTFGetEnd(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringSliceWTF(expr);\n        break;\n      }\n      case ExpressionId.StringSliceIter: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringSliceIterGetRef(expr));\n        this.visit(_BinaryenStringSliceIterGetNum(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringSliceIter(expr);\n        break;\n      }\n      default: throw new Error(\"unexpected expression kind\");\n    }\n    this._currentExpression = previousExpression;\n  }\n}\n\n/** Base class of custom Binaryen passes. */\nexport abstract class Pass extends Visitor {\n\n  /** Gets the current function being walked. */\n  get currentFunction(): FunctionRef {\n    let currentFunction = this._currentFunction;\n    if (!currentFunction) throw new Error(\"not walking a function\");\n    return currentFunction;\n  }\n  private _currentFunction: FunctionRef = 0;\n\n  /** Gets the current global being walked. */\n  get currentGlobal(): GlobalRef {\n    let currentGlobal = this._currentGlobal;\n    if (!currentGlobal) throw new Error(\"not walking a global\");\n    return currentGlobal;\n  }\n  private _currentGlobal: GlobalRef = 0;\n\n  /** Constructs a new Binaryen pass. */\n  constructor(readonly module: Module) {\n    super();\n  }\n\n  // Walking\n\n  /** Walks the entire module. */\n  walkModule(): void {\n    this.walkFunctions();\n    this.walkGlobals();\n  }\n\n  /** Walks all functions. */\n  walkFunctions(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {\n      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific function. */\n  walkFunction(func: FunctionRef): void {\n    let body = _BinaryenFunctionGetBody(func);\n    if (body) {\n      this._currentFunction = func;\n      this.visit(body);\n      this._currentFunction = 0;\n    }\n  }\n\n  /** Walks all global variables. */\n  walkGlobals(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {\n      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific global variable. */\n  walkGlobal(global: GlobalRef): void {\n    this._currentGlobal = global;\n    let init = _BinaryenGlobalGetInitExpr(global);\n    if (init) this.visit(init);\n    this._currentGlobal = 0;\n  }\n\n  // Utility\n\n  /** Replaces the current expression with the specified replacement. */\n  replaceCurrent(replacement: ExpressionRef): void {\n    let search = this.currentExpression;\n    let func = this.currentFunction;\n    let body = _BinaryenFunctionGetBody(func);\n    if (body == search) {\n      _BinaryenFunctionSetBody(func, replacement);\n    } else {\n      let parent = assert(this.parentExpressionOrNull);\n      let replaced = replaceChild(parent, search, replacement);\n      if (!replaced) throw Error(\"failed to replace expression\");\n      _BinaryenExpressionFinalize(parent);\n    }\n  }\n}\n\n/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */\nexport function replaceChild(\n  /** Parent expression containing `search`. */\n  parent: ExpressionRef,\n  /** Expression to replace. */\n  search: ExpressionRef,\n  /** Expression to replace `search` with. */\n  replacement: ExpressionRef\n): ExpressionRef {\n  switch (_BinaryenExpressionGetId(parent)) {\n    case ExpressionId.Block: {\n      let numChildren = _BinaryenBlockGetNumChildren(parent);\n      for (let i: Index = 0; i < numChildren; ++i) {\n        let child = _BinaryenBlockGetChildAt(parent, i);\n        if (child == search) {\n          _BinaryenBlockSetChildAt(parent, i, replacement);\n          return child;\n        }\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      let condition = _BinaryenIfGetCondition(parent);\n      if (condition == search) {\n        _BinaryenIfSetCondition(parent, replacement);\n        return condition;\n      }\n      let ifTrue = _BinaryenIfGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenIfSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenIfGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenIfSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      break;\n    }\n    case ExpressionId.Loop: {\n      let body = _BinaryenLoopGetBody(parent);\n      if (body == search) {\n        _BinaryenLoopSetBody(parent, replacement);\n        return body;\n      }\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = _BinaryenBreakGetCondition(parent);\n      if (condition == search) {\n        _BinaryenBreakSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenBreakGetValue(parent);\n      if (value == search) {\n        _BinaryenBreakSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Switch: {\n      let condition = _BinaryenSwitchGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSwitchSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenSwitchGetValue(parent);\n      if (value == search) {\n        _BinaryenSwitchSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Call: {\n      let numOperands = _BinaryenCallGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      let target = _BinaryenCallIndirectGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallIndirectSetTarget(parent, replacement);\n        return target;\n      }\n      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      let value = _BinaryenLocalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenLocalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      let value = _BinaryenGlobalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenGlobalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Load: {\n      let ptr = _BinaryenLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.Store: {\n      let ptr = _BinaryenStoreGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStoreSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenStoreGetValue(parent);\n      if (value == search) {\n        _BinaryenStoreSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      let value = _BinaryenUnaryGetValue(parent);\n      if (value == search) {\n        _BinaryenUnarySetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Binary: {\n      let left = _BinaryenBinaryGetLeft(parent);\n      if (left == search) {\n        _BinaryenBinarySetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenBinaryGetRight(parent);\n      if (right == search) {\n        _BinaryenBinarySetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Select: {\n      let ifTrue = _BinaryenSelectGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenSelectSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenSelectGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenSelectSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      let condition = _BinaryenSelectGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSelectSetCondition(parent, replacement);\n        return condition;\n      }\n      break;\n    }\n    case ExpressionId.Drop: {\n      let value = _BinaryenDropGetValue(parent);\n      if (value == search) {\n        _BinaryenDropSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Return: {\n      let value = _BinaryenReturnGetValue(parent);\n      if (value == search) {\n        _BinaryenReturnSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.MemorySize: {\n      break;\n    }\n    case ExpressionId.MemoryGrow: {\n      let delta = _BinaryenMemoryGrowGetDelta(parent);\n      if (delta == search) {\n        _BinaryenMemoryGrowSetDelta(parent, replacement);\n        return delta;\n      }\n      break;\n    }\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      let ptr = _BinaryenAtomicRMWGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicRMWSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenAtomicRMWGetValue(parent);\n      if (value == search) {\n        _BinaryenAtomicRMWSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);\n        return expected;\n      }\n      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);\n      if (repl == search) {\n        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);\n        return repl;\n      }\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      let ptr = _BinaryenAtomicWaitGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicWaitSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicWaitGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicWaitSetExpected(parent, replacement);\n        return expected;\n      }\n      let timeout = _BinaryenAtomicWaitGetTimeout(parent);\n      if (timeout == search) {\n        _BinaryenAtomicWaitSetTimeout(parent, replacement);\n        return timeout;\n      }\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      let ptr = _BinaryenAtomicNotifyGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicNotifySetPtr(parent, replacement);\n        return ptr;\n      }\n      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);\n      if (notifyCount == search) {\n        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);\n        return notifyCount;\n      }\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      let vec = _BinaryenSIMDExtractGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDExtractSetVec(parent, replacement);\n        return vec;\n      }\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      let vec = _BinaryenSIMDReplaceGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDReplaceSetVec(parent, replacement);\n        return vec;\n      }\n      let value = _BinaryenSIMDReplaceGetValue(parent);\n      if (value == search) {\n        _BinaryenSIMDReplaceSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      let left = _BinaryenSIMDShuffleGetLeft(parent);\n      if (left == search) {\n        _BinaryenSIMDShuffleSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenSIMDShuffleGetRight(parent);\n      if (right == search) {\n        _BinaryenSIMDShuffleSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      let a = _BinaryenSIMDTernaryGetA(parent);\n      if (a == search) {\n        _BinaryenSIMDTernarySetA(parent, replacement);\n        return a;\n      }\n      let b = _BinaryenSIMDTernaryGetB(parent);\n      if (b == search) {\n        _BinaryenSIMDTernarySetB(parent, replacement);\n        return b;\n      }\n      let c = _BinaryenSIMDTernaryGetC(parent);\n      if (c == search) {\n        _BinaryenSIMDTernarySetC(parent, replacement);\n        return c;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      let vec = _BinaryenSIMDShiftGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDShiftSetVec(parent, replacement);\n        return vec;\n      }\n      let shift = _BinaryenSIMDShiftGetShift(parent);\n      if (shift == search) {\n        _BinaryenSIMDShiftSetShift(parent, replacement);\n        return shift;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      let ptr = _BinaryenSIMDLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoadStoreLane: {\n      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);\n        return ptr;\n      }\n      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      let dest = _BinaryenMemoryInitGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryInitSetDest(parent, replacement);\n        return dest;\n      }\n      let offset = _BinaryenMemoryInitGetOffset(parent);\n      if (offset == search) {\n        _BinaryenMemoryInitSetOffset(parent, replacement);\n        return offset;\n      }\n      let size = _BinaryenMemoryInitGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryInitSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      let dest = _BinaryenMemoryCopyGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryCopySetDest(parent, replacement);\n        return dest;\n      }\n      let source = _BinaryenMemoryCopyGetSource(parent);\n      if (source == search) {\n        _BinaryenMemoryCopySetSource(parent, replacement);\n        return source;\n      }\n      let size = _BinaryenMemoryCopyGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryCopySetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      let dest = _BinaryenMemoryFillGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryFillSetDest(parent, replacement);\n        return dest;\n      }\n      let value = _BinaryenMemoryFillGetValue(parent);\n      if (value == search) {\n        _BinaryenMemoryFillSetValue(parent, replacement);\n        return value;\n      }\n      let size = _BinaryenMemoryFillGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryFillSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIs: {\n      let value = _BinaryenRefIsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefIsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.RefEq: {\n      let left = _BinaryenRefEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenRefEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenRefEqGetRight(parent);\n      if (right == search) {\n        _BinaryenRefEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Try: {\n      let body = _BinaryenTryGetBody(parent);\n      if (body == search) {\n        _BinaryenTrySetBody(parent, replacement);\n        return body;\n      }\n      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);\n      for (let i: Index = 0; i < numCatchBodies; ++i) {\n        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);\n        if (catchBody == search) {\n          _BinaryenTrySetCatchBodyAt(parent, i, replacement);\n          return catchBody;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Throw: {\n      let numOperands = _BinaryenThrowGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenThrowGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenThrowSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      let tuple = _BinaryenTupleExtractGetTuple(parent);\n      if (tuple == search) {\n        _BinaryenTupleExtractSetTuple(parent, replacement);\n        return tuple;\n      }\n      break;\n    }\n    case ExpressionId.I31New: {\n      let value = _BinaryenI31NewGetValue(parent);\n      if (value == search) {\n        _BinaryenI31NewSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.I31Get: {\n      let i31Expr = _BinaryenI31GetGetI31(parent);\n      if (i31Expr == search) {\n        _BinaryenI31GetSetI31(parent, replacement);\n        return i31Expr;\n      }\n      break;\n    }\n    case ExpressionId.CallRef: {\n      let numOperands = _BinaryenCallRefGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallRefGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallRefSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      let target = _BinaryenCallRefGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallRefSetTarget(parent, replacement);\n        return target;\n      }\n      break;\n    }\n    case ExpressionId.RefTest: {\n      let ref = _BinaryenRefTestGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefTestSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.RefCast: {\n      let ref = _BinaryenRefCastGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefCastSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.BrOn: {\n      let ref = _BinaryenBrOnGetRef(parent);\n      if (ref == search) {\n        _BinaryenBrOnSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructNew: {\n      let numOperands = _BinaryenStructNewGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenStructNewGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenStructNewSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.StructGet: {\n      let ref = _BinaryenStructGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructGetSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructSet: {\n      let ref = _BinaryenStructSetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructSetSetRef(parent, replacement);\n        return ref;\n      }\n      let value = _BinaryenStructSetGetValue(parent);\n      if (value == search) {\n        _BinaryenStructSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayNew: {\n      let size = _BinaryenArrayNewGetSize(parent);\n      if (size == search) {\n        _BinaryenArrayNewSetSize(parent, replacement);\n        return size;\n      }\n      let init = _BinaryenArrayNewGetInit(parent);\n      if (init == search) {\n        _BinaryenArrayNewSetInit(parent, replacement);\n        return init;\n      }\n      break;\n    }\n    case ExpressionId.ArrayInit: {\n      let numValues = _BinaryenArrayInitGetNumValues(parent);\n      for (let i: Index = 0; i < numValues; ++i) {\n        let value = _BinaryenArrayInitGetValueAt(parent, i);\n        if (value == search) {\n          _BinaryenArrayInitSetValueAt(parent, i, replacement);\n          return value;\n        }\n      }\n      break;\n    }\n    case ExpressionId.ArrayGet: {\n      let ref = _BinaryenArrayGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayGetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArrayGetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArrayGetSetIndex(parent, replacement);\n        return index;\n      }\n      break;\n    }\n    case ExpressionId.ArraySet: {\n      let ref = _BinaryenArraySetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArraySetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArraySetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArraySetSetIndex(parent, replacement);\n        return index;\n      }\n      let value = _BinaryenArraySetGetValue(parent);\n      if (value == search) {\n        _BinaryenArraySetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayLen: {\n      let ref = _BinaryenArrayLenGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayLenSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.ArrayCopy: {\n      let destRef = _BinaryenArrayCopyGetDestRef(parent);\n      if (destRef == search) {\n        _BinaryenArrayCopySetDestRef(parent, replacement);\n        return destRef;\n      }\n      let destIndex = _BinaryenArrayCopyGetDestIndex(parent);\n      if (destIndex == search) {\n        _BinaryenArrayCopySetDestIndex(parent, replacement);\n        return destIndex;\n      }\n      let srcRef = _BinaryenArrayCopyGetSrcRef(parent);\n      if (srcRef == search) {\n        _BinaryenArrayCopySetSrcRef(parent, replacement);\n        return srcRef;\n      }\n      let srcIndex = _BinaryenArrayCopyGetSrcIndex(parent);\n      if (srcIndex == search) {\n        _BinaryenArrayCopySetSrcIndex(parent, replacement);\n        return srcIndex;\n      }\n      let length = _BinaryenArrayCopyGetLength(parent);\n      if (length == search) {\n        _BinaryenArrayCopySetLength(parent, replacement);\n        return length;\n      }\n      break;\n    }\n    case ExpressionId.RefAs: {\n      let value = _BinaryenRefAsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefAsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.StringNew: {\n      let ptr = _BinaryenStringNewGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStringNewSetPtr(parent, replacement);\n        return ptr;\n      }\n      let length = _BinaryenStringNewGetLength(parent);\n      if (length == search) {\n        _BinaryenStringNewSetLength(parent, replacement);\n        return length;\n      }\n      let start = _BinaryenStringNewGetStart(parent);\n      if (start == search) {\n        _BinaryenStringNewSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringNewGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringNewSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    case ExpressionId.StringConst: {\n      break;\n    }\n    case ExpressionId.StringMeasure: {\n      let ref = _BinaryenStringMeasureGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringMeasureSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringEncode: {\n      let ref = _BinaryenStringEncodeGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringEncodeSetRef(parent, replacement);\n        return ref;\n      }\n      let ptr = _BinaryenStringEncodeGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStringEncodeSetPtr(parent, replacement);\n        return ptr;\n      }\n      let start = _BinaryenStringEncodeGetStart(parent);\n      if (start == search) {\n        _BinaryenStringEncodeSetStart(parent, replacement);\n        return start;\n      }\n      break;\n    }\n    case ExpressionId.StringConcat: {\n      let left = _BinaryenStringConcatGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringConcatSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringConcatGetRight(parent);\n      if (right == search) {\n        _BinaryenStringConcatSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringEq: {\n      let left = _BinaryenStringEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringEqGetRight(parent);\n      if (right == search) {\n        _BinaryenStringEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringAs: {\n      let ref = _BinaryenStringAsGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringAsSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringWTF8Advance: {\n      let ref = _BinaryenStringWTF8AdvanceGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringWTF8AdvanceSetRef(parent, replacement);\n        return ref;\n      }\n      let pos = _BinaryenStringWTF8AdvanceGetPos(parent);\n      if (pos == search) {\n        _BinaryenStringWTF8AdvanceSetPos(parent, replacement);\n        return pos;\n      }\n      let bytes = _BinaryenStringWTF8AdvanceGetBytes(parent);\n      if (bytes == search) {\n        _BinaryenStringWTF8AdvanceSetBytes(parent, replacement);\n        return bytes;\n      }\n      break;\n    }\n    case ExpressionId.StringWTF16Get: {\n      let ref = _BinaryenStringWTF16GetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringWTF16GetSetRef(parent, replacement);\n        return ref;\n      }\n      let pos = _BinaryenStringWTF16GetGetPos(parent);\n      if (pos == search) {\n        _BinaryenStringWTF16GetSetPos(parent, replacement);\n        return pos;\n      }\n      break;\n    }\n    case ExpressionId.StringIterNext: {\n      let ref = _BinaryenStringIterNextGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringIterNextSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringIterMove: {\n      let ref = _BinaryenStringIterMoveGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringIterMoveSetRef(parent, replacement);\n        return ref;\n      }\n      let num = _BinaryenStringIterMoveGetNum(parent);\n      if (num == search) {\n        _BinaryenStringIterMoveSetNum(parent, replacement);\n        return num;\n      }\n      break;\n    }\n    case ExpressionId.StringSliceWTF: {\n      let ref = _BinaryenStringSliceWTFGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringSliceWTFSetRef(parent, replacement);\n        return ref;\n      }\n      let start = _BinaryenStringSliceWTFGetStart(parent);\n      if (start == search) {\n        _BinaryenStringSliceWTFSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringSliceWTFGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringSliceWTFSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    case ExpressionId.StringSliceIter: {\n      let ref = _BinaryenStringSliceIterGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringSliceIterSetRef(parent, replacement);\n        return ref;\n      }\n      let num = _BinaryenStringSliceIterGetNum(parent);\n      if (num == search) {\n        _BinaryenStringSliceIterSetNum(parent, replacement);\n        return num;\n      }\n      break;\n    }\n    default: throw new Error(\"unexpected expression id\");\n  }\n  return 0;\n}\n", "/**\n * @fileoverview A lightweight store instrumentation pass.\n * \n * Can be used to find rogue stores to protected memory addresses like object\n * headers or similar, without going overboard with instrumentation. Also\n * passes a flag whether a store originates within the runtime or other code.\n * \n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  Compiler\n} from \"../compiler\";\n\nimport {\n  createType,\n  ExpressionRef,\n  TypeRef\n} from \"../module\";\n\nimport {\n  _BinaryenFunctionGetName,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr\n} from \"../glue/binaryen\";\n\n/** Instruments stores to also call an import. */\nexport class RtraceMemory extends Pass {\n  /** Whether we've seen any stores. */\n  seenStores: bool = false;\n  /** Target pointer type. */\n  ptrType: TypeRef;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.ptrType = compiler.options.sizeTypeRef;\n  }\n\n  checkRT(): bool {\n    let functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;\n    return functionName.startsWith(\"~lib/rt/\");\n  }\n\n  /** @override */\n  visitStore(store: ExpressionRef): void {\n    let module = this.module;\n    let ptr = _BinaryenStoreGetPtr(store);\n    let offset = _BinaryenStoreGetOffset(store);\n    let bytes = _BinaryenStoreGetBytes(store);\n    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr\n    _BinaryenStoreSetPtr(store,\n      module.call(\"~onstore\", [\n        ptr,\n        module.i32(offset),\n        module.i32(bytes),\n        module.i32(i32(this.checkRT()))\n      ], this.ptrType)\n    );\n    this.seenStores = true;\n  }\n\n  // TODO: MemoryFill, Atomics\n\n  /** @override */\n  walkModule(): void {\n    super.walkModule();\n    if (this.seenStores) {\n      this.module.addFunctionImport(\"~onstore\", \"rtrace\", \"onstore\",\n        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),\n        this.ptrType\n      );\n    }\n  }\n}\n", "/**\n * @fileoverview Shadow stack instrumentation for a precise GC.\n *\n * Instruments function arguments and local assignments marked with a 'tostack'\n * call to also do stores to a shadow stack of managed values only.\n *\n * Consider a simple call to a function looking like the following, taking\n * managed arguments, plus assigning managed values to locals:\n *\n *   function foo(a: Obj, b: Obj): Obj {\n *     let c = __tostack(a) // slot 2\n *     __collect()\n *     return b\n *   }\n *\n *   foo(__tostack(a), __tostack(b)) // slot 0, 1\n *\n * At the call to `__collect()` the 32-bit stack frame of the function is:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed argument 'a'\n *      4   | Second managed argument 'b'\n *   -------|----------------------------\n *      8   | First managed local 'c'\n *\n * We are splitting the frame in two halves as annotated since both halves are\n * only known separately for indirect calls, with the first half becoming an\n * extension of the calling function's stack frame by means of treating the\n * arguments as if these were locals beyond the caller's `numLocals`. Function\n * arguments stay a bit longer on the stack than usually, but we also don't have\n * to modify the stack pointer pre-call at all this way. The caller's amended\n * stack frame when assuming one managed local may look like this:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local '?'\n *      4   | Extended with first managed argument 'a'\n *      8   | Extended with second managed argument 'b'\n *\n * with the callee's stack frame becoming just:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local 'c'\n *\n * Instrumentation added below looks about like the following, with the stack\n * growing downwards and 't' and 'r' being new temporary locals:\n *\n *   // callee frameSize = 1 * sizeof<usize>()\n *   function foo(a: usize, b: usize): usize {\n *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)\n *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())\n *     __collect()\n *     let r = b\n *     __stack_pointer += frameSize\n *     return r\n *   }\n *\n *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()\n *   (\n *     r = foo(\n *       ( t = a,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),\n *         t ),\n *       ( t = b,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),\n *         t )\n *     ),\n *     r\n *   )\n *\n * Also note that we have to `memory.fill` the second half because the first\n * assignment to a local may happen at a later point within the function. The\n * invariant we need to maintain for a precise GC is that it only sees zeroes\n * or valid pointers, but never an invalid pointer left on the stack earlier.\n * Since most frames are small, we unroll a sequence of `store`s up to a frame\n * size of 16 bytes, and `memory.fill`, if available, beyond.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  _BinaryenAddFunction,\n  _BinaryenAddFunctionExport,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallGetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionSetBody,\n  _BinaryenGetExport,\n  _BinaryenGetFunction,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetSetValue,\n  _BinaryenRemoveExport,\n  _BinaryenRemoveFunction,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n  _free\n} from \"../glue/binaryen\";\n\nimport {\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  Index,\n  BinaryOp,\n  TypeRef,\n  allocPtrArray,\n  Module,\n  ExternalKind,\n  ExportRef,\n  expandType,\n  isConstZero,\n} from \"../module\";\n\nimport {\n  Compiler,\n  Options\n} from \"../compiler\";\n\nimport {\n  Feature\n} from \"../common\";\n\nimport {\n  BuiltinNames\n} from \"../builtins\";\n\ntype LocalIndex = Index;\ntype SlotIndex = Index;\ntype SlotMap = Map<LocalIndex,SlotIndex>;\ntype TempMap = Map<TypeRef,LocalIndex>;\n\n/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */\nfunction matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {\n  if (\n    _BinaryenExpressionGetId(expr) == ExpressionId.Call &&\n    module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack\n  ) {\n    assert(_BinaryenCallGetNumOperands(expr) == 1);\n    return _BinaryenCallGetOperandAt(expr, 0);\n  }\n  return 0;\n}\n\n/** Tests whether a `value` matched by `matchTostack` needs a slot. */\nfunction needsSlot(module: Module, value: ExpressionRef): bool {\n  switch (_BinaryenExpressionGetId(value)) {\n    // no need to stack null pointers\n    case ExpressionId.Const: return !isConstZero(value);\n    // already kept in another slot\n    case ExpressionId.LocalGet:\n    case ExpressionId.LocalSet: return false; // tee\n  }\n  return true;\n}\n\n/** Instruments a module with a shadow stack for precise GC. */\nexport class ShadowStackPass extends Pass {\n  /** Stack frame slots, per function. */\n  slotMaps: Map<FunctionRef, SlotMap> = new Map();\n  /** Temporary locals, per function. */\n  tempMaps: Map<FunctionRef, TempMap> = new Map();\n  /** Exports (with managed operands) map. */\n  exportMap: Map<string,i32[]> = new Map();\n  /** Compiler reference. */\n  compiler: Compiler;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.compiler = compiler;\n  }\n\n  /** Compiler options. */\n  get options(): Options { return this.compiler.options; }\n  /** Target pointer type. */\n  get ptrType(): TypeRef { return this.options.sizeTypeRef; }\n  /** Target pointer size. */\n  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }\n  /** Target pointer addition operation. */\n  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }\n  /** Target pointer subtraction operation. */\n  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }\n\n  /** Gets a constant with the specified value of the target pointer type. */\n  ptrConst(value: i32): ExpressionRef {\n    return this.ptrType == TypeRef.I64\n      ? this.module.i64(value)\n      : this.module.i32(value);\n  }\n\n  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */\n  noteSlot(func: FunctionRef, localIndex: Index): i32 {\n    let slotMap: SlotMap;\n    if (this.slotMaps.has(func)) {\n      slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      if (slotMap.has(localIndex)) {\n        return changetype<i32>(slotMap.get(localIndex));\n      }\n    } else {\n      slotMap = new Map();\n      this.slotMaps.set(func, slotMap);\n    }\n    let slotIndex = slotMap.size;\n    slotMap.set(localIndex, slotIndex);\n    return slotIndex;\n  }\n\n  /** Notes the presence of an exported function taking managed operands. */\n  noteExport(name: string, managedOperandIndices: i32[]): void {\n    if (!managedOperandIndices.length) return;\n    this.exportMap.set(name, managedOperandIndices);\n  }\n\n  /** Gets a shared temporary local of the given type in the specified functions. */\n  getSharedTemp(func: FunctionRef, type: TypeRef): Index {\n    let tempMap: TempMap;\n    if (this.tempMaps.has(func)) {\n      tempMap = changetype<TempMap>(this.tempMaps.get(func));\n      if (tempMap.has(type)) {\n        return changetype<Index>(tempMap.get(type));\n      }\n    } else {\n      tempMap = new Map();\n      this.tempMaps.set(func, tempMap);\n    }\n    let numLocals = _BinaryenFunctionGetNumLocals(func);\n    let localIndex = numLocals + tempMap.size;\n    tempMap.set(type, localIndex);\n    return localIndex;\n  }\n\n  /** Makes an expression modifying the stack pointer by the given offset. */\n  makeStackOffset(offset: i32): ExpressionRef {\n    assert(offset != 0);\n    let module = this.module;\n    let expr = module.global_set(BuiltinNames.stack_pointer,\n      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        this.ptrConst(abs(offset))\n      )\n    );\n    if (offset > 0) return expr;\n    return module.block(null, [\n      expr,\n      this.makeStackCheck()\n    ], TypeRef.None);\n  }\n\n  /** Makes a sequence of expressions zeroing the stack frame. */\n  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {\n    assert(frameSize > 0);\n    let module = this.module;\n    if (this.options.hasFeature(Feature.BulkMemory) && frameSize > 16) {\n      stmts.push(\n        module.memory_fill(\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.i32(0), // TODO: Wasm64 also i32?\n          this.ptrConst(frameSize)\n        )\n      );\n    } else {\n      let remain = frameSize;\n      while (remain >= 8) {\n        // store<i64>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(8,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i64(0),\n            TypeRef.I64,\n            frameSize - remain\n          )\n        );\n        remain -= 8;\n      }\n      if (remain) {\n        assert(remain == 4);\n        // store<i32>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(4,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i32(0),\n            TypeRef.I32,\n            frameSize - remain\n          )\n        );\n      }\n    }\n  }\n\n  private hasStackCheckFunction: bool = false;\n\n  /** Makes a check that the current stack pointer is valid. */\n  makeStackCheck(): ExpressionRef {\n    let module = this.module;\n    if (!this.hasStackCheckFunction) {\n      this.hasStackCheckFunction = true;\n      module.addFunction(\"~stack_check\", TypeRef.None, TypeRef.None, null,\n        module.if(\n          module.binary(BinaryOp.LtI32,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.global_get(BuiltinNames.data_end, this.ptrType)\n          ),\n          this.compiler.makeStaticAbort(\n            this.compiler.ensureStaticString(\"stack overflow\"),\n            this.compiler.program.nativeSource\n          )\n        )\n      );\n    }\n    return module.call(\"~stack_check\", null, TypeRef.None);\n  }\n\n  private updateCallOperands(operands: ExpressionRef[]): i32 {\n    let module = this.module;\n    let numSlots = 0;\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      let operand = operands[i];\n      let match = matchPattern(module, operand);\n      if (!match) continue;\n      if (!needsSlot(module, match)) {\n        operands[i] = match;\n        continue;\n      }\n      let currentFunction = this.currentFunction;\n      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);\n      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + i);\n      let temp = this.getSharedTemp(currentFunction, this.ptrType);\n      let stmts = new Array<ExpressionRef>();\n      // t = value\n      stmts.push(\n        module.local_set(temp, match, false)\n      );\n      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)\n      stmts.push(\n        module.store(this.ptrSize,\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.local_get(temp, this.ptrType),\n          this.ptrType, slotIndex * this.ptrSize\n        )\n      );\n      // -> t\n      stmts.push(\n        module.local_get(temp, this.ptrType)\n      );\n      operands[i] = module.block(null, stmts, this.ptrType);\n      ++numSlots;\n    }\n    return numSlots;\n  }\n\n  /** Slot offset accounting for nested calls. */\n  private callSlotOffset: i32 = 0;\n  /** Slot offset stack in nested calls. */\n  private callSlotStack: i32[] = new Array();\n\n  /** @override */\n  visitCallPre(call: ExpressionRef): void {\n    let numOperands = _BinaryenCallGetNumOperands(call);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallGetOperandAt(call, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallSetOperandAt(call, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCall(call: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitCallIndirectPre(callIndirect: ExpressionRef): void {\n    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCallIndirect(callIndirect: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    let module = this.module;\n    let value = _BinaryenLocalSetGetValue(localSet);\n    let match = matchPattern(module, value);\n    if (!match) return;\n    if (!needsSlot(module, match)) {\n      _BinaryenLocalSetSetValue(localSet, match);\n      return;\n    }\n    let index = _BinaryenLocalSetGetIndex(localSet);\n    let slotIndex = this.noteSlot(this.currentFunction, index);\n    let stmts = new Array<ExpressionRef>();\n    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)\n    stmts.push(\n      module.store(this.ptrSize,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        module.local_tee(index, match, false),\n        this.ptrType, slotIndex * this.ptrSize\n      )\n    );\n    if (_BinaryenLocalSetIsTee(localSet)) {\n      // -> local\n      stmts.push(\n        module.local_get(index, this.ptrType)\n      );\n      this.replaceCurrent(module.flatten(stmts, this.ptrType));\n    } else {\n      this.replaceCurrent(module.flatten(stmts, TypeRef.None));\n    }\n  }\n\n  /** Updates a function with additional locals etc. */\n  updateFunction(funcRef: FunctionRef): void {\n    let name = _BinaryenFunctionGetName(funcRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let body = assert(_BinaryenFunctionGetBody(funcRef));\n    let numVars = _BinaryenFunctionGetNumVars(funcRef);\n    let vars = new Array<TypeRef>();\n    for (let i: Index = 0; i < numVars; ++i) {\n      vars[i] = _BinaryenFunctionGetVar(funcRef, i);\n    }\n    let tempMaps = this.tempMaps;\n    if (tempMaps.has(funcRef)) {\n      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));\n      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {\n        vars.push(_keys[i]);\n      }\n    }\n    let moduleRef = this.module.ref;\n    _BinaryenRemoveFunction(moduleRef, name);\n    let cArr = allocPtrArray(vars);\n    let newFuncRef = _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);\n    if (this.options.sourceMap || this.options.debugInfo) {\n      let func = this.compiler.program.searchFunctionByRef(newFuncRef);\n      if (func) func.addDebugInfo(this.module, newFuncRef);\n    }\n    _free(cArr);\n  }\n\n  /** Updates a function export taking managed arguments. */\n  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {\n    let module = this.module;\n    let moduleRef = module.ref;\n    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);\n\n    let internalNameRef = _BinaryenExportGetValue(exportRef);\n    let internalName = module.readStringCached(internalNameRef)!;\n    let externalNameRef = _BinaryenExportGetName(exportRef);\n    let funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let paramTypes = expandType(params);\n    let numParams = paramTypes.length;\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let numLocals = numParams;\n    let vars = new Array<TypeRef>();\n    let numSlots = assert(managedOperandIndices.length);\n    let frameSize = numSlots * this.ptrSize;\n    let wrapperName = \"export:\" + internalName;\n    let wrapperNameRef = module.allocStringCached(wrapperName);\n\n    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {\n        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)\n        stmts.push(\n          module.store(this.ptrSize,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.local_get(managedOperandIndices[slotIndex], this.ptrType),\n            this.ptrType, slotIndex * this.ptrSize\n          )\n        );\n      }\n      let forwardedOperands = new Array<ExpressionRef>(numParams);\n      for (let i = 0; i < numParams; ++i) {\n        forwardedOperands[i] = module.local_get(i, paramTypes[i]);\n      }\n      if (results != TypeRef.None) {\n        let tempIndex = numLocals++;\n        vars.push(results);\n        // t = original(...)\n        stmts.push(\n          module.local_set(tempIndex,\n            module.call(internalName, forwardedOperands, results),\n            false // internal\n          )\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(tempIndex, results)\n        );\n      } else {\n        // original(...)\n        stmts.push(\n          module.call(internalName, forwardedOperands, results)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      }\n      let cArr = allocPtrArray(vars);\n      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,\n        module.block(null, stmts, results)\n      );\n      _free(cArr);\n    }\n    _BinaryenRemoveExport(moduleRef, externalNameRef);\n    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);\n  }\n\n  /** @override */\n  walkModule(): void {\n    // Run the pass normally\n    super.walkModule();\n\n    // Instrument returns in functions utilizing stack slots\n    let module = this.module;\n    let instrumentReturns = new InstrumentReturns(this);\n    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {\n      let func = _keys[i];\n      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      let frameSize = slotMap.size * this.ptrSize;\n\n      // Instrument function returns\n      instrumentReturns.frameSize = frameSize;\n      instrumentReturns.walkFunction(func);\n\n      // Instrument function entry\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      // memory.fill(__stack_pointer, 0, frameSize)\n      this.makeStackFill(frameSize, stmts);\n\n      // Handle implicit return\n      let body = _BinaryenFunctionGetBody(func);\n      let bodyType = _BinaryenExpressionGetType(body);\n      if (bodyType == TypeRef.Unreachable) {\n        // body\n        stmts.push(\n          body\n        );\n      } else if (bodyType == TypeRef.None) {\n        // body\n        stmts.push(\n          body\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      } else {\n        let temp = this.getSharedTemp(func, bodyType);\n        // t = body\n        stmts.push(\n          module.local_set(temp, body, false)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(temp, bodyType)\n        );\n      }\n      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));\n    }\n\n    // Update functions we added more locals to\n    // TODO: _BinaryenFunctionAddVar ?\n    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {\n      this.updateFunction(_keys[i]);\n    }\n\n    // Update exports taking managed arguments\n    let exportMap = this.exportMap;\n    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {\n      let exportName = _keys[i];\n      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));\n      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));\n      this.updateExport(exportRef, managedOperandIndices);\n    }\n  }\n}\n\n/** Companion pass instrumenting `return` statements to restore the stack frame. */\nclass InstrumentReturns extends Pass {\n  /** Parent pass. */\n  parentPass: ShadowStackPass;\n  /** Frame size of the current function being processed. */\n  frameSize: i32 = 0;\n\n  constructor(shadowStack: ShadowStackPass) {\n    super(shadowStack.module);\n    this.parentPass = shadowStack;\n  }\n\n  /** @override */\n  visitReturn(ret: ExpressionRef): void {\n    assert(this.frameSize);\n    let module = this.module;\n    let value = _BinaryenReturnGetValue(ret);\n    let stmts = new Array<ExpressionRef>();\n    if (value) {\n      let returnType = _BinaryenExpressionGetType(value);\n      if (returnType == TypeRef.Unreachable) return;\n      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);\n      // t = value\n      stmts.push(\n        module.local_set(temp, value, false)\n      );\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return t\n      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));\n    } else {\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return\n    }\n    stmts.push(\n      ret\n    );\n    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));\n  }\n}\n", "import {\n  SourceKind\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  ClassPrototype,\n  Element,\n  ElementKind,\n  Function,\n  Enum,\n  Class,\n  Interface,\n  Field,\n  File,\n  FunctionPrototype,\n  Global,\n  Program,\n  Property,\n  PropertyPrototype\n} from \"../program\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.Private) && !this.includePrivate) return;\n    let seen = this.seen;\n    if (!element.is(CommonFlags.Instance) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.Global: {\n        if (element.is(CommonFlags.Compiled)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.Enum: {\n        if (element.is(CommonFlags.Compiled)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.EnumValue: break; // handled by visitEnum\n      case ElementKind.FunctionPrototype: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.ClassPrototype: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.Field: {\n        let fieldInstance = <Field>element;\n        if (fieldInstance.is(CommonFlags.Compiled)) this.visitField(name, fieldInstance);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.Namespace: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TypeDefinition: break;\n      default: assert(false);\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.Compiled)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.Compiled)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitField(name: string, element: Field): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n// Helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nexport function hasCompiledMember(element: Element): bool {\n  let members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.ClassPrototype: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.Compiled) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "import {\n  NodeKind,\n  DecoratorKind,\n  LiteralKind,\n  LiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  findDecorator\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  ElementKind,\n  Element,\n  Program,\n  Function,\n  Global,\n  Class,\n  Interface,\n  Enum,\n  EnumValue,\n  Field\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags,\n  Signature\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent,\n  isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n// Limitations\n//\n// - Instrumented globals are no longer WebAssembly.Global, hence cannot be\n//   imported the same way as non-instrumented globals would allow. Affects both\n//   globals imported here and globals imported elsewhere.\n//\n// - Since little is known about how class imports and exports will behave,\n//   there is currently no glue generated for them. In IT there appears to be\n//   a concept of protocols that may or may not map in the future. In GC there\n//   doesn't appear to be a connection between classes and their methods so far.\n//\n//   Instead, generated bindings are limited to lifting and lowering of plain\n//   objects when the class has no constructor and no non-public elements. In\n//   any other sitation an internal or external reference is passed.\n//\n// - Linking two instrumented modules with separate bindings produces\n//   intermediate garbage (i.e. goes through a temporary JS object). Any native\n//   mechanism enabling communication between modules directly would help here.\n//\n// - Cycles between the internal and the external GC cannot be resolved. Using\n//   a common GC as envisioned by the GC proposal can help here, but so far it\n//   seems that the same limitations as for IT will remain.\n//\n// - Duplicate Wasm imports don't yet work when instrumentation is required as\n//   provided argument types cannot be told apart when these only come in as\n//   numbers. It might be possible to modify the binary post compilation, but\n//   this has not been attempted yet.\n//\n// Oddities\n//\n// - Interface Types `string` will be incompatible with JavaScript `String` and\n//   it remains unclear how to proceed on this front. We could either use the IT\n//   mechanism and accept potential hazards or keep using unfortunate glue code.\n//\n// - Functions with a variable number of arguments need some special glue to\n//   inform the binary how many arguments have been provided so it can fill in\n//   defaults for the omitted arguments. No native mechanism in sight, yet.\n//\n// - Optional BigInt arguments must be coerced to 0n since JS does not\n//   implicitly coerce from `null` or `undefined`. Numbers do, however.\n//\n// - Generated bindings assume little endian architecture with typed arrays as\n//   it appears to be more efficient than using a DataView and BE use cases\n//   haven't been seen in the wild so far.\n//\n// - It is assumed that generated import bindings call JavaScript and that the\n//   callee expects a properly coerced integer value, leading to more `>>> 0`\n//   coercions than necessary when the import is actually another Wasm module.\n\n/** A JavaScript bindings builder. */\nexport class JSBuilder extends ExportsWalker {\n\n  /** Builds JavaScript bindings for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new JSBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  private needsLiftBuffer: bool = false;\n  private needsLowerBuffer: bool = false;\n  private needsLiftString: bool = false;\n  private needsLowerString: bool = false;\n  private needsLiftArray: bool = false;\n  private needsLowerArray: bool = false;\n  private needsLiftTypedArray: bool = false;\n  private needsLowerTypedArray: bool = false;\n  private needsLiftStaticArray: bool = false;\n  private needsLowerStaticArray: bool = false;\n  private needsLiftInternref: bool = false;\n  private needsLowerInternref: bool = false;\n  private needsRetain: bool = false;\n  private needsRelease: bool = false;\n  private needsNotNull: bool = false;\n\n  private deferredLifts: Set<Element> = new Set();\n  private deferredLowers: Set<Element> = new Set();\n  private deferredCode: string[] = new Array<string>();\n\n  private exports: string[] = new Array();\n  private importMappings: Map<string,i32> = new Map();\n\n  /** Constructs a new JavaScript bindings builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    this.exports.push(name);\n    if (!isPlainValue(type, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\": {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"valueOf() { return this.value; },\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"get value() {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"return \");\n      this.makeLiftFromValue(\"exports.\" + name + \".value\", type, sb);\n      sb.push(\";\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n      if (!element.is(CommonFlags.Const)) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(\"set value(value) {\\n\");\n        indent(sb, ++this.indentLevel);\n        sb.push(\"exports.\");\n        sb.push(name);\n        sb.push(\".value = \");\n        this.makeLowerToValue(\"value\", type, sb);\n        sb.push(\";\\n\");\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\");\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    this.exports.push(name);\n    indent(sb, this.indentLevel);\n    sb.push(name);\n    sb.push(\": (values => (\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let members = element.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let value = _values[i];\n        if (value.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"values[values.\");\n        sb.push(value.name);\n        if (value.is(CommonFlags.Inlined)) {\n          sb.push(\" = \");\n          sb.push(i64_low((<EnumValue>value).constantIntegerValue).toString());\n        } else {\n          sb.push(\" = exports[\\\"\");\n          sb.push(escapeString(name + \".\" + value.name, CharCode.DoubleQuote));\n          sb.push(\"\\\"].valueOf()\");\n        }\n        sb.push(\"] = \\\"\");\n        sb.push(escapeString(value.name, CharCode.DoubleQuote));\n        sb.push(\"\\\",\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"values\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"))({}),\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  makeGlobalImport(moduleName: string, name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\": \");\n    }\n    let moduleId = this.ensureModuleId(moduleName);\n    if (isPlainValue(type, Mode.Import)) {\n      sb.push(\"(\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(\"__module\");\n        sb.push(moduleId.toString());\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"// not supported: cannot lower before instantiate completes\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  makeFunctionImport(moduleName: string, name: string, element: Function, code: string | null = null): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\"\");\n    }\n    if (isPlainFunction(signature, Mode.Import) && !code) {\n      sb.push(\": (\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(moduleName);\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let parameterNames = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        parameterNames.push(element.getParameterName(i));\n      }\n      sb.push(parameterNames.join(\", \"));\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Export)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          this.makeLiftFromValue(name, type, sb);\n          sb.push(\";\\n\");\n        }\n      }\n      let expr = new Array<string>();\n      let moduleId = this.ensureModuleId(moduleName);\n      if (code) {\n        expr.push(\"(() => {\\n\");\n        indent(expr, 1);\n        expr.push(\"// @external.js\\n\");\n        indentText(code, 1, expr);\n        expr.push(\"\\n})()\");\n      } else {\n        if (moduleName != \"env\") {\n          expr.push(\"__module\");\n          expr.push(moduleId.toString());\n          expr.push(\".\");\n        }\n        expr.push(name);\n        expr.push(\"(\");\n        expr.push(parameterNames.join(\", \"));\n        expr.push(\")\");\n      }\n      code = expr.join(\"\");\n      expr.length = 0;\n      indentText(code, this.indentLevel, expr, true);\n      code = expr.join(\"\");\n      indent(sb, this.indentLevel);\n      if (signature.returnType != Type.void) {\n        sb.push(\"return \");\n        this.makeLowerToValue(code, signature.returnType, sb);\n        sb.push(\";\\n\");\n      } else {\n        sb.push(code);\n        sb.push(\";\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.is(CommonFlags.Private)) return;\n    let sb = this.sb;\n    let signature = element.signature;\n    this.exports.push(name);\n    if (!isPlainFunction(signature, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let numReferences = 0;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (parameterTypes[i].isInternalReference) numReferences++;\n        if (i > 0) sb.push(\", \");\n        sb.push(element.getParameterName(i));\n      }\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(signature.toString());\n      sb.push(\"\\n\");\n      let releases = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Import)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          let needsRetainRelease = type.isInternalReference && --numReferences > 0;\n          if (needsRetainRelease) {\n            this.needsRetain = true;\n            this.needsRelease = true;\n            sb.push(\"__retain(\");\n            releases.push(name);\n          }\n          this.makeLowerToValue(name, type, sb);\n          if (needsRetainRelease) {\n            sb.push(\")\");\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      if (releases.length) {\n        indent(sb, this.indentLevel++);\n        sb.push(\"try {\\n\");\n      }\n      if (signature.requiredParameters < parameterTypes.length) {\n        indent(sb, this.indentLevel);\n        sb.push(\"exports.__setArgumentsLength(arguments.length);\\n\");\n      }\n      const expr = new Array<string>();\n      expr.push(\"exports.\");\n      expr.push(name);\n      expr.push(\"(\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (i > 0) expr.push(\", \");\n        expr.push(element.getParameterName(i));\n      }\n      expr.push(\")\");\n      if (signature.returnType != Type.void) {\n        indent(sb, this.indentLevel);\n        sb.push(\"return \");\n        this.makeLiftFromValue(expr.join(\"\"), signature.returnType, sb);\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(expr.join(\"\"));\n      }\n      sb.push(\";\\n\");\n      if (releases.length) {\n        indent(sb, this.indentLevel - 1);\n        sb.push(\"} finally {\\n\");\n        for (let i = 0, k = releases.length; i < k; ++i) {\n          indent(sb, this.indentLevel);\n          sb.push(\"__release(\");\n          sb.push(releases[i]);\n          sb.push(\");\\n\");\n        }\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    // not implemented\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n    // let sb = this.sb;\n    // sb.push(\"export const \");\n    // sb.push(name);\n    // sb.push(\" = \");\n    // sb.push(originalName);\n    // sb.push(\";\\n\");\n  }\n\n  getExternalCode(element: Function): string | null {\n    let decorator = findDecorator(DecoratorKind.ExternalJs, element.decoratorNodes);\n    if (decorator) {\n      let args = decorator.args;\n      if (args && args.length == 1) {\n        let codeArg = args[0];\n        if (codeArg.kind == NodeKind.Literal) {\n          let literal = <LiteralExpression>codeArg;\n          if (literal.literalKind == LiteralKind.String) {\n            return (<StringLiteralExpression>literal).value;\n          }\n          if (literal.literalKind == LiteralKind.Template) {\n            let parts = (<TemplateLiteralExpression>literal).parts;\n            if (parts.length == 1) {\n              return parts[0];\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  build(): string {\n    let exports = this.exports;\n    let moduleImports = this.program.moduleImports;\n    let program = this.program;\n    let options = program.options;\n    let sb = this.sb;\n\n    sb.push(\"\"); // placeholder\n    indent(sb, this.indentLevel++);\n    if (!this.esm) sb.push(\"export \");\n    sb.push(\"async function instantiate(module, imports = {}) {\\n\");\n    const insertPos = sb.push(\"\") - 1;\n\n    // Instrument module imports. Keeps raw (JS) imports on the respective\n    // prototypes and overrides selectively where instrumentation is required.\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedImports = {\\n\");\n    let sbLengthBefore = sb.length;\n    for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      let moduleId = this.ensureModuleId(moduleName);\n      let module = <Map<string,Element>>moduleImports.get(moduleName);\n      indent(sb, this.indentLevel);\n      if (isIdentifier(moduleName)) {\n        sb.push(moduleName);\n      } else {\n        sb.push(\"\\\"\");\n        sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n        sb.push(\"\\\"\");\n      }\n      let resetPos = sb.length;\n      sb.push(\": Object.assign(Object.create(\");\n      if (moduleName == \"env\") {\n        sb.push(\"globalThis\");\n      } else {\n        sb.push(\"__module\");\n        sb.push(moduleId.toString());\n      }\n      sb.push(\"), \");\n      if (moduleName == \"env\") {\n        sb.push(\"imports.env || {}, \");\n      }\n      sb.push(\"{\\n\");\n      ++this.indentLevel;\n      let numInstrumented = 0;\n      for (let _keys2 = Map_keys(module), j = 0, l = _keys2.length; j < l; ++j) {\n        let name = _keys2[j];\n        let elem = assert(module.get(name));\n        if (elem.kind == ElementKind.Function) {\n          let func = <Function>elem;\n          let code = this.getExternalCode(func);\n          if (!isPlainFunction(func.signature, Mode.Import) || !isIdentifier(name) || code) {\n            this.makeFunctionImport(moduleName, name, <Function>elem, code);\n            ++numInstrumented;\n          }\n        } else if (elem.kind == ElementKind.Global) {\n          let global = <Global>elem;\n          if (!isPlainValue(global.type, Mode.Import) || !isIdentifier(name)) {\n            this.makeGlobalImport(moduleName, name, global);\n            ++numInstrumented;\n          }\n        }\n      }\n      --this.indentLevel;\n      if (!numInstrumented) {\n        sb.length = resetPos;\n        if (moduleName == \"env\") {\n          sb.push(\": Object.assign(Object.create(globalThis), imports.env || {})\");\n        } else {\n          sb.push(\": __module\");\n          sb.push(moduleId.toString());\n        }\n        sb.push(\",\\n\");\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(\"}),\\n\");\n      }\n    }\n    --this.indentLevel;\n    let hasAdaptedImports = sb.length > sbLengthBefore;\n    if (hasAdaptedImports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"};\\n\");\n    } else {\n      sb.length = sbLengthBefore - 2; // incl. indent\n    }\n\n    let mappings = this.importMappings;\n    let map = new Array<string>();\n    for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      if (moduleName == \"env\") {\n        map.push(\"  const env = imports.env;\\n\");\n      } else {\n        let moduleId = <i32>mappings.get(moduleName);\n        map.push(\"  const __module\");\n        map.push(moduleId.toString());\n        map.push(\" = imports\");\n        if (isIdentifier(moduleName)) {\n          map.push(\".\");\n          map.push(moduleName);\n        } else {\n          map.push(\"[\\\"\");\n          map.push(escapeString(moduleName, CharCode.DoubleQuote));\n          map.push(\"\\\"]\");\n        }\n        map.push(\";\\n\");\n      }\n    }\n    sb[insertPos] = map.join(\"\");\n\n    indent(sb, this.indentLevel);\n    sb.push(\"const { exports } = await WebAssembly.instantiate(module\");\n    if (hasAdaptedImports) {\n      sb.push(\", adaptedImports);\\n\");\n    } else {\n      sb.push(\", imports);\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"const memory = exports.memory || imports.env.memory;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedExports = Object.setPrototypeOf({\\n\");\n    sbLengthBefore = sb.length;\n\n    // Instrument module exports. Keeps raw (Wasm) exports on the prototype and\n    // overrides selectively where instrumentation is required.\n    this.walk();\n    --this.indentLevel;\n    let hasAdaptedExports = sb.length > sbLengthBefore;\n    if (hasAdaptedExports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"}, exports);\\n\");\n    } else {\n      if (\n        this.needsLiftBuffer || this.needsLowerBuffer ||\n        this.needsLiftString || this.needsLowerString ||\n        this.needsLiftArray || this.needsLowerArray ||\n        this.needsLiftTypedArray || this.needsLowerTypedArray ||\n        this.needsLiftStaticArray\n      ) {\n        sb.length = sbLengthBefore - 2; // skip adaptedExports + 1x indent\n      } else {\n        sb.length = sbLengthBefore - 4; // skip memory and adaptedExports + 2x indent\n      }\n    }\n\n    // Add external JS code fragments\n    let deferredCode = this.deferredCode;\n    if (deferredCode.length) {\n      for (let i = 0, k = deferredCode.length; i < k; ++i) {\n        sb.push(deferredCode[i]);\n      }\n    }\n\n    // Add the respective lifting and lowering adapters\n    if (this.needsLiftBuffer) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      sb.push(`  function __liftBuffer(pointer) {\n    if (!pointer) return null;\n    return memory.buffer.slice(pointer, pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2]);\n  }\n`);\n    }\n    if (this.needsLowerBuffer) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      sb.push(`  function __lowerBuffer(value) {\n    if (value == null) return 0;\n    const pointer = exports.__new(value.byteLength, ${arrayBufferId}) >>> 0;\n    new Uint8Array(memory.buffer).set(new Uint8Array(value), pointer);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftString) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      let chunkSize = 1024;\n      sb.push(`  function __liftString(pointer) {\n    if (!pointer) return null;\n    const\n      end = pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2] >>> 1,\n      memoryU16 = new Uint16Array(memory.buffer);\n    let\n      start = pointer >>> 1,\n      string = \"\";\n    while (end - start > ${chunkSize}) string += String.fromCharCode(...memoryU16.subarray(start, start += ${chunkSize}));\n    return string + String.fromCharCode(...memoryU16.subarray(start, end));\n  }\n`);\n    }\n    if (this.needsLowerString) {\n      let stringId = program.stringInstance.id;\n      sb.push(`  function __lowerString(value) {\n    if (value == null) return 0;\n    const\n      length = value.length,\n      pointer = exports.__new(length << 1, ${stringId}) >>> 0,\n      memoryU16 = new Uint16Array(memory.buffer);\n    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftArray) {\n      let dataStartOffset = program.arrayBufferViewInstance.offsetof(\"dataStart\");\n      let lengthOffset = program.arrayBufferViewInstance.nextMemoryOffset;\n      sb.push(`  function __liftArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      memoryU32 = new Uint32Array(memory.buffer),\n      dataStart = memoryU32[pointer + ${dataStartOffset} >>> 2],\n      length = memoryU32[pointer + ${lengthOffset} >>> 2],\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(dataStart + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let arraySize = arrayBufferViewInstance.nextMemoryOffset + 4; // + length\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      let lengthOffset = byteLengthOffset + 4;\n      sb.push(`  function __lowerArray(lowerElement, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__pin(exports.__new(${arraySize}, id)) >>> 0,\n      memoryU32 = new Uint32Array(memory.buffer);\n    memoryU32[header + ${bufferOffset} >>> 2] = buffer;\n    memoryU32[header + ${dataStartOffset} >>> 2] = buffer;\n    memoryU32[header + ${byteLengthOffset} >>> 2] = length << align;\n    memoryU32[header + ${lengthOffset} >>> 2] = length;\n    for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);\n    exports.__unpin(buffer);\n    exports.__unpin(header);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftTypedArray) {\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      sb.push(`  function __liftTypedArray(constructor, pointer) {\n    if (!pointer) return null;\n    const memoryU32 = new Uint32Array(memory.buffer);\n    return new constructor(\n      memory.buffer,\n      memoryU32[pointer + ${dataStartOffset} >>> 2],\n      memoryU32[pointer + ${byteLengthOffset} >>> 2] / constructor.BYTES_PER_ELEMENT\n    ).slice();\n  }\n`);\n    }\n    if (this.needsLowerTypedArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let size = arrayBufferViewInstance.nextMemoryOffset;\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      sb.push(`  function __lowerTypedArray(constructor, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__new(${size}, id) >>> 0,\n      memoryU32 = new Uint32Array(memory.buffer);\n    memoryU32[header + ${bufferOffset} >>> 2] = buffer;\n    memoryU32[header + ${dataStartOffset} >>> 2] = buffer;\n    memoryU32[header + ${byteLengthOffset} >>> 2] = length << align;\n    new constructor(memory.buffer, buffer, length).set(values);\n    exports.__unpin(buffer);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftStaticArray) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      sb.push(`  function __liftStaticArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      length = new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2] >>> align,\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(pointer + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerStaticArray) {\n      sb.push(`  function __lowerStaticArray(lowerElement, id, align, values, typedConstructor) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, id)) >>> 0;\n    if (typedConstructor) {\n      new typedConstructor(memory.buffer, buffer, length).set(values);\n    } else {\n      for (let i = 0; i < length; i++) lowerElement(buffer + (i << align >>> 0), values[i]);\n    }\n    exports.__unpin(buffer);\n    return buffer;\n  }\n`);\n    }\n    if (this.needsLiftInternref || this.needsLowerInternref) {\n      sb.push(\"  class Internref extends Number {}\\n\");\n    }\n    if (this.needsLiftInternref) {\n      this.needsRetain = true;\n      this.needsRelease = true;\n      sb.push(`  const registry = new FinalizationRegistry(__release);\n  function __liftInternref(pointer) {\n    if (!pointer) return null;\n    const sentinel = new Internref(__retain(pointer));\n    registry.register(sentinel, pointer);\n    return sentinel;\n  }\n`);\n    }\n    if (this.needsLowerInternref) {\n      sb.push(`  function __lowerInternref(value) {\n    if (value == null) return 0;\n    if (value instanceof Internref) return value.valueOf();\n    throw TypeError(\"internref expected\");\n  }\n`);\n    }\n    if (this.needsRetain || this.needsRelease) {\n      sb.push(`  const refcounts = new Map();\n`);\n    }\n    if (this.needsRetain) {\n      sb.push(`  function __retain(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount) refcounts.set(pointer, refcount + 1);\n      else refcounts.set(exports.__pin(pointer), 1);\n    }\n    return pointer;\n  }\n`);\n    }\n    if (this.needsRelease) {\n      sb.push(`  function __release(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);\n      else if (refcount) refcounts.set(pointer, refcount - 1);\n      else throw Error(\\`invalid refcount '\\${refcount}' for reference '\\${pointer}'\\`);\n    }\n  }\n`);\n    }\n    if (this.needsNotNull) {\n      sb.push(`  function __notnull() {\n    throw TypeError(\"value must not be null\");\n  }\n`);\n    }\n\n    let exportStart = options.exportStart;\n    if (exportStart) {\n      sb.push(`  exports.${exportStart}();\\n`);\n    }\n\n    if (hasAdaptedExports) {\n      sb.push(\"  return adaptedExports;\\n}\\n\");\n    } else {\n      sb.push(\"  return exports;\\n}\\n\");\n    }\n    --this.indentLevel;\n    assert(this.indentLevel == 0);\n\n    if (this.esm) {\n      sb.push(\"export const {\\n  \");\n      if (this.program.options.exportMemory) {\n        sb.push(\"memory,\\n  \");\n      }\n      if (this.program.options.exportTable) {\n        sb.push(\"table,\\n  \");\n      }\n      for (let i = 0, k = exports.length; i < k; ++i) {\n        if (i > 0) sb.push(\",\\n  \");\n        sb.push(exports[i]);\n      }\n      sb.push(`\n} = await (async url => instantiate(\n  await (async () => {\n    try { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }\n    catch { return globalThis.WebAssembly.compile(await (await import(\"node:fs/promises\")).readFile(url)); }\n  })(), {\n`);\n      let needsMaybeDefault = false;\n      let importExpr = new Array<string>();\n      for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        if (moduleName == \"env\") {\n          indent(sb, 2);\n          sb.push(\"env: globalThis,\\n\");\n        } else {\n          let moduleId = this.ensureModuleId(moduleName);\n          indent(sb, 2);\n          if (isIdentifier(moduleName)) {\n            sb.push(moduleName);\n          } else {\n            sb.push(\"\\\"\");\n            sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n            sb.push(\"\\\"\");\n          }\n          sb.push(\": __maybeDefault(__import\");\n          sb.push(moduleId.toString());\n          sb.push(\"),\\n\");\n          importExpr.push(\"import * as __import\");\n          importExpr.push(moduleId.toString());\n          importExpr.push(\" from \\\"\");\n          importExpr.push(escapeString(moduleName, CharCode.DoubleQuote));\n          importExpr.push(\"\\\";\\n\");\n          needsMaybeDefault = true;\n        }\n      }\n      sb[0] = importExpr.join(\"\");\n      sb.push(`  }\n))(new URL(\"${escapeString(options.basenameHint, CharCode.DoubleQuote)}.wasm\", import.meta.url));\n`);\n      if (needsMaybeDefault) {\n        sb.push(`function __maybeDefault(module) {\n  return typeof module.default === \"object\" && Object.keys(module).length == 1\n    ? module.default\n    : module;\n}\n`);\n      }\n    }\n    return sb.join(\"\");\n  }\n\n  ensureModuleId(moduleName: string): i32 {\n    if (moduleName == \"env\") return -1;\n    let importMap = this.importMappings;\n    let moduleId = importMap.has(moduleName)\n      ? i32(importMap.get(moduleName))\n      : importMap.size;\n    importMap.set(moduleName, moduleId);\n    return moduleId;\n  }\n\n  /** Lifts a WebAssembly value to a JavaScript value. */\n  makeLiftFromValue(name: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lift reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extends(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__liftBuffer(\");\n        this.needsLiftBuffer = true;\n      } else if (clazz.extends(this.program.stringInstance.prototype)) {\n        sb.push(\"__liftString(\");\n        this.needsLiftString = true;\n      } else if (clazz.extends(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftArray(\");\n        this.makeLiftFromMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftArray = true;\n      } else if (clazz.extends(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftStaticArray(\");\n        this.makeLiftFromMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftStaticArray = true;\n      } else if (clazz.extends(this.program.arrayBufferViewInstance.prototype)) {\n        sb.push(\"__liftTypedArray(\");\n        if (clazz.name == \"Uint64Array\") {\n          sb.push(\"BigUint64Array\");\n        } else if (clazz.name == \"Int64Array\") {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        this.needsLiftTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__liftRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLifts.has(clazz)) {\n          this.deferredLifts.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLiftRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__liftInternref(\");\n        this.needsLiftInternref = true;\n      }\n      sb.push(name);\n      if (!name.startsWith(\"new Uint32Array(\")) {\n        // no need to coerce when lifting with indirection\n        sb.push(\" >>> 0\");\n      }\n      sb.push(\")\");\n    } else {\n      // Lift basic plain types\n      if (type == Type.bool) {\n        sb.push(`${name} != 0`);\n      } else if (type.isUnsignedIntegerValue && type.size >= 32) {\n        sb.push(type.size == 64 ? `BigInt.asUintN(64, ${name})` : `${name} >>> 0`);\n      } else {\n        sb.push(name);\n      }\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly value. */\n  makeLowerToValue(name: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lower reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extends(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__lowerBuffer(\");\n        this.needsLowerBuffer = true;\n      } else if (clazz.extends(this.program.stringInstance.prototype)) {\n        sb.push(\"__lowerString(\");\n        this.needsLowerString = true;\n      } else if (clazz.extends(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerArray(\");\n        this.makeLowerToMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerArray = true;\n      } else if (clazz.extends(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerStaticArray(\");\n        this.makeLowerToMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerStaticArray = true;\n      } else if (clazz.extends(this.program.arrayBufferViewInstance.prototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerTypedArray(\");\n        if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__lowerRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLowers.has(clazz)) {\n          this.deferredLowers.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLowerRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__lowerInternref(\");\n        this.needsLowerInternref = true;\n      }\n      sb.push(name);\n      if (clazz.extends(this.program.staticArrayPrototype)) {\n        // optional last argument for __lowerStaticArray\n        let valueType = clazz.getArrayValueType();\n        if (valueType.isNumericValue) {\n          sb.push(\", \");\n          if (valueType == Type.u8 || valueType == Type.bool) {\n            sb.push(\"Uint8Array\");\n          } else if (valueType == Type.i8) {\n            sb.push(\"Int8Array\");\n          } else if (valueType == Type.u16) {\n            sb.push(\"Uint16Array\");\n          } else if (valueType == Type.i16) {\n            sb.push(\"Int16Array\");\n          } else if (valueType == Type.u32 || valueType == Type.usize32) {\n            sb.push(\"Uint32Array\");\n          } else if (valueType == Type.i32 || valueType == Type.isize32) {\n            sb.push(\"Int32Array\");\n          } else if (valueType == Type.u64 || valueType == Type.usize64) {\n            sb.push(\"BigUint64Array\");\n          } else if (valueType == Type.i64 || valueType == Type.isize64) {\n            sb.push(\"BigInt64Array\");\n          } else if (valueType == Type.f32) {\n            sb.push(\"Float32Array\");\n          } else if (valueType == Type.f64) {\n            sb.push(\"Float64Array\");\n          } else {\n            // unreachable\n            assert(false);\n          }\n        }\n      }\n      sb.push(\")\");\n      if (!type.is(TypeFlags.Nullable)) {\n        this.needsNotNull = true;\n        sb.push(\" || __notnull()\");\n      }\n    } else {\n      // Lower basic types\n      sb.push(name); // basic value\n      if (type.isIntegerValue && type.size == 64) {\n        sb.push(\" || 0n\");\n      } else if (type == Type.bool) {\n        // may be stored to an Uint8Array, make sure to store 1/0\n        sb.push(\" ? 1 : 0\");\n      }\n    }\n  }\n\n  /** Lifts a WebAssembly memory address to a JavaScript value. */\n  makeLiftFromMemory(valueType: Type, sb: string[] = this.sb, target: string | null = null): void {\n    if (!target) {\n      sb.push(\"pointer => \");\n      target = \"pointer\";\n    }\n    if (valueType.isInternalReference) {\n      let expr = new Array<string>();\n      expr.push(\"new Uint32Array(memory.buffer)[\");\n      expr.push(target);\n      expr.push(\" >>> 2]\");\n      this.makeLiftFromValue(expr.join(\"\"), valueType, sb);\n    } else {\n      if (valueType == Type.i8) {\n        sb.push(\"new Int8Array(memory.buffer)[\");\n      } else if (valueType == Type.u8 || valueType == Type.bool) {\n        sb.push(\"new Uint8Array(memory.buffer)[\");\n      } else if (valueType == Type.i16) {\n        sb.push(\"new Int16Array(memory.buffer)[\");\n      } else if (valueType == Type.u16) {\n        sb.push(\"new Uint16Array(memory.buffer)[\");\n      } else if (valueType == Type.i32 || valueType == Type.isize32) {\n        sb.push(\"new Int32Array(memory.buffer)[\");\n      } else if (valueType == Type.u32 || valueType == Type.usize32) {\n        sb.push(\"new Uint32Array(memory.buffer)[\");\n      } else if (valueType == Type.i64 || valueType == Type.isize64) {\n        sb.push(\"new BigInt64Array(memory.buffer)[\");\n      } else if (valueType == Type.u64 || valueType == Type.usize64) {\n        sb.push(\"new BigUint64Array(memory.buffer)[\");\n      } else if (valueType == Type.f32) {\n        sb.push(\"new Float32Array(memory.buffer)[\");\n      } else if (valueType == Type.f64) {\n        sb.push(\"new Float64Array(memory.buffer)[\");\n      } else {\n        sb.push(\"{ throw Error(\\\"unsupported type\\\"); }\");\n        return;\n      }\n      sb.push(target);\n      sb.push(\" >>> \");\n      sb.push(valueType.alignLog2.toString());\n      sb.push(\"]\");\n      if (valueType == Type.bool) {\n        sb.push(\" != 0\");\n      }\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly memory address. */\n  makeLowerToMemory(valueType: Type, sb: string[] = this.sb, targetName: string | null = null, valueName: string | null = null): void {\n    let skipTail = true;\n    if (!targetName  || !valueName) {\n      sb.push(\"(pointer, value) => { \");\n      targetName = \"pointer\";\n      valueName = \"value\";\n      skipTail = false;\n    }\n    if (valueType.isInternalReference) {\n      sb.push(\"new Uint32Array(memory.buffer)[\");\n    } else {\n      if (valueType == Type.i8) {\n        sb.push(\"new Int8Array(memory.buffer)[\");\n      } else if (valueType == Type.u8 || valueType == Type.bool) {\n        sb.push(\"new Uint8Array(memory.buffer)[\");\n      } else if (valueType == Type.i16) {\n        sb.push(\"new Int16Array(memory.buffer)[\");\n      } else if (valueType == Type.u16) {\n        sb.push(\"new Uint16Array(memory.buffer)[\");\n      } else if (valueType == Type.i32 || valueType == Type.isize32) {\n        sb.push(\"new Int32Array(memory.buffer)[\");\n      } else if (valueType == Type.u32 || valueType == Type.usize32) {\n        sb.push(\"new Uint32Array(memory.buffer)[\");\n      } else if (valueType == Type.i64 || valueType == Type.isize64) {\n        sb.push(\"new BigInt64Array(memory.buffer)[\");\n      } else if (valueType == Type.u64 || valueType == Type.usize64) {\n        sb.push(\"new BigUint64Array(memory.buffer)[\");\n      } else if (valueType == Type.f32) {\n        sb.push(\"new Float32Array(memory.buffer)[\");\n      } else if (valueType == Type.f64) {\n        sb.push(\"new Float64Array(memory.buffer)[\");\n      } else {\n        if (skipTail) {\n          sb.push(\"(() => { throw Error(\\\"unsupported type\\\") })()\");\n        } else {\n          sb.push(\"throw Error(\\\"unsupported type\\\"); }\");\n        }\n        return;\n      }\n    }\n    sb.push(targetName);\n    sb.push(\" >>> \");\n    sb.push(valueType.alignLog2.toString());\n    sb.push(\"] = \");\n    this.makeLowerToValue(valueName, valueType, sb);\n    if (!skipTail) sb.push(\"; }\");\n  }\n\n  makeLiftRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __liftRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(pointer) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lifting as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (!pointer) return null;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"return {\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.Field) continue;\n        let field = <Field>member;\n        indent(sb, this.indentLevel);\n        sb.push(field.name);\n        sb.push(\": \");\n        this.makeLiftFromMemory(field.type, sb, \"pointer + \" + field.memoryOffset.toString());\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  makeLowerRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __lowerRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(value) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lowering as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (value == null) return 0;\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"const pointer = exports.__pin(exports.__new(\");\n    sb.push(clazz.nextMemoryOffset.toString());\n    sb.push(\", \");\n    sb.push(clazz.id.toString());\n    sb.push(\"));\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.Field) continue;\n        let field = <Field>member;\n        indent(sb, this.indentLevel);\n        this.makeLowerToMemory(field.type, sb, \"pointer + \" + field.memoryOffset.toString(), \"value.\" + memberName);\n        sb.push(\";\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"exports.__unpin(pointer);\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"return pointer;\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  Import,\n  Export\n}\n\nfunction isPlainValue(type: Type, kind: Mode): bool {\n  if (kind == Mode.Import) {\n    // may be stored to an Uint8Array, make sure to store 1/0\n    if (type == Type.bool) return false;\n    // requires coercion of undefined to 0n\n    if (type.isIntegerValue && type.size == 64) return false;\n  } else {\n    // requires coercion from 1/0 to true/false\n    if (type == Type.bool) return false;\n    // requires coercion from signed to unsigned for u32 and u64.\n    // Note, u8 and u16 doesn't overflow in native type so mark as plain\n    if (type.isUnsignedIntegerValue && type.size >= 32) return false;\n  }\n  return !type.isInternalReference;\n}\n\nfunction isPlainFunction(signature: Signature, mode: Mode): bool {\n  let parameterTypes = signature.parameterTypes;\n  let inverseMode = mode == Mode.Import ? Mode.Export : Mode.Import;\n  if (!isPlainValue(signature.returnType, mode)) return false;\n  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n    if (!isPlainValue(parameterTypes[i], inverseMode)) return false;\n  }\n  return true;\n}\n\nfunction isPlainObject(clazz: Class): bool {\n  // A plain object does not inherit and does not have a constructor or private properties\n  if (clazz.base) return false;\n  let members = clazz.members;\n  if (members) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = _values[i];\n      if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n      if (member.is(CommonFlags.Constructor)) {\n        // a generated constructor is ok\n        if (member.declaration.range != member.program.nativeRange) return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction indentText(text: string, indentLevel: i32, sb: string[], butFirst: bool = false): void {\n  let lineStart = 0;\n  let length = text.length;\n  let pos = 0;\n  while (pos < length) {\n    if (text.charCodeAt(pos) == CharCode.LineFeed) {\n      if (butFirst) butFirst = false;\n      else indent(sb, indentLevel);\n      sb.push(text.substring(lineStart, lineStart = pos + 1));\n    }\n    ++pos;\n  }\n  if (lineStart < length) {\n    if (!butFirst) indent(sb, indentLevel);\n    sb.push(text.substring(lineStart));\n  }\n}\n\nexport function liftRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // functions lift as internref using __pin\n    assert(type.signatureReference);\n    return true;\n  }\n  let program = clazz.program;\n  // flat collections lift via memory copy\n  if (\n    clazz.extends(program.arrayBufferInstance.prototype) ||\n    clazz.extends(program.stringInstance.prototype) ||\n    clazz.extends(program.arrayBufferViewInstance.prototype)\n  ) {\n    return false;\n  }\n  // nested collections lift depending on element type\n  if (\n    clazz.extends(program.arrayPrototype) ||\n    clazz.extends(program.staticArrayPrototype)\n  ) {\n    return liftRequiresExportRuntime(clazz.getArrayValueType());\n  }\n  // complex objects lift as internref using __pin. plain objects may or may not\n  // involve the runtime: assume that they do to avoid potentially costly checks\n  return true;\n}\n\nexport function lowerRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // lowers by reference\n    assert(type.signatureReference);\n    return false;\n  }\n  // lowers using __new\n  let program = clazz.program;\n  if (\n    clazz.extends(program.arrayBufferInstance.prototype) ||\n    clazz.extends(program.stringInstance.prototype) ||\n    clazz.extends(program.arrayBufferViewInstance.prototype) ||\n    clazz.extends(program.arrayPrototype) ||\n    clazz.extends(program.staticArrayPrototype)\n  ) {\n    return true;\n  }\n  // complex objects lower via internref by reference,\n  // while plain objects lower using __new\n  return isPlainObject(clazz);\n}\n", "/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\nimport {\n  BuiltinNames,\n  BuiltinContext,\n  builtins,\n  function_builtins,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI,\n  compileClassInstanceOf\n} from \"./builtins\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  TypeRef,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getConstValueV128,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  needsExplicitUnreachable,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  createType,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags,\n  isConstZero,\n  isConstNegZero,\n  isConstExpressionNaN,\n  ensureType\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  STATIC_DELIMITER,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  Runtime,\n  featureToString\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  DeclaredElement,\n  Enum,\n  Field,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n  DecoratorNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n  CompiledExpression,\n\n  TypeNode,\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToRefs\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  writeV128,\n  cloneMap,\n  isPowerOf2,\n  readI32,\n  isIdentifier,\n  accuratePow64,\n  v128_zero,\n  v128_ones,\n} from \"./util\";\n\nimport {\n  RtraceMemory\n} from \"./passes/rtrace\";\n\nimport {\n  ShadowStackPass\n} from \"./passes/shadowstack\";\n\nimport {\n  liftRequiresExportRuntime,\n  lowerRequiresExportRuntime\n} from \"./bindings/js\";\n\n/** Compiler options. */\nexport class Options {\n  constructor() { /* as internref */ }\n\n  /** WebAssembly target. Defaults to {@link Target.Wasm32}. */\n  target: Target = Target.Wasm32;\n  /** Runtime type. Defaults to Incremental GC. */\n  runtime: Runtime = Runtime.Incremental;\n  /** If true, indicates that debug information will be emitted by Binaryen. */\n  debugInfo: bool = false;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imported memory is zero filled. */\n  zeroFilledMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** If given, exports the start function instead of calling it implicitly. */\n  exportStart: string | null = null;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. These are the finished proposals. */\n  features: Feature = Feature.MutableGlobals\n                    | Feature.SignExtension\n                    | Feature.NontrappingF2I\n                    | Feature.BulkMemory;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n  /** If true, exports the runtime helpers. */\n  exportRuntime: bool = false;\n  /** Stack size in bytes, if using a stack. */\n  stackSize: i32 = 0;\n  /** Semantic major bundle version from root package.json */\n  bundleMajorVersion: i32 = 0;\n  /** Semantic minor bundle version from root package.json */\n  bundleMinorVersion: i32 = 0;\n  /** Semantic patch bundle version from root package.json */\n  bundlePatchVersion: i32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n  /** Hinted basename. */\n  basenameHint: string = \"output\";\n  /** Hinted bindings generation. */\n  bindingsHint: bool = false;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.Wasm64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the size type reference matching the target. */\n  get sizeTypeRef(): TypeRef {\n    return this.target == Target.Wasm64 ? TypeRef.I64 : TypeRef.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  None = 0,\n\n  /** Must implicitly convert to the target type. */\n  ConvImplicit = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  ConvExplicit = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MustWrap = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WillDrop = 1 << 3,\n  /** Indicates that static data is preferred. */\n  PreferStatic = 1 << 4,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IsThis = 1 << 5\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  None = 0,\n  /** Requires data setup. */\n  Data = 1 << 0,\n  /** Requires a stack. */\n  Stack = 1 << 1,\n  /** Requires heap setup. */\n  Heap = 1 << 2,\n  /** Requires runtime type information setup. */\n  Rtti = 1 << 3,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 4,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 5,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 6\n}\n\n/** Imported default names of compiler-generated elements. */\nexport namespace ImportNames {\n  /** Name of the default namespace */\n  export const DefaultNamespace = \"env\";\n  /** Name of the memory instance, if imported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if imported. */\n  export const Table = \"table\";\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the memory instance, if exported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const Table = \"table\";\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n}\n\n/** Functions to export if `--exportRuntime` is set. */\nconst runtimeFunctions = [ \"__new\", \"__pin\", \"__unpin\", \"__collect\" ];\n/** Globals to export if `--exportRuntime` is set. */\nconst runtimeGlobals = [ \"__rtti_base\" ];\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Module instance being compiled. */\n  module: Module;\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.None;\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending class-specific instanceof helpers. */\n  pendingClassInstanceOf: Set<ClassPrototype> = new Set();\n  /** Virtually called stubs that may have overloads. */\n  virtualStubs: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n  /** Shadow stack reference. */\n  shadowStack!: ShadowStackPass;\n  /** Whether the module has custom function exports. */\n  hasCustomFunctionExports: bool = false;\n  /** Whether the module would use the exported runtime to lift/lower. */\n  desiresExportRuntime: bool = false;\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    let options = program.options;\n    let module = Module.create(options.stackSize > 0, options.sizeTypeRef);\n    this.module = module;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    let featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SignExtension)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MutableGlobals)) featureFlags |= FeatureFlags.MutableGlobals;\n    if (options.hasFeature(Feature.NontrappingF2I)) featureFlags |= FeatureFlags.TruncSat;\n    if (options.hasFeature(Feature.BulkMemory)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.Simd)) featureFlags |= FeatureFlags.SIMD;\n    if (options.hasFeature(Feature.Threads)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.ExceptionHandling)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TailCalls)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.ReferenceTypes)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MultiValue)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.Memory64)) featureFlags |= FeatureFlags.Memory64;\n    if (options.hasFeature(Feature.RelaxedSimd)) featureFlags |= FeatureFlags.RelaxedSIMD;\n    if (options.hasFeature(Feature.ExtendedConst)) featureFlags |= FeatureFlags.ExtendedConst;\n    if (options.hasFeature(Feature.Stringref)) featureFlags |= FeatureFlags.Stringref;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    let startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, new Signature(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n    this.shadowStack = new ShadowStackPass(this);\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    let options = this.options;\n    let module = this.module;\n    let program = this.program;\n    let resolver = this.resolver;\n    let hasShadowStack = options.stackSize > 0; // implies runtime=incremental\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n    // obtain the main start function\n    let startFunctionInstance = this.currentFlow.targetFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    let startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // add mutable data, heap and rtti offset dummies\n    if (options.isWasm64) {\n      module.addGlobal(BuiltinNames.data_end,  TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, true, module.i64(0));\n    } else {\n      module.addGlobal(BuiltinNames.data_end,  TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, true, module.i32(0));\n    }\n\n    // compile entry file(s) while traversing reachable elements\n    let files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.compileFile(file);\n        this.compileModuleExports(file);\n      }\n    }\n\n    // compile and export runtime if requested or necessary\n    if (this.options.exportRuntime || (this.options.bindingsHint && this.desiresExportRuntime)) {\n      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\n        let name = runtimeFunctions[i];\n        let instance = program.requireFunction(name);\n        if (this.compileFunction(instance) && !module.hasExport(name)) {\n          module.addFunctionExport(instance.internalName, name);\n        }\n      }\n      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\n        let name = runtimeGlobals[i];\n        let instance = program.requireGlobal(name);\n        if (this.compileGlobal(instance) && !module.hasExport(name)) {\n          module.addGlobalExport(instance.internalName, name);\n        }\n      }\n    }\n\n    // hooks must import _g to pass validation; the easiest way is to\n    // just call it (in dead code after accept, if there's no better\n    // place), but we can save 7 bytes by only importing it...\n    let instance = program.requireFunction(CommonNames._g);\n    if (!instance.is(CommonFlags.Compiled)) {\n      this.compileFunction(instance);\n      // ...except optimization will remove the import if it isn't\n      // used; so export it instead of calling (this might seem to\n      // contradict the documented restriction that hooks \"must only\n      // export the cbak and hook functions\", but works in practice,\n      // because the export is removed in post-processing by hook\n      // cleaner)\n      module.addFunctionExport(BuiltinNames._g, CommonNames._g);\n    }\n\n    // compile lazy functions\n    let lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // compile pending class-specific instanceof helpers\n    // TODO: for (let prototype of this.pendingClassInstanceOf.values()) {\n    for (let _values = Set_values(this.pendingClassInstanceOf), i = 0, k = _values.length; i < k; ++i) {\n      let prototype = unchecked(_values[i]);\n      compileClassInstanceOf(this, prototype);\n    }\n\n    // set up virtual stubs\n    let functionTable = this.functionTable;\n    let virtualStubs = this.virtualStubs;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.Virtual)) {\n        assert(instance.is(CommonFlags.Instance));\n        functionTable[i] = this.ensureVirtualStub(instance); // includes varargs stub\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    let virtualStubsSeen = new Set<Function>();\n    do {\n      // virtual stubs and overloads have cross-dependencies on each other, in that compiling\n      // either may discover the respective other. do this in a loop until no more are found.\n      resolver.discoveredOverload = false;\n      for (let _values = Set_values(virtualStubs), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        let overloadInstances = resolver.resolveOverloads(instance);\n        if (overloadInstances) {\n          for (let i = 0, k = overloadInstances.length; i < k; ++i) {\n            this.compileFunction(overloadInstances[i]);\n          }\n        }\n        virtualStubsSeen.add(instance);\n      }\n    } while (virtualStubs.size > virtualStubsSeen.size || resolver.discoveredOverload);\n    virtualStubsSeen.clear();\n    for (let _values = Set_values(virtualStubs), i = 0, k = _values.length; i < k; ++i) {\n      this.finalizeVirtualStub(_values[i]);\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.Rtti) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    let memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);\n\n    // finalize data\n    module.removeGlobal(BuiltinNames.data_end);\n    if ((this.runtimeFeatures & RuntimeFeatures.Data) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize stack (grows down from __heap_base to __data_end)\n    module.removeGlobal(BuiltinNames.stack_pointer);\n    if ((this.runtimeFeatures & RuntimeFeatures.Stack) != 0 || hasShadowStack) {\n      memoryOffset = i64_align(\n        i64_add(memoryOffset, i64_new(options.stackSize)),\n        options.usizeType.byteSize\n      );\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize heap\n    module.removeGlobal(BuiltinNames.heap_base);\n    if ((this.runtimeFeatures & RuntimeFeatures.Heap) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // setup default memory & table\n    this.initDefaultMemory(memoryOffset);\n    this.initDefaultTable();\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,\n        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n\n    // NOTE: no more element compiles from here. may go to the start function!\n\n    // compile the start function if not empty or if explicitly requested\n    let startIsEmpty = !startFunctionBody.length;\n    let exportStart = options.exportStart;\n    if (!startIsEmpty || exportStart != null) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && exportStart != null) {\n        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.global_set(BuiltinNames.started, module.i32(1))\n        );\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, TypeRef.I32),\n            module.return()\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(startFunctionInstance.getNonParameterLocalTypes()),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (exportStart == null) module.setStart(funcRef);\n      else {\n        if (!isIdentifier(exportStart) || module.hasExport(exportStart)) {\n          this.error(\n            DiagnosticCode.Start_function_name_0_is_invalid_or_conflicts_with_another_export,\n            this.program.nativeRange, exportStart\n          );\n        } else {\n          module.addFunctionExport(startFunctionInstance.internalName, exportStart);\n        }\n      }\n    }\n\n    // Run custom passes\n    if (hasShadowStack) {\n      this.shadowStack.walkModule();\n    }\n    if (program.lookup(\"ASC_RTRACE\") != null) {\n      new RtraceMemory(this).walkModule();\n    }\n\n    return module;\n  }\n\n  private initDefaultMemory(memoryOffset: i64): void {\n    this.memoryOffset = memoryOffset;\n\n    let options = this.options;\n    let module = this.module;\n    let memorySegments = this.memorySegments;\n\n    let initialPages: u32 = 0;\n    let maximumPages = Module.UNLIMITED_MEMORY;\n    let isSharedMemory = false;\n\n    if (options.memoryBase /* is specified */ || memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.Threads)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n\n    // check that we didn't exceed lowMemoryLimit already\n    let lowMemoryLimit32 = options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n\n    // Setup internal memory with default name \"0\"\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.Memory : null,\n      CommonNames.DefaultMemory,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) {\n      module.addMemoryImport(\n        CommonNames.DefaultMemory,\n        ImportNames.DefaultNamespace,\n        ImportNames.Memory,\n        isSharedMemory\n      );\n    }\n  }\n\n  private initDefaultTable(): void {\n    let options = this.options;\n    let module = this.module;\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\n        CommonNames.DefaultTable,\n        ImportNames.DefaultNamespace,\n        ImportNames.Table\n      );\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(CommonNames.DefaultTable, ExportNames.Table);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up function table (first elem is blank)\n    let tableBase = options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    let functionTable = this.functionTable;\n    let functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n\n    let initialTableSize = <Index>tableBase + functionTable.length;\n    let maximumTableSize = Module.UNLIMITED_TABLE;\n\n    if (!(options.importTable || options.exportTable)) {\n      // use fixed size for non-imported and non-exported tables\n      maximumTableSize = initialTableSize;\n      if (options.willOptimize) {\n        // Hint for directize pass which indicate table's content will not change\n        // and can be better optimized\n        module.setPassArgument(\"directize-initial-contents-immutable\", \"true\");\n      }\n    }\n    module.addFunctionTable(\n      CommonNames.DefaultTable,\n      initialTableSize,\n      maximumTableSize,\n      functionTableNames,\n      module.i32(tableBase)\n    );\n  }\n\n  // === Exports ==================================================================================\n\n  /** Compiles the respective module exports for the specified entry file. */\n  private compileModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.compileModuleExport(elementName, element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.compileModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Compiles the respective module export(s) for the specified element. */\n  private compileModuleExport(name: string, element: DeclaredElement, prefix: string = \"\"): void {\n    let module = this.module;\n    switch (element.kind) {\n      case ElementKind.FunctionPrototype: {\n        // obtain the default instance\n        let functionPrototype = <FunctionPrototype>element;\n        if (!functionPrototype.is(CommonFlags.Generic)) {\n          let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n          if (functionInstance) {\n            this.compileModuleExport(name, functionInstance, prefix);\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          this.compileFunction(functionInstance);\n          if (functionInstance.is(CommonFlags.Compiled)) {\n            let exportName = prefix + name;\n            if (!module.hasExport(exportName)) {\n              module.addFunctionExport(functionInstance.internalName, exportName);\n              this.hasCustomFunctionExports = true;\n              let hasManagedOperands = signature.hasManagedOperands;\n              if (hasManagedOperands) {\n                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());\n              }\n              if (!this.desiresExportRuntime) {\n                let thisType = signature.thisType;\n                if (\n                  thisType && lowerRequiresExportRuntime(thisType) ||\n                  liftRequiresExportRuntime(signature.returnType)\n                ) {\n                  this.desiresExportRuntime = true;\n                } else {\n                  let parameterTypes = signature.parameterTypes;\n                  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n                    if (lowerRequiresExportRuntime(parameterTypes[i])) {\n                      this.desiresExportRuntime = true;\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n        }\n        break;\n      }\n      case ElementKind.Global: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n        if (!isConst && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.warning(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            global.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        this.compileGlobal(global);\n        if (global.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n            if (!this.desiresExportRuntime) {\n              let type = global.type;\n              if (\n                liftRequiresExportRuntime(type) ||\n                !global.is(CommonFlags.Const) && lowerRequiresExportRuntime(type)\n              ) {\n                this.desiresExportRuntime = true;\n              }\n            }\n          }\n          if (global.type == Type.v128) {\n            this.warning(\n              DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n              global.typeNode\n                ? assert(global.typeNode).range\n                : global.identifierNode.range,\n              \"v128\"\n            );\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Enum: {\n        this.compileEnum(<Enum>element);\n        let members = element.members;\n        if (members) {\n          let subPrefix = prefix + name + STATIC_DELIMITER;\n          for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(members.get(memberName));\n            if (!member.is(CommonFlags.Private)) {\n              this.compileModuleExport(memberName, member, subPrefix);\n            }\n          }\n        }\n        return;\n      }\n      case ElementKind.EnumValue: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.error(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            enumValue.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        if (enumValue.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n          return;\n        }\n        break;\n      }\n    }\n    this.warning(\n      DiagnosticCode.Only_variables_functions_and_enums_become_WebAssembly_module_exports,\n      element.identifierNode.range\n    );\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    let file: File;\n    let filesByName = this.program.filesByName;\n    let pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.Compiled)) return;\n    file.set(CommonFlags.Compiled);\n\n    // compile top-level statements within the file's start function\n    let startFunction = file.startFunction;\n    let startSignature = startFunction.signature;\n    let previousBody = this.currentBody;\n    let startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    let previousFlow = this.currentFlow;\n    let flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<TypeRef>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();\n      const funcRef = module.addFunction(\n        startFunction.internalName,\n        startSignature.paramRefs,\n        startSignature.resultRefs,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      startFunction.finalize(module, funcRef);\n      previousBody.push(\n        module.call(startFunction.internalName, null, TypeRef.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.Compiled)) return !global.is(CommonFlags.Errored);\n    global.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    let module = this.module;\n    let initExpr: ExpressionRef = 0;\n    let typeNode = global.typeNode;\n    let initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.Resolved)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.checkTypeSupported(global.type, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.Errored);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.is(CommonFlags.Ambient) && global.hasDecorator(DecoratorFlags.Builtin)) {\n      let internalName = global.internalName;\n      if (internalName == BuiltinNames.data_end) this.runtimeFeatures |= RuntimeFeatures.Data;\n      else if (internalName == BuiltinNames.stack_pointer) this.runtimeFeatures |= RuntimeFeatures.Stack;\n      else if (internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.Heap;\n      else if (internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.Rtti;\n      pendingElements.delete(global);\n      return true;\n    }\n\n    let type = global.type;\n    let typeRef = type.toRef();\n    let isDeclaredConstant = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n    let isDeclaredInline = global.hasDecorator(DecoratorFlags.Inline);\n\n    // Handle imports\n    if (global.is(CommonFlags.Ambient)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MutableGlobals)) {\n        mangleImportName(global, global.declaration);\n        this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, global);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          typeRef,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        if (!this.desiresExportRuntime && lowerRequiresExportRuntime(type)) {\n          this.desiresExportRuntime = true;\n        }\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.Errored);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    let initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.ConvImplicit | Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant expression, attempt to precompute\n      if (!module.isConstExpression(initExpr)) {\n        if (isDeclaredConstant) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp;\n          } else {\n            initializeInStart = true;\n          }\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.Ambient)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>TypeRef.I32: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>TypeRef.I64: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>TypeRef.F32: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>TypeRef.F64: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.Errored);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.Inlined); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.Inlined)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PreferStatic);\n      } else {\n        initExpr = this.makeZero(type);\n      }\n    }\n\n    let internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.Inline, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      module.addGlobal(internalName, typeRef, true, this.makeZero(type));\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.Compiled)) return !element.is(CommonFlags.Errored);\n    element.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    let module = this.module;\n    let previousParent = this.currentParent;\n    this.currentParent = element;\n    let previousValue: EnumValue | null = null;\n    let previousValueIsMut = false;\n    let isInline = element.is(CommonFlags.Const) || element.hasDecorator(DecoratorFlags.Inline);\n\n    let members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.EnumValue) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.Compiled);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.ConvImplicit\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, TypeRef.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.ModuleExport)) {\n              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.Compiled)) return !instance.is(CommonFlags.Errored);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.Builtin)) return true;\n      if (instance.hasDecorator(DecoratorFlags.Lazy)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    // ensure the function hasn't duplicate parameters\n    let parameters = instance.prototype.functionTypeNode.parameters;\n    let numParameters = parameters.length;\n    if (numParameters >= 2) {\n      let visited = new Set<string>();\n      visited.add(parameters[0].name.text);\n      for (let i = 1; i < numParameters; i++) {\n        let paramIdentifier = parameters[i].name;\n        let paramName = paramIdentifier.text;\n        if (!visited.has(paramName)) {\n          visited.add(paramName);\n        } else {\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            paramIdentifier.range, paramName\n          );\n        }\n      }\n    }\n\n    instance.set(CommonFlags.Compiled);\n    let pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    let previousType = this.currentType;\n    let module = this.module;\n    let signature = instance.signature;\n    let bodyNode = instance.prototype.bodyNode;\n    let declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FunctionDeclaration || declarationNode.kind == NodeKind.MethodDeclaration);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    let funcRef: FunctionRef;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.Ambient)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name or code\n      if (instance.hasAnyDecorator(DecoratorFlags.External | DecoratorFlags.ExternalJs)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator: DecoratorNode | null;\n        if (decorator = findDecorator(DecoratorKind.External, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external\"\n          );\n        }\n        if (decorator = findDecorator(DecoratorKind.ExternalJs, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external.js\"\n          );\n        }\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      if (!this.compileFunctionBody(instance, stmts)) {\n        stmts.push(module.unreachable());\n      }\n\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(instance.getNonParameterLocalTypes()),\n        module.flatten(stmts, instance.signature.returnType.toRef())\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.Ambient)) {\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, instance);\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.paramRefs,\n        signature.resultRefs\n      );\n      funcRef = module.getFunction(instance.internalName);\n      if (!this.desiresExportRuntime) {\n        let thisType = signature.thisType;\n        if (\n          thisType && liftRequiresExportRuntime(thisType) ||\n          lowerRequiresExportRuntime(signature.returnType)\n        ) {\n          this.desiresExportRuntime = true;\n        } else {\n          let parameterTypes = signature.parameterTypes;\n          for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n            if (liftRequiresExportRuntime(parameterTypes[i])) {\n              this.desiresExportRuntime = true;\n              break;\n            }\n          }\n        }\n      }\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.Abstract) || instance.parent.kind == ElementKind.Interface) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        null,\n        module.unreachable()\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        instance.identifierNode.range\n      );\n      funcRef = 0; // TODO?\n      instance.set(CommonFlags.Errored);\n    }\n\n    if (instance.is(CommonFlags.Ambient) || instance.is(CommonFlags.Export)) {\n      // Verify and print warn if signature has v128 type for imported or exported functions\n      let hasVectorValueOperands = signature.hasVectorValueOperands;\n      if (hasVectorValueOperands) {\n        let range: Range;\n        let fnTypeNode = instance.prototype.functionTypeNode;\n        if (signature.returnType == Type.v128) {\n          range = fnTypeNode.returnType.range;\n        } else {\n          let firstIndex = signature.getVectorValueOperandIndices()[0];\n          range = fnTypeNode.parameters[firstIndex].range;\n        }\n        this.warning(\n          DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n          range, \"v128\"\n        );\n      }\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    let module = this.module;\n    let bodyNode = assert(instance.prototype.bodyNode);\n    let returnType = instance.signature.returnType;\n    let flow = this.currentFlow;\n    let thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n    let bodyStartIndex = stmts.length;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.Block) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, true, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.Expression);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.Constructor | CommonFlags.Get | CommonFlags.Set));\n\n      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.ConvImplicit);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.Terminates)) {\n        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n        flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.Constructor)) {\n      assert(instance.is(CommonFlags.Instance));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.AccessesThis | FlowFlags.ConditionallyAccessesThis) || !flow.is(FlowFlags.Terminates)) {\n\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          this.makeConditionalAllocation(classInstance, thisLocal.index)\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n\n        // Insert right before the body\n        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {\n          stmts[i + 1] = stmts[i];\n        }\n        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MayReturnNonThis)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MayReturnNonThis) && !classInstance.hasDecorator(DecoratorFlags.Final)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.Terminates)) {\n        stmts.push(\n          module.local_get(thisLocal.index, this.options.sizeTypeRef)\n        );\n        flow.set(FlowFlags.Returns | FlowFlags.ReturnsNonNull | FlowFlags.Terminates);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base && !flow.is(FlowFlags.CallsSuper)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.Terminates)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  /** Compiles an instance field to a getter and a setter. */\n  compileField(instance: Field): bool {\n    this.compileFieldGetter(instance);\n    this.compileFieldSetter(instance);\n    return instance.is(CommonFlags.Compiled);\n  }\n\n  /** Compiles the getter of the specified instance field. */\n  compileFieldGetter(instance: Field): bool {\n    if (instance.getterRef) return true;\n    let module = this.module;\n    let valueType = instance.type;\n    let valueTypeRef = valueType.toRef();\n    let thisTypeRef = this.options.sizeTypeRef;\n    // return this.field\n    instance.getterRef = module.addFunction(instance.internalGetterName, thisTypeRef, valueTypeRef, null,\n      module.load(valueType.byteSize, valueType.isSignedIntegerValue,\n        module.local_get(0, thisTypeRef),\n        valueTypeRef, instance.memoryOffset\n      )\n    );\n    if (instance.setterRef) {\n      instance.set(CommonFlags.Compiled);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles the setter of the specified instance field. */\n  compileFieldSetter(instance: Field): bool {\n    if (instance.setterRef) return true;\n    let type = instance.type;\n    let thisTypeRef = this.options.sizeTypeRef;\n    let valueTypeRef = type.toRef();\n    let module = this.module;\n    // void(this.field = value)\n    let bodyExpr = module.store(type.byteSize,\n      module.local_get(0, thisTypeRef),\n      module.local_get(1, valueTypeRef),\n      valueTypeRef, instance.memoryOffset\n    );\n    if (type.isManaged) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.Class);\n      if ((<Class>parent).type.isManaged) {\n        let linkInstance = this.program.linkInstance;\n        this.compileFunction(linkInstance);\n        bodyExpr = module.block(null, [\n          bodyExpr,\n          module.call(linkInstance.internalName, [\n            module.local_get(0, thisTypeRef),\n            module.local_get(1, valueTypeRef),\n            module.i32(0)\n          ], TypeRef.None)\n        ], TypeRef.None);\n      }\n    }\n    instance.setterRef = module.addFunction(\n      instance.internalSetterName,\n      createType([ thisTypeRef, valueTypeRef ]),\n      TypeRef.None,\n      null,\n      bodyExpr\n    );\n    if (instance.getterRef) {\n      instance.set(CommonFlags.Compiled);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    let memoryOffset = i64_align(this.memoryOffset, alignment);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    let memoryOffset = this.program.computeBlockStart64(this.memoryOffset);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    let ptr = this.ensureStaticStringPtr(stringValue);\n    this.currentType = this.program.stringInstance.type;\n    return this.module.usize(ptr);\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticStringPtr(stringValue: string): i64 {\n    let program = this.program;\n    let totalOverhead = program.totalOverhead;\n    let stringInstance = assert(program.stringInstance);\n    let stringSegment: MemorySegment;\n    let segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let te = new TextEncoder();\n      let u8 = te.encode(stringValue);\n      let len = u8.length;\n      let buf = stringInstance.createBuffer(len);\n      for (let i = 0; i < len; ++i) {\n        buf[totalOverhead + i] = u8[i];\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    return i64_add(stringSegment.offset, i64_new(totalOverhead));\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    let length = values.length;\n    let byteSize = elementType.byteSize;\n    let elementTypeRef = elementType.toRef();\n    switch (<u32>elementTypeRef) {\n      case <u32>TypeRef.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.V128: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeV128(getConstValueV128(value), buf, pos);\n          pos += 16;\n        }\n        break;\n      }\n      case <u32>TypeRef.None: {\n        // nothing to write\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    let program = this.program;\n    let arrayBufferInstance = program.arrayBufferInstance;\n    let buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(\n    elementType: Type,\n    bufferSegment: MemorySegment,\n    /** Optional array instance override. */\n    arrayInstance: Class | null = null\n  ): MemorySegment {\n    let program = this.program;\n    if (!arrayInstance) {\n      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));\n    }\n    let bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof(\"rtSize\"));\n    let arrayLength = i32(bufferLength / elementType.byteSize);\n    let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n    let buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.Compiled) && !instance.is(CommonFlags.Stub));\n    let program = this.program;\n    let memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.ClassDeclaration: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.EnumDeclaration: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.Enum);\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potentiall merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.Variable: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.Global);\n            if (\n              !element.is(CommonFlags.Ambient) && // delay imports\n              !element.hasDecorator(DecoratorFlags.Lazy)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FieldDeclaration: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element && element.kind == ElementKind.Global) { // static\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.Export: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath != null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.ExportDefault: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.Import: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FunctionDeclaration:\n      case NodeKind.MethodDeclaration:\n      case NodeKind.InterfaceDeclaration:\n      case NodeKind.IndexSignature:\n      case NodeKind.TypeDeclaration: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement,\n    /** Whether this is the last statement of the body, if known. */\n    isLastInBody: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    let stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.Block: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.Break: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.Continue: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.Do: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.Empty: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.Expression: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.For: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.ForOf: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.If: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.Return: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement, isLastInBody);\n        break;\n      }\n      case NodeKind.Switch: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.Throw: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.Try: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.Variable: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.Void: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.While: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TypeDeclaration: {\n        // TODO: integrate inner type declaration into flow\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          statement.range,\n          \"Inner type alias\"\n        );\n        stmt = module.unreachable();\n        break;\n      }\n      case NodeKind.Module: {\n        stmt = module.nop();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Whether this is an immediate body statement. */\n    isBody: bool = false,\n    /** Statements to append to that is also returned. Created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    let numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    let module = this.module;\n    let flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n        if (needsExplicitUnreachable(stmt)) stmts.push(module.unreachable());\n        break;\n      }\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    let statements = statement.statements;\n    let outerFlow = this.currentFlow;\n    let innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    let stmts = this.compileStatements(statements);\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    let flow = this.currentFlow;\n    let breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Breaks);\n    return module.br(breakLabel);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    let flow = this.currentFlow;\n    let continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Continues | FlowFlags.Terminates);\n    return module.br(continueLabel);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break                          \u2514\u25BA\u2510 flow\n    //  (loop $loop                             \u251C\u25C4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 recompile?\n    //   (?block $continue                      \u2514\u2500\u2510          \u2502\n    //    (body)                                  \u2502 bodyFlow \u2502\n    //   )                                      \u250C\u2500\u2518          \u2502\n    //                                        \u250C\u25C4\u253C\u25BA\u2562          \u2502 breaks or terminates?\n    //                                        \u2502 \u2514\u2500\u2510          \u2502 but does not continue\n    //   (br_if (cond) $loop)                 \u2502   \u2502 condFlow \u2502\n    //                                        \u2502 \u250C\u2500\u2518          \u2502\n    //                                        \u251C\u25C4\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 condition?\n    //  )                                     \u2514\u2500\u2510\n    // )                                      \u250C\u2500\u2518\n\n    let label = outerFlow.pushBreakLabel();\n    let flow = outerFlow.fork(/* resetBreakContext */ true);\n    this.currentFlow = flow;\n\n    let breakLabel = `do-break|${label}`;\n    flow.breakLabel = breakLabel;\n    let continueLabel = `do-continue|${label}`;\n    flow.continueLabel = continueLabel;\n    let loopLabel = `do-loop|${label}`;\n\n    // Compile the body (always executes)\n    let bodyFlow = flow.fork();\n    this.currentFlow = bodyFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Shortcut if body never falls through\n    let possiblyContinues = bodyFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    if (bodyFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks) && !possiblyContinues) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      flow.inherit(bodyFlow);\n\n    // Otherwise evaluate the condition\n    } else {\n      let condFlow = flow.fork();\n      this.currentFlow = condFlow;\n      let condExpr = this.makeIsTrueish(\n        this.compileExpression(statement.condition, Type.i32),\n        this.currentType,\n        statement.condition\n      );\n      let condKind = this.evaluateCondition(condExpr);\n\n      if (possiblyContinues) {\n        bodyStmts = [\n          module.block(continueLabel, bodyStmts)\n        ];\n      }\n\n      // Shortcut if condition is always false\n      if (condKind == ConditionKind.False) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        flow.inherit(bodyFlow);\n\n      // Terminate if condition is always true and body never breaks\n      } else if (condKind == ConditionKind.True && !bodyFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks)) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        bodyStmts.push(\n          module.br(loopLabel)\n        );\n        flow.set(FlowFlags.Terminates);\n\n      } else {\n        bodyStmts.push(\n          module.br(loopLabel,\n            condExpr\n          )\n        );\n        flow.inherit(condFlow);\n\n        // Detect if local flags are incompatible before and after looping, and\n        // if so recompile by unifying local flags between iterations. Note that\n        // this may be necessary multiple times where locals depend on each other.\n        if (outerFlow.resetIfNeedsRecompile(flow, numLocalsBefore)) {\n          outerFlow.popBreakLabel();\n          this.currentFlow = outerFlow;\n          return this.doCompileDoStatement(statement);\n        }\n      }\n    }\n\n    // Finalize\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    let expr = module.block(breakLabel, [\n      module.loop(loopLabel,\n        module.flatten(bodyStmts)\n      )\n    ]);\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.ConvImplicit);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (initializer)                  \u2514\u25BA\u2510 flow\n    // (block $break                    \u2502\n    //  (loop $loop                     \u251C\u25C4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 recompile?\n    //   (local.set $tcond (condition)) \u2514\u2500\u2510 condFlow \u2502\n    //                                  \u250C\u2500\u2518          \u2502\n    //   (if (local.get $tcond)       \u250C\u25C4\u2524            \u2502 condition?\n    //    (block $continue            \u2502 \u2502            \u2502\n    //     (body)                     \u2502 \u2514\u2500\u2510 bodyFlow \u2502\n    //                                \u2502 \u250C\u2500\u2518          \u2502\n    //    )                           \u251C\u25C4\u253C\u25BA\u2562          \u2502 breaks or terminates?\n    //    (incrementor)               \u2502 \u2514\u2500\u2510 incrFlow \u2502\n    //                                \u2502 \u250C\u2500\u2518          \u2502\n    //                                \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    //    (br $loop)                  \u2514\u2500\u2510\n    //   )                              \u2502\n    //  )                               \u2502\n    // )                                \u2502\n    //                                \u250C\u2500\u2518\n\n    let label = outerFlow.pushBreakLabel();\n    let stmts = new Array<ExpressionRef>();\n    let flow = outerFlow.fork(/* resetBreakContext */ true);\n    this.currentFlow = flow;\n\n    let breakLabel = `for-break${label}`;\n    flow.breakLabel = breakLabel;\n    let continueLabel = `for-continue|${label}`;\n    flow.continueLabel = continueLabel;\n    let loopLabel = `for-loop|${label}`;\n\n    // Compile initializer if present\n    let initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.Expression ||\n        initializer.kind == NodeKind.Variable\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    // Precompute the condition\n    let condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    let condExpr: ExpressionRef;\n    let condKind: ConditionKind;\n    let condition = statement.condition;\n    if (condition) {\n      condExpr = this.makeIsTrueish(\n        this.compileExpression(condition, Type.bool),\n        this.currentType,\n        condition\n      );\n      condKind = this.evaluateCondition(condExpr);\n\n      // Shortcut if condition is always false (body never runs)\n      if (condKind == ConditionKind.False) {\n        stmts.push(\n          module.drop(condExpr)\n        );\n        flow.inherit(condFlow);\n        outerFlow.inherit(flow);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condKind = ConditionKind.True;\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp\n    let tcond = flow.getTempLocal(Type.bool);\n    let loopStmts = new Array<ExpressionRef>();\n    loopStmts.push(\n      module.local_set(tcond.index, condExpr, false) // bool\n    );\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    let bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Check if body terminates\n    if (bodyFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n      bodyStmts.push(module.unreachable());\n    }\n    if (condKind == ConditionKind.True) flow.inherit(bodyFlow);\n    else flow.inheritBranch(bodyFlow);\n\n    let ifStmts = new Array<ExpressionRef>();\n    ifStmts.push(\n      module.block(continueLabel, bodyStmts)\n    );\n\n    // Compile the incrementor if it runs\n    // Can still fall through to here if body continues, hence is already known to terminate\n    if (!bodyFlow.is(FlowFlags.Terminates) || bodyFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues)) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        let incrFlow = flow.fork();\n        this.currentFlow = incrFlow;\n        ifStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.ConvImplicit | Constraints.WillDrop)\n        );\n        flow.inherit(incrFlow); // mostly local flags, also covers late termination by throwing\n        this.currentFlow = flow;\n      }\n\n      ifStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (outerFlow.resetIfNeedsRecompile(flow, numLocalsBefore)) {\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement);\n      }\n    }\n    loopStmts.push(\n      module.if(module.local_get(tcond.index, TypeRef.I32),\n        module.flatten(ifStmts)\n      )\n    );\n\n    stmts.push(\n      module.block(breakLabel, [\n        module.loop(loopLabel,\n          module.flatten(loopStmts)\n        )\n      ])\n    );\n    this.currentFlow = flow;\n\n    // Finalize\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      stmts.push(module.unreachable());\n    }\n    this.currentFlow = outerFlow;\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let ifTrue = statement.ifTrue;\n    let ifFalse = statement.ifFalse;\n\n    // (if              \u2514\u25BA\u2510 flow\n    //  (condition)      \u250C\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 condition?\n    //  (block           \u2502            \u2502\n    //   (ifTrue)        \u2514\u25BA\u2510 thenFlow \u2502\n    //                   \u250C\u2500\u2518          \u2502\n    //  )                \u251C\u2500\u2562          \u2502\n    //  (block           \u2502          \u250C\u25C4\u2524 present?\n    //   (ifFalse)       \u2502          \u2502 \u2514\u25BA\u2510 elseFlow\n    //                   \u2502          \u2502 \u250C\u2500\u2518\n    //  )                \u2502          \u2502 \u251C\u2500\u2562\n    // )                 \u2514\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2518\n    // ...              \u250C\u25C4\u2518\n\n    // Precompute the condition (always executes)\n    let condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    let condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.True: {\n        return module.block(null, [\n          module.drop(condExpr),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.False: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExpr),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExpr);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    let flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    let thenStmts = new Array<ExpressionRef>();\n    let thenFlow = flow.fork();\n    this.currentFlow = thenFlow;\n    thenFlow.inheritNonnullIfTrue(condExpr);\n    if (ifTrue.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, false, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    let thenTerminates = thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n    if (thenTerminates) {\n      thenStmts.push(module.unreachable());\n    }\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    if (ifFalse) {\n      let elseStmts = new Array<ExpressionRef>();\n      let elseFlow = flow.fork();\n      this.currentFlow = elseFlow;\n      elseFlow.inheritNonnullIfFalse(condExpr);\n      if (ifFalse.kind == NodeKind.Block) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, false, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      let elseTerminates = elseFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n      if (elseTerminates) {\n        elseStmts.push(module.unreachable());\n      }\n      this.currentFlow = flow;\n      flow.inheritMutual(thenFlow, elseFlow);\n      return module.if(condExpr,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      flow.inheritBranch(thenFlow);\n      flow.inheritNonnullIfFalse(condExpr,\n        thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)\n          ? null     // thenFlow terminates: just inherit\n          : thenFlow // must become nonnull in thenFlow otherwise\n      );\n      return module.if(condExpr,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement,\n    isLastInBody: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let expr: ExpressionRef = 0;\n    let flow = this.currentFlow;\n    let returnType = flow.returnType;\n\n    let valueExpression = statement.value;\n    if (valueExpression) {\n      let constraints = Constraints.ConvImplicit;\n      if (flow.sourceFunction.is(CommonFlags.ModuleExport)) constraints |= Constraints.MustWrap;\n\n      expr = this.compileExpression(valueExpression, returnType, constraints);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n      if (flow.sourceFunction.is(CommonFlags.Constructor) && valueExpression.kind != NodeKind.This) {\n        flow.set(FlowFlags.MayReturnNonThis);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      this.currentType = returnType;\n      return module.unreachable();\n    }\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n\n    // Handle inline return\n    if (flow.isInline) {\n      return !expr\n        ? isLastInBody\n          ? module.nop()\n          : module.br(assert(flow.inlineReturnLabel))\n        : isLastInBody\n          ? expr\n          : this.currentType == Type.void\n            ? module.block(null, [ expr, module.br(assert(flow.inlineReturnLabel)) ])\n            : module.br(assert(flow.inlineReturnLabel), 0, expr);\n    }\n\n    // Otherwise emit a normal return\n    return !expr\n      ? isLastInBody\n        ? module.nop()\n        : module.return()\n      : isLastInBody\n        ? expr\n        : this.currentType == Type.void\n          ? module.block(null, [ expr, module.return() ])\n          : module.return(expr);\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    let module = this.module;\n\n    let cases = statement.cases;\n    let numCases = cases.length;\n    if (!numCases) {\n      return this.compileExpression(statement.condition, Type.void,\n        Constraints.ConvImplicit\n      );\n    }\n\n    // Everything within a switch uses the same break context\n    let outerFlow = this.currentFlow;\n    let context = outerFlow.pushBreakLabel();\n\n    // introduce a local for evaluating the condition (exactly once)\n    let tempLocal = outerFlow.getTempLocal(Type.u32);\n    let tempLocalIndex = tempLocal.index;\n\n    // Prepend initializer to inner block. Does not initiate a new branch, yet.\n    let breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set( // initializer\n      tempLocalIndex,\n      this.compileExpression(statement.condition, Type.u32,\n        Constraints.ConvImplicit\n      ),\n      false // u32\n    );\n\n    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\n    let breakIndex = 1;\n    let defaultIndex = -1;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let label = case_.label;\n      if (label) {\n        breaks[breakIndex++] = module.br(`case${i}|${context}`,\n          module.binary(BinaryOp.EqI32,\n            module.local_get(tempLocalIndex, TypeRef.I32),\n            this.compileExpression(label, Type.u32,\n              Constraints.ConvImplicit\n            )\n          )\n        );\n      } else {\n        defaultIndex = i;\n      }\n    }\n\n    // otherwise br to default respectively out of the switch if there is no default case\n    breaks[breakIndex] = module.br(defaultIndex >= 0\n      ? `case${defaultIndex}|${context}`\n      : `break|${context}`\n    );\n\n    // nest blocks in order\n    let currentBlock = module.block(`case0|${context}`, breaks, TypeRef.None);\n    let commonCategorical = FlowFlags.AnyCategorical;\n    let commonConditional = 0;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Each switch case initiates a new branch\n      let innerFlow = outerFlow.fork();\n      this.currentFlow = innerFlow;\n      let breakLabel = `break|${context}`;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : `case${i + 1}|${context}`;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let terminates = false;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n          if (innerFlow.is(FlowFlags.Terminates)) terminates = true;\n          break;\n        }\n      }\n      stmts.length = count;\n      if (terminates || isLast || innerFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks)) {\n        commonCategorical &= innerFlow.flags;\n      }\n\n      commonConditional |= innerFlow.deriveConditionalFlags();\n\n      // Switch back to the parent flow\n      innerFlow.unset(\n        FlowFlags.Breaks |\n        FlowFlags.ConditionallyBreaks\n      );\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block\n    }\n    outerFlow.popBreakLabel();\n\n    // If the switch has a default (guaranteed to handle any value), propagate common flags\n    if (defaultIndex >= 0) outerFlow.flags |= commonCategorical & ~FlowFlags.Breaks;\n    outerFlow.flags |= commonConditional & ~FlowFlags.ConditionallyBreaks;\n    // TODO: what about local states?\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    let flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.Throws | FlowFlags.Terminates);\n\n    let stmts = new Array<ExpressionRef>();\n    let value = statement.value;\n    let message: Expression | null = null;\n    if (value.kind == NodeKind.New) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let declarations = statement.declarations;\n    let numDeclarations = declarations.length;\n    let flow = this.currentFlow;\n    let initializers = new Array<ExpressionRef>();\n    let resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode,\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type, statement); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.ConvImplicit\n          );\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto, statement); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto); // reports\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = this.currentType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.Const);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>TypeRef.I32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.I64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.F32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>TypeRef.F64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a virtual local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.Let | CommonFlags.Const) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.targetFunction.addLocal(type, name, declaration);\n          flow.unsetLocalFlag(local.index, ~0);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        }\n        if (initExpr) {\n          initializers.push(\n            this.makeLocalAssignment(local, initExpr, type, false)\n          );\n        } else {\n          // no need to assign zero\n          if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.Wrapped);\n          }\n        }\n      }\n    }\n    this.currentType = Type.void;\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.ConvExplicit | Constraints.WillDrop\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break                  \u2514\u25BA\u2510 flow\n    //  (loop $continue                 \u251C\u25C4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 recompile?\n    //   (local.set $tcond (condition)) \u2514\u2500\u2510 condFlow \u2502\n    //                                  \u250C\u2500\u2518          \u2502\n    //   (if (local.get $tcond)       \u250C\u25C4\u2524            \u2502 condition?\n    //    (body)                      \u2502 \u2514\u2500\u2510 bodyFlow \u2502\n    //                                \u2502 \u250C\u2500\u2518          \u2502\n    //                                \u251C\u25C4\u253C\u25BA\u2562          \u2502 breaks or terminates?\n    //    (br $continue)              \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    //   )                            \u2514\u2500\u2510\n    //  )                               \u2502\n    // )                              \u250C\u2500\u2518\n\n    let label = outerFlow.pushBreakLabel();\n    let stmts = new Array<ExpressionRef>();\n    let flow = outerFlow.fork(/* resetBreakContext */ true);\n    this.currentFlow = flow;\n\n    let breakLabel = `while-break|${label}`;\n    flow.breakLabel = breakLabel;\n    let continueLabel = `while-continue|${label}`;\n    flow.continueLabel = continueLabel;\n\n    // Precompute the condition\n    let condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    let condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    let condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.False) {\n      stmts.push(\n        module.drop(condExpr)\n      );\n      outerFlow.popBreakLabel();\n      this.currentFlow = outerFlow;\n      return module.flatten(stmts);\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp\n    let tcond = flow.getTempLocal(Type.bool);\n    stmts.push(\n      module.local_set(tcond.index, condExpr, false) // bool\n    );\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    let bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Simplify if body always terminates\n    if (bodyFlow.is(FlowFlags.Terminates)) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      if (condKind == ConditionKind.True) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n    // Terminate if condition is always true and body never breaks\n    } else if (condKind == ConditionKind.True && !bodyFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks)) {\n      bodyStmts.push(\n        module.br(continueLabel)\n      );\n      flow.set(FlowFlags.Terminates);\n\n    } else {\n      let breaks = bodyFlow.is(FlowFlags.Breaks);\n      if (breaks) {\n        bodyStmts.push(\n          module.unreachable()\n        );\n      } else {\n        bodyStmts.push(\n          module.br(continueLabel)\n        );\n      }\n      if (condKind == ConditionKind.True) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      // Here: Only relevant if flow does not always break.\n      if (!breaks && outerFlow.resetIfNeedsRecompile(flow, numLocalsBefore)) {\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileWhileStatement(statement);\n      }\n    }\n    stmts.push(\n      module.if(module.local_get(tcond.index, TypeRef.I32),\n        module.flatten(bodyStmts)\n      )\n    );\n    this.currentFlow = flow;\n\n    // Finalize\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    let expr = module.block(breakLabel, [\n      module.loop(continueLabel,\n        module.flatten(stmts)\n      )\n    ]);\n    if (condKind == ConditionKind.True && outerFlow.is(FlowFlags.Terminates)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.Inlined | CommonFlags.Resolved));\n    let type = element.type;\n    this.currentType = type;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            // @ts-ignore\n            ? <i32>i64_ne(element.constantIntegerValue, i64_zero)\n            : 0\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.Integer\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.Integer\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.Builtin) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.Parenthesized) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.Assertion: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Binary: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Call: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Comma: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ElementAccess: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Function: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.This:\n      case NodeKind.Super:\n      case NodeKind.True: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.InstanceOf: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Literal: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.New: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PropertyAccess: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Ternary: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPostfix: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Compiled: {\n        let compiled = <CompiledExpression>expression;\n        expr = compiled.expr;\n        this.currentType = compiled.type;\n        break;\n      }\n      case NodeKind.Class: {\n        // TODO: compile as class expression\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Block-scoped class declarations or expressions\"\n        );\n        expr = this.module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    let currentType = this.currentType;\n    let wrap = (constraints & Constraints.MustWrap) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.ConvExplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = currentType = contextualType;\n      } else if (constraints & Constraints.ConvImplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n\n    if (fromType.kind == TypeKind.Void) {\n      if (toType.kind == TypeKind.Void) {\n        // void to void: Can happen as a result of a foregoing error. Since we\n        // have an `expr` here that is already supposed to be void, return it.\n        return expr;\n      }\n      // void to any\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.Void) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // upcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // downcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeDowncastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    // Early return if we have same types\n    if (toType.kind == fromType.kind) {\n      this.currentType = toType;\n      return expr;\n    }\n\n    // v128 to any / any to v128\n    // except v128 to bool\n    //\n    // NOTE:In case we would have more conversions to and from v128 type it's better\n    // to make these checks more individual and integrate in below flow.\n    if (\n      !toType.isBooleanValue &&\n      (toType.isVectorValue || fromType.isVectorValue)\n    ) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.None, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF32\n              : UnaryOp.ConvertU64ToF32,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF32\n              : UnaryOp.ConvertU32ToF32,\n            expr\n          );\n        }\n\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF64\n              : UnaryOp.ConvertU64ToF64,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF64\n              : UnaryOp.ConvertU32ToF64,\n            expr\n          );\n        }\n      }\n\n    // v128 to bool\n    } else if (fromType == Type.v128 && toType.isBooleanValue) {\n      expr = this.makeIsTrueish(expr, Type.v128, reportNode);\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let inheritedConstraints = constraints & ~(Constraints.ConvImplicit | Constraints.ConvExplicit);\n    switch (expression.assertionKind) {\n      case AssertionKind.Prefix:\n      case AssertionKind.As: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType),\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.ConvExplicit);\n      }\n      case AssertionKind.NonNull: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.Literal && (<LiteralExpression>operand).literalKind == LiteralKind.Array) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.Class) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let left = expression.left;\n    let right = expression.right;\n\n    let leftExpr: ExpressionRef;\n    let leftType: Type;\n    let rightExpr: ExpressionRef;\n    let rightType: Type;\n    let commonType: Type | null;\n\n    let expr: ExpressionRef;\n    let compound = false;\n\n    let operator = expression.operator;\n    switch (operator) {\n      case Token.LessThan: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Lt);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Gt);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.LessThan_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Le);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GreaterThan_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Ge);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n\n      case Token.Equals_Equals_Equals:\n      case Token.Equals_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Eq);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n        if (commonType.isFloatValue) {\n          if (\n            isConstExpressionNaN(module, rightExpr) ||\n            isConstExpressionNaN(module, leftExpr)\n          ) {\n            this.warning(\n              DiagnosticCode._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead,\n              expression.range\n            );\n          }\n          if (isConstNegZero(rightExpr) || isConstNegZero(leftExpr)) {\n            this.warning(\n              DiagnosticCode.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters,\n              expression.range\n            );\n          }\n        }\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Exclamation_Equals_Equals:\n      case Token.Exclamation_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClass();\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Ne);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n        if (commonType.isFloatValue) {\n          if (\n            isConstExpressionNaN(module, rightExpr) ||\n            isConstExpressionNaN(module, leftExpr)\n          ) {\n            this.warning(\n              DiagnosticCode._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead,\n              expression.range\n            );\n          }\n          if (isConstNegZero(rightExpr) || isConstNegZero(leftExpr)) {\n            this.warning(\n              DiagnosticCode.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters,\n              expression.range\n            );\n          }\n        }\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Equals: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.Plus_Equals: compound = true;\n      case Token.Plus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Add);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Minus_Equals: compound = true;\n      case Token.Minus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Sub);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Equals: compound = true;\n      case Token.Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Mul);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Asterisk_Equals: compound = true;\n      case Token.Asterisk_Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Pow);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.Slash_Equals: compound = true;\n      case Token.Slash: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Div);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Percent_Equals: compound = true;\n      case Token.Percent: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Rem);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LessThan_LessThan_Equals: compound = true;\n      case Token.LessThan_LessThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShl);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShrU);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.Ampersand_Equals: compound = true;\n      case Token.Ampersand: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overloadd\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseAnd);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Bar_Equals: compound = true;\n      case Token.Bar: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseOr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Caret_Equals: compound = true;\n      case Token.Caret: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseXor);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.Ampersand_Ampersand: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfTrue(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always false\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.False) {\n            expr = leftExpr;\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always true\n            if (condKind == ConditionKind.True) {\n              expr = rightExpr;\n            } else {\n              expr = module.if(leftExpr, rightExpr, module.i32(0));\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.ConvImplicit);\n          rightType = this.currentType;\n          this.currentFlow = flow;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, this.currentType, left),\n              rightExpr,\n              expr\n            );\n\n          // if not possible, tee left to a temp\n          } else {\n            let tempLocal = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),\n              rightExpr,\n              module.local_get(tempLocal.index, leftType.toRef())\n            );\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      case Token.Bar_Bar: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfFalse(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always true\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.True) {\n            expr = leftExpr;\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always false\n            if (condKind == ConditionKind.False) {\n              expr = rightExpr;\n            } else {\n              expr = module.if(leftExpr, module.i32(1), rightExpr);\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.ConvImplicit);\n          rightType = this.currentType;\n          this.currentFlow = flow;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              expr,\n              rightExpr\n            );\n\n          // if not possible, tee left to a temp. local\n          } else {\n            let temp = flow.getTempLocal(leftType);\n            let tempIndex = temp.index;\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempIndex, leftExpr, leftType.isManaged), leftType, left),\n              module.local_get(tempIndex, leftType.toRef()),\n              rightExpr\n            );\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    let targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.EqSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref: return module.ref_eq(leftExpr, rightExpr);\n      case TypeKind.Stringref: return module.string_eq(leftExpr, rightExpr);\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.NeSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref: {\n        return module.unary(UnaryOp.EqzI32,\n          module.ref_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Stringref: {\n        return module.unary(UnaryOp.EqzI32,\n          module.string_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AddSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.SubSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.MulSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr,\n          TypeRef.I32\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueI32(leftExpr);\n            let rightValue = getConstValueI32(rightExpr);\n            this.currentType = type;\n            return module.i32(i64_low(i64_pow(\n              i64_new(leftValue),\n              i64_new(rightValue)\n            )));\n          }\n        }\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n            let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n            let result = i64_pow(leftValue, rightValue);\n            this.currentType = type;\n            return module.i64(i64_low(result), i64_high(result));\n          }\n        }\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = this.options.isWasm64;\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            if (isWasm64) {\n              let leftValue  = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n              let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n              let result = i64_pow(leftValue, rightValue);\n              this.currentType = type;\n              return module.i64(i64_low(result), i64_high(result));\n            } else {\n              let leftValue  = getConstValueI32(leftExpr);\n              let rightValue = getConstValueI32(rightExpr);\n              this.currentType = type;\n              return module.i32(i64_low(i64_pow(\n                i64_new(leftValue),\n                i64_new(rightValue)\n              )));\n            }\n          }\n        }\n        let instance = isWasm64\n          ? this.i64PowInstance\n          : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(isWasm64\n            ? CommonNames.ipow64\n            : CommonNames.ipow32\n          );\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF32(leftExpr);\n            let rightValue = getConstValueF32(rightExpr);\n            this.currentType = type;\n            return module.f32(f32(accuratePow64(leftValue, rightValue)));\n          }\n        }\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF64(leftExpr);\n            let rightValue = getConstValueF64(rightExpr);\n            this.currentType = type;\n            return module.f64(accuratePow64(leftValue, rightValue));\n          }\n        }\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.DivISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.DivUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.RemISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.RemUSize, leftExpr, rightExpr);\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShlSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.ShrISize, leftExpr, rightExpr);\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AndSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.OrSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.XorSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    leftType: Type,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    if (operatorInstance.hasDecorator(DecoratorFlags.Builtin)) {\n      // for operators, @builtin is used only for ByteView::__n?eq (so far)\n      if (right.isLiteralKind(LiteralKind.String)) {\n        let literal = (<StringLiteralExpression>right).value;\n        let length = literal.length;\n        let args = new Array<Expression>();\n        args.push(left);\n        args.push(right);\n        let name = Node.createIdentifierExpression(\"__eq\" + length.toString(), reportNode.range);\n        let cmp = Node.createCallExpression(name, null, args, reportNode.range);\n        let exprOp = reportNode.operator;\n        if ((exprOp == Token.Exclamation_Equals_Equals) || (exprOp == Token.Exclamation_Equals))\n          cmp = Node.createUnaryPrefixExpression(Token.Exclamation, cmp, cmp.range);\n        return this.compileExpression(cmp, Type.bool);\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          right.range\n        );\n        return this.module.unreachable();\n      }\n    }\n\n    let rightType: Type;\n    let signature = operatorInstance.signature;\n    let parameterTypes = signature.parameterTypes;\n    if (operatorInstance.is(CommonFlags.Instance)) {\n      leftExpr = this.convertExpression(leftExpr, leftType, assert(signature.thisType), false, left);\n      rightType = parameterTypes[0];\n    } else {\n      leftExpr = this.convertExpression(leftExpr, leftType, parameterTypes[0], false, left);\n      rightType = parameterTypes[1];\n    }\n    let rightExpr = this.compileExpression(right, rightType, Constraints.ConvImplicit);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    let program = this.program;\n    let resolver = program.resolver;\n    let flow = this.currentFlow;\n    let target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    let elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    let targetType: Type;\n    switch (target.kind) {\n      case ElementKind.Global: {\n        // not yet compiled if a static field compiled as a global\n        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports\n        // fall-through\n      }\n      case ElementKind.Local:\n      case ElementKind.Field: {\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.IndexSignature: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        let parameterTypes = indexedSet.signature.parameterTypes;\n\n        assert(parameterTypes.length == 2); // parser must guarantee this\n        targetType = parameterTypes[1];     // 2nd parameter is the element\n\n        if (indexedSet.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          expression.range, target.internalName\n        );\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    let valueExpr = this.compileExpression(valueExpression, targetType);\n    let valueType = this.currentType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      valueType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.Constant, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable();\n        if (target.isAny(CommonFlags.Const | CommonFlags.Readonly)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.Field: {\n        let fieldInstance = <Field>target;\n        let initializerNode = fieldInstance.initializerNode;\n        let isConstructor = flow.sourceFunction.is(CommonFlags.Constructor);\n\n        // Cannot assign to readonly fields except in constructors if there's no initializer\n        if (fieldInstance.is(CommonFlags.Readonly)) {\n          if (!isConstructor || initializerNode) {\n            this.error(\n              DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n              valueExpression.range, fieldInstance.internalName\n            );\n            return module.unreachable();\n          }\n        }\n\n        // Mark initialized fields in constructors\n        thisExpression = assert(thisExpression);\n        if (isConstructor && thisExpression.kind == NodeKind.This) {\n          flow.setThisFieldFlag(fieldInstance, FieldFlags.Initialized);\n        }\n\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.Class);\n        return this.makeFieldAssignment(fieldInstance,\n          valueExpr,\n          valueType,\n          this.compileExpression(\n            thisExpression,\n            (<Class>fieldParent).type,\n            Constraints.ConvImplicit | Constraints.IsThis\n          ),\n          tee\n        );\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        if (propertyInstance.is(CommonFlags.Instance)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          assert(getterInstance.signature.thisType == thisType);\n          let returnType = getterInstance.signature.returnType;\n          let returnTypeRef = returnType.toRef();\n          let tempThis = flow.getTempLocal(returnType);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempThis.index, thisExpr, returnType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempThis.index, returnTypeRef)\n            ], valueExpression)\n          ], returnTypeRef);\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          return module.block(null, [\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\n            this.makeCallDirect(getterInstance, null, valueExpression)\n          ], getterInstance.signature.returnType.toRef());\n        }\n      }\n      case ElementKind.IndexSignature: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.Class);\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let thisType = classInstance.type;\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          thisType,\n          Constraints.ConvImplicit | Constraints.IsThis\n        );\n        let setterIndexType = setterInstance.signature.parameterTypes[0];\n        let getterIndexType = getterInstance.signature.parameterTypes[0];\n        if (!setterIndexType.equals(getterIndexType)) {\n          this.errorRelated(\n            DiagnosticCode.Index_signature_accessors_in_type_0_differ_in_types,\n            getterInstance.identifierAndSignatureRange,\n            setterInstance.identifierAndSignatureRange,\n            classInstance.internalName,\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        let elementExpr = this.compileExpression(assert(indexExpression), setterIndexType, Constraints.ConvImplicit);\n        let elementType = this.currentType;\n        if (tee) {\n          let tempTarget = flow.getTempLocal(thisType);\n          let tempElement = flow.getTempLocal(elementType);\n          let returnType = getterInstance.signature.returnType;\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),\n              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toRef()),\n              module.local_get(tempElement.index, tempElement.type.toRef())\n            ], valueExpression)\n          ], returnType.toRef());\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n      default: {\n        this.error(\n          DiagnosticCode.The_target_of_an_assignment_must_be_a_variable_or_a_property_access,\n          valueExpression.range\n        );\n      }\n    }\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let type = local.type;\n    assert(type != Type.void);\n    let localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NonNull);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NonNull);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.Initialized);\n    if (type.isShortIntegerValue) {\n      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.Wrapped);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.Wrapped);\n    }\n    if (tee) { // local = value\n      this.currentType = type;\n      return module.local_tee(localIndex, valueExpr, type.isManaged);\n    } else { // void(local = value)\n      this.currentType = Type.void;\n      return module.local_set(localIndex, valueExpr, type.isManaged);\n    }\n  }\n\n  /** Makes an assignment to a global. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let type = global.type;\n    assert(type != Type.void);\n    let typeRef = type.toRef();\n\n    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n    if (tee) { // (global = value), global\n      this.currentType = type;\n      return module.block(null, [\n        module.global_set(global.internalName, valueExpr),\n        module.global_get(global.internalName, typeRef)\n      ], typeRef);\n    } else { // global = value\n      this.currentType = Type.void;\n      return module.global_set(global.internalName,\n        valueExpr\n      );\n    }\n  }\n\n  /** Makes an assignment to a field. */\n  private makeFieldAssignment(\n    /** The field to assign to. */\n    field: Field,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** The value of `this`. */\n    thisExpr: ExpressionRef,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let fieldType = field.type;\n    let fieldTypeRef = fieldType.toRef();\n    assert(field.parent.kind == ElementKind.Class);\n    let thisType = (<Class>field.parent).type;\n\n    if (!field.is(CommonFlags.Compiled)) {\n      field.set(CommonFlags.Compiled);\n      let typeNode = field.typeNode;\n      if (typeNode) this.checkTypeSupported(field.type, typeNode);\n    }\n\n    if (tee) {\n      this.compileField(field);\n      let tempThis = flow.getTempLocal(thisType);\n      let expr = module.block(null, [\n        module.call(field.internalSetterName, [ module.local_tee(tempThis.index, thisExpr, thisType.isManaged), valueExpr ], TypeRef.None),\n        module.call(field.internalGetterName, [ module.local_get(tempThis.index, thisType.toRef()) ], fieldTypeRef)\n      ], fieldTypeRef);\n      this.currentType = fieldType;\n      return expr;\n    } else {\n      this.compileFieldSetter(field);\n      let expr = module.call(field.internalSetterName, [ thisExpr, valueExpr ], TypeRef.None);\n      this.currentType = Type.void;\n      return expr;\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.Super) {\n      let flow = this.currentFlow;\n      let sourceFunction = flow.sourceFunction;\n      if (!sourceFunction.is(CommonFlags.Constructor)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(sourceFunction.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let baseClassInstance = classInstance.base;\n      if (!baseClassInstance) {\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.expression.range\n        );\n        return module.unreachable();\n      }\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let sizeTypeRef = this.options.sizeTypeRef;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, sizeTypeRef)\n      );\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.AccessesThis |\n        FlowFlags.ConditionallyAccessesThis\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.AccessesThis | FlowFlags.CallsSuper);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);\n    }\n\n    // otherwise resolve normally\n    let target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = this.resolver.currentThisExpression;\n\n    let signature: Signature | null;\n    let functionArg: ExpressionRef;\n    switch (target.kind) {\n\n      // direct call: concrete function\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.Builtin)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n\n      // indirect call: first-class function (non-generic, can't be inlined)\n      case ElementKind.Local: {\n        let local = <Local>target;\n        signature = local.type.signatureReference;\n        if (signature) {\n          if (local.parent != flow.targetFunction) {\n            // TODO: closures\n            this.error(\n              DiagnosticCode.Not_implemented_0,\n              expression.range,\n              \"Closures\"\n            );\n            return module.unreachable();\n          }\n          if (local.is(CommonFlags.Inlined)) {\n            let inlinedValue = local.constantIntegerValue;\n            if (this.options.isWasm64) {\n              functionArg = module.i64(i64_low(inlinedValue), i64_high(inlinedValue));\n            } else {\n              assert(!i64_high(inlinedValue));\n              functionArg = module.i32(i64_low(inlinedValue));\n            }\n          } else {\n            functionArg = module.local_get(local.index, this.options.sizeTypeRef);\n          }\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, local.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        signature = global.type.signatureReference;\n        if (signature) {\n          functionArg = module.global_get(global.internalName, global.type.toRef());\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, global.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.Field: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        signature = fieldType.signatureReference;\n        if (signature) {\n          let fieldParent = fieldInstance.parent;\n          assert(fieldParent.kind == ElementKind.Class);\n          let usizeType = this.options.usizeType;\n          functionArg = module.load(usizeType.byteSize, false,\n            this.compileExpression(\n              assert(thisExpression),\n              (<Class>fieldParent).type,\n              Constraints.ConvImplicit | Constraints.IsThis\n            ),\n            usizeType.toRef(),\n            fieldInstance.memoryOffset\n          );\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, fieldType.toString()\n        );\n        return module.unreachable();\n      }\n\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        let getterInstance = propertyInstance.getterInstance;\n        let type = assert(this.resolver.getTypeOfElement(target));\n\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, type.toString()\n          );\n          return module.unreachable();\n        }\n\n        let thisArg: ExpressionRef = 0;\n        if (propertyInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        functionArg = this.compileCallDirect(getterInstance, [], expression.expression, thisArg);\n        signature = this.currentType.signatureReference;\n        if (!signature) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n        break;\n      }\n      case ElementKind.Class: {\n        let classInstance = <Class>target;\n        let typeArguments = classInstance.getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          signature = ftype.getSignature();\n          functionArg = this.compileExpression(expression.expression, ftype, Constraints.ConvImplicit);\n          break;\n        }\n        // fall-through\n      }\n\n      // not supported\n      default: {\n        let type = this.resolver.getTypeOfElement(target);\n        if (type) {\n          this.error(\n            DiagnosticCode.Type_0_has_no_call_signatures,\n            expression.range, type.toString()\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            expression.range\n          );\n        }\n        return module.unreachable();\n      }\n    }\n    return this.compileCallIndirect(\n      assert(signature), // FIXME: bootstrap can't see this yet\n      functionArg,\n      expression.args,\n      expression,\n      0,\n      contextualType == Type.void\n    );\n  }\n\n  /** Compiles the given arguments like a call expression according to the specified context. */\n  private compileCallExpressionLike(\n    /** Called expression. */\n    expression: Expression,\n    /** Call type arguments. */\n    typeArguments: TypeNode[] | null,\n    /** Call arguments. */\n    args: Expression[],\n    /** Diagnostic range. */\n    range: Range,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    // Desugaring like this can happen many times. Let's cache the intermediate allocation.\n    let call = this._reusableCallExpression;\n    if (call) {\n      call.expression = expression;\n      call.typeArguments = typeArguments;\n      call.args = args;\n      call.range = range;\n    } else {\n      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);\n    }\n    return this.compileCallExpression(call, contextualType, constraints);\n  }\n  private _reusableCallExpression: CallExpression | null = null;\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    let typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow.sourceFunction.parent,\n        cloneMap(this.currentFlow.contextualTypeArguments), // don't update\n        expression\n      );\n    }\n    let callee = expression.expression;\n    let ctx = new BuiltinContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PropertyAccess\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    // global builtins\n    let internalName = prototype.internalName;\n    if (builtins.has(internalName)) {\n      let fn = assert(builtins.get(internalName));\n      return fn(ctx);\n    }\n    // class builtins\n    let parent = prototype.parent;\n    if (parent.kind == ElementKind.Class) {\n      let classPrototype = (<Class>parent).prototype;\n      if (classPrototype == this.program.functionPrototype) {\n        let methodName = prototype.name;\n        if (function_builtins.has(methodName)) {\n          let fn = assert(function_builtins.get(methodName));\n          return fn(ctx);\n        }\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    let thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\n    let hasRest = signature.hasRest;\n    if (hasRest) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        reportNode.range, \"Rest parameters\"\n      );\n      return false;\n    }\n\n    let minimum = signature.requiredParameters;\n    let maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n    let signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n\n    // handle call on `this` in constructors\n    let sourceFunction = this.currentFlow.sourceFunction;\n    if (sourceFunction.is(CommonFlags.Constructor) && reportNode.isAccessOnThis) {\n      let parent = sourceFunction.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    if (instance.hasDecorator(DecoratorFlags.Inline) && (!instance.is(CommonFlags.Virtual) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions *before* pushing to the inline stack\n        // otherwise, the arguments may not be inlined, e.g. `abc(abc(123))`\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.ConvImplicit);\n        }\n        // make the inlined call\n        inlineStack.push(instance);\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WillDrop) != 0);\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      let paramType = parameterTypes[i];\n      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.ConvImplicit);\n      operands[index] = paramExpr;\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WillDrop) != 0);\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    let numArguments = operands ? operands.length : 0;\n    let signature = instance.signature;\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    let previousFlow = this.currentFlow;\n    let flow = Flow.createInline(previousFlow.targetFunction, instance);\n    let body = [];\n\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType);\n      body.push(\n        module.local_set(thisLocal.index, thisArg, thisType.isManaged)\n      );\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n    for (let i = 0; i < numArguments; ++i) {\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.Wrapped);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NonNull);\n      body.push(\n        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)\n      );\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    let isConstructor = instance.is(CommonFlags.Constructor);\n    if (isConstructor) flow.set(FlowFlags.CtorParamContext);\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.ConvImplicit\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      body.push(\n        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)\n      );\n    }\n    flow.unset(FlowFlags.CtorParamContext);\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (isConstructor) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    let returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    this.currentType = returnType;\n    return module.block(flow.inlineReturnLabel, body, returnType.toRef());\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): string {\n    let name = BuiltinNames.argumentsLength;\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));\n    }\n    return name;\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    let stub = original.varargsStub;\n    if (stub) return stub;\n\n    let originalSignature = original.signature;\n    let originalParameterTypes = originalSignature.parameterTypes;\n    let originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    let returnType = originalSignature.returnType;\n    let isInstance = original.is(CommonFlags.Instance);\n\n    // arguments excl. `this`, operands incl. `this`\n    let minArguments = originalSignature.requiredParameters;\n    let minOperands = minArguments;\n    let maxArguments = originalParameterTypes.length;\n    let maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    let numOptional = assert(maxOperands - minOperands);\n\n    let forwardedOperands = new Array<ExpressionRef>(minOperands);\n    let operandIndex = 0;\n    let stmts = new Array<ExpressionRef>();\n\n    // forward `this` if applicable\n    let module = this.module;\n    let thisType = originalSignature.thisType;\n    if (thisType) {\n      forwardedOperands[0] = module.local_get(0, thisType.toRef());\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      let paramType = originalParameterTypes[i];\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\");\n    stub.signature.requiredParameters = maxArguments;\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    let previousFlow = this.currentFlow;\n    let flow = stub.flow;\n    if (original.is(CommonFlags.Constructor)) flow.set(FlowFlags.CtorParamContext);\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    let numNames = numOptional + 1; // incl. outer block\n    let names = new Array<string>(numNames);\n    let ofN = `of${numOptional}`;\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = `${i}${ofN}`;\n    }\n    let argumentsLength = this.ensureArgumentsLength();\n    let table = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(argumentsLength, TypeRef.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(argumentsLength, TypeRef.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (initializer) {\n        initExpr = this.compileExpression(\n          initializer,\n          type,\n          Constraints.ConvImplicit\n        );\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      table = module.block(names[i + 1], [\n        table,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());\n    }\n    assert(operandIndex == maxOperands);\n\n    stmts.push(\n      table\n    );\n    stmts.push(\n      // assume this will always succeed (can just use name as the reportNode)\n      this.makeCallDirect(original, forwardedOperands, original.declaration.name)\n    );\n    this.currentFlow = previousFlow;\n\n    let funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      typesToRefs(stub.getNonParameterLocalTypes()),\n      module.flatten(stmts, returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the virtual stub for the specified function. */\n  ensureVirtualStub(original: Function): Function {\n    // A virtual stub is a function redirecting virtual calls to the actual\n    // overload targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    let stub = original.virtualStub;\n    if (stub) return stub;\n    stub = original.newStub(\"virtual\");\n    original.virtualStub = stub;\n    let module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      null,\n      module.unreachable()\n    );\n    this.virtualStubs.add(original);\n    return stub;\n  }\n\n  /** Finalizes the virtual stub of the specified function. */\n  private finalizeVirtualStub(instance: Function): void {\n    let stub = this.ensureVirtualStub(instance);\n    if (stub.is(CommonFlags.Compiled)) return;\n\n    assert(instance.parent.kind == ElementKind.Class || instance.parent.kind == ElementKind.Interface);\n    let module = this.module;\n    let usizeType = this.options.usizeType;\n    let sizeTypeRef = usizeType.toRef();\n    let parameterTypes = instance.signature.parameterTypes;\n    let returnType = instance.signature.returnType;\n    let numParameters = parameterTypes.length;\n    let tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    let builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, sizeTypeRef),\n          sizeTypeRef == TypeRef.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        TypeRef.I32\n      )\n    );\n    let overloadInstances = this.resolver.resolveOverloads(instance);\n    if (overloadInstances) {\n      for (let i = 0, k = overloadInstances.length; i < k; ++i) {\n        let overloadInstance = overloadInstances[i];\n        if (!overloadInstance.is(CommonFlags.Compiled)) continue; // errored\n        let overloadType = overloadInstance.type;\n        let originalType = instance.type;\n        if (!overloadType.isAssignableTo(originalType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            overloadInstance.identifierNode.range, overloadType.toString(), originalType.toString()\n          );\n          continue;\n        }\n        // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n        let overloadSignature = overloadInstance.signature;\n        let overloadParameterTypes = overloadSignature.parameterTypes;\n        let overloadNumParameters = overloadParameterTypes.length;\n        let paramExprs = new Array<ExpressionRef>(1 + overloadNumParameters);\n        paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n        for (let n = 1; n <= numParameters; ++n) {\n          paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());\n        }\n        let needsVarargsStub = false;\n        for (let n = numParameters; n < overloadNumParameters; ++n) {\n          // TODO: inline constant initializers and skip varargs stub\n          paramExprs[1 + n] = this.makeZero(overloadParameterTypes[n]);\n          needsVarargsStub = true;\n        }\n        let calledName = needsVarargsStub\n          ? this.ensureVarargsStub(overloadInstance).internalName\n          : overloadInstance.internalName;\n        let returnTypeRef = overloadSignature.returnType.toRef();\n        let stmts = new Array<ExpressionRef>();\n        if (needsVarargsStub) {\n          // Safe to prepend since paramExprs are local.get's\n          stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));\n        }\n        if (returnType == Type.void) {\n          stmts.push(\n            module.call(calledName, paramExprs, returnTypeRef)\n          );\n          stmts.push(\n            module.return()\n          );\n        } else {\n          stmts.push(\n            module.return(\n              module.call(calledName, paramExprs, returnTypeRef)\n            )\n          );\n        }\n        let classInstance = assert(overloadInstance.getClassOrInterface());\n        builder.addCase(classInstance.id, stmts);\n        // Also alias each extendee inheriting this exact overload\n        let extendees = classInstance.getAllExtendees(instance.declaration.name.text); // without get:/set:\n        for (let _values = Set_values(extendees), a = 0, b = _values.length; a < b; ++a) {\n          let extendee = _values[a];\n          builder.addCase(extendee.id, stmts);\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extendees inheriting the original function.\n    let body: ExpressionRef;\n    if (instance.prototype.bodyNode) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toRef());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the virtual stub function\n    let ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      [ TypeRef.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n  }\n\n  /** Marks managed call operands for the shadow stack. */\n  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {\n    if (!this.options.stackSize) return;\n    let module = this.module;\n    let operandIndex = 0;\n    let thisType = signature.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        let operand = operands[0];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n    }\n    let parameterIndex = 0;\n    let parameterTypes = signature.parameterTypes;\n    assert(parameterTypes.length >= operands.length - operandIndex);\n    while (operandIndex < operands.length) {\n      let paramType = parameterTypes[parameterIndex];\n      if (paramType.isManaged) {\n        let operand = operands[operandIndex];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n      ++parameterIndex;\n    }\n  }\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.Inline)) {\n      if (!instance.is(CommonFlags.Virtual)) {\n        assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.Instance)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = instance.signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = instance.signature.parameterTypes;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (instance.is(CommonFlags.Instance)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    let returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.ConvImplicit\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.Swallow);\n          if (resolved) {\n            if (resolved.kind == ElementKind.Global) {\n              let global = <Global>resolved;\n              if (this.compileGlobal(global)) {\n                if (global.is(CommonFlags.Inlined)) {\n                  operands.push(\n                    this.compileInlineConstant(global, parameterTypes[i], Constraints.ConvImplicit)\n                  );\n                } else {\n                  operands.push(\n                    this.convertExpression(\n                      module.global_get(global.internalName, global.type.toRef()),\n                      global.type, parameterTypes[i], false, initializer\n                    )\n                  );\n                }\n                continue;\n              }\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i]));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant && !instance.is(CommonFlags.ModuleImport)) {\n        let original = instance;\n        instance = this.ensureVarargsStub(instance);\n        if (!this.compileFunction(instance)) return module.unreachable();\n        instance.flow.flags = original.flow.flags;\n        let returnTypeRef = returnType.toRef();\n        // We know the last operand is optional and omitted, so inject setting\n        // ~argumentsLength into that operand, which is always safe.\n        let lastOperand = operands[maxOperands - 1];\n        assert(!(getSideEffects(lastOperand, module.ref) & SideEffects.WritesGlobal));\n        let lastOperandType = parameterTypes[maxArguments - 1];\n        operands[maxOperands - 1] = module.block(null, [\n          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),\n          lastOperand\n        ], lastOperandType.toRef());\n        this.operandsTostack(instance.signature, operands);\n        let expr = module.call(instance.internalName, operands, returnTypeRef);\n        if (returnType != Type.void && immediatelyDropped) {\n          expr = module.drop(expr);\n          this.currentType = Type.void;\n        } else {\n          this.currentType = returnType;\n        }\n        return expr;\n      }\n    }\n\n    // Call the virtual stub with the vtable if the function has overloads\n    if (instance.is(CommonFlags.Virtual) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureVirtualStub(instance);\n    }\n\n    if (operands) this.operandsTostack(instance.signature, operands);\n    let expr = module.call(instance.internalName, operands, returnType.toRef());\n    this.currentType = returnType;\n    return expr;\n  }\n\n  /** Compiles an indirect call to a first-class function. */\n  compileCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.ConvImplicit\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to a first-class function. */\n  makeCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = signature.parameterTypes;\n    let returnType = signature.returnType;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i]));\n      }\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    let argumentsLength = this.ensureArgumentsLength();\n    let sizeTypeRef = this.options.sizeTypeRef;\n    if (getSideEffects(functionArg, module.ref) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType);\n      let tempIndex = temp.index;\n      functionArg = module.block(null, [\n        module.local_set(tempIndex, functionArg, true), // Function\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        module.local_get(tempIndex, sizeTypeRef)\n      ], sizeTypeRef);\n    } else { // simplify\n      functionArg = module.block(null, [\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        functionArg\n      ], sizeTypeRef);\n    }\n    if (operands) this.operandsTostack(signature, operands);\n    let expr = module.call_indirect(\n      null, // TODO: handle multiple tables\n      module.load(4, false, functionArg, TypeRef.I32), // ._index\n      operands,\n      signature.paramRefs,\n      signature.resultRefs\n    );\n    this.currentType = returnType;\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    let exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.ConvImplicit | Constraints.WillDrop\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toRef());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let targetExpression = expression.expression;\n    let targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UncheckedContext);\n        let indexedGet = classReference.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.ConvImplicit\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n    let isNamed = declaration.name.text.length > 0;\n    let isSemanticallyAnonymous = !isNamed || contextualType != Type.void;\n    let prototype = new FunctionPrototype(\n      isSemanticallyAnonymous\n        ? `${isNamed ? declaration.name.text : \"anonymous\"}|${sourceFunction.nextAnonymousId++}`\n        : declaration.name.text,\n      sourceFunction,\n      declaration,\n      DecoratorFlags.None\n    );\n    let instance: Function | null;\n    let contextualTypeArguments = cloneMap(flow.contextualTypeArguments);\n    let module = this.module;\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    let contextualSignature = contextualType.signatureReference;\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type,\n            sourceFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      let signature = new Signature(this.program, parameterTypes, returnType, thisType);\n      signature.requiredParameters = numParameters; // !\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = contextualSignature.type;\n      if (!worked) return module.unreachable();\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n      if (!worked) return module.unreachable();\n    }\n\n    let offset = this.ensureRuntimeFunction(instance); // reports\n    let expr = this.options.isWasm64\n      ? module.i64(i64_low(offset), i64_high(offset))\n      : module.i32(i64_low(offset));\n\n    // add a constant local referring to the function if applicable\n    if (!isSemanticallyAnonymous) {\n      let fname = instance.name;\n      let existingLocal = flow.getScopedLocal(fname);\n      if (existingLocal) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existingLocal.declaration.name.range,\n            fname\n          );\n        } else { // scoped locals are shared temps that don't track declarations\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range, fname\n          );\n        }\n      } else {\n        let ftype = instance.type;\n        let local = flow.addScopedLocal(instance.name, ftype);\n        flow.setLocalFlag(local.index, LocalFlags.Constant);\n        expr = module.local_tee(local.index, expr, ftype.isManaged);\n      }\n    }\n\n    return expr;\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    let internalPath = expression.range.source.internalPath;\n    let filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    let enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.Compiled)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.Null: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.True: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.False: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.This: {\n        let thisType = sourceFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          }\n          if (!(constraints & Constraints.IsThis)) {\n            let parent = sourceFunction.parent;\n            assert(parent.kind == ElementKind.Class);\n            this.checkFieldInitialization(<Class>parent, expression);\n          }\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.AccessesThis);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toRef());\n      }\n      case NodeKind.Super: {\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          } else if (!flow.is(FlowFlags.CallsSuper)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toRef());\n            }\n          }\n        }\n        if (sourceFunction.is(CommonFlags.Instance)) {\n          let parent = assert(sourceFunction.parent);\n          assert(parent.kind == ElementKind.Class);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toRef());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    let currentParent = this.currentParent;\n    if (!currentParent) currentParent = sourceFunction;\n    let target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        assert(localIndex >= 0);\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NonNull, false)) {\n          localType = localType.nonNullableType;\n        }\n        this.currentType = localType;\n\n        if (target.parent != flow.targetFunction) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        return module.local_get(localIndex, localType.toRef());\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toRef());\n      }\n      case ElementKind.EnumValue: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.Compiled)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            expression.range\n          );\n          break; // also diagnose 'not a value at runtime'\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range, \"First-class built-ins\"\n          );\n          this.currentType = functionInstance.type;\n          return module.unreachable();\n        }\n        if (contextualType.isExternalReference) {\n          // TODO: Concrete function types currently map to first class functions implemented in\n          // linear memory (on top of `usize`), leaving only generic `funcref` for use here. In the\n          // future, once functions become Wasm GC objects, the actual signature type can be used.\n          this.currentType = Type.funcref;\n          return module.ref_func(functionInstance.internalName, ensureType(functionInstance.type));\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return module.unreachable();\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let flow = this.currentFlow;\n    let isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NamedType) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow.sourceFunction, ReportMode.Swallow);\n        if (element && element.kind == ElementKind.ClassPrototype) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.Generic)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    let expectedType = this.resolver.resolveType(\n      expression.isType,\n      flow.sourceFunction,\n      cloneMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let expr = this.compileExpression(expression.expression, expectedType);\n    let actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    let sizeTypeRef = actualType.toRef();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // upcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType)\n        );\n      }\n\n      // downcast - check dynamically\n      if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(tempIndex, sizeTypeRef),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // upcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n\n      // downcast - check dynamically\n      } else if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          // FIXME: the temp local and the if can be removed here once flows\n          // perform null checking, which would error earlier when checking\n          // uninitialized (thus zero) `let a: A` to be an instance of something.\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(tempIndex, sizeTypeRef),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    let module = this.module;\n    let expr = this.compileExpression(expression.expression, Type.auto);\n    let actualType = this.currentType;\n    let sizeTypeRef = actualType.toRef();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    let classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extends(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            sizeTypeRef == TypeRef.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        this.pendingClassInstanceOf.add(prototype);\n        return module.call(`${prototype.internalName}~instanceof`, [ expr ], TypeRef.I32);\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.Array: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.Float: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.Integer: {\n        let expr = <IntegerLiteralExpression>expression;\n        let type = this.resolver.determineIntegerLiteralType(expr, implicitlyNegate, contextualType);\n        this.currentType = type;\n        let intValue = expr.value;\n        let sign = 1.0; // should multiply for float literals\n        if (implicitlyNegate) {\n          if (type.isFloatValue) {\n            sign = -1.0;\n          } else {\n            intValue = i64_neg(intValue);\n          }\n        }\n        switch (type.kind) {\n          case TypeKind.Isize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.Usize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(<f32>sign * i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(sign * i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.String: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Template: {\n        assert(!implicitlyNegate);\n        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Object: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.RegExp: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    return this.ensureStaticString(expression.value);\n  }\n\n  private compileTemplateLiteral(\n    expression: TemplateLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    let tag = expression.tag;\n    let parts = expression.parts;\n    let numParts = parts.length;\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    let exprLengths = expression.exprLengths;\n    assert(numExpressions == numParts - 1);\n    assert(exprLengths.length == numExpressions);\n\n    let module = this.module;\n    let stringInstance = this.program.stringInstance;\n    let stringType = stringInstance.type;\n\n    if (!tag) {\n      // Shortcut if just a (multi-line) string\n      if (numParts == 1) {\n        return this.ensureStaticString(parts[0]);\n      }\n\n      // Compile to nested calls to __copy<n> in the general case\n      let totalLength = i64_new(0);\n      for (let i = 0; i < numParts; ++i) {\n        totalLength = i64_add(totalLength, parts[i].length);\n      }\n      for (let i = 0; i < numExpressions; ++i) {\n        totalLength = i64_add(totalLength, exprLengths[i]);\n      }\n\n      let callIdent = Node.createIdentifierExpression(\"newStringBuffer\", expression.range);\n      let args = new Array<Expression>();\n      args.push(Node.createIntegerLiteralExpression(totalLength, expression.range));\n      let call = Node.createCallExpression(callIdent, null, args, expression.range);\n      let literalSegment = parts[0];\n      let curLength = literalSegment.length;\n      if (curLength) {\n        callIdent = Node.createIdentifierExpression(\"__copy\" + curLength.toString(), expression.range);\n        args = new Array<Expression>();\n        args.push(call);\n        args.push(Node.createStringLiteralExpression(literalSegment, expression.range));\n        call = Node.createCallExpression(callIdent, null, args, expression.range);\n      }\n\n      for (let i = 1; i < numParts; ++i) {\n        curLength = i64_low(exprLengths[i - 1]);\n        callIdent = Node.createIdentifierExpression(\"__copy\" + curLength.toString(), expression.range);\n        args = new Array<Expression>();\n        args.push(call);\n        args.push(expressions[i - 1]);\n        call = Node.createCallExpression(callIdent, null, args, expression.range);\n        literalSegment = parts[i];\n        curLength = literalSegment.length;\n        if (curLength) {\n          callIdent = Node.createIdentifierExpression(\"__copy\" + curLength.toString(), expression.range);\n          args = new Array<Expression>();\n          args.push(call);\n          args.push(Node.createStringLiteralExpression(literalSegment, expression.range));\n          call = Node.createCallExpression(callIdent, null, args, expression.range);\n        }\n      }\n\n      callIdent = Node.createIdentifierExpression(\"convertStringBuffer\", expression.range);\n      args = new Array<Expression>();\n      args.push(call);\n      args.push(Node.createIntegerLiteralExpression(totalLength, expression.range));\n      call = Node.createCallExpression(callIdent, null, args, expression.range);\n      return this.compileCallExpression(call, stringType);\n    }\n\n    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if\n    // it is sufficient to compile to a normal array. While technically incorrect, this allows us\n    // to avoid generating unnecessary static data that is not explicitly signaled to be used.\n    let tsaArrayInstance = this.program.templateStringsArrayInstance;\n    let arrayInstance = tsaArrayInstance;\n    let target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.Swallow);\n    if (target) {\n      switch (target.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instance = this.resolver.resolveFunction(\n            <FunctionPrototype>target,\n            null,\n            new Map(),\n            ReportMode.Swallow\n          );\n          if (!instance) break;\n          target = instance;\n          // fall-through\n        }\n        case ElementKind.Function: {\n          let instance = <Function>target;\n          let parameterTypes = instance.signature.parameterTypes;\n          if (parameterTypes.length) {\n            let first = parameterTypes[0].getClass();\n            if (first && !first.extends(tsaArrayInstance.prototype)) {\n              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    // Compile to a call to the tag function\n    let rawParts = expression.rawParts;\n    assert(rawParts.length == numParts);\n    let partExprs = new Array<ExpressionRef>(numParts);\n    for (let i = 0; i < numParts; ++i) {\n      partExprs[i] = this.ensureStaticString(parts[i]);\n    }\n    let arraySegment: MemorySegment;\n    if (arrayInstance == tsaArrayInstance) {\n      let rawExprs = new Array<ExpressionRef>(numParts);\n      for (let i = 0; i < numParts; ++i) {\n        rawExprs[i] = this.ensureStaticString(rawParts[i]);\n      }\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n      let rawHeaderSegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, rawExprs)\n      );\n      arrayInstance.writeField(\"raw\",\n        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),\n        arraySegment.buffer\n      );\n    } else {\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n    }\n\n    // Desugar to compileCallExpression\n    let args = expressions.slice();\n    args.unshift(\n      Node.createCompiledExpression(\n        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),\n        arrayInstance.type,\n        this.program.nativeRange\n      )\n    );\n    // TODO: Requires ReadonlyArray to be safe\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      expression.range, \"Tagged template literals\"\n    );\n    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass && contextualClass.extends(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    let element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.Class);\n    let arrayInstance = <Class>element;\n    let arrayType = arrayInstance.type;\n    let elementType = (arrayInstance.prototype != program.byteArrayPrototype)\n      ? arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0]\n      : Type.u8;\n    let arrayBufferInstance = (arrayInstance.prototype != program.byteArrayPrototype)\n      ? assert(program.arrayBufferInstance)\n      : arrayInstance;\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n    let tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\n\n    // compile value expressions and find out whether all are constant\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.ConvImplicit);\n        if (getExpressionType(expr) != elementType.toRef()) {\n          isStatic = false;\n        } else {\n          let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            expr = precomp;\n          } else {\n            isStatic = false;\n          }\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment / static ByteArray\n    if (isStatic) {\n      let totalOverhead = program.totalOverhead;\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayBufferInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));\n\n      // Make ByteArray static; this couldn't be done in generic\n      // AssemblyScript if inside of a function, because each\n      // invocation would have to create a new array reference, but as\n      // Hooks do not support functions calling each other the problem\n      // does not arise.\n      if (arrayInstance.prototype == program.byteArrayPrototype) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        this.currentType = arrayType;\n        return expr;\n      }\n\n      if (constraints & Constraints.PreferStatic) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        return this.makeNewArray(arrayInstance, length, bufferAddress, expression);\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeNewArray(arrayInstance, length, i64_new(0), expression),\n        arrayType.isManaged\n      )\n    );\n    // tempData = tempThis.dataStart\n    let memoryOffset = 0;\n    let dataStartMember = arrayInstance.getMember(\"dataStart\");\n    if (dataStartMember) {\n      assert(dataStartMember.kind == ElementKind.Field);\n      memoryOffset = (<Field>dataStartMember).memoryOffset;\n    }\n    stmts.push(\n      module.local_set(tempDataStart.index,\n        module.load(arrayType.byteSize, false,\n          module.local_get(tempThis.index, arrayTypeRef),\n          arrayTypeRef,\n          memoryOffset\n        ),\n        true // ArrayBuffer\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // this[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  /** Makes a new array instance from a static buffer segment. */\n  private makeNewArray(\n    /** Concrete array class. */\n    arrayInstance: Class,\n    /** Length of the array. */\n    length: i32,\n    /** Source address to copy from. Array is zeroed if `0`. */\n    source: i64,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let module = this.module;\n    assert(!arrayInstance.extends(program.staticArrayPrototype));\n    let elementType = (arrayInstance.prototype != program.byteArrayPrototype)\n      ? arrayInstance.getArrayValueType() // asserts\n      : Type.u8;\n\n    // __newArray(length, alignLog2, classId, staticBuffer)\n    let expr = this.makeCallDirect(program.newArrayInstance, [\n      module.i32(length),\n      program.options.isWasm64\n        ? module.i64(elementType.alignLog2)\n        : module.i32(elementType.alignLog2),\n      module.i32(arrayInstance.id),\n      program.options.isWasm64\n        ? module.i64(i64_low(source), i64_high(source))\n        : module.i32(i64_low(source))\n    ], reportNode);\n    this.currentType = arrayInstance.type;\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    let arrayInstance = assert(contextualType.getClass());\n    let arrayType = arrayInstance.type;\n    let typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    let elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    let isWasm64 = this.options.isWasm64;\n    let bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PreferStatic) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id),\n          isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id)\n        ], expression),\n        arrayType.isManaged\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // array[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    let module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    let classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    let classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.kind == ElementKind.Interface) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        expression.range, \"Interface hidden classes\"\n      );\n      return module.unreachable();\n    }\n    if (classReference.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    let ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    let isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.Unmanaged, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    let names = expression.names;\n    let numNames = names.length;\n    let values = expression.values;\n    let members = classReference.members;\n    let hasErrors = false;\n    let exprs = new Array<ExpressionRef>();\n    let flow = this.currentFlow;\n    let tempLocal = flow.getTempLocal(classType);\n    let classTypeRef = classType.toRef();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    let omittedFields = new Set<Field>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member && member.kind == ElementKind.Field) {\n          omittedFields.add(<Field>member); // incl. private/protected\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member = classReference.getMember(memberName);\n      if (!member || member.kind != ElementKind.Field) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Private)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Protected)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let fieldInstance = <Field>member;\n      let fieldType = fieldInstance.type;\n\n      let expr = this.compileExpression(values[i], fieldType, Constraints.ConvImplicit);\n      exprs.push(\n        module.call(fieldInstance.internalSetterName, [\n          module.local_get(tempLocal.index, classTypeRef),\n          expr\n        ], TypeRef.None)\n      );\n      this.compileFieldSetter(fieldInstance);\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(fieldInstance);\n    }\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let fieldInstance = _values[j];\n      let fieldType = fieldInstance.type;\n\n      if (fieldInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (fieldType.isReference) {\n        if (!fieldType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, fieldInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (fieldType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.Bool:\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.Isize:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.Usize:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          exprs.push(\n            module.call(fieldInstance.internalSetterName, [\n              module.local_get(tempLocal.index, classTypeRef),\n              this.makeZero(fieldType)\n            ], TypeRef.None)\n          );\n          this.compileFieldSetter(fieldInstance);\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, fieldInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    let ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.None, expression),\n        classType.isManaged\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, classTypeRef)\n    );\n\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, classTypeRef);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    let target = this.resolver.resolveTypeName(expression.typeName, flow.sourceFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.ClassPrototype) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    let classPrototype = <ClassPrototype>target;\n    let classInstance: Class | null = null;\n    let typeArguments = expression.typeArguments;\n    let classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) &&\n      classReference.prototype == classPrototype &&\n      classReference.is(CommonFlags.Generic)\n    ) {\n      // e.g. `arr: Array<T> = new Array()`\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        cloneMap(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow.sourceFunction.parent, // relative to caller\n        cloneMap(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.Inline)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    let instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.Compiled)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.Inline)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class. note that we cannot just\n      // call the base ctor since the derived class may have additional fields.\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = cloneMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          baseCtor.signature,\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.Instance | CommonFlags.Constructor\n            )\n          ),\n          null,\n          new Signature(this.program, null, classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n      }\n\n      instance.set(CommonFlags.Compiled);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      if (classInstance.is(CommonFlags.ModuleExport)) {\n        instance.set(CommonFlags.ModuleExport);\n      }\n      classInstance.constructorInstance = instance;\n      let members = classInstance.members;\n      if (!members) classInstance.members = members = new Map();\n      members.set(\"constructor\", instance.prototype);\n\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let sizeTypeRef = this.options.sizeTypeRef;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   this = <COND_ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      stmts.push(\n        this.makeConditionalAllocation(classInstance, 0)\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, sizeTypeRef);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),\n            baseClass.type.isManaged\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      stmts.push(\n        module.local_get(0, sizeTypeRef)\n      );\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());\n      }\n      let funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        varTypes,\n        module.flatten(stmts, sizeTypeRef)\n      );\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    let ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind == ElementKind.Field && element.parent == classInstance) {\n          let field = <Field>element;\n          if (!field.initializerNode && !flow.isThisFieldFlag(field, FieldFlags.Initialized)) {\n            if (!field.is(CommonFlags.DefinitelyAssigned)) {\n              if (relatedNode) {\n                this.errorRelated(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  relatedNode.range,\n                  field.internalName\n                );\n              } else {\n                this.error(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  field.internalName\n                );\n              }\n            }\n          } else if (field.is(CommonFlags.DefinitelyAssigned)) {\n            if (field.type.isReference) {\n              this.warning( // involves a runtime check\n                DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n                field.identifierNode.range,\n                field.internalName\n              );\n            } else {\n              this.pedantic( // is a nop anyway\n                DiagnosticCode.Unnecessary_definite_assignment,\n                field.identifierNode.range\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.Constructor));\n    let parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n    let expr = this.compileCallDirect(\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType),\n      constraints\n    );\n    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.Global: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable(); // reports\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toRef());\n      }\n      case ElementKind.EnumValue: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.Enum);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.Field: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        assert(fieldInstance.memoryOffset >= 0);\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.Class);\n        thisExpression = assert(thisExpression);\n        let thisExpr = this.compileExpression(\n          thisExpression,\n          (<Class>fieldParent).type,\n          Constraints.ConvImplicit | Constraints.IsThis\n        );\n        let thisType = this.currentType;\n        if (\n          flow.sourceFunction.is(CommonFlags.Constructor) &&\n          thisExpression.kind == NodeKind.This &&\n          !flow.isThisFieldFlag(fieldInstance, FieldFlags.Initialized) &&\n          !fieldInstance.is(CommonFlags.DefinitelyAssigned)\n        ) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_used_before_being_assigned,\n            expression.range,\n            fieldInstance.identifierNode.range,\n            fieldInstance.internalName\n          );\n        }\n        if (thisType.isNullableReference) {\n          if (!flow.isNonnull(thisExpr, thisType)) {\n            this.error(\n              DiagnosticCode.Object_is_possibly_null,\n              thisExpression.range\n            );\n          }\n        }\n        if (!fieldInstance.is(CommonFlags.Compiled)) {\n          fieldInstance.set(CommonFlags.Compiled);\n          let typeNode = fieldInstance.typeNode;\n          if (typeNode) this.checkTypeSupported(fieldInstance.type, typeNode);\n        }\n        this.currentType = fieldType;\n        let ret = module.load(\n          fieldType.byteSize,\n          fieldType.isSignedIntegerValue,\n          thisExpr,\n          fieldType.toRef(),\n          fieldInstance.memoryOffset\n        );\n        if (fieldInstance.is(CommonFlags.DefinitelyAssigned) && fieldType.isReference && !fieldType.isNullableReference) {\n          ret = this.makeRuntimeNonNullCheck(ret, fieldType, expression);\n        }\n        return ret;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        let getterInstance = propertyInstance.getterInstance;\n        if (!getterInstance) return module.unreachable(); // failed earlier\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (target.internalName == \"~lib/params/Params.__get\") {\n          let args = [ Node.createStringLiteralExpression(expression.property.text, expression.property.range) ]\n          return this.compileCallDirect(functionInstance, args, expression);\n        }\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return this.module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let ifThen = expression.ifThen;\n    let ifElse = expression.ifElse;\n\n    let condExpr = this.makeIsTrueish(\n      this.compileExpression(expression.condition, Type.bool),\n      this.currentType,\n      expression.condition\n    );\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    let condKind = this.evaluateCondition(condExpr);\n    if (condKind == ConditionKind.True) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifThen, ctxType));\n    }\n    if (condKind == ConditionKind.False) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifElse, ctxType));\n    }\n\n    let outerFlow = this.currentFlow;\n    let ifThenFlow = outerFlow.fork();\n    ifThenFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = ifThenFlow;\n    let ifThenExpr = this.compileExpression(ifThen, ctxType);\n    let ifThenType = this.currentType;\n\n    let ifElseFlow = outerFlow.fork();\n    ifElseFlow.inheritNonnullIfFalse(condExpr);\n    this.currentFlow = ifElseFlow;\n    let ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType);\n    let ifElseType = this.currentType;\n\n    if (ctxType == Type.void) { // values, including type mismatch, are irrelevant\n      if (ifThenType != Type.void) {\n        ifThenExpr = module.drop(ifThenExpr);\n        ifThenType = Type.void;\n      }\n      if (ifElseType != Type.void) {\n        ifElseExpr = module.drop(ifElseExpr);\n        ifElseType = Type.void;\n      }\n      this.currentType = Type.void;\n    } else {\n      let commonType = Type.commonDenominator(ifThenType, ifElseType, false);\n      if (!commonType) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          ifElse.range, ifElseType.toString(), ifThenType.toString()\n        );\n        this.currentType = ctxType;\n        return module.unreachable();\n      }\n      ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n      ifThenType = commonType;\n      ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n      ifElseType = commonType;\n      this.currentType = commonType;\n    }\n\n    this.currentFlow = outerFlow;\n    outerFlow.inheritMutual(ifThenFlow, ifElseFlow);\n\n    return module.if(condExpr, ifThenExpr, ifElseExpr);\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    let getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.None\n    );\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    let tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue,\n        this.currentType.isManaged\n      );\n    }\n\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus_Plus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixInc);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixDec);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.Instance)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    let setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    let typeRef = tempLocal.type.toRef();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, typeRef)\n    ], typeRef); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let compound = false;\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Plus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.Minus: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.None, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Minus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              this.makeZero(this.currentType),\n              expr\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Plus_Plus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixInc);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixDec);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Exclamation: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Tilde: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.XorSize,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TypeOf: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      case Token.Dot_Dot_Dot: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"Spread operator\"\n        );\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let operand = expression.operand;\n    let expr: ExpressionRef = 0;\n    let stringInstance = this.program.stringInstance;\n    let typeString: string;\n    if (operand.kind == NodeKind.Null) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.Swallow);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.Identifier: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PropertyAccess:\n          case NodeKind.ElementAccess: {\n            operand = operand.kind == NodeKind.PropertyAccess\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.Report);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.ClassPrototype:\n          case ElementKind.Namespace:\n          case ElementKind.Enum: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FunctionPrototype: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype == stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend8I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend16I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    let targetFunction = this.currentFlow.targetFunction;\n    let source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    range.debugInfoRef = expr;\n    targetFunction.debugLocations.push(range);\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.Simd, reportNode);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode);\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.Stringref, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    let supported = true;\n    let explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    let parameterTypes = signature.parameterTypes;\n    let parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    let type = getExpressionType(expr);\n    if (type == TypeRef.Unreachable)\n      return ConditionKind.Unknown;\n\n    assert(type == TypeRef.I32);\n    let module = this.module;\n    let evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.True\n        : ConditionKind.False;\n    }\n    return ConditionKind.Unknown;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        // TODO: what if not nullable?\n        return module.ref_null(type.toRef());\n      }\n      case TypeKind.I31ref: {\n        if (type.is(TypeFlags.Nullable)) return module.ref_null(type.toRef());\n        return module.i31_new(module.i32(0));\n      }\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n      case TypeKind.I31ref: return module.i31_new(module.i32(1));\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n      case TypeKind.V128: return module.v128(v128_ones);\n      case TypeKind.I31ref: return module.i31_new(module.i32(-1));\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.Bool: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: return expr;\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f32_u(f32.ceil(f32.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF32ToU32,\n                module.unary(UnaryOp.CeilF32,\n                  module.unary(UnaryOp.AbsF32, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n          //\n          // and finally:\n          // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n          return module.binary(BinaryOp.LeU32,\n            module.binary(BinaryOp.SubI32,\n              module.binary(BinaryOp.ShlI32,\n                module.unary(UnaryOp.ReinterpretF32ToI32, expr),\n                module.i32(1)\n              ),\n              module.i32(2) // 1 << 1\n            ),\n            module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.F64: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f64_u(f64.ceil(f64.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF64ToU32,\n                module.unary(UnaryOp.CeilF64,\n                  module.unary(UnaryOp.AbsF64, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n          //\n          // and finally:\n          // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n          return module.binary(BinaryOp.LeU64,\n            module.binary(BinaryOp.SubI64,\n              module.binary(BinaryOp.ShlI64,\n                module.unary(UnaryOp.ReinterpretF64ToI64, expr),\n                module.i64(1)\n              ),\n              module.i64(2) // 1 << 1\n            ),\n            module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128, expr);\n      }\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        // Needs to be true (i.e. not zero) when the ref is _not_ null,\n        // which means `ref.is_null` returns false (i.e. zero).\n        return module.unary(UnaryOp.EqzI32, module.ref_is_null(expr));\n      }\n      case TypeKind.Void:\n      default: {\n        this.error(\n          DiagnosticCode.An_expression_of_type_0_cannot_be_tested_for_truthiness,\n          reportNode.range, type.toString()\n        );\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes a string conversion of the given expression. */\n  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let stringType = this.program.stringInstance.type;\n    if (type == stringType) {\n      return expr;\n    }\n    let classType = type.getClassOrWrapper(this.program);\n    if (classType) {\n      let toStringInstance = classType.getMethod(\"toString\");\n      if (toStringInstance) {\n        let toStringSignature = toStringInstance.signature;\n        if (!this.checkCallSignature( // reports\n          toStringSignature,\n          0,\n          true,\n          reportNode\n        )) {\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {\n          this.errorRelated(\n            DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n            reportNode.range, toStringInstance.identifierAndSignatureRange\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        let toStringReturnType = toStringSignature.returnType;\n        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {\n          this.errorRelated(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);\n      }\n    }\n    this.error(\n      DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n      reportNode.range, type.toString(), stringType.toString()\n    );\n    this.currentType = stringType;\n    return this.module.unreachable();\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    let program = this.program;\n    assert(classInstance.program == program);\n    let module = this.module;\n    let options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.sizeTypeRef);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.sizeTypeRef);\n    }\n  }\n\n  /** Makes a conditional allocation where `this` might not have been initialized yet. */\n  makeConditionalAllocation(\n    classInstance: Class,\n    thisIndex: i32\n  ): ExpressionRef {\n    let module = this.module;\n    let classType = classInstance.type;\n    let classTypeRef = classType.toRef();\n    assert(classTypeRef == this.options.sizeTypeRef);\n    return module.if(\n      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n        module.local_get(thisIndex, classTypeRef)\n      ),\n      module.local_set(thisIndex,\n        this.makeAllocation(classInstance),\n        classInstance.type.isManaged\n      )\n    );\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    let members = classInstance.members;\n    if (!members) return stmts;\n\n    let module = this.module;\n    let flow = this.currentFlow;\n    let isInline = flow.isInline;\n    let thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;\n    let sizeTypeRef = this.options.sizeTypeRef;\n    let nonParameterFields: Field[] | null = null;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (\n        member.kind != ElementKind.Field || // not a field\n        member.parent != classInstance      // inherited field\n      ) continue;\n      let field = <Field>member;\n      assert(!field.isAny(CommonFlags.Const));\n      let fieldPrototype = field.prototype;\n      let parameterIndex = fieldPrototype.parameterIndex;\n\n      // Defer non-parameter fields until parameter fields are initialized\n      if (parameterIndex < 0) {\n        if (!nonParameterFields) nonParameterFields = new Array();\n        nonParameterFields.push(field);\n        continue;\n      }\n\n      // Initialize constructor parameter field\n      let fieldType = field.type;\n      let fieldTypeRef = fieldType.toRef();\n      assert(!fieldPrototype.initializerNode);\n      this.compileFieldSetter(field);\n      stmts.push(\n        module.call(field.internalSetterName, [\n          module.local_get(thisLocalIndex, sizeTypeRef),\n          module.local_get(\n            isInline\n              ? flow.lookupLocal(field.name)!.index\n              : 1 + parameterIndex, // `this` is local 0\n            fieldTypeRef\n          )\n        ], TypeRef.None)\n      );\n    }\n\n    // Initialize deferred non-parameter fields\n    if (nonParameterFields) {\n      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {\n        let field = unchecked(nonParameterFields[i]);\n        let fieldType = field.type;\n        let fieldPrototype = field.prototype;\n        let initializerNode = fieldPrototype.initializerNode;\n        assert(fieldPrototype.parameterIndex < 0);\n        this.compileFieldSetter(field);\n        stmts.push(\n          module.call(field.internalSetterName, [\n            module.local_get(thisLocalIndex, sizeTypeRef),\n            initializerNode // use initializer if present, otherwise initialize with zero\n              ? this.compileExpression(initializerNode, fieldType, Constraints.ConvImplicit)\n              : this.makeZero(fieldType)\n          ], TypeRef.None)\n        );\n      }\n    }\n\n    this.currentType = Type.void;\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    let stringInstance = program.stringInstance;\n    let messageArg: ExpressionRef;\n    if (message) {\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.ConvImplicit);\n    } else {\n      messageArg = this.makeZero(stringInstance.type);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let module = this.module;\n    return module.unreachable();\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n    flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"unexpected null\"),\n      reportNode\n    ); // TODO: throw\n\n    if (type.isExternalReference) {\n      let nonNullExpr = module.local_get(tempIndex, type.toRef());\n      if (this.options.hasFeature(Feature.GC)) {\n        nonNullExpr = module.ref_as_nonnull(nonNullExpr);\n      }\n      expr = module.if(\n        module.ref_is_null(\n          module.local_tee(tempIndex, expr, false)\n        ),\n        staticAbortCallExpr,\n        nonNullExpr\n      );\n    } else {\n      expr = module.if(\n        module.local_tee(tempIndex, expr, type.isManaged),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    }\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime downcast check, e.g. on `<Child>parent`. */\n  makeRuntimeDowncastCheck(\n    /** Expression being downcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n    let instanceofInstance = this.program.instanceofInstance;\n    assert(this.compileFunction(instanceofInstance));\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"unexpected downcast\"),\n      reportNode\n    ); // TODO: throw\n\n    if (!toType.isNullableReference || flow.isNonnull(expr, type)) {\n      // Simplify if the value cannot be `null`. If toType is non-nullable, a\n      // null-check would have been emitted separately so is not necessary here.\n      expr = module.if(\n        module.call(instanceofInstance.internalName, [\n          module.local_tee(tempIndex, expr, type.isManaged),\n          module.i32(toType.classReference!.id)\n        ], TypeRef.I32),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    } else {\n      expr = module.if(\n        module.local_tee(tempIndex, expr, type.isManaged),\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(tempIndex, type.toRef()),\n            module.i32(toType.classReference!.id)\n          ], TypeRef.I32),\n          module.local_get(tempIndex, type.toRef()),\n          staticAbortCallExpr\n        ),\n        module.usize(0)\n      );\n    }\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.Instance), true\n  );\n  // override module name if a `module` statement is present\n  let overriddenModuleName = declaration.overriddenModuleName;\n  if (overriddenModuleName) mangleImportName_moduleName = overriddenModuleName;\n\n  if (!element.hasDecorator(DecoratorFlags.External)) return;\n\n  let program = element.program;\n  let decorator = assert(findDecorator(DecoratorKind.External, declaration.decorators));\n  let args = decorator.args;\n  if (args && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.String)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.String)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n\nlet mangleImportName_moduleName: string;\nlet mangleImportName_elementName: string;\n", "import {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  Global,\n  Program,\n  Function,\n  Class,\n  Interface,\n  Enum,\n  ElementKind,\n  Field,\n  Element\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent, isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new TSDBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n  private seenObjectTypes: Map<Class,string> = new Map();\n  private deferredTypings: string[] = new Array();\n\n  /** Constructs a new TypeScript definitions builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    let tsType = this.toTypeScriptType(type, Mode.EXPORT);\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"const \");\n    sb.push(name);\n    sb.push(\": {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"/** @type `\");\n    sb.push(type.toString());\n    sb.push(\"` */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"get value(): \");\n    sb.push(tsType);\n    if (!element.is(CommonFlags.Const)) {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"set value(value: \");\n      sb.push(tsType);\n      sb.push(\");\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    let members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"/** @type `i32` */\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(memberName);\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(\"/**\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\" * \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n    for (let i = 0; i < numParameters; ++i) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @param \");\n      sb.push(element.getParameterName(i));\n      sb.push(\" `\");\n      sb.push(parameterTypes[i].toString());\n      sb.push(\"`\\n\");\n    }\n    let returnType = signature.returnType;\n    if (returnType != Type.void) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @returns `\");\n      sb.push(returnType.toString());\n      sb.push(\"`\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"function \");\n    sb.push(name);\n    sb.push(\"(\");\n    let requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      sb.push(element.getParameterName(i));\n      if (i >= requiredParameters) sb.push(\"?\");\n      sb.push(\": \");\n      sb.push(this.toTypeScriptType(parameterTypes[i], Mode.IMPORT));\n    }\n    sb.push(\"): \");\n    sb.push(this.toTypeScriptType(returnType, Mode.EXPORT));\n    sb.push(\";\\n\");\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    // not implemented\n  }\n\n  visitField(name: string, element: Field): void {\n    // not implemented\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n  }\n\n  build(): string {\n    let sb = this.sb;\n    if (!this.esm) {\n      sb.push(\"declare namespace __AdaptedExports {\\n\");\n      ++this.indentLevel;\n    }\n    if (this.program.options.exportMemory) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported memory */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const memory: WebAssembly.Memory;\\n`);\n    }\n    if (this.program.options.exportTable) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported table */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const table: WebAssembly.Table;\\n`);\n    }\n    this.walk();\n    if (!this.esm) {\n      --this.indentLevel;\n      sb.push(\"}\\n\");\n    }\n    let deferredTypes = this.deferredTypings;\n    for (let i = 0, k = deferredTypes.length; i < k; ++i) {\n      sb.push(deferredTypes[i]);\n    }\n    if (!this.esm) {\n      sb.push(\"/** Instantiates the compiled WebAssembly module with the given imports. */\\n\");\n      sb.push(\"export declare function instantiate(module: WebAssembly.Module, imports: {\\n\");\n      let moduleImports = this.program.moduleImports;\n      for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        sb.push(\"  \");\n        if (isIdentifier(moduleName)) {\n          sb.push(moduleName);\n        } else {\n          sb.push(\"\\\"\");\n          sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n          sb.push(\"\\\"\");\n        }\n        sb.push(\": unknown,\\n\");\n      }\n      sb.push(\"}): Promise<typeof __AdaptedExports>;\\n\");\n    }\n    return sb.join(\"\");\n  }\n\n  isPlainObject(clazz: Class): bool {\n    // A plain object does not inherit and does not have a constructor or private properties\n    if (clazz.base) return false;\n    let members = clazz.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n        if (member.is(CommonFlags.Constructor)) {\n          // a generated constructor is ok\n          if (member.declaration.range != this.program.nativeRange) return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  toTypeScriptType(type: Type, mode: Mode): string {\n    if (type.isInternalReference) {\n      const sb = new Array<string>();\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extends(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"ArrayBuffer\");\n      } else if (clazz.extends(this.program.stringInstance.prototype)) {\n        sb.push(\"string\");\n      } else if (clazz.extends(this.program.arrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"Array<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extends(this.program.staticArrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"ArrayLike<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extends(this.program.arrayBufferViewInstance.prototype)) {\n        const valueType = clazz.getArrayValueType();\n        if (valueType == Type.i8) {\n          sb.push(\"Int8Array\");\n        } else if (valueType == Type.u8) {\n          if (clazz.extends(this.program.uint8ClampedArrayPrototype)) {\n            sb.push(\"Uint8ClampedArray\");\n          } else {\n            sb.push(\"Uint8Array\");\n          }\n        } else if (valueType == Type.i16) {\n          sb.push(\"Int16Array\");\n        } else if (valueType == Type.u16) {\n          sb.push(\"Uint16Array\");\n        } else if (valueType == Type.i32) {\n          sb.push(\"Int32Array\");\n        } else if (valueType == Type.u32) {\n          sb.push(\"Uint32Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.f32) {\n          sb.push(\"Float32Array\");\n        } else if (valueType == Type.f64) {\n          sb.push(\"Float64Array\");\n        } else {\n          sb.push(\"unknown\");\n        }\n      } else {\n        let seenObjectTypes = this.seenObjectTypes;\n        let typeName: string;\n        if (seenObjectTypes.has(clazz)) {\n          typeName = assert(seenObjectTypes.get(clazz));\n          sb.push(typeName);\n          if (this.isPlainObject(clazz)) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n          }\n        } else {\n          let isPlain = this.isPlainObject(clazz);\n          typeName = `${isPlain ? \"__Record\" : \"__Internref\"}${clazz.id}`;\n          sb.push(typeName);\n          seenObjectTypes.set(clazz, typeName);\n          if (isPlain) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n            this.deferredTypings.push(this.makeRecordType(clazz, mode));\n          } else {\n            this.deferredTypings.push(this.makeInternrefType(clazz));\n          }\n        }\n      }\n      if (type.is(TypeFlags.Nullable)) {\n        sb.push(\" | null\");\n      }\n      return sb.join(\"\");\n    } else {\n      if (type == Type.bool) {\n        return \"boolean\";\n      }\n      if (type == Type.void) {\n        return \"void\";\n      }\n      if (type.isNumericValue) {\n        if (type.isLongIntegerValue) {\n          return \"bigint\";\n        }\n        return \"number\";\n      }\n    }\n    return \"unknown\";\n  }\n\n  makeRecordType(clazz: Class, mode: Mode): string {\n    let sb = new Array<string>();\n    let members = clazz.members;\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\ndeclare interface __Record\");\n    sb.push(clazz.id.toString());\n    sb.push(\"<TOmittable> {\\n\");\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.Field) continue;\n        let field = <Field>member;\n        sb.push(\"  /** @type `\");\n        sb.push(field.type.toString());\n        sb.push(\"` */\\n  \");\n        sb.push(field.name);\n        sb.push(\": \");\n        sb.push(this.toTypeScriptType(field.type, mode));\n        if (this.fieldAcceptsUndefined(field.type)) {\n          sb.push(\" | TOmittable\");\n        }\n        sb.push(\";\\n\");\n      }\n    }\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  fieldAcceptsUndefined(type: Type): bool {\n    if (type.isInternalReference) {\n      return type.is(TypeFlags.Nullable);\n    }\n    return true;\n  }\n\n  makeInternrefType(clazz: Class): string {\n    let sb = new Array<string>();\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\n\");\n    sb.push(\"declare class __Internref\");\n    sb.push(clazz.id.toString());\n    sb.push(\" extends Number {\\n\");\n    let base: Class | null = clazz;\n    do {\n      sb.push(\"  private __nominal\");\n      sb.push(base.id.toString());\n      sb.push(\": symbol;\\n\");\n      base = base.base;\n    } while (base);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  IMPORT,\n  EXPORT\n}\n", "/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport {\n  Target,\n  Runtime,\n  Feature\n} from \"./common\";\n\nimport {\n  Compiler,\n  Options\n} from \"./compiler\";\n\nimport {\n  TSDBuilder,\n  JSBuilder\n} from \"./bindings\";\n\nimport {\n  Range,\n  DiagnosticMessage,\n  DiagnosticCategory,\n  formatDiagnosticMessage\n} from \"./diagnostics\";\n\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\nimport { Source } from \"./ast\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\nexport function setRuntime(options: Options, runtime: Runtime): void {\n  options.runtime = runtime;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Adds a 'globalAliases' value. */\nexport function addGlobalAlias(options: Options, alias: string, name: string): void {\n  let globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Removes a 'globalAliases' value. */\nexport function removeGlobalAlias(options: Options, alias: string): void {\n  let globalAliases = options.globalAliases;\n  if (globalAliases) globalAliases.delete(alias);\n}\n\n/** Sets the `exportStart` option. */\nexport function setExportStart(options: Options, exportStart: string | null): void {\n  options.exportStart = exportStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sets the `exportRuntime` option. */\nexport function setExportRuntime(options: Options, exportRuntime: bool): void {\n  options.exportRuntime = exportRuntime;\n}\n\n/** Default stack size. */\nexport const DEFAULT_STACK_SIZE = 32768;\n\n/** Sets the `stackSize` option. */\nexport function setStackSize(options: Options, stackSize: i32): void {\n  options.stackSize = stackSize;\n}\n\n/** Sets the bundle semantic version. */\nexport function setBundleVersion(\n  options: Options,\n  bundleMajorVersion: i32,\n  bundleMinorVersion: i32,\n  bundlePatchVersion: i32,\n): void {\n  options.bundleMajorVersion = bundleMajorVersion;\n  options.bundleMinorVersion = bundleMinorVersion;\n  options.bundlePatchVersion = bundlePatchVersion;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SignExtension;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MutableGlobals;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NontrappingF2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BulkMemory;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.Simd;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.Threads;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.ExceptionHandling;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TailCalls;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.ReferenceTypes;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MultiValue;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.Memory64;\n/** Relaxed SIMD. */\nexport const FEATURE_RELAXED_SIMD = Feature.RelaxedSimd;\n/** Extended const expressions. */\nexport const FEATURE_EXTENDED_CONST = Feature.ExtendedConst;\n/** String references. */\nexport const FEATURE_STRINGREF = Feature.Stringref;\n\n/** Enables a specific feature. */\nexport function enableFeature(options: Options, feature: Feature): void {\n  options.features |= feature;\n}\n\n/** Disables a specific feature. */\nexport function disableFeature(options: Options, feature: Feature): void {\n  options.features &= ~feature;\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Gives the compiler a hint of the emitted module's basename. */\nexport function setBasenameHint(options: Options, basename: string): void {\n  options.basenameHint = basename;\n}\n\n/** Gives the compiler a hint that bindings will be generated. */\nexport function setBindingsHint(options: Options, bindings: bool): void {\n  options.bindingsHint = bindings;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\nexport function setDebugInfo(options: Options, debug: bool): void {\n  options.debugInfo = debug;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Gets the code of a diagnostic message. */\nexport function getDiagnosticCode(diagnostic: DiagnosticMessage): i32 {\n  return diagnostic.code;\n}\n\n/** Gets the category of a diagnostic message. */\nexport function getDiagnosticCategory(diagnostic: DiagnosticMessage): DiagnosticCategory {\n  return diagnostic.category;\n}\n\n/** Gets the textual message of a diagnostic message. */\nexport function getDiagnosticMessage(diagnostic: DiagnosticMessage): string {\n  return diagnostic.message;\n}\n\n/** Gets the primary range, if any, of a diagnostic message. */\nexport function getDiagnosticRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.range;\n}\n\n/** Gets the related range, if any, of a diagnostic message. */\nexport function getDiagnosticRelatedRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.relatedRange;\n}\n\n/** Gets a range's start offset. */\nexport function getRangeStart(range: Range): i32 {\n  return range.start;\n}\n\n/** Gets a range's end offsset. */\nexport function getRangeEnd(range: Range): i32 {\n  return range.end;\n}\n\n/** Gets a range's relevant source. */\nexport function getRangeSource(range: Range): Source {\n  return range.source;\n}\n\n/** Gets a source's normalized path. */\nexport function getSourceNormalizedPath(source: Source): string {\n  return source.normalizedPath;\n}\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Info;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Warning;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Error;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program, esm: bool): string {\n  return TSDBuilder.build(program, esm);\n}\n\n/** Builds JavaScript glue code for the specified program. */\nexport function buildJS(program: Program, esm: bool): string {\n  return JSBuilder.build(program, esm);\n}\n\n/** Gets the Binaryen module reference of a module. */\nexport function getBinaryenModuleRef(module: Module): usize {\n  return module.ref;\n}\n\n/** Validates a module. */\nexport function validate(module: Module): bool {\n  return module.validate();\n}\n\n/** Optimizes a module. */\nexport function optimize(\n  module: Module,\n  optimizeLevel: i32,\n  shrinkLevel: i32,\n  debugInfo: bool = false,\n  zeroFilledMemory: bool = false\n): void {\n  module.optimize(optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n}\n", "/**\n * @fileoverview Abstract Syntax Tree extras.\n *\n * Provides serialization of the AssemblyScript AST back to it source form.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  ArrowKind,\n\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  TypeName,\n  TypeParameterNode,\n\n  Expression,\n  IdentifierExpression,\n  LiteralExpression,\n  LiteralKind,\n  FloatLiteralExpression,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  RegexpLiteralExpression,\n  ArrayLiteralExpression,\n  AssertionExpression,\n  AssertionKind,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FunctionExpression,\n  NewExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  UnaryPostfixExpression,\n  UnaryExpression,\n  UnaryPrefixExpression,\n  ClassExpression,\n  ObjectLiteralExpression,\n\n  BlockStatement,\n  BreakStatement,\n  ContinueStatement,\n  DoStatement,\n  EmptyStatement,\n  ExportImportStatement,\n  ExportStatement,\n  ExportDefaultStatement,\n  ExpressionStatement,\n  ForStatement,\n  ForOfStatement,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  WhileStatement,\n  ModuleDeclaration,\n\n  DeclarationStatement,\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  DecoratorNode,\n  ParameterNode,\n  ParameterKind,\n  ExportMember,\n  SwitchCase,\n  IndexSignatureNode,\n\n  isTypeOmitted\n} from \"../ast\";\n\nimport {\n  operatorTokenToString\n} from \"../tokenizer\";\n\nimport {\n  CharCode,\n  indent,\n  escapeString\n} from \"../util\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\n/** An AST builder. */\nexport class ASTBuilder {\n\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\n  static build(node: Node): string {\n    let builder = new ASTBuilder();\n    builder.visitNode(node);\n    return builder.finish();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  visitNode(node: Node): void {\n    switch (node.kind) {\n      case NodeKind.Source: {\n        this.visitSource(<Source>node);\n        break;\n      }\n\n      // types\n\n      case NodeKind.NamedType: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FunctionType: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      case NodeKind.TypeParameter: {\n        this.visitTypeParameter(<TypeParameterNode>node);\n        break;\n      }\n\n      // expressions\n\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.Super:\n      case NodeKind.This:\n      case NodeKind.True:\n      case NodeKind.Constructor:\n      case NodeKind.Identifier: {\n        this.visitIdentifierExpression(<IdentifierExpression>node);\n        break;\n      }\n      case NodeKind.Assertion: {\n        this.visitAssertionExpression(<AssertionExpression>node);\n        break;\n      }\n      case NodeKind.Binary: {\n        this.visitBinaryExpression(<BinaryExpression>node);\n        break;\n      }\n      case NodeKind.Call: {\n        this.visitCallExpression(<CallExpression>node);\n        break;\n      }\n      case NodeKind.Class: {\n        this.visitClassExpression(<ClassExpression>node);\n        break;\n      }\n      case NodeKind.Comma: {\n        this.visitCommaExpression(<CommaExpression>node);\n        break;\n      }\n      case NodeKind.ElementAccess: {\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\n        break;\n      }\n      case NodeKind.Function: {\n        this.visitFunctionExpression(<FunctionExpression>node);\n        break;\n      }\n      case NodeKind.InstanceOf: {\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\n        break;\n      }\n      case NodeKind.Literal: {\n        this.visitLiteralExpression(<LiteralExpression>node);\n        break;\n      }\n      case NodeKind.New: {\n        this.visitNewExpression(<NewExpression>node);\n        break;\n      }\n      case NodeKind.Parenthesized: {\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\n        break;\n      }\n      case NodeKind.PropertyAccess: {\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\n        break;\n      }\n      case NodeKind.Ternary: {\n        this.visitTernaryExpression(<TernaryExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPostfix: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n\n      // statements\n\n      case NodeKind.Block: {\n        this.visitBlockStatement(<BlockStatement>node);\n        break;\n      }\n      case NodeKind.Break: {\n        this.visitBreakStatement(<BreakStatement>node);\n        break;\n      }\n      case NodeKind.Continue: {\n        this.visitContinueStatement(<ContinueStatement>node);\n        break;\n      }\n      case NodeKind.Do: {\n        this.visitDoStatement(<DoStatement>node);\n        break;\n      }\n      case NodeKind.Empty: {\n        this.visitEmptyStatement(<EmptyStatement>node);\n        break;\n      }\n      case NodeKind.Export: {\n        this.visitExportStatement(<ExportStatement>node);\n        break;\n      }\n      case NodeKind.ExportDefault: {\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\n        break;\n      }\n      case NodeKind.ExportImport: {\n        this.visitExportImportStatement(<ExportImportStatement>node);\n        break;\n      }\n      case NodeKind.Expression: {\n        this.visitExpressionStatement(<ExpressionStatement>node);\n        break;\n      }\n      case NodeKind.For: {\n        this.visitForStatement(<ForStatement>node);\n        break;\n      }\n      case NodeKind.ForOf: {\n        this.visitForOfStatement(<ForOfStatement>node);\n        break;\n      }\n      case NodeKind.If: {\n        this.visitIfStatement(<IfStatement>node);\n        break;\n      }\n      case NodeKind.Import: {\n        this.visitImportStatement(<ImportStatement>node);\n        break;\n      }\n      case NodeKind.Return: {\n        this.visitReturnStatement(<ReturnStatement>node);\n        break;\n      }\n      case NodeKind.Switch: {\n        this.visitSwitchStatement(<SwitchStatement>node);\n        break;\n      }\n      case NodeKind.Throw: {\n        this.visitThrowStatement(<ThrowStatement>node);\n        break;\n      }\n      case NodeKind.Try: {\n        this.visitTryStatement(<TryStatement>node);\n        break;\n      }\n      case NodeKind.Variable: {\n        this.visitVariableStatement(<VariableStatement>node);\n        break;\n      }\n      case NodeKind.While: {\n        this.visitWhileStatement(<WhileStatement>node);\n        break;\n      }\n      case NodeKind.Module: {\n        this.visitModuleDeclaration(<ModuleDeclaration>node);\n        break;\n      }\n\n      // declaration statements\n\n      case NodeKind.ClassDeclaration: {\n        this.visitClassDeclaration(<ClassDeclaration>node);\n        break;\n      }\n      case NodeKind.EnumDeclaration: {\n        this.visitEnumDeclaration(<EnumDeclaration>node);\n        break;\n      }\n      case NodeKind.EnumValueDeclaration: {\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\n        break;\n      }\n      case NodeKind.FieldDeclaration: {\n        this.visitFieldDeclaration(<FieldDeclaration>node);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\n        break;\n      }\n      case NodeKind.ImportDeclaration: {\n        this.visitImportDeclaration(<ImportDeclaration>node);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\n        break;\n      }\n      case NodeKind.MethodDeclaration: {\n        this.visitMethodDeclaration(<MethodDeclaration>node);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\n        break;\n      }\n      case NodeKind.TypeDeclaration: {\n        this.visitTypeDeclaration(<TypeDeclaration>node);\n        break;\n      }\n      case NodeKind.VariableDeclaration: {\n        this.visitVariableDeclaration(<VariableDeclaration>node);\n        break;\n      }\n\n      // other\n\n      case NodeKind.Decorator: {\n        this.serializeDecorator(<DecoratorNode>node);\n        break;\n      }\n      case NodeKind.ExportMember: {\n        this.visitExportMember(<ExportMember>node);\n        break;\n      }\n      case NodeKind.Parameter: {\n        this.serializeParameter(<ParameterNode>node);\n        break;\n      }\n      case NodeKind.SwitchCase: {\n        this.visitSwitchCase(<SwitchCase>node);\n        break;\n      }\n      case NodeKind.IndexSignature: {\n        this.visitIndexSignature(<IndexSignatureNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitSource(source: Source): void {\n    let statements = source.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      this.visitNodeAndTerminate(statements[i]);\n    }\n  }\n\n  // types\n\n  visitTypeNode(node: TypeNode): void {\n    switch (node.kind) {\n      case NodeKind.NamedType: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FunctionType: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitTypeName(node: TypeName): void {\n    this.visitIdentifierExpression(node.identifier);\n    let sb = this.sb;\n    let current = node.next;\n    while (current) {\n      sb.push(\".\");\n      this.visitIdentifierExpression(current.identifier);\n      current = current.next;\n    }\n  }\n\n  visitNamedTypeNode(node: NamedTypeNode): void {\n    this.visitTypeName(node.name);\n    let typeArguments = node.typeArguments;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      let sb = this.sb;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">\");\n      }\n      if (node.isNullable) sb.push(\" | null\");\n    }\n  }\n\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\n    let isNullable = node.isNullable;\n    let sb = this.sb;\n    sb.push(isNullable ? \"((\" : \"(\");\n    let explicitThisType = node.explicitThisType;\n    if (explicitThisType) {\n      sb.push(\"this: \");\n      this.visitTypeNode(explicitThisType);\n    }\n    let parameters = node.parameters;\n    let numParameters = parameters.length;\n    if (numParameters) {\n      if (explicitThisType) sb.push(\", \");\n      this.serializeParameter(parameters[0]);\n      for (let i = 1; i < numParameters; ++i) {\n        sb.push(\", \");\n        this.serializeParameter(parameters[i]);\n      }\n    }\n    let returnType = node.returnType;\n    if (returnType) {\n      sb.push(\") => \");\n      this.visitTypeNode(returnType);\n    } else {\n      sb.push(\") => void\");\n    }\n    if (isNullable) sb.push(\") | null\");\n  }\n\n  visitTypeParameter(node: TypeParameterNode): void {\n    this.visitIdentifierExpression(node.name);\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      this.sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    let defaultType = node.defaultType;\n    if (defaultType) {\n      this.sb.push(\"=\");\n      this.visitTypeNode(defaultType);\n    }\n  }\n\n  // expressions\n\n  visitIdentifierExpression(node: IdentifierExpression): void {\n    if (node.isQuoted) this.visitStringLiteral(node.text);\n    else this.sb.push(node.text);\n  }\n\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\n    let sb = this.sb;\n    sb.push(\"[\");\n    let elements = node.elementExpressions;\n    let numElements = elements.length;\n    if (numElements) {\n      let element = elements[0];\n      if (element) this.visitNode(element);\n      for (let i = 1; i < numElements; ++i) {\n        element = elements[i];\n        sb.push(\", \");\n        if (element) this.visitNode(element);\n      }\n    }\n    sb.push(\"]\");\n  }\n\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\n    let sb = this.sb;\n    let names = node.names;\n    let values = node.values;\n    let numElements = names.length;\n    assert(numElements == values.length);\n    if (numElements) {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      this.visitNode(names[0]);\n      sb.push(\": \");\n      this.visitNode(values[0]);\n      for (let i = 1; i < numElements; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        let name = names[i];\n        let value = values[i];\n        if (name == value) {\n          this.visitNode(name);\n        } else {\n          this.visitNode(name);\n          sb.push(\": \");\n          this.visitNode(value);\n        }\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitAssertionExpression(node: AssertionExpression): void {\n    let sb = this.sb;\n    switch (node.assertionKind) {\n      case AssertionKind.Prefix: {\n        sb.push(\"<\");\n        this.visitTypeNode(assert(node.toType));\n        sb.push(\">\");\n        this.visitNode(node.expression);\n        break;\n      }\n      case AssertionKind.As: {\n        this.visitNode(node.expression);\n        sb.push(\" as \");\n        this.visitTypeNode(assert(node.toType));\n        break;\n      }\n      case AssertionKind.NonNull: {\n        this.visitNode(node.expression);\n        sb.push(\"!\");\n        break;\n      }\n      case AssertionKind.Const: {\n        this.visitNode(node.expression);\n        sb.push(\" as const\");\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.left);\n    sb.push(\" \");\n    sb.push(operatorTokenToString(node.operator));\n    sb.push(\" \");\n    this.visitNode(node.right);\n  }\n\n  visitCallExpression(node: CallExpression): void {\n    this.visitNode(node.expression);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\n    let sb = this.sb;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">(\");\n      }\n    } else {\n      sb.push(\"(\");\n    }\n    let numArgs = args.length;\n    if (numArgs) {\n      this.visitNode(args[0]);\n      for (let i = 1; i < numArgs; ++i) {\n        sb.push(\", \");\n        this.visitNode(args[i]);\n      }\n    }\n    sb.push(\")\");\n  }\n\n  visitClassExpression(node: ClassExpression): void {\n    let declaration = node.declaration;\n    this.visitClassDeclaration(declaration);\n  }\n\n  visitCommaExpression(node: CommaExpression): void {\n    let expressions = node.expressions;\n    let numExpressions = assert(expressions.length);\n    this.visitNode(expressions[0]);\n    let sb = this.sb;\n    for (let i = 1; i < numExpressions; ++i) {\n      sb.push(\",\");\n      this.visitNode(expressions[i]);\n    }\n  }\n\n  visitElementAccessExpression(node: ElementAccessExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.expression);\n    sb.push(\"[\");\n    this.visitNode(node.elementExpression);\n    sb.push(\"]\");\n  }\n\n  visitFunctionExpression(node: FunctionExpression): void {\n    let declaration = node.declaration;\n    if (!declaration.arrowKind) {\n      if (declaration.name.text.length) {\n        this.sb.push(\"function \");\n      } else {\n        this.sb.push(\"function\");\n      }\n    } else {\n      assert(declaration.name.text.length == 0);\n    }\n    this.visitFunctionCommon(declaration);\n  }\n\n  visitLiteralExpression(node: LiteralExpression): void {\n    switch (node.literalKind) {\n      case LiteralKind.Float: {\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Integer: {\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.String: {\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Template: {\n        this.visitTemplateLiteralExpression(<TemplateLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.RegExp: {\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Array: {\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Object: {\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\n        break;\n      }\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  }\n\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\n    this.sb.push(node.value.toString());\n  }\n\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\" instanceof \");\n    this.visitTypeNode(node.isType);\n  }\n\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\n    let range = node.range;\n    let hasExplicitSign = range.source.text.startsWith(\"-\", range.start);\n    this.sb.push(i64_to_string(node.value, !hasExplicitSign));\n  }\n\n  visitStringLiteral(str: string): void {\n    let sb = this.sb;\n    sb.push(\"\\\"\");\n    sb.push(escapeString(str, CharCode.DoubleQuote));\n    sb.push(\"\\\"\");\n  }\n\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\n    this.visitStringLiteral(node.value);\n  }\n\n  visitTemplateLiteralExpression(node: TemplateLiteralExpression): void {\n    let sb = this.sb;\n    let tag = node.tag;\n    let parts = node.parts;\n    let expressions = node.expressions;\n    if (tag) this.visitNode(tag);\n    sb.push(\"`\");\n    sb.push(escapeString(parts[0], CharCode.Backtick));\n    assert(parts.length == expressions.length + 1);\n    for (let i = 0, k = expressions.length; i < k; ++i) {\n      sb.push(\"${\");\n      this.visitNode(expressions[i]);\n      sb.push(\"}\");\n      sb.push(escapeString(parts[i + 1], CharCode.Backtick));\n    }\n    sb.push(\"`\");\n  }\n\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\n    let sb = this.sb;\n    sb.push(\"/\");\n    sb.push(node.pattern);\n    sb.push(\"/\");\n    sb.push(node.patternFlags);\n  }\n\n  visitNewExpression(node: NewExpression): void {\n    this.sb.push(\"new \");\n    this.visitTypeName(node.typeName);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\n    let sb = this.sb;\n    sb.push(\"(\");\n    this.visitNode(node.expression);\n    sb.push(\")\");\n  }\n\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\".\");\n    this.visitIdentifierExpression(node.property);\n  }\n\n  visitTernaryExpression(node: TernaryExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.condition);\n    sb.push(\" ? \");\n    this.visitNode(node.ifThen);\n    sb.push(\" : \");\n    this.visitNode(node.ifElse);\n  }\n\n  visitUnaryExpression(node: UnaryExpression): void {\n    switch (node.kind) {\n      case NodeKind.UnaryPostfix: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\n    this.visitNode(node.operand);\n    this.sb.push(operatorTokenToString(node.operator));\n  }\n\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\n    this.sb.push(operatorTokenToString(node.operator));\n    this.visitNode(node.operand);\n  }\n\n  // statements\n\n  visitNodeAndTerminate(node: Node): void {\n    this.visitNode(node);\n    let sb = this.sb;\n    if (\n      !sb.length ||                     // leading EmptyStatement\n      node.kind == NodeKind.Variable || // potentially assigns a FunctionExpression\n      node.kind == NodeKind.Expression  // potentially assigns a FunctionExpression\n    ) {\n      sb.push(\";\\n\");\n    } else {\n      let last = sb[sb.length - 1];\n      let lastCharPos = last.length - 1;\n      if (lastCharPos >= 0 && (\n        last.charCodeAt(lastCharPos) == CharCode.CloseBrace ||\n        last.charCodeAt(lastCharPos) == CharCode.Semicolon)\n      ) {\n        sb.push(\"\\n\");\n      } else {\n        sb.push(\";\\n\");\n      }\n    }\n  }\n\n  visitBlockStatement(node: BlockStatement): void {\n    let sb = this.sb;\n    let statements = node.statements;\n    let numStatements = statements.length;\n    if (numStatements) {\n      sb.push(\"{\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitBreakStatement(node: BreakStatement): void {\n    let label = node.label;\n    if (label) {\n      this.sb.push(\"break \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"break\");\n    }\n  }\n\n  visitContinueStatement(node: ContinueStatement): void {\n    let label = node.label;\n    if (label) {\n      this.sb.push(\"continue \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"continue\");\n    }\n  }\n\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.Abstract)) sb.push(\"abstract \");\n    if (node.name.text.length) {\n      sb.push(\"class \");\n      this.visitIdentifierExpression(node.name);\n    } else {\n      sb.push(\"class\");\n    }\n    let typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    let implementsTypes = node.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        sb.push(\" implements \");\n        this.visitTypeNode(implementsTypes[0]);\n        for (let i = 1; i < numImplementsTypes; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(implementsTypes[i]);\n        }\n      }\n    }\n    let indexSignature = node.indexSignature;\n    let members = node.members;\n    let numMembers = members.length;\n    if (indexSignature || numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      if (indexSignature) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(indexSignature);\n      }\n      for (let i = 0, k = members.length; i < k; ++i) {\n        let member = members[i];\n        if (member.kind != NodeKind.FieldDeclaration || (<FieldDeclaration>member).parameterIndex < 0) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(member);\n        }\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitDoStatement(node: DoStatement): void {\n    let sb = this.sb;\n    sb.push(\"do \");\n    this.visitNode(node.body);\n    if (node.body.kind == NodeKind.Block) {\n      sb.push(\" while (\");\n    } else {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"while (\");\n    }\n    this.visitNode(node.condition);\n    sb.push(\")\");\n  }\n\n  visitEmptyStatement(node: EmptyStatement): void {\n    /* nop */\n  }\n\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.Const)) sb.push(\"const \");\n    sb.push(\"enum \");\n    this.visitIdentifierExpression(node.name);\n    let values = node.values;\n    let numValues = values.length;\n    if (numValues) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitEnumValueDeclaration(node.values[0]);\n      for (let i = 1; i < numValues; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitEnumValueDeclaration(node.values[i]);\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    let initializer = node.initializer;\n    if (initializer) {\n      this.sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitExportImportStatement(node: ExportImportStatement): void {\n    let sb = this.sb;\n    sb.push(\"export import \");\n    this.visitIdentifierExpression(node.externalName);\n    sb.push(\" = \");\n    this.visitIdentifierExpression(node.name);\n  }\n\n  visitExportMember(node: ExportMember): void {\n    this.visitIdentifierExpression(node.localName);\n    if (node.exportedName.text != node.localName.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(node.exportedName);\n    }\n  }\n\n  visitExportStatement(node: ExportStatement): void {\n    let sb = this.sb;\n    if (node.isDeclare) {\n      sb.push(\"declare \");\n    }\n    let members = node.members;\n    if (members == null) {\n      sb.push(\"export *\");\n    } else if (members.length > 0) {\n      let numMembers = members.length;\n      sb.push(\"export {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitExportMember(members[0]);\n      for (let i = 1; i < numMembers; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitExportMember(members[i]);\n      }\n      --this.indentLevel;\n      sb.push(\"\\n}\");\n    } else {\n      sb.push(\"export {}\");\n    }\n    let path = node.path;\n    if (path) {\n      sb.push(\" from \");\n      this.visitStringLiteralExpression(path);\n    }\n    sb.push(\";\");\n  }\n\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\n    let declaration = node.declaration;\n    switch (declaration.kind) {\n      case NodeKind.EnumDeclaration: {\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.ClassDeclaration: {\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitExpressionStatement(node: ExpressionStatement): void {\n    this.visitNode(node.expression);\n  }\n\n  visitFieldDeclaration(node: FieldDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    this.visitIdentifierExpression(node.name);\n    let sb = this.sb;\n    if (node.flags & CommonFlags.DefinitelyAssigned) {\n      sb.push(\"!\");\n    }\n    let type = node.type;\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    let initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitForStatement(node: ForStatement): void {\n    let sb = this.sb;\n    sb.push(\"for (\");\n    let initializer = node.initializer;\n    if (initializer) {\n      this.visitNode(initializer);\n    }\n    let condition = node.condition;\n    if (condition) {\n      sb.push(\"; \");\n      this.visitNode(condition);\n    } else {\n      sb.push(\";\");\n    }\n    let incrementor = node.incrementor;\n    if (incrementor) {\n      sb.push(\"; \");\n      this.visitNode(incrementor);\n    } else {\n      sb.push(\";\");\n    }\n    sb.push(\") \");\n    this.visitNode(node.body);\n  }\n\n  visitForOfStatement(node: ForOfStatement): void {\n    let sb = this.sb;\n    sb.push(\"for (\");\n    this.visitNode(node.variable);\n    sb.push(\" of \");\n    this.visitNode(node.iterable);\n    sb.push(\") \");\n    this.visitNode(node.body);\n  }\n\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\n    let sb = this.sb;\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n      this.serializeAccessModifiers(node);\n    }\n    if (node.name.text.length) {\n      sb.push(\"function \");\n    } else {\n      sb.push(\"function\");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitFunctionCommon(node: FunctionDeclaration): void {\n    let sb = this.sb;\n    this.visitIdentifierExpression(node.name);\n    let signature = node.signature;\n    let typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        this.visitTypeParameter(typeParameters[0]);\n        for (let i = 1; i < numTypeParameters; ++i) {\n          sb.push(\", \");\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    if (node.arrowKind == ArrowKind.Single) {\n      let parameters = signature.parameters;\n      assert(parameters.length == 1);\n      assert(!signature.explicitThisType);\n      this.serializeParameter(parameters[0]);\n    } else {\n      sb.push(\"(\");\n      let parameters = signature.parameters;\n      let numParameters = parameters.length;\n      let explicitThisType = signature.explicitThisType;\n      if (explicitThisType) {\n        sb.push(\"this: \");\n        this.visitTypeNode(explicitThisType);\n      }\n      if (numParameters) {\n        if (explicitThisType) sb.push(\", \");\n        this.serializeParameter(parameters[0]);\n        for (let i = 1; i < numParameters; ++i) {\n          sb.push(\", \");\n          this.serializeParameter(parameters[i]);\n        }\n      }\n    }\n    let body = node.body;\n    let returnType = signature.returnType;\n    if (node.arrowKind) {\n      if (body) {\n        if (node.arrowKind == ArrowKind.Single) {\n          assert(isTypeOmitted(returnType));\n        } else {\n          if (isTypeOmitted(returnType)) {\n            sb.push(\")\");\n          } else {\n            sb.push(\"): \");\n            this.visitTypeNode(returnType);\n          }\n        }\n        sb.push(\" => \");\n        this.visitNode(body);\n      } else {\n        assert(!isTypeOmitted(returnType));\n        sb.push(\" => \");\n        this.visitTypeNode(returnType);\n      }\n    } else {\n      if (\n        !isTypeOmitted(returnType) &&\n        !node.isAny(CommonFlags.Constructor | CommonFlags.Set)\n      ) {\n        sb.push(\"): \");\n        this.visitTypeNode(returnType);\n      } else {\n        sb.push(\")\");\n      }\n      if (body) {\n        sb.push(\" \");\n        this.visitNode(body);\n      }\n    }\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    let sb = this.sb;\n    sb.push(\"if (\");\n    this.visitNode(node.condition);\n    sb.push(\") \");\n    let ifTrue = node.ifTrue;\n    this.visitNode(ifTrue);\n    if (ifTrue.kind != NodeKind.Block) {\n      sb.push(\";\\n\");\n    }\n    let ifFalse = node.ifFalse;\n    if (ifFalse) {\n      if (ifTrue.kind == NodeKind.Block) {\n        sb.push(\" else \");\n      } else {\n        sb.push(\"else \");\n      }\n      this.visitNode(ifFalse);\n    }\n  }\n\n  visitImportDeclaration(node: ImportDeclaration): void {\n    let externalName = node.foreignName;\n    let name = node.name;\n    this.visitIdentifierExpression(externalName);\n    if (externalName.text != name.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(name);\n    }\n  }\n\n  visitImportStatement(node: ImportStatement): void {\n    let sb = this.sb;\n    sb.push(\"import \");\n    let declarations = node.declarations;\n    let namespaceName = node.namespaceName;\n    if (declarations) {\n      let numDeclarations = declarations.length;\n      if (numDeclarations) {\n        sb.push(\"{\\n\");\n        let indentLevel = ++this.indentLevel;\n        indent(sb, indentLevel);\n        this.visitImportDeclaration(declarations[0]);\n        for (let i = 1; i < numDeclarations; ++i) {\n          sb.push(\",\\n\");\n          indent(sb, indentLevel);\n          this.visitImportDeclaration(declarations[i]);\n        }\n        --this.indentLevel;\n        sb.push(\"\\n} from \");\n      } else {\n        sb.push(\"{} from \");\n      }\n    } else if (namespaceName) {\n      sb.push(\"* as \");\n      this.visitIdentifierExpression(namespaceName);\n      sb.push(\" from \");\n    }\n    this.visitStringLiteralExpression(node.path);\n  }\n\n  visitIndexSignature(node: IndexSignatureNode): void {\n    let sb = this.sb;\n    sb.push(\"[key: \");\n    this.visitTypeNode(node.keyType);\n    sb.push(\"]: \");\n    this.visitTypeNode(node.valueType);\n  }\n\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"interface \");\n    this.visitIdentifierExpression(node.name);\n    let typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    // must not have implementsTypes\n    sb.push(\" {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let members = node.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(members[i]);\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitMethodDeclaration(node: MethodDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    if (node.is(CommonFlags.Get)) {\n      this.sb.push(\"get \");\n    } else if (node.is(CommonFlags.Set)) {\n      this.sb.push(\"set \");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"namespace \");\n    this.visitIdentifierExpression(node.name);\n    let members = node.members;\n    let numMembers = members.length;\n    if (numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0, k = members.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(members[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitReturnStatement(node: ReturnStatement): void {\n    let value = node.value;\n    if (value) {\n      this.sb.push(\"return \");\n      this.visitNode(value);\n    } else {\n      this.sb.push(\"return\");\n    }\n  }\n\n  visitSwitchCase(node: SwitchCase): void {\n    let sb = this.sb;\n    let label = node.label;\n    if (label) {\n      sb.push(\"case \");\n      this.visitNode(label);\n      sb.push(\":\\n\");\n    } else {\n      sb.push(\"default:\\n\");\n    }\n    let statements = node.statements;\n    let numStatements = statements.length;\n    if (numStatements) {\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[0]);\n      for (let i = 1; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      --this.indentLevel;\n    }\n  }\n\n  visitSwitchStatement(node: SwitchStatement): void {\n    let sb = this.sb;\n    sb.push(\"switch (\");\n    this.visitNode(node.condition);\n    sb.push(\") {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let cases = node.cases;\n    for (let i = 0, k = cases.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitSwitchCase(cases[i]);\n      sb.push(\"\\n\");\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitThrowStatement(node: ThrowStatement): void {\n    this.sb.push(\"throw \");\n    this.visitNode(node.value);\n  }\n\n  visitTryStatement(node: TryStatement): void {\n    let sb = this.sb;\n    sb.push(\"try {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let bodyStatements = node.bodyStatements;\n    for (let i = 0, k = bodyStatements.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(bodyStatements[i]);\n    }\n    let catchVariable = node.catchVariable;\n    if (catchVariable) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} catch (\");\n      this.visitIdentifierExpression(catchVariable);\n      sb.push(\") {\\n\");\n      let catchStatements = node.catchStatements;\n      if (catchStatements) {\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(catchStatements[i]);\n        }\n      }\n    }\n    let finallyStatements = node.finallyStatements;\n    if (finallyStatements) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} finally {\\n\");\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(finallyStatements[i]);\n      }\n    }\n    indent(sb, indentLevel - 1);\n    sb.push(\"}\");\n  }\n\n  visitTypeDeclaration(node: TypeDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    this.serializeExternalModifiers(node);\n    sb.push(\"type \");\n    this.visitIdentifierExpression(node.name);\n    let typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        for (let i = 0; i < numTypeParameters; ++i) {\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    sb.push(\" = \");\n    this.visitTypeNode(node.type);\n  }\n\n  visitModuleDeclaration(node: ModuleDeclaration): void {\n    let sb = this.sb;\n    if (node.flags & CommonFlags.Declare) {\n      sb.push(\"declare \");\n    }\n    sb.push(\"module \\\"\");\n    sb.push(escapeString(node.moduleName, CharCode.DoubleQuote));\n    sb.push(\"\\\"\");\n  }\n\n  visitVariableDeclaration(node: VariableDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    let type = node.type;\n    let sb = this.sb;\n    if (node.flags & CommonFlags.DefinitelyAssigned) {\n      sb.push(\"!\");\n    }\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    let initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitVariableStatement(node: VariableStatement): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    let declarations = node.declarations;\n    let numDeclarations = assert(declarations.length);\n    let firstDeclaration = declarations[0];\n    this.serializeExternalModifiers(firstDeclaration);\n    sb.push(firstDeclaration.is(CommonFlags.Const) ? \"const \" : firstDeclaration.is(CommonFlags.Let) ? \"let \" : \"var \");\n    this.visitVariableDeclaration(node.declarations[0]);\n    for (let i = 1; i < numDeclarations; ++i) {\n      sb.push(\", \");\n      this.visitVariableDeclaration(node.declarations[i]);\n    }\n  }\n\n  visitWhileStatement(node: WhileStatement): void {\n    let sb = this.sb;\n    sb.push(\"while (\");\n    this.visitNode(node.condition);\n    let body = node.body;\n    if (body.isEmpty) {\n      sb.push(\")\");\n    } else {\n      sb.push(\") \");\n      this.visitNode(body);\n    }\n  }\n\n  // other\n\n  serializeDecorator(node: DecoratorNode): void {\n    let sb = this.sb;\n    sb.push(\"@\");\n    this.visitNode(node.name);\n    let args = node.args;\n    if (args) {\n      sb.push(\"(\");\n      let numArgs = args.length;\n      if (numArgs) {\n        this.visitNode(args[0]);\n        for (let i = 1; i < numArgs; ++i) {\n          sb.push(\", \");\n          this.visitNode(args[i]);\n        }\n      }\n      sb.push(\")\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, this.indentLevel);\n  }\n\n  serializeParameter(node: ParameterNode): void {\n    let sb = this.sb;\n    let kind = node.parameterKind;\n    let implicitFieldDeclaration = node.implicitFieldDeclaration;\n    if (implicitFieldDeclaration) {\n      this.serializeAccessModifiers(implicitFieldDeclaration);\n    }\n    if (kind == ParameterKind.Rest) {\n      sb.push(\"...\");\n    }\n    this.visitIdentifierExpression(node.name);\n    let type = node.type;\n    let initializer = node.initializer;\n    if (type) {\n      if (kind == ParameterKind.Optional && !initializer) sb.push(\"?\");\n      if (!isTypeOmitted(type)) {\n        sb.push(\": \");\n        this.visitTypeNode(type);\n      }\n    }\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  serializeExternalModifiers(node: DeclarationStatement): void {\n    let sb = this.sb;\n    if (node.is(CommonFlags.Export)) {\n      sb.push(\"export \");\n    } else if (node.is(CommonFlags.Import)) {\n      sb.push(\"import \");\n    } else if (node.is(CommonFlags.Declare)) {\n      sb.push(\"declare \");\n    }\n  }\n\n  serializeAccessModifiers(node: DeclarationStatement): void {\n    let sb = this.sb;\n    if (node.is(CommonFlags.Declare)) {\n      sb.push(\"declare \");\n    }\n    if (node.is(CommonFlags.Public)) {\n      sb.push(\"public \");\n    } else if (node.is(CommonFlags.Private)) {\n      sb.push(\"private \");\n    } else if (node.is(CommonFlags.Protected)) {\n      sb.push(\"protected \");\n    }\n    if (node.is(CommonFlags.Static)) {\n      sb.push(\"static \");\n    } else if (node.is(CommonFlags.Abstract)) {\n      sb.push(\"abstract \");\n    }\n    if (node.is(CommonFlags.Readonly)) {\n      sb.push(\"readonly \");\n    }\n  }\n\n  finish(): string {\n    let ret = this.sb.join(\"\");\n    this.sb = [];\n    return ret;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from \"./index-js\";\nimport * as assemblyscript from \"./index-js\";\nexport default assemblyscript;\n"],
  "mappings": "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AY,CACV,SAAY,SACZ,YAAe,CACb,oDACA,GACA,4DACA,8DACA,2DACA,4DACF,EACA,KAAQ,IACR,MAAS,GACX,EACA,UAAa,CACX,SAAY,YACZ,YAAe,CACb,0DACA,wDACF,EACA,KAAQ,GACV,EACA,MAAS,CACP,SAAY,YACZ,YAAe,iDACf,KAAQ,IACR,QAAW,EACb,EACA,aAAgB,CACd,SAAY,WACZ,YAAe,wCACf,KAAQ,IACR,QAAW,EACb,EACA,eAAkB,CAChB,SAAY,WACZ,YAAe,0CACf,KAAQ,IACR,QAAW,EACb,EACA,cAAiB,CACf,SAAY,WACZ,YAAe,yCACf,KAAQ,IACR,QAAW,CACb,EACA,cAAiB,CACf,SAAY,WACZ,YAAe,yCACf,KAAQ,IACR,QAAW,CACb,EACA,aAAgB,CACd,SAAY,WACZ,YAAe,oDACf,KAAQ,IACR,QAAW,EACb,EACA,iBAAoB,CAClB,SAAY,WACZ,YAAe,2DACf,KAAQ,IACR,QAAW,EACb,EACA,YAAe,CACb,SAAY,WACZ,YAAe,+CACf,KAAQ,IACR,QAAW,EACb,EACA,YAAe,CACb,SAAY,WACZ,YAAe,yCACf,KAAQ,IACR,QAAW,EACb,EACA,YAAe,CACb,SAAY,WACZ,YAAe,CACb,8DACA,iEACA,yCACF,EACA,KAAQ,GACV,EACA,QAAW,CACT,SAAY,WACZ,YAAe,CACb,2DACA,GACA,gDACA,yDACA,mDACA,wDACA,EACF,EACA,KAAQ,IACR,QAAW,aACb,EACA,cAAiB,CACf,SAAY,WACZ,YAAe,CACb,qEACA,oEACF,EACA,KAAQ,IACR,QAAW,EACb,EACA,UAAa,CACX,SAAY,WACZ,YAAe,CACb,6DACA,4DACA,yDACF,EACA,QAAW,EACX,KAAQ,GACV,EACA,OAAU,CACR,SAAY,WACZ,YAAe,CACb,0DACA,GACA,wDACA,kDACA,uDACA,iDACA,+CACA,EACF,EACA,oBAAuB,CACrB,2CACA,6CACA,0CACA,4CACA,gDACA,kDACF,EACA,KAAQ,IACR,kBAAqB,SACvB,EACA,QAAW,CACT,SAAY,WACZ,YAAe,CACb,0DACA,GACA,2DACA,iDA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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,MAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACT,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,QAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,oBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACrB,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAChB,kBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACnB,gBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACjB,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,OAAU;AAAA;AAAA,EACV,QAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,MAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACT,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,KAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACR,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACP,MAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACT,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,QAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACP,KAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACR,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,QAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,UAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,GAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACN,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,uBAAwB;AAAA;AAAA,EACxB,mBAAoB;AAAA;AAAA,EACpB,gBAAiB;AAAA,EACjB,WAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACX,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACP,iBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAClB,iBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAClB,gBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACjB,kBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACnB,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,OAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACV,MAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACT,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,WAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACd,IAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACP,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAChB,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACd,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACb,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACf,WAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,OAAU;AAAA;AAAA;AAAA;AAAA,CACZ,EACaC,GAAkB,CAC7B,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EACZ,SAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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AAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,IAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,MAC1B,EACMH,GAA4B,IAC5BC,GAA4B,OAG5BK,GAA+B,CAEnC,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,IAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,O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",
  "names": ["fs_exports", "__export", "promises", "init_fs", "__esmMin", "module_exports", "__export", "createRequire", "path", "init_module", "__esmMin", "process_exports", "__export", "argv", "cwd", "exit", "hrtime", "platform", "umask", "code", "previousTimestamp", "clocktime", "performanceNow", "performance", "seconds", "nanoseconds", "init_process", "__esmMin", "path_exports", "__export", "basename", "delimiter", "dirname", "extname", "format", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "win32", "assertPath", "path", "normalizeStringPosix", "allowAboveRoot", "res", "lastSegmentLength", "lastSlash", "dots", "code", "i", "lastSlashIndex", "_format", "pathObject", "dir", "base", "resolvedPath", "resolvedAbsolute", "cwd", "trailingSeparator", "joined", "arg", "from", "to", "fromStart", "fromEnd", "fromLen", "toStart", "toEnd", "toLen", "length", "lastCommonSep", "fromCode", "toCode", "out", "hasRoot", "end", "matchedSlash", "ext", "start", "extIdx", "firstNonSlashEnd", "startDot", "startPart", "preDotState", "ret", "init_path", "__esmMin", "init_process", "url_exports", "__export", "pathToFileURL", "encodePathChars", "filepath", "resolved", "resolve", "sep", "url", "init_url", "__esmMin", "init_path", "cli_exports", "__export", "Stats", "checkDiagnostics", "compileString", "configToArguments", "createMemoryStream", "defaultOptimizeLevel", "defaultShrinkLevel", "definitionFiles", "libraryFiles", "libraryPrefix", "main", "options", "tscOptions", "version", "isNode", "fs", "module", "path", "process", "url", "proc", "isCI", "GRAY", "RED", "GREEN", "YELLOW", "BLUE", "MAGENTA", "CYAN", "WHITE", "RESET", "Colors", "stream", "text", "stdoutColors", "stderrColors", "Diff", "oldString", "newString", "options", "callback", "self", "done", "value", "newLen", "oldLen", "editLength", "maxEditLength", "bestPath", "oldPos", "execEditLength", "diagonalPath", "basePath", "addPath", "removePath", "_oldPos", "canAdd", "canRemove", "clonePath", "buildValues", "exec", "ret", "components", "added", "removed", "last", "newPos", "commonCount", "left", "right", "array", "i", "chars", "diff", "useLongestToken", "componentPos", "componentLen", "component", "tmp", "oldValue", "lastComponent", "path", "characterDiff", "extendedWordChars", "reWhitespace", "wordDiff", "Diff", "left", "right", "value", "tokens", "i", "lineDiff", "Diff", "value", "retLines", "linesAndNewlines", "i", "line", "sentenceDiff", "Diff", "value", "cssDiff", "Diff", "value", "_typeof", "obj", "objectPrototypeToString", "jsonDiff", "Diff", "lineDiff", "value", "_this$options", "undefinedReplacement", "_this$options$stringi", "stringifyReplacer", "k", "v", "canonicalize", "left", "right", "canonicalize", "obj", "stack", "replacementStack", "replacer", "key", "i", "canonicalizedObj", "objectPrototypeToString", "_typeof", "sortedKeys", "_key", "arrayDiff", "Diff", "value", "utf8Length", "string", "len", "i", "k", "c", "utf8Read", "buffer", "start", "end", "parts", "chunk", "t", "utf8Write", "offset", "c1", "c2", "utf8", "require", "module", "parse", "argv", "config", "propagateDefaults", "options", "unknown", "args", "trailing", "aliases", "key", "option", "alias", "i", "k", "arg", "match", "addDefaults", "help", "indent", "padding", "eol", "sbCategories", "sbOther", "text", "sb", "line", "hasCategories", "category", "stdoutColors", "sanitizeValue", "value", "type", "v", "merge", "currentOptions", "parentOptions", "parentBaseDir", "mergedOptions", "mutuallyExclusive", "isPath", "useNodeResolution", "cliOnly", "currentValue", "parentValue", "exclude", "resolvePath", "normalizePath", "p", "parsed", "path", "baseDir", "defaultValue", "version", "options", "libraryPrefix", "libraryFiles", "definitionFiles", "binaryen_exports", "__export", "default", "__reExport", "binaryen_star", "binaryen_star", "default", "Long", "index_js_exports", "__export", "ASTBuilder", "ArrayLiteralExpression", "ArrowKind", "AssertionExpression", "AssertionKind", "AtomicRMWOp", "BinaryExpression", "BinaryModule", "BinaryOp", "BlockStatement", "BrOnOp", "BreakStatement", "CallExpression", "Class", "ClassDeclaration", "ClassExpression", "ClassPrototype", "CommaExpression", "CommentKind", "CommentNode", "CommonFlags", "CommonNames", "CompiledExpression", "Compiler", "ConditionKind", "ConstantValueKind", "Constraints", "ConstructorExpression", "ContinueStatement", "DEFAULT_STACK_SIZE", "DeclarationStatement", "DeclaredElement", "DecoratorFlags", "DecoratorKind", "DecoratorNode", "DiagnosticCategory", "DiagnosticCode", "DiagnosticEmitter", "DiagnosticMessage", "DoStatement", "Element", "ElementAccessExpression", "ElementKind", "EmptyStatement", "Enum", "EnumDeclaration", "EnumValue", "EnumValueDeclaration", "ExportDefaultStatement", "ExportImportStatement", "ExportMember", "ExportNames", "ExportStatement", "Expression", "ExpressionId", "ExpressionRunnerFlags", "ExpressionStatement", "ExternalKind", "FEATURE_BULK_MEMORY", "FEATURE_EXCEPTION_HANDLING", "FEATURE_EXTENDED_CONST", "FEATURE_GC", "FEATURE_MEMORY64", "FEATURE_MULTI_VALUE", "FEATURE_MUTABLE_GLOBALS", "FEATURE_NONTRAPPING_F2I", "FEATURE_REFERENCE_TYPES", "FEATURE_RELAXED_SIMD", "FEATURE_SIGN_EXTENSION", "FEATURE_SIMD", "FEATURE_STRINGREF", "FEATURE_TAIL_CALLS", "FEATURE_THREADS", "FalseExpression", "Feature", "FeatureFlags", "Field", "FieldDeclaration", "FieldFlags", "FieldPrototype", "File", "FloatLiteralExpression", "Flow", "FlowFlags", "ForOfStatement", "ForStatement", "Function", "FunctionDeclaration", "FunctionExpression", "FunctionPrototype", "FunctionTypeNode", "GETTER_PREFIX", "Global", "HeapTypeRef", "INDEX_SUFFIX", "INNER_DELIMITER", "INSTANCE_DELIMITER", "IdentifierExpression", "IdentifierHandling", "IfStatement", "ImportDeclaration", "ImportNames", "ImportStatement", "IndexSignature", "IndexSignatureNode", "InstanceOfExpression", "IntegerLiteralExpression", "Interface", "InterfaceDeclaration", "InterfacePrototype", "JSBuilder", "LIBRARY_PREFIX", "LIBRARY_SUBST", "LiteralExpression", "LiteralKind", "Local", "LocalFlags", "MemorySegment", "MethodDeclaration", "Module", "ModuleDeclaration", "NamedTypeNode", "Namespace", "NamespaceDeclaration", "NewExpression", "Node", "NodeKind", "NullExpression", "ObjectLiteralExpression", "OmittedExpression", "OperatorKind", "Options", "PARENT_SUBST", "PATH_DELIMITER", "PackedType", "Parameter", "ParameterKind", "ParameterNode", "ParenthesizedExpression", "Parser", "Precedence", "Program", "Property", "PropertyAccessExpression", "PropertyPrototype", "Range", "RefAsOp", "RefIsOp", "RegexpLiteralExpression", "Relooper", "ReportMode", "Resolver", "ReturnStatement", "Runtime", "RuntimeFeatures", "SETTER_PREFIX", "SIMDExtractOp", "SIMDLoadOp", "SIMDLoadStoreLaneOp", "SIMDReplaceOp", "SIMDShiftOp", "SIMDTernaryOp", "STATIC_DELIMITER", "STUB_DELIMITER", "SideEffects", "Signature", "Source", "SourceKind", "State", "Statement", "StringAsOp", "StringEncodeOp", "StringIterMoveOp", "StringLiteralExpression", "StringMeasureOp", "StringNewOp", "StringSliceWTFOp", "SuperExpression", "SwitchBuilder", "SwitchCase", "SwitchStatement", "TSDBuilder", "Target", "TemplateLiteralExpression", "TernaryExpression", "ThisExpression", "ThrowStatement", "Token", "Tokenizer", "TrueExpression", "TryStatement", "Type", "TypeBuilderErrorReason", "TypeDeclaration", "TypeDefinition", "TypeFlags", "TypeKind", "TypeName", "TypeNode", "TypeParameterNode", "TypeRef", "TypeSystem", "TypedElement", "Typeinfo", "TypeinfoFlags", "UnaryExpression", "UnaryOp", "UnaryPostfixExpression", "UnaryPrefixExpression", "VariableDeclaration", "VariableLikeDeclarationStatement", "VariableLikeElement", "VariableStatement", "VoidStatement", "WhileStatement", "addGlobalAlias", "allocPtrArray", "buildJS", "buildTSD", "compile", "createType", "diagnosticCategoryToColor", "diagnosticCategoryToString", "diagnosticCodeToString", "disableFeature", "enableFeature", "ensureType", "expandType", "featureToString", "findDecorator", "formatDiagnosticMessage", "getBinaryLeft", "getBinaryOp", "getBinaryRight", "getBinaryenModuleRef", "getBlockChildAt", "getBlockChildCount", "getBlockName", "getBreakCondition", "getBreakName", "getCallOperandAt", "getCallOperandCount", "getCallTarget", "getConstValueF32", "getConstValueF64", "getConstValueI32", "getConstValueI64High", "getConstValueI64Low", "getConstValueV128", "getDefaultParameterName", "getDependee", "getDiagnosticCategory", "getDiagnosticCode", "getDiagnosticMessage", "getDiagnosticRange", "getDiagnosticRelatedRange", "getDropValue", "getExpressionId", "getExpressionType", "getFunctionBody", "getFunctionName", "getFunctionParams", "getFunctionResults", "getFunctionVars", "getGlobalGetName", "getGlobalInit", "getGlobalName", "getGlobalType", "getIfCondition", "getIfFalse", "getIfTrue", "getLoadBytes", "getLoadOffset", "getLoadPtr", "getLocalGetIndex", "getLocalSetIndex", "getLocalSetValue", "getLoopBody", "getLoopName", "getMemoryGrowDelta", "getRangeEnd", "getRangeSource", "getRangeStart", "getReturnValue", "getSelectCondition", "getSelectElse", "getSelectThen", "getSideEffects", "getSource", "getSourceNormalizedPath", "getStoreBytes", "getStoreOffset", "getStorePtr", "getStoreValue", "getTagName", "getTagParams", "getTagResults", "getUnaryOp", "getUnaryValue", "initializeProgram", "isConstExpressionNaN", "isConstNaN", "isConstNegZero", "isConstNonZero", "isConstZero", "isDeclaredElement", "isError", "isGlobalMutable", "isIllegalVariableIdentifier", "isInfo", "isLoadSigned", "isLocalTee", "isNullableType", "isTypeOmitted", "isTypedElement", "isWarning", "mangleInternalName", "mangleInternalPath", "mustPreserveSideEffects", "needsExplicitUnreachable", "newOptions", "newProgram", "nextDiagnostic", "nextFile", "operatorTokenToString", "optimize", "parse", "readString", "removeGlobalAlias", "setBasenameHint", "setBindingsHint", "setBundleVersion", "setDebugInfo", "setExportMemory", "setExportRuntime", "setExportStart", "setExportTable", "setImportMemory", "setImportTable", "setInitialMemory", "setLowMemoryLimit", "setMaximumMemory", "setMemoryBase", "setNoAssert", "setNoUnsafe", "setOptimizeLevelHints", "setPedantic", "setRuntime", "setSharedMemory", "setSourceMap", "setStackSize", "setTableBase", "setTarget", "tokenFromKeyword", "tokenIsAlsoIdentifier", "typesToRefs", "typesToString", "util_exports", "validate", "globalScope", "UnreachableError", "AssertionError", "message", "defaultComparator", "b", "nanA", "nanB", "F64", "U64", "value", "shift", "y", "ifTrue", "ifFalse", "condition", "x", "a", "isTrueish", "arr", "len", "index", "parts", "search", "replacment", "res", "arraySort", "comparator", "Ctr", "fn", "i", "buffer", "byteOffset", "length", "arg", "expr", "n", "binaryen_exports", "__reExport", "_BinaryenTypeCreate", "_BinaryenTypeArity", "_BinaryenTypeExpand", "_BinaryenTypeGetHeapType", "_BinaryenTypeFromHeapType", "_BinaryenTypeIsNullable", "_BinaryenTypeFuncref", "_BinaryenTypeExternref", "_BinaryenTypeAnyref", "_BinaryenTypeEqref", "_BinaryenTypeI31ref", "_BinaryenTypeDataref", "_BinaryenTypeArrayref", "_BinaryenTypeStringref", "_BinaryenTypeStringviewWTF8", "_BinaryenTypeStringviewWTF16", "_BinaryenTypeStringviewIter", "_BinaryenTypeNullref", "_BinaryenTypeNullExternref", "_BinaryenTypeNullFuncref", "_BinaryenHeapTypeFunc", "_BinaryenHeapTypeExt", "_BinaryenHeapTypeAny", "_BinaryenHeapTypeEq", "_BinaryenHeapTypeI31", "_BinaryenHeapTypeData", "_BinaryenHeapTypeArray", "_BinaryenHeapTypeString", "_BinaryenHeapTypeStringviewWTF8", "_BinaryenHeapTypeStringviewWTF16", "_BinaryenHeapTypeStringviewIter", "_BinaryenHeapTypeNone", "_BinaryenHeapTypeNoext", "_BinaryenHeapTypeNofunc", "_BinaryenHeapTypeIsBottom", "_BinaryenHeapTypeGetBottom", "_BinaryenModuleCreate", "_BinaryenModuleDispose", "_BinaryenSizeofLiteral", "_BinaryenLiteralInt32", "_BinaryenLiteralInt64", "_BinaryenLiteralFloat32", "_BinaryenLiteralFloat64", "_BinaryenLiteralVec128", "_BinaryenLiteralFloat32Bits", "_BinaryenLiteralFloat64Bits", "_BinaryenExpressionGetId", "_BinaryenExpressionGetType", "_BinaryenExpressionSetType", "_BinaryenExpressionPrint", "_BinaryenExpressionCopy", "_BinaryenExpressionFinalize", "_BinaryenBlock", "_BinaryenBlockGetName", "_BinaryenBlockSetName", "_BinaryenBlockGetNumChildren", "_BinaryenBlockGetChildAt", "_BinaryenBlockSetChildAt", "_BinaryenBlockAppendChild", "_BinaryenBlockInsertChildAt", "_BinaryenBlockRemoveChildAt", "_BinaryenIf", "_BinaryenIfGetCondition", "_BinaryenIfSetCondition", "_BinaryenIfGetIfTrue", "_BinaryenIfSetIfTrue", "_BinaryenIfGetIfFalse", "_BinaryenIfSetIfFalse", "_BinaryenLoop", "_BinaryenLoopGetName", "_BinaryenLoopSetName", "_BinaryenLoopGetBody", "_BinaryenLoopSetBody", "_BinaryenBreak", "_BinaryenBreakGetName", "_BinaryenBreakSetName", "_BinaryenBreakGetCondition", "_BinaryenBreakSetCondition", "_BinaryenBreakGetValue", "_BinaryenBreakSetValue", "_BinaryenSwitch", "_BinaryenSwitchGetNumNames", "_BinaryenSwitchGetNameAt", "_BinaryenSwitchSetNameAt", "_BinaryenSwitchAppendName", "_BinaryenSwitchInsertNameAt", "_BinaryenSwitchRemoveNameAt", "_BinaryenSwitchGetDefaultName", "_BinaryenSwitchSetDefaultName", "_BinaryenSwitchGetCondition", "_BinaryenSwitchSetCondition", "_BinaryenSwitchGetValue", "_BinaryenSwitchSetValue", "_BinaryenCall", "_BinaryenCallGetTarget", "_BinaryenCallSetTarget", "_BinaryenCallGetNumOperands", "_BinaryenCallGetOperandAt", "_BinaryenCallSetOperandAt", "_BinaryenCallAppendOperand", "_BinaryenCallInsertOperandAt", "_BinaryenCallRemoveOperandAt", "_BinaryenCallIsReturn", "_BinaryenCallSetReturn", "_BinaryenReturnCall", "_BinaryenCallIndirect", "_BinaryenCallIndirectGetTable", "_BinaryenCallIndirectSetTable", "_BinaryenCallIndirectGetTarget", "_BinaryenCallIndirectSetTarget", "_BinaryenCallIndirectGetNumOperands", "_BinaryenCallIndirectGetOperandAt", "_BinaryenCallIndirectSetOperandAt", "_BinaryenCallIndirectAppendOperand", "_BinaryenCallIndirectInsertOperandAt", "_BinaryenCallIndirectRemoveOperandAt", "_BinaryenCallIndirectIsReturn", "_BinaryenCallIndirectSetReturn", "_BinaryenReturnCallIndirect", "_BinaryenLocalGet", "_BinaryenLocalGetGetIndex", "_BinaryenLocalGetSetIndex", "_BinaryenLocalSet", "_BinaryenLocalSetIsTee", "_BinaryenLocalSetGetIndex", "_BinaryenLocalSetSetIndex", "_BinaryenLocalSetGetValue", "_BinaryenLocalSetSetValue", "_BinaryenLocalTee", "_BinaryenGlobalGet", "_BinaryenGlobalGetGetName", "_BinaryenGlobalGetSetName", "_BinaryenGlobalSet", "_BinaryenGlobalSetGetName", "_BinaryenGlobalSetSetName", "_BinaryenGlobalSetGetValue", "_BinaryenGlobalSetSetValue", "_BinaryenMemorySize", "_BinaryenMemoryGrow", "_BinaryenMemoryGrowGetDelta", "_BinaryenMemoryGrowSetDelta", "_BinaryenLoad", "_BinaryenLoadIsAtomic", "_BinaryenLoadSetAtomic", "_BinaryenLoadIsSigned", "_BinaryenLoadSetSigned", "_BinaryenLoadGetOffset", "_BinaryenLoadSetOffset", "_BinaryenLoadGetBytes", "_BinaryenLoadSetBytes", "_BinaryenLoadGetAlign", "_BinaryenLoadSetAlign", "_BinaryenLoadGetPtr", "_BinaryenLoadSetPtr", "_BinaryenAtomicLoad", "_BinaryenStore", "_BinaryenStoreIsAtomic", "_BinaryenStoreSetAtomic", "_BinaryenStoreGetBytes", "_BinaryenStoreSetBytes", "_BinaryenStoreGetOffset", "_BinaryenStoreSetOffset", "_BinaryenStoreGetAlign", "_BinaryenStoreSetAlign", "_BinaryenStoreGetPtr", "_BinaryenStoreSetPtr", "_BinaryenStoreGetValue", "_BinaryenStoreSetValue", "_BinaryenStoreGetValueType", "_BinaryenStoreSetValueType", "_BinaryenAtomicStore", "_BinaryenConst", "_BinaryenConstGetValueI32", "_BinaryenConstSetValueI32", "_BinaryenConstGetValueI64Low", "_BinaryenConstSetValueI64Low", "_BinaryenConstGetValueI64High", "_BinaryenConstSetValueI64High", "_BinaryenConstGetValueF32", "_BinaryenConstSetValueF32", "_BinaryenConstGetValueF64", "_BinaryenConstSetValueF64", "_BinaryenConstGetValueV128", "_BinaryenConstSetValueV128", "_BinaryenUnary", "_BinaryenUnaryGetOp", "_BinaryenUnarySetOp", "_BinaryenUnaryGetValue", "_BinaryenUnarySetValue", "_BinaryenBinary", "_BinaryenBinaryGetOp", "_BinaryenBinarySetOp", "_BinaryenBinaryGetLeft", "_BinaryenBinarySetLeft", "_BinaryenBinaryGetRight", "_BinaryenBinarySetRight", "_BinaryenSelect", "_BinaryenSelectGetIfTrue", "_BinaryenSelectSetIfTrue", "_BinaryenSelectGetIfFalse", "_BinaryenSelectSetIfFalse", "_BinaryenSelectGetCondition", "_BinaryenSelectSetCondition", "_BinaryenDrop", "_BinaryenDropGetValue", "_BinaryenDropSetValue", "_BinaryenReturn", "_BinaryenReturnGetValue", "_BinaryenReturnSetValue", "_BinaryenNop", "_BinaryenUnreachable", "_BinaryenAtomicRMW", "_BinaryenAtomicRMWGetOp", "_BinaryenAtomicRMWSetOp", "_BinaryenAtomicRMWGetBytes", "_BinaryenAtomicRMWSetBytes", "_BinaryenAtomicRMWGetOffset", "_BinaryenAtomicRMWSetOffset", "_BinaryenAtomicRMWGetPtr", "_BinaryenAtomicRMWSetPtr", "_BinaryenAtomicRMWGetValue", "_BinaryenAtomicRMWSetValue", "_BinaryenAtomicCmpxchg", "_BinaryenAtomicCmpxchgGetBytes", "_BinaryenAtomicCmpxchgSetBytes", "_BinaryenAtomicCmpxchgGetOffset", "_BinaryenAtomicCmpxchgSetOffset", "_BinaryenAtomicCmpxchgGetPtr", "_BinaryenAtomicCmpxchgSetPtr", "_BinaryenAtomicCmpxchgGetExpected", "_BinaryenAtomicCmpxchgSetExpected", "_BinaryenAtomicCmpxchgGetReplacement", "_BinaryenAtomicCmpxchgSetReplacement", "_BinaryenAtomicWait", "_BinaryenAtomicWaitGetPtr", "_BinaryenAtomicWaitSetPtr", "_BinaryenAtomicWaitGetExpected", "_BinaryenAtomicWaitSetExpected", "_BinaryenAtomicWaitGetTimeout", "_BinaryenAtomicWaitSetTimeout", "_BinaryenAtomicWaitGetExpectedType", "_BinaryenAtomicWaitSetExpectedType", "_BinaryenAtomicNotify", "_BinaryenAtomicNotifyGetPtr", "_BinaryenAtomicNotifySetPtr", "_BinaryenAtomicNotifyGetNotifyCount", "_BinaryenAtomicNotifySetNotifyCount", "_BinaryenAtomicFence", "_BinaryenAtomicFenceGetOrder", "_BinaryenAtomicFenceSetOrder", "_BinaryenSIMDExtract", "_BinaryenSIMDExtractGetOp", "_BinaryenSIMDExtractSetOp", "_BinaryenSIMDExtractGetVec", "_BinaryenSIMDExtractSetVec", "_BinaryenSIMDExtractGetIndex", "_BinaryenSIMDExtractSetIndex", "_BinaryenSIMDReplace", "_BinaryenSIMDReplaceGetOp", "_BinaryenSIMDReplaceSetOp", "_BinaryenSIMDReplaceGetVec", "_BinaryenSIMDReplaceSetVec", "_BinaryenSIMDReplaceGetIndex", "_BinaryenSIMDReplaceSetIndex", "_BinaryenSIMDReplaceGetValue", "_BinaryenSIMDReplaceSetValue", "_BinaryenSIMDShuffle", "_BinaryenSIMDShuffleGetLeft", "_BinaryenSIMDShuffleSetLeft", "_BinaryenSIMDShuffleGetRight", "_BinaryenSIMDShuffleSetRight", "_BinaryenSIMDShuffleGetMask", "_BinaryenSIMDShuffleSetMask", "_BinaryenSIMDTernary", "_BinaryenSIMDTernaryGetOp", "_BinaryenSIMDTernarySetOp", "_BinaryenSIMDTernaryGetA", "_BinaryenSIMDTernarySetA", "_BinaryenSIMDTernaryGetB", "_BinaryenSIMDTernarySetB", "_BinaryenSIMDTernaryGetC", "_BinaryenSIMDTernarySetC", "_BinaryenSIMDShift", "_BinaryenSIMDShiftGetOp", "_BinaryenSIMDShiftSetOp", "_BinaryenSIMDShiftGetVec", "_BinaryenSIMDShiftSetVec", "_BinaryenSIMDShiftGetShift", "_BinaryenSIMDShiftSetShift", "_BinaryenSIMDLoad", "_BinaryenSIMDLoadGetOp", "_BinaryenSIMDLoadSetOp", "_BinaryenSIMDLoadGetOffset", "_BinaryenSIMDLoadSetOffset", "_BinaryenSIMDLoadGetAlign", "_BinaryenSIMDLoadSetAlign", "_BinaryenSIMDLoadGetPtr", "_BinaryenSIMDLoadSetPtr", "_BinaryenSIMDLoadStoreLane", "_BinaryenSIMDLoadStoreLaneGetOp", "_BinaryenSIMDLoadStoreLaneSetOp", "_BinaryenSIMDLoadStoreLaneGetOffset", "_BinaryenSIMDLoadStoreLaneSetOffset", "_BinaryenSIMDLoadStoreLaneGetAlign", "_BinaryenSIMDLoadStoreLaneSetAlign", "_BinaryenSIMDLoadStoreLaneGetIndex", "_BinaryenSIMDLoadStoreLaneSetIndex", "_BinaryenSIMDLoadStoreLaneGetPtr", "_BinaryenSIMDLoadStoreLaneSetPtr", "_BinaryenSIMDLoadStoreLaneGetVec", "_BinaryenSIMDLoadStoreLaneSetVec", "_BinaryenSIMDLoadStoreLaneIsStore", "_BinaryenMemoryInit", "_BinaryenMemoryInitGetSegment", "_BinaryenMemoryInitSetSegment", "_BinaryenMemoryInitGetDest", "_BinaryenMemoryInitSetDest", "_BinaryenMemoryInitGetOffset", "_BinaryenMemoryInitSetOffset", "_BinaryenMemoryInitGetSize", "_BinaryenMemoryInitSetSize", "_BinaryenDataDrop", "_BinaryenDataDropGetSegment", "_BinaryenDataDropSetSegment", "_BinaryenMemoryCopy", "_BinaryenMemoryCopyGetDest", "_BinaryenMemoryCopySetDest", "_BinaryenMemoryCopyGetSource", "_BinaryenMemoryCopySetSource", "_BinaryenMemoryCopyGetSize", "_BinaryenMemoryCopySetSize", "_BinaryenMemoryFill", "_BinaryenMemoryFillGetDest", "_BinaryenMemoryFillSetDest", "_BinaryenMemoryFillGetValue", "_BinaryenMemoryFillSetValue", "_BinaryenMemoryFillGetSize", "_BinaryenMemoryFillSetSize", "_BinaryenRefNull", "_BinaryenRefIs", "_BinaryenRefIsGetOp", "_BinaryenRefIsSetOp", "_BinaryenRefIsGetValue", "_BinaryenRefIsSetValue", "_BinaryenRefAs", "_BinaryenRefAsGetOp", "_BinaryenRefAsSetOp", "_BinaryenRefAsGetValue", "_BinaryenRefAsSetValue", "_BinaryenRefFunc", "_BinaryenRefFuncGetFunc", "_BinaryenRefFuncSetFunc", "_BinaryenRefEq", "_BinaryenRefEqGetLeft", "_BinaryenRefEqSetLeft", "_BinaryenRefEqGetRight", "_BinaryenRefEqSetRight", "_BinaryenTableGet", "_BinaryenTableGetGetTable", "_BinaryenTableGetSetTable", "_BinaryenTableGetGetIndex", "_BinaryenTableGetSetIndex", "_BinaryenTableSet", "_BinaryenTableSetGetTable", "_BinaryenTableSetSetTable", "_BinaryenTableSetGetIndex", "_BinaryenTableSetSetIndex", "_BinaryenTableSetGetValue", "_BinaryenTableSetSetValue", "_BinaryenTableSize", "_BinaryenTableSizeGetTable", "_BinaryenTableSizeSetTable", "_BinaryenTableGrow", "_BinaryenTableGrowGetTable", "_BinaryenTableGrowSetTable", "_BinaryenTableGrowGetValue", "_BinaryenTableGrowSetValue", "_BinaryenTableGrowGetDelta", "_BinaryenTableGrowSetDelta", "_BinaryenTry", "_BinaryenTryGetName", "_BinaryenTrySetName", "_BinaryenTryGetBody", "_BinaryenTrySetBody", "_BinaryenTryGetNumCatchTags", "_BinaryenTryGetNumCatchBodies", "_BinaryenTryGetCatchTagAt", "_BinaryenTrySetCatchTagAt", "_BinaryenTryAppendCatchTag", "_BinaryenTryInsertCatchTagAt", "_BinaryenTryRemoveCatchTagAt", "_BinaryenTryGetCatchBodyAt", "_BinaryenTrySetCatchBodyAt", "_BinaryenTryAppendCatchBody", "_BinaryenTryInsertCatchBodyAt", "_BinaryenTryRemoveCatchBodyAt", "_BinaryenTryHasCatchAll", "_BinaryenTryGetDelegateTarget", "_BinaryenTrySetDelegateTarget", "_BinaryenTryIsDelegate", "_BinaryenThrow", "_BinaryenThrowGetTag", "_BinaryenThrowSetTag", "_BinaryenThrowGetNumOperands", "_BinaryenThrowGetOperandAt", "_BinaryenThrowSetOperandAt", "_BinaryenThrowAppendOperand", "_BinaryenThrowInsertOperandAt", "_BinaryenThrowRemoveOperandAt", "_BinaryenRethrow", "_BinaryenRethrowGetTarget", "_BinaryenRethrowSetDepth", "_BinaryenTupleMake", "_BinaryenTupleMakeGetNumOperands", "_BinaryenTupleMakeGetOperandAt", "_BinaryenTupleMakeSetOperandAt", "_BinaryenTupleMakeAppendOperand", "_BinaryenTupleMakeInsertOperandAt", "_BinaryenTupleMakeRemoveOperandAt", "_BinaryenTupleExtract", "_BinaryenTupleExtractGetTuple", "_BinaryenTupleExtractSetTuple", "_BinaryenTupleExtractGetIndex", "_BinaryenTupleExtractSetIndex", "_BinaryenPop", "_BinaryenI31New", "_BinaryenI31NewGetValue", "_BinaryenI31NewSetValue", "_BinaryenI31Get", "_BinaryenI31GetGetI31", "_BinaryenI31GetSetI31", "_BinaryenI31GetIsSigned", "_BinaryenI31GetSetSigned", "_BinaryenCallRef", "_BinaryenCallRefGetNumOperands", "_BinaryenCallRefGetOperandAt", "_BinaryenCallRefSetOperandAt", "_BinaryenCallRefAppendOperand", "_BinaryenCallRefInsertOperandAt", "_BinaryenCallRefRemoveOperandAt", "_BinaryenCallRefGetTarget", "_BinaryenCallRefSetTarget", "_BinaryenCallRefIsReturn", "_BinaryenCallRefSetReturn", "_BinaryenRefTest", "_BinaryenRefTestGetRef", "_BinaryenRefTestSetRef", "_BinaryenRefTestGetIntendedType", "_BinaryenRefTestSetIntendedType", "_BinaryenRefCast", "_BinaryenRefCastGetRef", "_BinaryenRefCastSetRef", "_BinaryenRefCastGetIntendedType", "_BinaryenRefCastSetIntendedType", "_BinaryenBrOn", "_BinaryenBrOnGetOp", "_BinaryenBrOnSetOp", "_BinaryenBrOnGetName", "_BinaryenBrOnSetName", "_BinaryenBrOnGetRef", "_BinaryenBrOnSetRef", "_BinaryenBrOnGetIntendedType", "_BinaryenBrOnSetIntendedType", "_BinaryenStructNew", "_BinaryenStructNewGetNumOperands", "_BinaryenStructNewGetOperandAt", "_BinaryenStructNewSetOperandAt", "_BinaryenStructNewAppendOperand", "_BinaryenStructNewInsertOperandAt", "_BinaryenStructNewRemoveOperandAt", "_BinaryenStructGet", "_BinaryenStructGetGetIndex", "_BinaryenStructGetSetIndex", "_BinaryenStructGetGetRef", "_BinaryenStructGetSetRef", "_BinaryenStructGetIsSigned", "_BinaryenStructGetSetSigned", "_BinaryenStructSet", "_BinaryenStructSetGetIndex", "_BinaryenStructSetSetIndex", "_BinaryenStructSetGetRef", "_BinaryenStructSetSetRef", "_BinaryenStructSetGetValue", "_BinaryenStructSetSetValue", "_BinaryenArrayNew", "_BinaryenArrayNewGetInit", "_BinaryenArrayNewSetInit", "_BinaryenArrayNewGetSize", "_BinaryenArrayNewSetSize", "_BinaryenArrayInit", "_BinaryenArrayInitGetNumValues", "_BinaryenArrayInitGetValueAt", "_BinaryenArrayInitSetValueAt", "_BinaryenArrayInitAppendValue", "_BinaryenArrayInitInsertValueAt", "_BinaryenArrayInitRemoveValueAt", "_BinaryenArrayGet", "_BinaryenArrayGetGetRef", "_BinaryenArrayGetSetRef", "_BinaryenArrayGetGetIndex", "_BinaryenArrayGetSetIndex", "_BinaryenArrayGetIsSigned", "_BinaryenArrayGetSetSigned", "_BinaryenArraySet", "_BinaryenArraySetGetRef", "_BinaryenArraySetSetRef", "_BinaryenArraySetGetIndex", "_BinaryenArraySetSetIndex", "_BinaryenArraySetGetValue", "_BinaryenArraySetSetValue", "_BinaryenArrayLen", "_BinaryenArrayLenGetRef", "_BinaryenArrayLenSetRef", "_BinaryenArrayCopy", "_BinaryenArrayCopyGetDestRef", "_BinaryenArrayCopySetDestRef", "_BinaryenArrayCopyGetDestIndex", "_BinaryenArrayCopySetDestIndex", "_BinaryenArrayCopyGetSrcRef", "_BinaryenArrayCopySetSrcRef", "_BinaryenArrayCopyGetSrcIndex", "_BinaryenArrayCopySetSrcIndex", "_BinaryenArrayCopyGetLength", "_BinaryenArrayCopySetLength", "_BinaryenStringNew", "_BinaryenStringNewGetOp", "_BinaryenStringNewSetOp", "_BinaryenStringNewGetPtr", "_BinaryenStringNewSetPtr", "_BinaryenStringNewGetLength", "_BinaryenStringNewSetLength", "_BinaryenStringNewGetStart", "_BinaryenStringNewSetStart", "_BinaryenStringNewGetEnd", "_BinaryenStringNewSetEnd", "_BinaryenStringConst", "_BinaryenStringConstGetString", "_BinaryenStringConstSetString", "_BinaryenStringMeasure", "_BinaryenStringMeasureGetOp", "_BinaryenStringMeasureSetOp", "_BinaryenStringMeasureGetRef", "_BinaryenStringMeasureSetRef", "_BinaryenStringEncode", "_BinaryenStringEncodeGetOp", "_BinaryenStringEncodeSetOp", "_BinaryenStringEncodeGetRef", "_BinaryenStringEncodeSetRef", "_BinaryenStringEncodeGetPtr", "_BinaryenStringEncodeSetPtr", "_BinaryenStringEncodeGetStart", "_BinaryenStringEncodeSetStart", "_BinaryenStringConcat", "_BinaryenStringConcatGetLeft", "_BinaryenStringConcatSetLeft", "_BinaryenStringConcatGetRight", "_BinaryenStringConcatSetRight", "_BinaryenStringEq", "_BinaryenStringEqGetLeft", "_BinaryenStringEqSetLeft", "_BinaryenStringEqGetRight", "_BinaryenStringEqSetRight", "_BinaryenStringAs", "_BinaryenStringAsGetOp", "_BinaryenStringAsSetOp", "_BinaryenStringAsGetRef", "_BinaryenStringAsSetRef", "_BinaryenStringWTF8Advance", "_BinaryenStringWTF8AdvanceGetRef", "_BinaryenStringWTF8AdvanceSetRef", "_BinaryenStringWTF8AdvanceGetPos", "_BinaryenStringWTF8AdvanceSetPos", "_BinaryenStringWTF8AdvanceGetBytes", "_BinaryenStringWTF8AdvanceSetBytes", "_BinaryenStringWTF16Get", "_BinaryenStringWTF16GetGetRef", "_BinaryenStringWTF16GetSetRef", "_BinaryenStringWTF16GetGetPos", "_BinaryenStringWTF16GetSetPos", "_BinaryenStringIterNext", "_BinaryenStringIterNextGetRef", "_BinaryenStringIterNextSetRef", "_BinaryenStringIterMove", "_BinaryenStringIterMoveGetOp", "_BinaryenStringIterMoveSetOp", "_BinaryenStringIterMoveGetRef", "_BinaryenStringIterMoveSetRef", "_BinaryenStringIterMoveGetNum", "_BinaryenStringIterMoveSetNum", "_BinaryenStringSliceWTF", "_BinaryenStringSliceWTFGetOp", "_BinaryenStringSliceWTFSetOp", "_BinaryenStringSliceWTFGetRef", "_BinaryenStringSliceWTFSetRef", "_BinaryenStringSliceWTFGetStart", "_BinaryenStringSliceWTFSetStart", "_BinaryenStringSliceWTFGetEnd", "_BinaryenStringSliceWTFSetEnd", "_BinaryenStringSliceIter", "_BinaryenStringSliceIterGetRef", "_BinaryenStringSliceIterSetRef", "_BinaryenStringSliceIterGetNum", "_BinaryenStringSliceIterSetNum", "_BinaryenAddFunction", "_BinaryenGetFunction", "_BinaryenRemoveFunction", "_BinaryenGetNumFunctions", "_BinaryenGetFunctionByIndex", "_BinaryenFunctionGetName", "_BinaryenFunctionGetParams", "_BinaryenFunctionGetResults", "_BinaryenFunctionGetNumVars", "_BinaryenFunctionGetVar", "_BinaryenFunctionGetNumLocals", "_BinaryenFunctionHasLocalName", "_BinaryenFunctionGetLocalName", "_BinaryenFunctionSetLocalName", "_BinaryenFunctionGetBody", "_BinaryenFunctionSetBody", "_BinaryenFunctionOptimize", "_BinaryenFunctionRunPasses", "_BinaryenFunctionSetDebugLocation", "_BinaryenAddFunctionImport", "_BinaryenAddTableImport", "_BinaryenAddMemoryImport", "_BinaryenAddGlobalImport", "_BinaryenAddTagImport", "_BinaryenAddFunctionExport", "_BinaryenAddTableExport", "_BinaryenAddMemoryExport", "_BinaryenAddGlobalExport", "_BinaryenAddTagExport", "_BinaryenGetExport", "_BinaryenRemoveExport", "_BinaryenGetNumExports", "_BinaryenGetExportByIndex", "_BinaryenExportGetKind", "_BinaryenExportGetName", "_BinaryenExportGetValue", "_BinaryenAddGlobal", "_BinaryenGetGlobal", "_BinaryenRemoveGlobal", "_BinaryenGetNumGlobals", "_BinaryenGetGlobalByIndex", "_BinaryenGlobalGetName", "_BinaryenGlobalGetType", "_BinaryenGlobalIsMutable", "_BinaryenGlobalGetInitExpr", "_BinaryenAddTag", "_BinaryenGetTag", "_BinaryenRemoveTag", "_BinaryenTagGetName", "_BinaryenTagGetParams", "_BinaryenTagGetResults", "_BinaryenAddTable", "_BinaryenRemoveTable", "_BinaryenGetNumTables", "_BinaryenGetTable", "_BinaryenGetTableByIndex", "_BinaryenTableGetName", "_BinaryenTableSetName", "_BinaryenTableGetInitial", "_BinaryenTableSetInitial", "_BinaryenTableHasMax", "_BinaryenTableGetMax", "_BinaryenTableSetMax", "_BinaryenAddActiveElementSegment", "_BinaryenAddPassiveElementSegment", "_BinaryenRemoveElementSegment", "_BinaryenGetNumElementSegments", "_BinaryenGetElementSegment", "_BinaryenGetElementSegmentByIndex", "_BinaryenSetMemory", "_BinaryenGetNumMemorySegments", "_BinaryenGetMemorySegmentByteOffset", "_BinaryenGetMemorySegmentByteLength", "_BinaryenCopyMemorySegmentData", "_BinaryenSetStart", "_BinaryenModuleParse", "_BinaryenModulePrint", "_BinaryenModulePrintAsmjs", "_BinaryenModuleValidate", "_BinaryenModuleOptimize", "_BinaryenModuleRunPasses", "_BinaryenModuleAutoDrop", "_BinaryenSizeofAllocateAndWriteResult", "_BinaryenModuleAllocateAndWrite", "_BinaryenModuleAllocateAndWriteText", "_BinaryenModuleAllocateAndWriteStackIR", "_BinaryenModuleRead", "_BinaryenModuleInterpret", "_BinaryenModuleAddDebugInfoFileName", "_BinaryenModuleGetDebugInfoFileName", "_BinaryenModuleGetFeatures", "_BinaryenModuleSetFeatures", "_BinaryenAddCustomSection", "_BinaryenExpressionGetSideEffects", "_RelooperCreate", "_RelooperAddBlock", "_RelooperAddBranch", "_RelooperAddBlockWithSwitch", "_RelooperAddBranchForSwitch", "_RelooperRenderAndDispose", "_ExpressionRunnerCreate", "_ExpressionRunnerSetLocalValue", "_ExpressionRunnerSetGlobalValue", "_ExpressionRunnerRunAndDispose", "_TypeBuilderCreate", "_TypeBuilderGrow", "_TypeBuilderGetSize", "_TypeBuilderSetBasicHeapType", "_TypeBuilderSetSignatureType", "_TypeBuilderSetStructType", "_TypeBuilderSetArrayType", "_TypeBuilderIsBasic", "_TypeBuilderGetBasic", "_TypeBuilderGetTempHeapType", "_TypeBuilderGetTempTupleType", "_TypeBuilderGetTempRefType", "_TypeBuilderSetSubType", "_TypeBuilderCreateRecGroup", "_TypeBuilderBuildAndDispose", "_BinaryenModuleSetTypeName", "_BinaryenModuleSetFieldName", "_BinaryenGetOptimizeLevel", "_BinaryenSetOptimizeLevel", "_BinaryenGetShrinkLevel", "_BinaryenSetShrinkLevel", "_BinaryenGetDebugInfo", "_BinaryenSetDebugInfo", "_BinaryenGetLowMemoryUnused", "_BinaryenSetLowMemoryUnused", "_BinaryenGetZeroFilledMemory", "_BinaryenSetZeroFilledMemory", "_BinaryenGetFastMath", "_BinaryenSetFastMath", "_BinaryenGetPassArgument", "_BinaryenSetPassArgument", "_BinaryenClearPassArguments", "_BinaryenGetAlwaysInlineMaxSize", "_BinaryenSetAlwaysInlineMaxSize", "_BinaryenGetFlexibleInlineMaxSize", "_BinaryenSetFlexibleInlineMaxSize", "_BinaryenGetOneCallerInlineMaxSize", "_BinaryenSetOneCallerInlineMaxSize", "_BinaryenGetAllowInliningFunctionsWithLoops", "_BinaryenSetAllowInliningFunctionsWithLoops", "_BinaryenGetTypeSystem", "_BinaryenSetTypeSystem", "_malloc", "_free", "__i32_store8", "__i32_store16", "__i32_store", "__f32_store", "__f64_store", "__i32_load8_s", "__i32_load8_u", "__i32_load16_s", "__i32_load16_u", "__i32_load", "__f32_load", "__f64_load", "F32", "I32", "lo", "hi", "left", "right", "rightLo", "rightHi", "result", "alignment", "mask", "minSafeF32", "maxSafeF32", "minSafeF64", "maxSafeF64", "unsigned", "map", "set", "feature", "__decorateClass", "code", "BitSet", "COLOR_BLUE", "COLOR_CYAN", "COLOR_GRAY", "COLOR_GREEN", "COLOR_MAGENTA", "COLOR_RED", "COLOR_RESET", "COLOR_WHITE", "COLOR_YELLOW", "CharCode", "SURROGATE_HIGH", "SURROGATE_LOW", "accuratePow64", "cloneMap", "colorize", "combineSurrogates", "dirname", "escapeString", "indent", "isAlpha", "isAlphaOrDecimal", "isColorsEnabled", "isDecimal", "isHexBase", "isHexOrDecimal", "isHighSurrogate", "isIdentifier", "isIdentifierPart", "isIdentifierStart", "isLineBreak", "isLowSurrogate", "isOctal", "isPowerOf2", "isSurrogate", "isSurrogateHigh", "isSurrogateLow", "isWhiteSpace", "mergeMaps", "normalizePath", "numCodeUnits", "readF32", "readF64", "readI16", "readI32", "readI64", "readI8", "readV128", "resolvePath", "setColorsEnabled", "v128_ones", "v128_zero", "writeF32", "writeF64", "writeI16", "writeI32", "writeI32AsI64", "writeI64", "writeI64AsI32", "writeI8", "writeV128", "offset", "valueI64", "out", "_keys", "k", "v", "map1", "map2", "count", "words", "word", "idx", "p", "c", "cp", "c0", "unicodeIdentifierStartMin", "unicodeIdentifierStartMax", "lookupInUnicodeMap", "unicodeIdentifierStart", "unicodeIdentifierPartMin", "unicodeIdentifierPartMax", "unicodeIdentifierPart", "str", "mid", "midVal", "indentX1", "indentX2", "indentX3", "indentX4", "indentCache", "sb", "level", "indents", "quote", "off", "separator", "path", "pos", "atEnd", "ipos", "normalizedPath", "origin", "colorsEnabled", "isEnabled", "wasEnabled", "text", "color", "start", "end", "range", "other", "category", "arg0", "arg1", "arg2", "thisRange", "otherRange", "thisRelatedRange", "otherRelatedRange", "source", "line", "column", "useColors", "showContext", "wasColorsEnabled", "formatDiagnosticContext", "relatedRange", "relatedSource", "lineNumber", "lineSpace", "cc", "diagnostics", "seen", "seenInSource", "seenMessagesAtPos", "kind", "name", "typeArguments", "isNullable", "parameters", "returnType", "explicitThisType", "extendsType", "defaultType", "parameterKind", "type", "initializer", "args", "commentKind", "isQuoted", "elementExpressions", "assertionKind", "expression", "toType", "operator", "declaration", "expressions", "elementExpression", "isType", "typeName", "names", "values", "property", "pattern", "patternFlags", "ifThen", "ifElse", "tag", "rawParts", "exprLengths", "operand", "statements", "label", "decorators", "flags", "typeParameters", "implementsTypes", "members", "body", "isDeclare", "externalName", "localName", "exportedName", "declarations", "namespaceName", "foreignName", "incrementor", "variable", "iterable", "signature", "arrowKind", "keyType", "valueType", "cases", "bodyStatements", "catchVariable", "catchStatements", "finallyStatements", "statement", "literalKind", "node", "typeParameterNodes", "namedTypeNode", "typeArgumentNodes", "functionTypeNode", "parameterNodes", "identifier", "next", "flag", "fromNode", "nameNode", "nameStr", "propertyAccessNode", "propStr", "decoratorKind", "numTypeArguments", "numArguments", "sourceKind", "internalPath", "lineCache", "l", "r", "m", "s", "parameterIndex", "moduleName", "decorator", "token", "identifierHandling", "maxTokenLength", "chr", "commentStartPos", "closed", "posBefore", "maybeKeywordToken", "checkOnNewLine", "maxCompoundLength", "tokenBefore", "tokenPosBefore", "nextToken", "state", "reusableState", "isTaggedTemplate", "escaped", "sepEnd", "i64_4", "nextValue", "overflowOccurred", "i64_10", "i64_3", "sepCount", "allowLeadingZeroSep", "remain", "startIfTaggedTemplate", "value32", "invalid", "tokenPos", "isBottom", "ht", "getBottom", "toString", "reason", "_Module", "ref", "useShadowStack", "sizeType", "cArr", "allocU8Array", "module", "valueLow", "valueHigh", "bytes", "op", "isWam64", "isWasm64", "is64", "cStr", "delta", "BuiltinNames", "isManaged", "signed", "ptr", "align", "expected", "replacement", "timeout", "expectedType", "notifyCount", "children", "ret", "stmts", "single", "singleType", "defaultName", "numNames", "strs", "target", "operands", "isReturn", "tableName", "params", "results", "dest", "size", "destName", "sourceName", "cStr1", "cStr2", "catchTags", "catchBodies", "delegateTarget", "numCatchTags", "cArr1", "cArr2", "tagName", "tuple", "vec", "vec1", "vec2", "mutable", "varTypes", "funcRef", "paramTypes", "tempName", "func", "internalName", "externalModuleName", "externalBaseName", "cStr3", "shared", "globalType", "initial", "maximum", "segments", "exportName", "segs", "psvs", "offs", "sizs", "segment", "cArr3", "cArr4", "allocU32Array", "funcs", "tableRef", "contents", "on", "key", "enabled", "featureFlags", "passes", "cStrs", "allocString", "optimizeLevel", "shrinkLevel", "debugInfo", "zeroFilledMemory", "sourceMapUrl", "resPtr", "urlPtr", "binaryPtr", "binaryLen", "srcMapPtr", "binary", "readBuffer", "watFormat", "textPtr", "cached", "_values", "maxDepth", "maxLoopIterations", "runner", "precomp", "fileIndex", "columnNumber", "types", "arity", "d", "id", "global", "from", "to", "indexes", "allocI32Array", "entry", "labelHelper", "localIndex", "labelPostfix", "numCases", "numValues", "labels", "defaultIndex", "defaultLabel", "current", "block", "lastCase", "u8s", "i32s", "val", "u32s", "ptrs", "stringLengthUTF8", "c1", "u", "c2", "u1", "u2", "u3", "ch", "output", "sourceMap", "numChildren", "DEBUG_TYPEBUILDER", "typeRef", "tryEnsureBasicType", "originalType", "builder", "prepareType", "errorIndex", "errorReason", "seenType", "heapType", "fullType", "determinePackedType", "classReference", "base", "baseRef", "heapTypeRef", "fieldTypes", "packedTypes", "fieldMutables", "member", "fieldType", "cArrFT", "cArrPT", "cArrFM", "signatureReference", "tempTypeRef", "resultTypes", "parameterTypes", "paramType", "tempParamType", "tempResultType", "cArrRT", "targetFunction", "inlineFunction", "flow", "condiFlags", "resetBreakContext", "branch", "thisFieldFlags", "local", "scopedLocals", "scopedLocal", "declarationNode", "scopedDummy", "reportNode", "existingLocal", "scopedAlias", "scope", "defaultIfInlined", "localFlags", "sourceFunction", "parent", "classInstance", "field", "fieldFlags", "stack", "otherFlags", "conditionKind", "thisFlags", "newFlags", "thisLocalFlags", "numThisLocalFlags", "otherLocalFlags", "numOtherLocalFlags", "maxLocalFlags", "leftFlags", "rightFlags", "rightLocalFlags", "leftLocalFlags", "numLeftLocalFlags", "numRightLocalFlags", "leftFieldFlags", "newFieldFlags", "rightFieldFlags", "numLocalsBefore", "localsByIndex", "needsRecompile", "iff", "canConversionOverflow", "fromType", "last", "instancesByName", "instanceName", "instance", "functionInstance", "levels", "program", "ctxElement", "ctxTypes", "reportMode", "isSimpleType", "simpleName", "element", "shadowType", "typeDefinition", "thisType", "numParameters", "requiredParameters", "hasRest", "parameterNode", "parameterTypeNode", "parameterType", "returnTypeNode", "typeArgumentNode", "typeArgument", "overload", "prev", "alternativeReportNode", "minParameterCount", "maxParameterCount", "argumentCount", "oldCtxTypes", "prototype", "ctxFlow", "contextualTypeArguments", "numTypeParameters", "typeParameterNames", "argumentNodes", "argumentExpression", "typeNode", "resolvedTypeArguments", "typeParameterNode", "inferredType", "defaultTypeContextualTypeArguments", "resolvedDefaultType", "classPrototype", "currentType", "wrappedType", "ctxType", "resolvingExpressions", "resolved", "outerFlow", "targetNode", "propertyName", "variableLikeElement", "propertyInstance", "indexedGet", "resolvedType", "wrapper", "basePrototype", "baseInstance", "lookupName", "targetExpression", "targetType", "indexSignature", "negate", "intValue", "leftType", "rightType", "commonType", "thisLocal", "superLocal", "intType", "fltType", "elementType", "numNullLiterals", "functionPrototype", "varType", "varElement", "ftype", "thenType", "elseType", "functionType", "tempFlow", "parameter", "actualParent", "instanceKey", "resolvedInstance", "classTypeArguments", "classTypeParameters", "numClassTypeArguments", "classTypeParameterName", "signatureNode", "numFunctionTypeArguments", "signatureParameters", "numSignatureParameters", "parameterDeclaration", "nameInclTypeParameters", "methodOrPropertyName", "baseClass", "baseMembers", "overloadPrototypes", "parentClassInstance", "overloads", "unboundOverloadPrototype", "unboundOverloadParent", "isProperty", "classInstances", "propertyParent", "j", "overloadInstance", "boundProperty", "boundPropertyInstance", "boundPrototype", "pendingClasses", "anyPending", "extendsNode", "interfacePrototypes", "interfacePrototype", "implementsNode", "iface", "unimplemented", "interfaces", "ifaceMembers", "memberName", "existing", "memoryOffset", "instanceMemberPrototypes", "properties", "fieldPrototype", "fieldTypeNode", "existingField", "baseField", "fieldInstance", "propertyGetter", "propertySetter", "ctorPrototype", "ctorInstance", "overloadKind", "overloadPrototype", "operatorInstance", "pending", "dependsOnInstance", "_values2", "getterPrototype", "getterInstance", "setterPrototype", "setterInstance", "Dependee", "sources", "isEntry", "dependees", "dependee", "tn", "namespace", "startPos", "exportStart", "exportEnd", "defaultStart", "defaultEnd", "declareStart", "declareEnd", "contextIsAmbient", "first", "abstractStart", "abstractEnd", "backlog", "dependent", "acceptParenthesized", "suppressErrors", "isNullableSignature", "innerType", "notNullStart", "notNull", "bracketStart", "bracketRange", "nullable", "isSignature", "firstParamNameNoType", "firstParamKind", "paramStart", "param", "isFor", "parentFlags", "parentDecorators", "seenOptional", "typeParameter", "isConstructor", "seenRest", "reportedRest", "isRest", "isOptional", "startRange", "accessFlags", "signatureStart", "isSetter", "explicitThis", "bodyExpression", "isInterface", "accessStart", "accessEnd", "staticStart", "staticEnd", "overrideStart", "overrideEnd", "readonlyStart", "readonlyEnd", "isGetter", "getStart", "getEnd", "setStart", "setEnd", "isGetterOrSetter", "retIndex", "typeParametersStart", "implicitFieldDeclaration", "retMethod", "retField", "currentSource", "exportPaths", "asIdentifier", "skipFrom", "topLevel", "elseStatement", "switchCases", "switchCase", "stmt", "identifierName", "depth", "fnType", "arguments_", "again", "inner", "identifierText", "regexpPattern", "precedence", "nextPrecedence", "determinePrecedence", "commaExprs", "exprs", "call", "callee", "potentiallyGeneric", "AL_SIZE", "AL_MASK", "QueuedImport", "localFile", "localIdentifier", "foreignIdentifier", "foreignPath", "foreignPathAlt", "QueuedExport", "QueuedExportStar", "pathLiteral", "fromDecorator", "fromBinaryToken", "fromUnaryPrefixToken", "fromUnaryPostfixToken", "options", "nativeSource", "nativeFile", "modifiedFunctionName", "currentOffset", "blockOverhead", "payloadSize", "blockSize", "blockMinsize", "blockMaxsize", "tagsMask", "decoratorFlags", "elementsByDeclaration", "queuedImports", "queuedExports", "queuedExportsStar", "queuedExtends", "queuedImplements", "file", "starExports", "exportStar", "foreignFile", "madeProgress", "queuedImport", "exports", "exportNames", "queuedExport", "globalElement", "resolver", "thisPrototype", "baseElement", "instanesMembers", "hasOverride", "instanceMembers", "implementsNodes", "interfaceElement", "globalAliases", "alias", "firstChar", "elementsByName", "thisInstanceMembers", "thisMembers", "baseInstanceMembers", "thisMember", "baseMember", "thisMethod", "baseMethod", "baseMethodInstances", "thisProperty", "baseProperty", "baseGetter", "thisGetter", "baseGetterInstances", "baseSetter", "thisSetter", "baseSetterInstances", "nextPrototype", "elements", "exportsStar", "propertyPrototype", "staticMembers", "moduleImports", "className", "wrapperClasses", "classElement", "merged", "tryMerge", "filesByName", "fileQueuedExports", "queuedExportForeignPath", "otherFile", "acceptedFlags", "numImplementsTypes", "memberDeclarations", "memberDeclaration", "methodDeclaration", "method", "isStatic", "numArgs", "firstArg", "parentMembers", "queued", "validDecorators", "original", "copyMembers", "fromKind", "localIdentifierIfImport", "originalDeclaration", "reportedIdentifier", "vis", "declaredElements", "identifierNode", "self", "checkCompatibleOverride", "selfFunction", "baseFunction", "selfProperty", "selfGetter", "selfSetter", "typedElements", "startFunction", "ns", "parentKind", "boundPrototypes", "bound", "instances", "parameterName", "registerConcreteElement", "numTotal", "numFixed", "numAdditional", "postfix", "stub", "defaultFlow", "breakStack", "debugLocations", "localNameMap", "firstDeclaration", "isUnchecked", "_isInterface", "arrayBufferViewInstance", "basePtototype", "usizeType", "lengthField", "extendees", "inheritedTypeArguments", "baseName", "baseType", "implementers", "unchecked", "uncheckedOverload", "fieldName", "overhead", "OBJECT", "baseOffset", "typeKind", "extendedPrototype", "arrayPrototype", "staticArrayPrototype", "abvInstance", "exceptIfMember", "extendee", "older", "newer", "olderIsExport", "newerIsExport", "src", "srcMembers", "destMembers", "isInstance", "asGlobal", "cachedDefaultParameterNames", "_Type", "nullableType", "signednessIsRelevant", "currentClass", "targetClass", "currentFunction", "thisClass", "signednessIsImportant", "validWat", "nullablePostfix", "numTypes", "signatureTypes", "compare", "numParameterTypes", "typeRefs", "thisThisType", "otherThisType", "thisParameterTypes", "otherParameterTypes", "thisParameterType", "otherParameterType", "targetThisType", "thisReturnType", "targetReturnType", "targetParameterTypes", "targetParameterType", "indices", "optionalStart", "restIndex", "cloneParameterTypes", "BuiltinContext", "compiler", "thisOperand", "contextualType", "contextIsExact", "builtins", "function_builtins", "guard_id_counter", "builtin_isBoolean", "ctx", "checkConstantType", "reifyConstantType", "builtin_isInteger", "builtin_isSigned", "builtin_isFloat", "builtin_isVector", "builtin_isReference", "builtin_isString", "builtin_isArray", "builtin_isArrayLike", "builtin_isFunction", "builtin_isNullable", "builtin_isDefined", "checkTypeAbsent", "checkArgsRequired", "builtin_isConstant", "builtin_isManaged", "builtin_isVoid", "builtin_lengthof", "builtin_sizeof", "checkTypeRequired", "byteSize", "contextualUsize", "builtin_alignof", "builtin_offsetof", "checkArgsOptional", "firstOperand", "classMembers", "builtin_nameof", "resultType", "builtin_idof", "builtin_bswap", "checkTypeOptional", "temp", "temp1", "temp2", "builtin_clz", "builtin_ctz", "builtin_popcnt", "builtin_rotl", "builtin_rotr", "builtin_abs", "builtin_max", "builtin_min", "builtin_ceil", "builtin_floor", "builtin_copysign", "builtin_nearest", "builtin_reinterpret", "builtin_sqrt", "builtin_trunc", "builtin_isNaN", "builtin_isFinite", "builtin_load", "outType", "numOperands", "immOffset", "immAlign", "evaluateImmediateOffset", "evaluateImmediateAlign", "builtin_store", "inType", "builtin_rem", "builtin_add", "builtin_sub", "builtin_mul", "builtin_div", "builtin_eq", "builtin_ne", "builtin_atomic_load", "checkFeatureEnabled", "builtin_atomic_store", "builtin_atomic_binary", "opName", "builtin_atomic_add", "builtin_atomic_sub", "builtin_atomic_and", "builtin_atomic_or", "builtin_atomic_xor", "builtin_atomic_xchg", "builtin_atomic_cmpxchg", "builtin_atomic_wait", "builtin_atomic_notify", "builtin_atomic_fence", "builtin_select", "builtin_unreachable", "builtin_memory_size", "builtin_memory_grow", "builtin_memory_copy", "builtin_memory_fill", "builtin_memory_data", "valuesOperand", "numElements", "buf", "builtin_i31_new", "builtin_i31_get", "builtin_changetype", "builtin_assert", "evaled", "abort", "builtin_unchecked", "alreadyUnchecked", "builtin_call_indirect", "indexArg", "operandExprs", "paramTypeRefs", "builtin_instantiate", "ctor", "builtin_diagnostic", "builtin_error", "builtin_warning", "builtin_info", "builtin_function_call", "functionArg", "thisArg", "builtin_string_raw", "builtin_max_iterations", "maxiter", "gid", "incremented", "builtin_conversion", "builtin_i8", "builtin_i16", "builtin_i32", "builtin_i64", "builtin_isize", "builtin_u8", "builtin_u16", "builtin_u32", "builtin_u64", "builtin_usize", "builtin_bool", "builtin_f32", "builtin_f64", "builtin_v128", "builtin_i8x16", "vars", "numVars", "fullVars", "builtin_i16x8", "builtin_i32x4", "builtin_i64x2", "builtin_f32x4", "builtin_f64x2", "builtin_v128_splat", "builtin_v128_extract_lane", "maxIdx", "builtin_v128_replace_lane", "builtin_v128_shuffle", "laneWidth", "laneCount", "argN", "off8", "idx8", "builtin_v128_swizzle", "builtin_v128_load_splat", "builtin_v128_load_ext", "builtin_v128_load_zero", "builtin_v128_load_lane", "builtin_v128_store_lane", "builtin_v128_add", "builtin_v128_sub", "builtin_v128_mul", "builtin_v128_div", "builtin_v128_add_sat", "builtin_v128_sub_sat", "builtin_v128_min", "builtin_v128_max", "builtin_v128_pmin", "builtin_v128_pmax", "builtin_v128_dot", "builtin_v128_avgr", "builtin_v128_eq", "builtin_v128_ne", "builtin_v128_lt", "builtin_v128_le", "builtin_v128_gt", "builtin_v128_ge", "builtin_v128_narrow", "builtin_v128_neg", "builtin_v128_abs", "builtin_v128_sqrt", "builtin_v128_ceil", "builtin_v128_floor", "builtin_v128_trunc", "builtin_v128_nearest", "builtin_v128_convert", "builtin_v128_convert_low", "builtin_v128_trunc_sat", "builtin_v128_trunc_sat_zero", "builtin_v128_extend_low", "builtin_v128_extend_high", "builtin_v128_shl", "builtin_v128_shr", "builtin_v128_bitwise_binary", "builtin_v128_and", "builtin_v128_or", "builtin_v128_xor", "builtin_v128_andnot", "builtin_v128_bitwise_unary", "builtin_v128_not", "builtin_v128_bitwise_ternary", "builtin_v128_bitselect", "builtin_v128_any_true", "builtin_v128_all_true", "builtin_v128_bitmask", "builtin_v128_popcnt", "builtin_v128_extadd_pairwise", "builtin_v128_demote_zero", "builtin_v128_promote_low", "builtin_v128_q15mulr_sat", "builtin_v128_extmul_low", "builtin_v128_extmul_high", "builtin_visit_globals", "builtin_visit_members", "builtin_i32_clz", "builtin_i64_clz", "builtin_i32_ctz", "builtin_i64_ctz", "builtin_i32_popcnt", "builtin_i64_popcnt", "builtin_i32_rotl", "builtin_i64_rotl", "builtin_i32_rotr", "builtin_i64_rotr", "builtin_f32_abs", "builtin_f64_abs", "builtin_f32_max", "builtin_f64_max", "builtin_f32_min", "builtin_f64_min", "builtin_f32_ceil", "builtin_f64_ceil", "builtin_f32_floor", "builtin_f64_floor", "builtin_f32_copysign", "builtin_f64_copysign", "builtin_f32_nearest", "builtin_f64_nearest", "builtin_i32_reinterpret_f32", "builtin_i64_reinterpret_f64", "builtin_f32_reinterpret_i32", "builtin_f64_reinterpret_i64", "builtin_f32_sqrt", "builtin_f64_sqrt", "builtin_f32_trunc", "builtin_f64_trunc", "builtin_i32_rem_s", "builtin_i32_rem_u", "builtin_i64_rem_s", "builtin_i64_rem_u", "builtin_i32_add", "builtin_i64_add", "builtin_f32_add", "builtin_f64_add", "builtin_i32_sub", "builtin_i64_sub", "builtin_f32_sub", "builtin_f64_sub", "builtin_i32_mul", "builtin_i64_mul", "builtin_f32_mul", "builtin_f64_mul", "builtin_i32_div_s", "builtin_i32_div_u", "builtin_i64_div_s", "builtin_i64_div_u", "builtin_f32_div", "builtin_f64_div", "builtin_i32_eq", "builtin_i64_eq", "builtin_f32_eq", "builtin_f64_eq", "builtin_i32_ne", "builtin_i64_ne", "builtin_f32_ne", "builtin_f64_ne", "builtin_i32_load8_s", "builtin_i32_load8_u", "builtin_i32_load16_s", "builtin_i32_load16_u", "builtin_i32_load", "builtin_i64_load8_s", "builtin_i64_load8_u", "builtin_i64_load16_s", "builtin_i64_load16_u", "builtin_i64_load32_s", "builtin_i64_load32_u", "builtin_i64_load", "builtin_f32_load", "builtin_f64_load", "builtin_i32_store8", "builtin_i32_store16", "builtin_i32_store", "builtin_i64_store8", "builtin_i64_store16", "builtin_i64_store32", "builtin_i64_store", "builtin_f32_store", "builtin_f64_store", "builtin_i32_atomic_load8_u", "builtin_i32_atomic_load16_u", "builtin_i32_atomic_load", "builtin_i64_atomic_load8_u", "builtin_i64_atomic_load16_u", "builtin_i64_atomic_load32_u", "builtin_i64_atomic_load", "builtin_i32_atomic_store8", "builtin_i32_atomic_store16", "builtin_i32_atomic_store", "builtin_i64_atomic_store8", "builtin_i64_atomic_store16", "builtin_i64_atomic_store32", "builtin_i64_atomic_store", "builtin_i32_atomic_rmw8_add_u", "builtin_i32_atomic_rmw16_add_u", "builtin_i32_atomic_rmw_add", "builtin_i64_atomic_rmw8_add_u", "builtin_i64_atomic_rmw16_add_u", "builtin_i64_atomic_rmw32_add_u", "builtin_i64_atomic_rmw_add", "builtin_i32_atomic_rmw8_sub_u", "builtin_i32_atomic_rmw16_sub_u", "builtin_i32_atomic_rmw_sub", "builtin_i64_atomic_rmw8_sub_u", "builtin_i64_atomic_rmw16_sub_u", "builtin_i64_atomic_rmw32_sub_u", "builtin_i64_atomic_rmw_sub", "builtin_i32_atomic_rmw8_and_u", "builtin_i32_atomic_rmw16_and_u", "builtin_i32_atomic_rmw_and", "builtin_i64_atomic_rmw8_and_u", "builtin_i64_atomic_rmw16_and_u", "builtin_i64_atomic_rmw32_and_u", "builtin_i64_atomic_rmw_and", "builtin_i32_atomic_rmw8_or_u", "builtin_i32_atomic_rmw16_or_u", "builtin_i32_atomic_rmw_or", "builtin_i64_atomic_rmw8_or_u", "builtin_i64_atomic_rmw16_or_u", "builtin_i64_atomic_rmw32_or_u", "builtin_i64_atomic_rmw_or", "builtin_i32_atomic_rmw8_xor_u", "builtin_i32_atomic_rmw16_xor_u", "builtin_i32_atomic_rmw_xor", "builtin_i64_atomic_rmw8_xor_u", "builtin_i64_atomic_rmw16_xor_u", "builtin_i64_atomic_rmw32_xor_u", "builtin_i64_atomic_rmw_xor", "builtin_i32_atomic_rmw8_xchg_u", "builtin_i32_atomic_rmw16_xchg_u", "builtin_i32_atomic_rmw_xchg", "builtin_i64_atomic_rmw8_xchg_u", "builtin_i64_atomic_rmw16_xchg_u", "builtin_i64_atomic_rmw32_xchg_u", "builtin_i64_atomic_rmw_xchg", "builtin_i32_atomic_rmw8_cmpxchg_u", "builtin_i32_atomic_rmw16_cmpxchg_u", "builtin_i32_atomic_rmw_cmpxchg", "builtin_i64_atomic_rmw8_cmpxchg_u", "builtin_i64_atomic_rmw16_cmpxchg_u", "builtin_i64_atomic_rmw32_cmpxchg_u", "builtin_i64_atomic_rmw_cmpxchg", "builtin_i32_wait", "builtin_i64_wait", "builtin_v128_load", "builtin_v128_load8x8_s", "builtin_v128_load8x8_u", "builtin_v128_load16x4_s", "builtin_v128_load16x4_u", "builtin_v128_load32x2_s", "builtin_v128_load32x2_u", "builtin_v128_load8_splat", "builtin_v128_load16_splat", "builtin_v128_load32_splat", "builtin_v128_load64_splat", "builtin_v128_load32_zero", "builtin_v128_load64_zero", "builtin_v128_load8_lane", "builtin_v128_load16_lane", "builtin_v128_load32_lane", "builtin_v128_load64_lane", "builtin_v128_store8_lane", "builtin_v128_store16_lane", "builtin_v128_store32_lane", "builtin_v128_store64_lane", "builtin_v128_store", "builtin_i8x16_splat", "builtin_i8x16_extract_lane_s", "builtin_i8x16_extract_lane_u", "builtin_i8x16_replace_lane", "builtin_i8x16_add", "builtin_i8x16_sub", "builtin_i8x16_min_s", "builtin_i8x16_min_u", "builtin_i8x16_max_s", "builtin_i8x16_max_u", "builtin_i8x16_avgr_u", "builtin_i8x16_abs", "builtin_i8x16_neg", "builtin_i8x16_add_sat_s", "builtin_i8x16_add_sat_u", "builtin_i8x16_sub_sat_s", "builtin_i8x16_sub_sat_u", "builtin_i8x16_shl", "builtin_i8x16_shr_s", "builtin_i8x16_shr_u", "builtin_i8x16_all_true", "builtin_i8x16_bitmask", "builtin_i8x16_popcnt", "builtin_i8x16_eq", "builtin_i8x16_ne", "builtin_i8x16_lt_s", "builtin_i8x16_lt_u", "builtin_i8x16_le_s", "builtin_i8x16_le_u", "builtin_i8x16_gt_s", "builtin_i8x16_gt_u", "builtin_i8x16_ge_s", "builtin_i8x16_ge_u", "builtin_i8x16_narrow_i16x8_s", "builtin_i8x16_narrow_i16x8_u", "builtin_i8x16_shuffle", "builtin_i8x16_swizzle", "builtin_i16x8_splat", "builtin_i16x8_extract_lane_s", "builtin_i16x8_extract_lane_u", "builtin_i16x8_replace_lane", "builtin_i16x8_add", "builtin_i16x8_sub", "builtin_i16x8_mul", "builtin_i16x8_min_s", "builtin_i16x8_min_u", "builtin_i16x8_max_s", "builtin_i16x8_max_u", "builtin_i16x8_avgr_u", "builtin_i16x8_abs", "builtin_i16x8_neg", "builtin_i16x8_add_sat_s", "builtin_i16x8_add_sat_u", "builtin_i16x8_sub_sat_s", "builtin_i16x8_sub_sat_u", "builtin_i16x8_shl", "builtin_i16x8_shr_s", "builtin_i16x8_shr_u", "builtin_i16x8_all_true", "builtin_i16x8_bitmask", "builtin_i16x8_eq", "builtin_i16x8_ne", "builtin_i16x8_lt_s", "builtin_i16x8_lt_u", "builtin_i16x8_le_s", "builtin_i16x8_le_u", "builtin_i16x8_gt_s", "builtin_i16x8_gt_u", "builtin_i16x8_ge_s", "builtin_i16x8_ge_u", "builtin_i16x8_narrow_i32x4_s", "builtin_i16x8_narrow_i32x4_u", "builtin_i16x8_extend_low_i8x16_s", "builtin_i16x8_extend_low_i8x16_u", "builtin_i16x8_extend_high_i8x16_s", "builtin_i16x8_extend_high_i8x16_u", "builtin_i16x8_extadd_pairwise_i8x16_s", "builtin_i16x8_extadd_pairwise_i8x16_u", "builtin_i16x8_q15mulr_sat_s", "builtin_i16x8_extmul_low_i8x16_s", "builtin_i16x8_extmul_low_i8x16_u", "builtin_i16x8_extmul_high_i8x16_s", "builtin_i16x8_extmul_high_i8x16_u", "builtin_i16x8_shuffle", "builtin_i16x8_swizzle", "builtin_i32x4_splat", "builtin_i32x4_extract_lane", "builtin_i32x4_replace_lane", "builtin_i32x4_add", "builtin_i32x4_sub", "builtin_i32x4_mul", "builtin_i32x4_min_s", "builtin_i32x4_min_u", "builtin_i32x4_max_s", "builtin_i32x4_max_u", "builtin_i32x4_dot_i16x8_s", "builtin_i32x4_abs", "builtin_i32x4_neg", "builtin_i32x4_shl", "builtin_i32x4_shr_s", "builtin_i32x4_shr_u", "builtin_i32x4_all_true", "builtin_i32x4_bitmask", "builtin_i32x4_eq", "builtin_i32x4_ne", "builtin_i32x4_lt_s", "builtin_i32x4_lt_u", "builtin_i32x4_le_s", "builtin_i32x4_le_u", "builtin_i32x4_gt_s", "builtin_i32x4_gt_u", "builtin_i32x4_ge_s", "builtin_i32x4_ge_u", "builtin_i32x4_trunc_sat_f32x4_s", "builtin_i32x4_trunc_sat_f32x4_u", "builtin_i32x4_trunc_sat_f64x2_s_zero", "builtin_i32x4_trunc_sat_f64x2_u_zero", "builtin_i32x4_extend_low_i16x8_s", "builtin_i32x4_extend_low_i16x8_u", "builtin_i32x4_extend_high_i16x8_s", "builtin_i32x4_extend_high_i16x8_u", "builtin_i32x4_extadd_pairwise_i16x8_s", "builtin_i32x4_extadd_pairwise_i16x8_u", "builtin_i32x4_extmul_low_i16x8_s", "builtin_i32x4_extmul_low_i16x8_u", "builtin_i32x4_extmul_high_i16x8_s", "builtin_i32x4_extmul_high_i16x8_u", "builtin_i32x4_shuffle", "builtin_i32x4_swizzle", "builtin_i64x2_splat", "builtin_i64x2_extract_lane", "builtin_i64x2_replace_lane", "builtin_i64x2_add", "builtin_i64x2_sub", "builtin_i64x2_mul", "builtin_i64x2_abs", "builtin_i64x2_neg", "builtin_i64x2_shl", "builtin_i64x2_shr_s", "builtin_i64x2_shr_u", "builtin_i64x2_all_true", "builtin_i64x2_bitmask", "builtin_i64x2_eq", "builtin_i64x2_ne", "builtin_i64x2_lt_s", "builtin_i64x2_le_s", "builtin_i64x2_gt_s", "builtin_i64x2_ge_s", "builtin_i64x2_extend_low_i32x4_s", "builtin_i64x2_extend_low_i32x4_u", "builtin_i64x2_extend_high_i32x4_s", "builtin_i64x2_extend_high_i32x4_u", "builtin_i64x2_extmul_low_i32x4_s", "builtin_i64x2_extmul_low_i32x4_u", "builtin_i64x2_extmul_high_i32x4_s", "builtin_i64x2_extmul_high_i32x4_u", "builtin_i64x2_shuffle", "builtin_i64x2_swizzle", "builtin_f32x4_splat", "builtin_f32x4_extract_lane", "builtin_f32x4_replace_lane", "builtin_f32x4_add", "builtin_f32x4_sub", "builtin_f32x4_mul", "builtin_f32x4_div", "builtin_f32x4_neg", "builtin_f32x4_min", "builtin_f32x4_max", "builtin_f32x4_pmin", "builtin_f32x4_pmax", "builtin_f32x4_abs", "builtin_f32x4_sqrt", "builtin_f32x4_ceil", "builtin_f32x4_floor", "builtin_f32x4_trunc", "builtin_f32x4_nearest", "builtin_f32x4_eq", "builtin_f32x4_ne", "builtin_f32x4_lt", "builtin_f32x4_le", "builtin_f32x4_gt", "builtin_f32x4_ge", "builtin_f32x4_convert_i32x4_s", "builtin_f32x4_convert_i32x4_u", "builtin_f32x4_demote_f64x2_zero", "builtin_f32x4_shuffle", "builtin_f32x4_swizzle", "builtin_f64x2_splat", "builtin_f64x2_extract_lane", "builtin_f64x2_replace_lane", "builtin_f64x2_add", "builtin_f64x2_sub", "builtin_f64x2_mul", "builtin_f64x2_div", "builtin_f64x2_neg", "builtin_f64x2_min", "builtin_f64x2_max", "builtin_f64x2_pmin", "builtin_f64x2_pmax", "builtin_f64x2_abs", "builtin_f64x2_sqrt", "builtin_f64x2_ceil", "builtin_f64x2_floor", "builtin_f64x2_trunc", "builtin_f64x2_nearest", "builtin_f64x2_eq", "builtin_f64x2_ne", "builtin_f64x2_lt", "builtin_f64x2_le", "builtin_f64x2_gt", "builtin_f64x2_ge", "builtin_f64x2_convert_low_i32x4_s", "builtin_f64x2_convert_low_i32x4_u", "builtin_f64x4_promote_low_f32x4", "builtin_f64x2_shuffle", "builtin_f64x2_swizzle", "compileVisitGlobals", "sizeTypeRef", "visitInstance", "ensureVisitMembersOf", "sizeTypeSize", "hasVisitImpl", "visitPrototype", "visitSignature", "visitThisType", "needsTempValue", "fieldOffset", "compileVisitMembers", "managedClasses", "nextId", "instanceId", "typeToRuntimeFlags", "compileRTTI", "data", "abvPrototype", "setPrototype", "mapPrototype", "lastId", "compileClassInstanceOf", "instanceofInstance", "checkConstantType_expr", "naturalAlign", "setCurrentTypeOnError", "expectedMinimum", "expectedMaximum", "Visitor", "currentExpression", "previousExpression", "numCatchBodies", "init", "Pass", "currentGlobal", "moduleRef", "replaceChild", "child", "repl", "catchBody", "i31Expr", "destRef", "destIndex", "srcRef", "srcIndex", "num", "RtraceMemory", "store", "matchPattern", "needsSlot", "ShadowStackPass", "slotMap", "slotIndex", "managedOperandIndices", "tempMap", "frameSize", "numSlots", "match", "numLocals", "callIndirect", "localSet", "tempMaps", "newFuncRef", "exportRef", "internalNameRef", "externalNameRef", "numParams", "wrapperName", "wrapperNameRef", "forwardedOperands", "tempIndex", "instrumentReturns", "InstrumentReturns", "bodyType", "exportMap", "shadowStack", "ExportsWalker", "includePrivate", "hasCompiledMember", "esm", "isPlainValue", "Mode", "moduleId", "isPlainFunction", "parameterNames", "indentText", "numReferences", "releases", "needsRetainRelease", "originalName", "codeArg", "literal", "insertPos", "sbLengthBefore", "resetPos", "numInstrumented", "_keys2", "elem", "hasAdaptedImports", "mappings", "hasAdaptedExports", "deferredCode", "objectInstance", "rtSizeOffset", "arrayBufferId", "chunkSize", "stringId", "dataStartOffset", "lengthOffset", "arraySize", "bufferOffset", "byteLengthOffset", "needsMaybeDefault", "importExpr", "importMap", "clazz", "isPlainObject", "prevIndentLevel", "targetName", "valueName", "skipTail", "mode", "inverseMode", "indentLevel", "butFirst", "lineStart", "liftRequiresExportRuntime", "lowerRequiresExportRuntime", "runtimeFunctions", "runtimeGlobals", "startFunctionInstance", "hasShadowStack", "startFunctionBody", "files", "lazyFunctions", "functionsToCompile", "functionTable", "virtualStubs", "virtualStubsSeen", "overloadInstances", "startIsEmpty", "memorySegments", "initialPages", "maximumPages", "isSharedMemory", "lowMemoryLimit32", "lowMemoryLimit", "tableBase", "functionTableNames", "initialTableSize", "maximumTableSize", "elementName", "prefix", "subPrefix", "enumValue", "normalizedPathWithoutExtension", "pathWithIndex", "startSignature", "previousBody", "previousFlow", "locals", "pendingElements", "initExpr", "initializerNode", "isDeclaredConstant", "isDeclaredInline", "mangleImportName", "mangleImportName_moduleName", "mangleImportName_elementName", "initializeInStart", "fromName", "previousParent", "previousValue", "previousValueIsMut", "isInline", "initInStart", "valueNode", "forceStdAlternative", "visited", "paramIdentifier", "paramName", "previousType", "bodyNode", "decoratorNodes", "fnTypeNode", "firstIndex", "bodyStartIndex", "allocStmts", "valueTypeRef", "thisTypeRef", "bodyExpr", "linkInstance", "stringValue", "totalOverhead", "stringInstance", "stringSegment", "u8", "elementTypeRef", "bufferSegment", "arrayInstance", "bufferLength", "arrayLength", "bufferAddress", "memorySegment", "rtInstance", "memberStatements", "exportStatement", "importStatement", "isLastInBody", "isBody", "numStatements", "innerFlow", "labelNode", "breakLabel", "continueLabel", "loopLabel", "bodyFlow", "bodyStmts", "possiblyContinues", "condFlow", "condExpr", "condKind", "tcond", "loopStmts", "ifStmts", "incrFlow", "thenStmts", "thenFlow", "elseStmts", "elseFlow", "valueExpression", "constraints", "context", "tempLocalIndex", "breaks", "breakIndex", "currentBlock", "commonCategorical", "commonConditional", "isLast", "nextLabel", "terminates", "newArgs", "numDeclarations", "initializers", "dummy", "isConst", "compiled", "wrap", "explicit", "saturating", "inheritedConstraints", "leftExpr", "rightExpr", "compound", "rightFlow", "tempLocal", "leftValue", "rightValue", "namespaceMembers", "valueExpr", "cmp", "exprOp", "thisExpression", "indexedSet", "indexExpression", "tee", "fieldParent", "thisExpr", "returnTypeRef", "tempThis", "setterIndexType", "getterIndexType", "elementExpr", "tempTarget", "tempElement", "fieldTypeRef", "baseClassInstance", "baseCtorInstance", "superCall", "inlinedValue", "methodName", "hasThis", "minimum", "relatedReportNode", "argumentExpressions", "inlineStack", "numArgumentsInclThis", "paramExpr", "immediatelyDropped", "argumentLocal", "initType", "originalSignature", "originalParameterTypes", "originalParameterDeclarations", "minArguments", "minOperands", "maxArguments", "maxOperands", "numOptional", "operandIndex", "ofN", "argumentsLength", "table", "overloadType", "overloadSignature", "overloadParameterTypes", "overloadNumParameters", "paramExprs", "needsVarargsStub", "calledName", "theOperands", "allOptionalsAreConstant", "lastOperand", "lastOperandType", "numExpressions", "isNamed", "isSemanticallyAnonymous", "contextualSignature", "numPresentParameters", "thisTypeNode", "worked", "fname", "scopedThis", "superType", "currentParent", "localType", "namedType", "actualType", "implicitlyNegate", "floatValue", "sign", "numParts", "stringType", "totalLength", "callIdent", "literalSegment", "curLength", "tsaArrayInstance", "partExprs", "arraySegment", "rawExprs", "rawHeaderSegment", "contextualClass", "arrayType", "arrayBufferInstance", "tempDataStart", "arrayAddress", "arrayTypeRef", "dataStartMember", "bufferSize", "classType", "hasErrors", "classTypeRef", "omittedFields", "memberKey", "baseCtor", "relatedNode", "parentEnum", "ifThenFlow", "ifThenExpr", "ifThenType", "ifElseFlow", "ifElseExpr", "ifElseType", "getValue", "setValue", "typeString", "supported", "parameterReportNode", "toStringInstance", "toStringSignature", "toStringReturnType", "allocInstance", "newInstance", "thisIndex", "thisLocalIndex", "nonParameterFields", "codeLocation", "abortInstance", "messageArg", "messageExpr", "staticAbortCallExpr", "nonNullExpr", "overriddenModuleName", "tsType", "deferredTypes", "seenObjectTypes", "isPlain", "runtime", "noAssert", "exportMemory", "importMemory", "initialMemory", "maximumMemory", "sharedMemory", "importTable", "exportTable", "memoryBase", "noUnsafe", "exportRuntime", "stackSize", "bundleMajorVersion", "bundleMinorVersion", "bundlePatchVersion", "basename", "bindings", "pedantic", "debug", "diagnostic", "hasExplicitSign", "lastCharPos", "isDefault", "numMembers", "src_default", "assemblyscript", "assemblyscript_exports", "wasmPos", "process", "wasmPath", "url", "require", "module", "WIN", "EOL", "SEP", "extension", "extension_d", "extension_re", "extension_re_except_d", "toUpperSnakeCase", "str", "isNonEmptyString", "value", "version", "options", "libraryPrefix", "libraryFiles", "definitionFiles", "defaultOptimizeLevel", "defaultShrinkLevel", "configToArguments", "argv", "key", "val", "opt", "compileString", "sources", "config", "output", "result", "main", "name", "contents", "stats", "Stats", "statsBegin", "bundleMinorVersion", "bundleMajorVersion", "bundlePatchVersion", "versionParts", "stdout", "createMemoryStream", "stderr", "readFile", "readFileNode", "writeFile", "writeFileNode", "listFiles", "listFilesNode", "optionsResult", "parse", "opts", "stdoutColors", "Colors", "stderrColors", "unknownOpts", "arg", "trailingArgv", "binaryenModule", "prepareResult", "error", "baseDir", "path", "configPath", "resolvePath", "configFile", "configDir", "getConfig", "configHasEntries", "out", "colors", "help", "fs", "seenAsconfig", "target", "targetOptions", "merge", "generalOptions", "entry", "addDefaults", "unique", "values", "program", "runtime", "compilerOptions", "aliases", "i", "k", "part", "p", "alias", "features", "flag", "optimizeLevel", "shrinkLevel", "transforms", "transformArgs", "filename", "resolved", "transform", "e1", "e", "applyTransform", "args", "start", "libPath", "begin", "customLibDirs", "lib", "libDir", "libFiles", "libText", "packageBases", "getFile", "internalPath", "dependeePath", "sourceText", "sourcePath", "plainName", "indexName", "match", "packageName", "filePath", "basePath", "paths", "parts", "currentDir", "getBacklog", "parseBacklog", "backlog", "files", "dependee", "file", "numErrors", "checkDiagnostics", "err", "runtimeName", "runtimePath", "runtimeText", "code", "crash", "default", "isValid", "debugInfo", "converge", "zeroFilledMemory", "runPasses", "pass", "last", "next", "pending", "bindings", "hasStdout", "hasOutFile", "hasTextFile", "hasOutput", "hasFileOutput", "basepath", "basename", "sourceMapURL", "wasm", "writeStdout", "map", "text", "bindingsEsm", "bindingsRaw", "source", "dirPath", "dirname", "stage", "BAR", "isObject", "location", "targets", "disableWarning", "reportDiagnostic", "useColors", "diagnostic", "isDisabledWarning", "wrapRange", "range", "wrapSource", "hrtime", "formatTime", "time", "keys", "times", "counts", "keysLen", "current", "timesLen", "countsLen", "count", "totalLen", "header", "totalTime", "readsWrites", "allocBuffer", "len", "fn", "stream", "chunk", "buffer", "utf8", "offset", "tscOptions"]
}
