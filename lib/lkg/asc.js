
/**
 * @license
 * The AssemblyScript frontend
 * Copyright 2023 Daniel Wirtz / The AssemblyScript Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var uc=Object.defineProperty;var U1=Object.getOwnPropertyDescriptor;var P1=Object.getOwnPropertyNames;var V1=Object.prototype.hasOwnProperty;var lr=(e,n)=>()=>(e&&(n=e(e=0)),n);var Mn=(e,n)=>{for(var t in n)uc(e,t,{get:n[t],enumerable:!0})},lc=(e,n,t,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of P1(n))!V1.call(e,i)&&i!==t&&uc(e,i,{get:()=>n[i],enumerable:!(r=U1(n,i))||r.enumerable});return e},bs=(e,n,t)=>(lc(e,n,"default"),t&&lc(t,n,"default"));var cc={};Mn(cc,{promises:()=>G1});var G1,fc=lr(()=>{"use strict";G1={}});var pc={};Mn(pc,{createRequire:()=>q1});function q1(){return function(n){throw new Error(`Cannot find module: '${n}'`)}}var hc=lr(()=>{"use strict"});var Es={};Mn(Es,{argv:()=>H1,cwd:()=>vs,exit:()=>X1,hrtime:()=>$1,platform:()=>j1,umask:()=>W1});function vs(){return"."}function W1(){return 0}function X1(e=0){throw Error(`exit ${e}`)}function $1(e){var n=K1.call(dc),t=Math.floor(n*.001),r=Math.floor(n*1e6-t*1e9);return e&&(t-=e[0],r-=e[1],r<0&&(t--,r+=1e9)),[t,r]}var j1,H1,dc,K1,Fs=lr(()=>{"use strict";j1="linux";H1=[];dc=globalThis.performance||{},K1=dc.now||function(){return new Date().getTime()}});var Ts={};Mn(Ts,{basename:()=>nh,delimiter:()=>sh,dirname:()=>eh,extname:()=>th,format:()=>rh,isAbsolute:()=>Z1,join:()=>J1,normalize:()=>gc,parse:()=>ih,relative:()=>Q1,resolve:()=>ur,sep:()=>As,win32:()=>ah});function ln(e){if(typeof e!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(e))}function xc(e,n){for(var t="",r=0,i=-1,s=0,a,o=0;o<=e.length;++o){if(o<e.length)a=e.charCodeAt(o);else{if(a===47)break;a=47}if(a===47){if(!(i===o-1||s===1))if(i!==o-1&&s===2){if(t.length<2||r!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){var u=t.lastIndexOf("/");if(u!==t.length-1){u===-1?(t="",r=0):(t=t.slice(0,u),r=t.length-1-t.lastIndexOf("/")),i=o,s=0;continue}}else if(t.length===2||t.length===1){t="",r=0,i=o,s=0;continue}}n&&(t.length>0?t+="/..":t="..",r=2)}else t.length>0?t+="/"+e.slice(i+1,o):t=e.slice(i+1,o),r=o-i-1;i=o,s=0}else a===46&&s!==-1?++s:s=-1}return t}function Y1(e,n){var t=n.dir||n.root,r=n.base||(n.name||"")+(n.ext||"");return t?t===n.root?t+r:t+e+r:r}function ur(){for(var e="",n=!1,t,r=arguments.length-1;r>=-1&&!n;r--){var i;r>=0?i=arguments[r]:(t===void 0&&(t=vs()),i=t),ln(i),i.length!==0&&(e=i+"/"+e,n=i.charCodeAt(0)===47)}return e=xc(e,!n),n?e.length>0?"/"+e:"/":e.length>0?e:"."}function gc(e){if(ln(e),e.length===0)return".";var n=e.charCodeAt(0)===47,t=e.charCodeAt(e.length-1)===47;return e=xc(e,!n),e.length===0&&!n&&(e="."),e.length>0&&t&&(e+="/"),n?"/"+e:e}function Z1(e){return ln(e),e.length>0&&e.charCodeAt(0)===47}function J1(){if(arguments.length===0)return".";for(var e,n=0;n<arguments.length;++n){var t=arguments[n];ln(t),t.length>0&&(e===void 0?e=t:e+="/"+t)}return e===void 0?".":gc(e)}function Q1(e,n){if(ln(e),ln(n),e===n||(e=ur(e),n=ur(n),e===n))return"";if(e===".")return n;for(var t=1;t<e.length&&e.charCodeAt(t)===47;++t);for(var r=e.length,i=r-t,s=1;s<n.length&&n.charCodeAt(s)===47;++s);for(var a=n.length,o=a-s,u=i<o?i:o,c=-1,f=0;f<=u;++f){if(f===u){if(o>u){if(n.charCodeAt(s+f)===47)return n.slice(s+f+1);if(f===0)return n.slice(s+f)}else i>u&&(e.charCodeAt(t+f)===47?c=f:f===0&&(c=0));break}var p=e.charCodeAt(t+f),d=n.charCodeAt(s+f);if(p!==d)break;p===47&&(c=f)}var m="";for(f=t+c+1;f<=r;++f)(f===r||e.charCodeAt(f)===47)&&(m.length===0?m+="..":m+="/..");return m.length>0?m+n.slice(s+c):(s+=c,n.charCodeAt(s)===47&&++s,n.slice(s))}function eh(e){if(ln(e),e.length===0)return".";for(var n=e.charCodeAt(0),t=n===47,r=-1,i=!0,s=e.length-1;s>=1;--s)if(n=e.charCodeAt(s),n===47){if(!i){r=s;break}}else i=!1;return r===-1?t?"/":".":t&&r===1?"//":e.slice(0,r)}function nh(e,n){if(n!==void 0&&typeof n!="string")throw new TypeError('"ext" argument must be a string');ln(e);var t=0,r=-1,i=!0,s;if(n!==void 0&&n.length>0&&n.length<=e.length){if(n.length===e.length&&n===e)return"";var a=n.length-1,o=-1;for(s=e.length-1;s>=0;--s){var u=e.charCodeAt(s);if(u===47){if(!i){t=s+1;break}}else o===-1&&(i=!1,o=s+1),a>=0&&(u===n.charCodeAt(a)?--a===-1&&(r=s):(a=-1,r=o))}return t===r?r=o:r===-1&&(r=e.length),e.slice(t,r)}else{for(s=e.length-1;s>=0;--s)if(e.charCodeAt(s)===47){if(!i){t=s+1;break}}else r===-1&&(i=!1,r=s+1);return r===-1?"":e.slice(t,r)}}function th(e){ln(e);for(var n=-1,t=0,r=-1,i=!0,s=0,a=e.length-1;a>=0;--a){var o=e.charCodeAt(a);if(o===47){if(!i){t=a+1;break}continue}r===-1&&(i=!1,r=a+1),o===46?n===-1?n=a:s!==1&&(s=1):n!==-1&&(s=-1)}return n===-1||r===-1||s===0||s===1&&n===r-1&&n===t+1?"":e.slice(n,r)}function rh(e){if(e===null||typeof e!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof e);return Y1("/",e)}function ih(e){ln(e);var n={root:"",dir:"",base:"",ext:"",name:""};if(e.length===0)return n;var t=e.charCodeAt(0),r=t===47,i;r?(n.root="/",i=1):i=0;for(var s=-1,a=0,o=-1,u=!0,c=e.length-1,f=0;c>=i;--c){if(t=e.charCodeAt(c),t===47){if(!u){a=c+1;break}continue}o===-1&&(u=!1,o=c+1),t===46?s===-1?s=c:f!==1&&(f=1):s!==-1&&(f=-1)}return s===-1||o===-1||f===0||f===1&&s===o-1&&s===a+1?o!==-1&&(a===0&&r?n.base=n.name=e.slice(1,o):n.base=n.name=e.slice(a,o)):(a===0&&r?(n.name=e.slice(1,s),n.base=e.slice(1,o)):(n.name=e.slice(a,s),n.base=e.slice(a,o)),n.ext=e.slice(s,o)),a>0?n.dir=e.slice(0,a-1):r&&(n.dir="/"),n}var As,sh,ah,Ss=lr(()=>{"use strict";Fs();As="/",sh=":",ah=null});var mc={};Mn(mc,{pathToFileURL:()=>lh});function oh(e){return e.replace(/%/g,"%25").replace(/\\/g,"%5C").replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/\t/g,"%09")}function lh(e){let n=ur(e);e.charCodeAt(e.length-1)===47&&n[n.length-1]!==As&&(n+="/");let t=new URL("file://");return t.pathname=oh(n),t}var yc=lr(()=>{"use strict";Ss()});var Qu={};Mn(Qu,{Stats:()=>_s,checkDiagnostics:()=>ys,compileString:()=>nA,configToArguments:()=>Ju,createMemoryStream:()=>Yu,default:()=>Qu,defaultOptimizeLevel:()=>z1,defaultShrinkLevel:()=>N1,definitionFiles:()=>eA,libraryFiles:()=>Dn,libraryPrefix:()=>an,main:()=>L1,options:()=>QF,tscOptions:()=>tA,version:()=>$u});var uh=Object.prototype.toString.call(typeof globalThis.process<"u"?globalThis.process:0)==="[object process]",bn,st,J,$e,cr;uh?(bn=await import("fs"),st=await import("module"),J=await import("path"),$e=globalThis.process,cr=await import("url")):(bn=await Promise.resolve().then(()=>(fc(),cc)),st=await Promise.resolve().then(()=>(hc(),pc)),J=await Promise.resolve().then(()=>(Ss(),Ts)),$e=await Promise.resolve().then(()=>(Fs(),Es)),cr=await Promise.resolve().then(()=>(yc(),mc)));var oi=typeof process<"u"&&process||{},ch=oi.env&&"CI"in oi.env,fh="\x1B[90m",ph="\x1B[91m",hh="\x1B[92m",dh="\x1B[93m",xh="\x1B[94m",gh="\x1B[95m",mh="\x1B[96m",yh="\x1B[97m",Un="\x1B[0m",at=class{constructor(n){this.stream=n,this.enabled=Boolean(this.stream&&this.stream.isTTY||ch)}gray(n){return this.enabled?fh+n+Un:n}red(n){return this.enabled?ph+n+Un:n}green(n){return this.enabled?hh+n+Un:n}yellow(n){return this.enabled?dh+n+Un:n}blue(n){return this.enabled?xh+n+Un:n}magenta(n){return this.enabled?gh+n+Un:n}cyan(n){return this.enabled?mh+n+Un:n}white(n){return this.enabled?yh+n+Un:n}},li=new at(oi.stdout),sA=new at(oi.stderr);function vn(){}vn.prototype={diff:function(n,t){var r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},i=r.callback;typeof r=="function"&&(i=r,r={}),this.options=r;var s=this;function a(E){return i?(setTimeout(function(){i(void 0,E)},0),!0):E}n=this.castInput(n),t=this.castInput(t),n=this.removeEmpty(this.tokenize(n)),t=this.removeEmpty(this.tokenize(t));var o=t.length,u=n.length,c=1,f=o+u,p=[{newPos:-1,components:[]}],d=this.extractCommon(p[0],t,n,0);if(p[0].newPos+1>=o&&d+1>=u)return a([{value:this.join(t),count:t.length}]);function m(){for(var E=-1*c;E<=c;E+=2){var y=void 0,b=p[E-1],T=p[E+1],S=(T?T.newPos:0)-E;b&&(p[E-1]=void 0);var C=b&&b.newPos+1<o,w=T&&0<=S&&S<u;if(!C&&!w){p[E]=void 0;continue}if(!C||w&&b.newPos<T.newPos?(y=bh(T),s.pushComponent(y.components,void 0,!0)):(y=b,y.newPos++,s.pushComponent(y.components,!0,void 0)),S=s.extractCommon(y,t,n,E),y.newPos+1>=o&&S+1>=u)return a(_h(s,y.components,t,n,s.useLongestToken));p[E]=y}c++}if(i)(function E(){setTimeout(function(){if(c>f)return i();m()||E()},0)})();else for(;c<=f;){var g=m();if(g)return g}},pushComponent:function(n,t,r){var i=n[n.length-1];i&&i.added===t&&i.removed===r?n[n.length-1]={count:i.count+1,added:t,removed:r}:n.push({count:1,added:t,removed:r})},extractCommon:function(n,t,r,i){for(var s=t.length,a=r.length,o=n.newPos,u=o-i,c=0;o+1<s&&u+1<a&&this.equals(t[o+1],r[u+1]);)o++,u++,c++;return c&&n.components.push({count:c}),n.newPos=o,u},equals:function(n,t){return this.options.comparator?this.options.comparator(n,t):n===t||this.options.ignoreCase&&n.toLowerCase()===t.toLowerCase()},removeEmpty:function(n){for(var t=[],r=0;r<n.length;r++)n[r]&&t.push(n[r]);return t},castInput:function(n){return n},tokenize:function(n){return n.split("")},join:function(n){return n.join("")}};function _h(e,n,t,r,i){for(var s=0,a=n.length,o=0,u=0;s<a;s++){var c=n[s];if(c.removed){if(c.value=e.join(r.slice(u,u+c.count)),u+=c.count,s&&n[s-1].added){var p=n[s-1];n[s-1]=n[s],n[s]=p}}else{if(!c.added&&i){var f=t.slice(o,o+c.count);f=f.map(function(m,g){var E=r[u+g];return E.length>m.length?E:m}),c.value=e.join(f)}else c.value=e.join(t.slice(o,o+c.count));o+=c.count,c.added||(u+=c.count)}}var d=n[a-1];return a>1&&typeof d.value=="string"&&(d.added||d.removed)&&e.equals("",d.value)&&(n[a-2].value+=d.value,n.pop()),n}function bh(e){return{newPos:e.newPos,components:e.components.slice(0)}}var oA=new vn;var _c=/^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,bc=/\S/,vc=new vn;vc.equals=function(e,n){return this.options.ignoreCase&&(e=e.toLowerCase(),n=n.toLowerCase()),e===n||this.options.ignoreWhitespace&&!bc.test(e)&&!bc.test(n)};vc.tokenize=function(e){for(var n=e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/),t=0;t<n.length-1;t++)!n[t+1]&&n[t+2]&&_c.test(n[t])&&_c.test(n[t+2])&&(n[t]+=n[t+2],n.splice(t+1,2),t--);return n};var Ec=new vn;Ec.tokenize=function(e){var n=[],t=e.split(/(\n|\r\n)/);t[t.length-1]||t.pop();for(var r=0;r<t.length;r++){var i=t[r];r%2&&!this.options.newlineIsToken?n[n.length-1]+=i:(this.options.ignoreWhitespace&&(i=i.trim()),n.push(i))}return n};var vh=new vn;vh.tokenize=function(e){return e.split(/(\S.+?[.!?])(?=\s+|$)/)};var Eh=new vn;Eh.tokenize=function(e){return e.split(/([{}:;,]|\s+)/)};function ui(e){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?ui=function(n){return typeof n}:ui=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ui(e)}var Fh=Object.prototype.toString,fr=new vn;fr.useLongestToken=!0;fr.tokenize=Ec.tokenize;fr.castInput=function(e){var n=this.options,t=n.undefinedReplacement,r=n.stringifyReplacer,i=r===void 0?function(s,a){return typeof a>"u"?t:a}:r;return typeof e=="string"?e:JSON.stringify(Cs(e,null,null,i),i,"  ")};fr.equals=function(e,n){return vn.prototype.equals.call(fr,e.replace(/,([\r\n])/g,"$1"),n.replace(/,([\r\n])/g,"$1"))};function Cs(e,n,t,r,i){n=n||[],t=t||[],r&&(e=r(i,e));var s;for(s=0;s<n.length;s+=1)if(n[s]===e)return t[s];var a;if(Fh.call(e)==="[object Array]"){for(n.push(e),a=new Array(e.length),t.push(a),s=0;s<e.length;s+=1)a[s]=Cs(e[s],n,t,r,i);return n.pop(),t.pop(),a}if(e&&e.toJSON&&(e=e.toJSON()),ui(e)==="object"&&e!==null){n.push(e),a={},t.push(a);var o=[],u;for(u in e)e.hasOwnProperty(u)&&o.push(u);for(o.sort(),s=0;s<o.length;s+=1)u=o[s],a[u]=Cs(e[u],n,t,r,u);n.pop(),t.pop()}else a=e;return a}var ws=new vn;ws.tokenize=function(e){return e.slice()};ws.join=ws.removeEmpty=function(e){return e};function Th(e){for(var n=0,t=0,r=e.length;t<r;++t){let i=e.charCodeAt(t);i<128?n+=1:i<2048?n+=2:(i&64512)===55296&&t+1<r&&(e.charCodeAt(t+1)&64512)===56320?(++t,n+=4):n+=3}return n}function Sh(e,n,t){var r=t-n;if(r<1)return"";for(var i=null,s=[],a=0,o;n<t;)o=e[n++],o<128?s[a++]=o:o>191&&o<224?s[a++]=(o&31)<<6|e[n++]&63:o>239&&o<365?(o=((o&7)<<18|(e[n++]&63)<<12|(e[n++]&63)<<6|e[n++]&63)-65536,s[a++]=55296+(o>>10),s[a++]=56320+(o&1023)):s[a++]=(o&15)<<12|(e[n++]&63)<<6|e[n++]&63,a>=8192&&((i||(i=[])).push(String.fromCharCode(...s)),a=0);return i?(a&&i.push(String.fromCharCode(...s.slice(0,a))),i.join("")):String.fromCharCode(...s.slice(0,a))}function Ch(e,n,t){for(var r=t,i=0,s=e.length;i<s;++i){let a=e.charCodeAt(i),o;a<128?n[t++]=a:a<2048?(n[t++]=a>>6|192,n[t++]=a&63|128):(a&64512)===55296&&i+1<s&&((o=e.charCodeAt(i+1))&64512)===56320?(a=65536+((a&1023)<<10)+(o&1023),++i,n[t++]=a>>18|240,n[t++]=a>>12&63|128,n[t++]=a>>6&63|128,n[t++]=a&63|128):(n[t++]=a>>12|224,n[t++]=a>>6&63|128,n[t++]=a&63|128)}return t-r}var ci={length:Th,read:Sh,write:Ch};var Fc=st.createRequire(import.meta.url);function Tc(e,n,t=!0){var r={},i=[],s=[],a=[],o={};Object.keys(n).forEach(f=>{if(!f.startsWith(" ")){var p=n[f];p.alias!=null&&(typeof p.alias=="string"?o[p.alias]=f:Array.isArray(p.alias)&&p.alias.forEach(d=>o[d]=f)),t&&p.default!=null&&(r[f]=p.default)}});for(var u=0,c=(e=e.slice()).length;u<c;++u){let f=e[u];if(f=="--"){++u;break}let p=/^(?:(-\w)(?:=(.*))?|(--\w{2,})(?:=(.*))?)$/.exec(f),d,m;if(p)n[f]?d=n[m=f]:p[1]!=null?(d=n[m=o[p[1].substring(1)]],d&&p[2]!=null&&(e[u--]=p[2])):p[3]!=null&&(d=n[m=p[3].substring(2)],d&&p[4]!=null&&(e[u--]=p[4]));else if(f.charCodeAt(0)==45)d=n[m=f];else{s.push(f);continue}if(d)if(d.value)Object.keys(d.value).forEach(g=>r[g]=d.value[g]);else if(d.type==null||d.type==="b")r[m]=!0;else if(u+1<e.length&&e[u+1].charCodeAt(0)!=45)switch(d.type){case"i":r[m]=parseInt(e[++u],10);break;case"I":r[m]=(r[m]||[]).concat(parseInt(e[++u],10));break;case"f":r[m]=parseFloat(e[++u]);break;case"F":r[m]=(r[m]||[]).concat(parseFloat(e[++u]));break;case"s":r[m]=String(e[++u]);break;case"S":r[m]=(r[m]||[]).concat(e[++u].split(","));break;default:i.push(f),--u}else switch(d.type){case"i":case"f":r[m]=d.default||0;break;case"s":r[m]=d.default||"";break;case"I":case"F":case"S":r[m]=d.default||[];break;default:i.push(f)}else i.push(f)}for(;u<c;)a.push(e[u++]);return t&&ks(n,r),{options:r,unknown:i,arguments:s,trailing:a}}function Sc(e,n){n||(n={});var t=n.indent||2,r=n.padding||24,i=n.eol||`
`,s={},a=[];Object.keys(e).forEach(c=>{var f=e[c];if(f.description!=null){for(var p="";p.length<t;)p+=" ";for(p+="--"+c,f.alias&&(p+=", -"+f.alias);p.length<r;)p+=" ";var d;!n.noCategories&&f.category?(d=s[f.category])||(s[f.category]=d=[]):d=a,Array.isArray(f.description)?d.push(p+f.description[0]+f.description.slice(1).map(m=>{for(let g=0;g<r;++g)m=" "+m;return i+m}).join("")):d.push(p+f.description)}});var o=[],u=!1;return Object.keys(s).forEach(c=>{u=!0,o.push(i+" "+li.gray(c)+i),o.push(s[c].join(i))}),u&&a.length&&o.push(i+" "+li.gray("Other")+i),o.push(a.join(i)),o.join(i)}function Ac(e,n){if(e!=null)switch(n){case void 0:case"b":return Boolean(e);case"i":return Math.trunc(e)||0;case"f":return Number(e)||0;case"s":return e===!0?"":String(e);case"I":return Array.isArray(e)||(e=[e]),e.map(t=>Math.trunc(t)||0);case"F":return Array.isArray(e)||(e=[e]),e.map(t=>Number(t)||0);case"S":return Array.isArray(e)||(e=[e]),e.map(String)}}function Is(e,n,t,r){let i={};for(let[s,{type:a,mutuallyExclusive:o,isPath:u,useNodeResolution:c,cliOnly:f}]of Object.entries(e)){let p=Ac(n[s],a),d=Ac(t[s],a);if(p==null){if(d!=null){if(f)continue;if(Array.isArray(d)){let m;u&&(d=d.map(g=>ot(g,r,c))),o!=null&&(m=n[o])?i[s]=d.filter(g=>!m.includes(g)):i[s]=d.slice()}else u&&(d=ot(d,r,c)),i[s]=d}}else if(d==null)Array.isArray(p)?i[s]=p.slice():i[s]=p;else if(Array.isArray(p)){if(f){i[s]=p.slice();continue}let m;u&&(d=d.map(g=>ot(g,r,c))),o!=null&&(m=n[o])?i[s]=[...p,...d.filter(g=>!p.includes(g)&&!m.includes(g))]:i[s]=[...p,...d.filter(g=>!p.includes(g))]}else i[s]=p}return i}function wh(e){let n=J.parse(e);return n.root||(n.root="./"),J.format(n)}function ot(e,n,t=!1){return J.isAbsolute(e)?e:t&&!e.startsWith(".")&&Fc.resolve?Fc.resolve(e,{paths:[n]}):wh(J.join(n,e))}function ks(e,n){for(let[t,{default:r}]of Object.entries(e))n[t]==null&&r!=null&&(n[t]=r)}var Cc="0.0.3",Pn={version:{category:"General",description:"Prints just the compiler's version and exits.",type:"b",alias:"v"},help:{category:"General",description:"Prints this message and exits.",type:"b",alias:"h"},config:{category:"General",description:"Configuration file to apply. CLI arguments take precedence.",type:"s",cliOnly:!0},target:{category:"General",description:"Configuration file target to use. Defaults to 'release'.",type:"s",cliOnly:!0},optimize:{category:"Optimization",description:["Optimizes the module. Typical shorthands are:",""," Default optimizations   -O"," Make a release build    -O --noAssert"," Make a debug build      --debug"," Optimize for speed      -Ospeed"," Optimize for size       -Osize",""],type:"b",alias:"O"},optimizeLevel:{category:"Optimization",description:"How much to focus on optimizing code. [0-3]",type:"i"},shrinkLevel:{category:"Optimization",description:"How much to focus on shrinking code size. [0-2, s=1, z=2]",type:"i"},converge:{category:"Optimization",description:"Re-optimizes until no further improvements can be made.",type:"b",default:!1},noAssert:{category:"Optimization",description:"Replaces assertions with just their value without trapping.",type:"b",default:!1},outFile:{category:"Output",description:"Specifies the WebAssembly output file (.wasm).",type:"s",alias:"o",isPath:!0},textFile:{category:"Output",description:"Specifies the WebAssembly text output file (.wat).",type:"s",alias:"t",isPath:!0},bindings:{category:"Output",description:["Specifies the bindings to generate (.js + .d.ts).","","  esm  JavaScript bindings & typings for ESM integration.","  raw  Like esm, but exports just the instantiate function.","       Useful where modules are meant to be instantiated","       multiple times or non-ESM imports must be provided."],type:"S",alias:"b"},sourceMap:{category:"Debugging",description:["Enables source map generation. Optionally takes the URL","used to reference the source map from the binary file."],type:"s"},debug:{category:"Debugging",description:"Enables debug information in emitted binaries.",type:"b",default:!1},importMemory:{category:"Features",description:"Imports the memory from 'env.memory'.",type:"b",default:!1},noExportMemory:{category:"Features",description:"Does not export the memory as 'memory'.",type:"b",default:!1},initialMemory:{category:"Features",description:"Sets the initial memory size in pages.",type:"i",default:0},maximumMemory:{category:"Features",description:"Sets the maximum memory size in pages.",type:"i",default:0},sharedMemory:{category:"Features",description:"Declare memory as shared. Requires maximumMemory.",type:"b",default:!1},zeroFilledMemory:{category:"Features",description:"Assume imported memory is zeroed. Requires importMemory.",type:"b",default:!1},importTable:{category:"Features",description:"Imports the function table from 'env.table'.",type:"b",default:!1},exportTable:{category:"Features",description:"Exports the function table as 'table'.",type:"b",default:!1},exportStart:{category:"Features",description:["Exports the start function using the specified name instead","of calling it implicitly. Useful to obtain the exported memory","before executing any code accessing it."],type:"s"},runtime:{category:"Features",description:["Specifies the runtime variant to include in the program.",""," incremental  TLSF + incremental GC (default)"," minimal      TLSF + lightweight GC invoked externally"," stub         Minimal runtime stub (never frees)"," ...          Path to a custom runtime implementation",""],type:"s",default:"incremental"},exportRuntime:{category:"Features",description:["Always exports the runtime helpers (__new, __collect, __pin etc.).","Automatically determined when generation of --bindings is enabled."],type:"b",default:!1},stackSize:{category:"Features",description:["Overrides the stack size. Only relevant for incremental GC","or when using a custom runtime that requires stack space.","Defaults to 0 without and to 32768 with incremental GC."],default:0,type:"i"},enable:{category:"Features",description:["Enables WebAssembly features being disabled by default.",""," threads             Threading and atomic operations."," simd                SIMD types and operations."," reference-types     Reference types and operations."," gc                  Garbage collection (WIP)."," stringref           String reference types.",""],TODO_doesNothingYet:[" exception-handling  Exception handling."," tail-calls          Tail call operations."," multi-value         Multi value types."," memory64            Memory64 operations."," relaxed-simd        Relaxed SIMD operations."," extended-const      Extended const expressions."],type:"S",mutuallyExclusive:"disable"},disable:{category:"Features",description:["Disables WebAssembly features being enabled by default.",""," mutable-globals     Mutable global imports and exports."," sign-extension      Sign-extension operations"," nontrapping-f2i     Non-trapping float to integer ops."," bulk-memory         Bulk memory operations.",""],type:"S",mutuallyExclusive:"enable"},use:{category:"Features",description:["Aliases a global object under another name, e.g., to switch","the default 'Math' implementation used: --use Math=JSMath","Can also be used to introduce an integer constant."],type:"S",alias:"u"},lowMemoryLimit:{category:"Features",description:"Enforces very low (<64k) memory constraints.",default:0,type:"i"},memoryBase:{category:"Linking",description:"Sets the start offset of emitted memory segments.",type:"i",default:0},tableBase:{category:"Linking",description:"Sets the start offset of emitted table elements.",type:"i",default:0},transform:{category:"API",description:"Specifies the path to a custom transform to load.",type:"S",isPath:!0,useNodeResolution:!0},trapMode:{category:"Binaryen",description:["Sets the trap mode to use.",""," allow  Allow trapping operations. This is the default."," clamp  Replace trapping operations with clamping semantics."," js     Replace trapping operations with JS semantics.",""],type:"s",default:"allow"},runPasses:{category:"Binaryen",description:["Specifies additional Binaryen passes to run after other","optimizations, if any. See: Binaryen/src/passes/pass.cpp"],type:"s"},noValidate:{category:"Binaryen",description:"Skips validating the module using Binaryen.",type:"b",default:!1},baseDir:{description:"Specifies the base directory of input and output files.",type:"s",default:"."},noColors:{description:"Disables terminal colors.",type:"b",default:!1},noUnsafe:{description:["Disallows the use of unsafe features in user code.","Does not affect library files and external modules."],type:"b",default:!1},disableWarning:{description:["Disables warnings matching the given diagnostic code.","If no diagnostic code is given, all warnings are disabled."],type:"I"},noEmit:{description:"Performs compilation as usual but does not emit code.",type:"b",default:!1},showConfig:{description:"Print computed compiler options and exit.",type:"b",default:!1},stats:{description:"Prints statistics on I/O and compile times.",type:"b",default:!1},pedantic:{description:"Make yourself sad for no good reason.",type:"b",default:!1},lib:{description:["Adds one or multiple paths to custom library components and","uses exports of all top-level files at this path as globals."],type:"S",isPath:!0},path:{description:["Adds one or multiple paths to package resolution, similar","to node_modules. Prefers an 'ascMain' entry in a package's","package.json and falls back to an inner 'assembly/' folder."],type:"S",isPath:!0},wasm:{description:"Uses the specified Wasm binary of the compiler.",type:"s"}," ...":{description:"Specifies node.js options (CLI only). See: node --help"},"-Os":{value:{optimizeLevel:0,shrinkLevel:1}},"-Oz":{value:{optimizeLevel:0,shrinkLevel:2}},"-O0":{value:{optimizeLevel:0,shrinkLevel:0}},"-O1":{value:{optimizeLevel:1,shrinkLevel:0}},"-O2":{value:{optimizeLevel:2,shrinkLevel:0}},"-O3":{value:{optimizeLevel:3,shrinkLevel:0}},"-O0s":{value:{optimizeLevel:0,shrinkLevel:1}},"-O1s":{value:{optimizeLevel:1,shrinkLevel:1}},"-O2s":{value:{optimizeLevel:2,shrinkLevel:1}},"-O3s":{value:{optimizeLevel:3,shrinkLevel:1}},"-O0z":{value:{optimizeLevel:0,shrinkLevel:2}},"-O1z":{value:{optimizeLevel:1,shrinkLevel:2}},"-O2z":{value:{optimizeLevel:2,shrinkLevel:2}},"-O3z":{value:{optimizeLevel:3,shrinkLevel:2}},"-Ospeed":{value:{optimizeLevel:3,shrinkLevel:0}},"-Osize":{value:{optimizeLevel:0,shrinkLevel:2,converge:!0}},"--measure":{value:{stats:!0}}},wc="~lib/",Ic={account:`export class Account {
  @inline
  constructor(public bytes: ByteArray) {
    if (bytes.length != 20)
      rollback("", bytes.length);
  }

  compare(right: ByteArray): i32 {
    let ptr1 = changetype<usize>(this.bytes);
    let ptr2 = changetype<usize>(right);
    if (ptr1 == ptr2) return 0;

    for (let i = 0; max_iterations(20), i < 20; ++i) {
      let a = load<u8>(ptr1);
      let b = load<u8>(ptr2);
      if (a > b)
        return 1;
      else if (a < b)
        return -1;

      ++ptr1;
      ++ptr2;
    }

    return 0;
  }

  @inline @operator("==")
  private static __eq(left: Account, right: ByteArray): bool {
    if (right.length != 20)
      return false;

    let ptr1 = changetype<usize>(left.bytes);
    let ptr2 = changetype<usize>(right);
    if (ptr1 == ptr2) return true;

    // unrolled loop takes less space (and also can be called from a
    // loop)
    if (load<u64>(ptr1) != load<u64>(ptr2)) return false;
    ptr1 += 8;
    ptr2 += 8;
    if (load<u64>(ptr1) != load<u64>(ptr2)) return false;
    ptr1 += 8;
    ptr2 += 8;

    if (load<u32>(ptr1) != load<u32>(ptr2)) return false;
    return true;
  }

  @inline @operator("!=")
  private static __ne(left: Account, right: ByteArray): bool {
    return !this.__eq(left, right);
  }
}
`,amount:`export class Amount {
  @inline
  constructor(public bytes: ByteArray) {
    if ((bytes.length != 8) && (bytes.length != 48))
      rollback("", bytes.length);
  }

  @inline
  get length(): i32 {
    return this.bytes.length;
  }

  @inline
  isXrp(): bool {
    return this.length == 8;
  }

  @inline
  get drops(): u64 {
    if (!this.isXrp()) unreachable();
    if (<u64>(this.bytes[0]) >> 7) unreachable();

    return ((<u64>(this.bytes[0]) & 0xb00111111) << 56) +
      (<u64>(this.bytes[1]) << 48) +
      (<u64>(this.bytes[2]) << 40) +
      (<u64>(this.bytes[3]) << 32) +
      (<u64>(this.bytes[4]) << 24) +
      (<u64>(this.bytes[5]) << 16) +
      (<u64>(this.bytes[6]) << 8) +
      <u64>(this.bytes[7]);
  }

  @inline
  static fromDrops(drops: u64): Amount {
    let buf = new ByteArray(8);
    buf[0] = <u8>((drops >> 56) & 0x3F);
    buf[1] = <u8>((drops >> 48) & 0xFF);
    buf[2] = <u8>((drops >> 40) & 0xFF);
    buf[3] = <u8>((drops >> 32) & 0xFF);
    buf[4] = <u8>((drops >> 24) & 0xFF);
    buf[5] = <u8>((drops >> 16) & 0xFF);
    buf[6] = <u8>((drops >> 8) & 0xFF);
    buf[7] = <u8>(drops & 0xFF);

    return new Amount(buf);
  }
};
`,array:`/// <reference path="./rt/index.d.ts" />

import { BLOCK_MAXSIZE } from "./rt/common";
import { Runtime } from "shared/runtime";
import { COMPARATOR, SORT } from "./util/sort";
import { REVERSE, FILL } from "./util/bytes";
import { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from "./util/string";
import { idof, isArray as builtin_isArray } from "./builtins";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from "./util/error";

// @ts-ignore: decorator
@inline @lazy const MIN_SIZE: usize = 8;

/** Ensures that the given array has _at least_ the specified backing size. */
function ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {
  // Depends on the fact that Arrays mimic ArrayBufferView
  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;
  if (newSize > oldCapacity >>> alignLog2) {
    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);
    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);
    // Grows old capacity by factor of two.
    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.
    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;
    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);
    let newData = __renew(oldData, newCapacity);
    // __new / __renew already init memory range as zeros in Incremental runtime.
    // So try to avoid this.
    if (ASC_RUNTIME != Runtime.Incremental) {
      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);
    }
    if (newData != oldData) { // oldData has been free'd
      store<usize>(array, newData, offsetof<ArrayBufferView>("buffer"));
      store<usize>(array, newData, offsetof<ArrayBufferView>("dataStart"));
      __link(array, changetype<usize>(newData), false);
    }
    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>("byteLength"));
  }
}

export class Array<T> {
  [key: number]: T;

  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code
  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need
  // \`dataStart\` (equals \`buffer\`) and \`byteLength\` (equals computed \`buffer.byteLength\`), but the
  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.

  private buffer: ArrayBuffer;
  @unsafe readonly dataStart: usize;
  private byteLength: i32; // Uses here as capacity

  // Also note that Array<T> with non-nullable T must guard against uninitialized null values
  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee
  // type-safety anymore. For lack of a better word, such an array is "holey".

  private length_: i32;

  static isArray<U>(value: U): bool {
    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;
  }

  static create<T>(capacity: i32 = 0): Array<T> {
    WARNING("'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.");
    let array = new Array<T>(capacity);
    array.length = 0;
    return array;
  }

  constructor(length: i32 = 0) {
    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);
    // reserve capacity for at least MIN_SIZE elements
    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();
    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));
    if (ASC_RUNTIME != Runtime.Incremental) {
      memory.fill(changetype<usize>(buffer), 0, bufferSize);
    }
    this.buffer = buffer; // links
    this.dataStart = changetype<usize>(buffer);
    this.byteLength = <i32>bufferSize;
    this.length_ = length;
  }

  get length(): i32 {
    return this.length_;
  }

  set length(newLength: i32) {
    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);
    this.length_ = newLength;
  }

  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;
    }
    return true;
  }

  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;
    }
    return -1;
  }

  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {
    for (let i = this.length_ - 1; i >= 0; --i) {
      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;
    }
    return -1;
  }

  @operator("[]") private __get(index: i32): T {
    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);
    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  @unsafe @operator("{}") private __uget(index: i32): T {
    return load<T>(this.dataStart + (<usize>index << alignof<T>()));
  }

  @operator("[]=") private __set(index: i32, value: T): void {
    if (<u32>index >= <u32>this.length_) {
      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);
      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());
      this.length_ = index + 1;
    }
    this.__uset(index, value);
  }

  @unsafe @operator("{}=") private __uset(index: i32, value: T): void {
    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);
    if (isManaged<T>()) {
      __link(changetype<usize>(this), changetype<usize>(value), true);
    }
  }

  at(index: i32): T {
    let len = this.length_;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {
    if (isManaged<T>()) {
      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);
      __link(changetype<usize>(this), changetype<usize>(value), false);
    } else {
      FILL<T>(this.dataStart, this.length_, value, start, end);
    }
    return this;
  }

  includes(value: T, fromIndex: i32 = 0): bool {
    if (isFloat<T>()) {
      let len = this.length_;
      if (len == 0 || fromIndex >= len) return false;
      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);
      let ptr = this.dataStart;
      while (fromIndex < len) {
        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));
        // @ts-ignore
        if (elem == value || isNaN(elem) & isNaN(value)) return true;
        ++fromIndex;
      }
      return false;
    } else {
      return this.indexOf(value, fromIndex) >= 0;
    }
  }

  indexOf(value: T, fromIndex: i32 = 0): i32 {
    let len = this.length_;
    if (len == 0 || fromIndex >= len) return -1;
    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);
    let ptr = this.dataStart;
    while (fromIndex < len) {
      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      ++fromIndex;
    }
    return -1;
  }

  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {
    let len = this.length_;
    if (len == 0) return -1;
    if (fromIndex < 0) fromIndex = len + fromIndex;
    else if (fromIndex >= len) fromIndex = len - 1;
    let ptr = this.dataStart;
    while (fromIndex >= 0) {
      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      --fromIndex;
    }
    return -1;
  }

  push(value: T): i32 {
    let oldLen = this.length_;
    let len = oldLen + 1;
    ensureCapacity(changetype<usize>(this), len, alignof<T>());
    if (isManaged<T>()) {
      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));
      __link(changetype<usize>(this), changetype<usize>(value), true);
    } else {
      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);
    }
    this.length_ = len;
    return len;
  }

  concat(other: Array<T>): Array<T> {
    let thisLen = this.length_;
    let otherLen = other.length_;
    let outLen = thisLen + otherLen;
    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);
    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));
    let outStart = out.dataStart;
    let thisSize = <usize>thisLen << alignof<T>();
    if (isManaged<T>()) {
      let thisStart = this.dataStart;
      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {
        let ref = load<usize>(thisStart + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
      outStart += thisSize;
      let otherStart = other.dataStart;
      let otherSize = <usize>otherLen << alignof<T>();
      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {
        let ref = load<usize>(otherStart + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
    } else {
      memory.copy(outStart, this.dataStart, thisSize);
      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());
    }
    return out;
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {
    let ptr = this.dataStart;
    let len = this.length_;

    end = min<i32>(end, len);

    let to    = target < 0 ? max(len + target, 0) : min(target, len);
    let from  = start < 0 ? max(len + start, 0) : min(start, len);
    let last  = end < 0 ? max(len + end, 0) : min(end, len);
    let count = min(last - from, len - to);

    memory.copy( // is memmove
      ptr + (<usize>to << alignof<T>()),
      ptr + (<usize>from << alignof<T>()),
      <usize>count << alignof<T>()
    );
    return this;
  }

  pop(): T {
    let len = this.length_;
    if (len < 1) throw new RangeError(E_EMPTYARRAY);
    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));
    this.length_ = len;
    return val;
  }

  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
    }
  }

  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {
    let len = this.length_;
    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));
    let outStart = out.dataStart;
    for (let i = 0; i < min(len, this.length_); ++i) {
      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
      store<U>(outStart + (<usize>i << alignof<U>()), result);
      if (isManaged<U>()) {
        __link(changetype<usize>(out), changetype<usize>(result), true);
      }
    }
    return out;
  }

  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {
    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));
      if (fn(value, i, this)) result.push(value);
    }
    return result;
  }

  reduce<U>(
    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,
    initialValue: U
  ): U {
    let acc = initialValue;
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
    }
    return acc;
  }

  reduceRight<U>(
    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,
    initialValue: U
  ): U {
    let acc = initialValue;
    for (let i = this.length_ - 1; i >= 0; --i) {
      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
    }
    return acc;
  }

  shift(): T {
    let len = this.length_;
    if (len < 1) throw new RangeError(E_EMPTYARRAY);
    let base = this.dataStart;
    let element = load<T>(base);
    let lastIndex = len - 1;
    memory.copy(
      base,
      base + sizeof<T>(),
      <usize>lastIndex << alignof<T>()
    );
    if (isReference<T>()) {
      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);
    } else {
      // @ts-ignore
      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);
    }
    this.length_ = lastIndex;
    return element;
  }

  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;
    }
    return false;
  }

  unshift(value: T): i32 {
    let len = this.length_ + 1;
    ensureCapacity(changetype<usize>(this), len, alignof<T>());
    let ptr = this.dataStart;
    memory.copy(
      ptr + sizeof<T>(),
      ptr,
      <usize>(len - 1) << alignof<T>()
    );
    store<T>(ptr, value);
    if (isManaged<T>()) {
      __link(changetype<usize>(this), changetype<usize>(value), true);
    }
    this.length_ = len;
    return len;
  }

  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {
    let len = this.length_;
    start = start < 0 ? max(start + len, 0) : min(start, len);
    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);
    len = max(end - start, 0);
    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));
    let sliceBase = slice.dataStart;
    let thisBase = this.dataStart + (<usize>start << alignof<T>());
    if (isManaged<T>()) {
      let off = <usize>0;
      let end = <usize>len << alignof<usize>();
      while (off < end) {
        let ref = load<usize>(thisBase + off);
        store<usize>(sliceBase + off, ref);
        __link(changetype<usize>(slice), ref, true);
        off += sizeof<usize>();
      }
    } else {
      memory.copy(sliceBase, thisBase, len << alignof<T>());
    }
    return slice;
  }

  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {
    let len = this.length_;
    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);
    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);
    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));
    let resultStart = result.dataStart;
    let thisStart = this.dataStart;
    let thisBase  = thisStart + (<usize>start << alignof<T>());
    memory.copy(
      resultStart,
      thisBase,
      <usize>deleteCount << alignof<T>()
    );
    let offset = start + deleteCount;
    if (len != offset) {
      memory.copy(
        thisBase,
        thisStart + (<usize>offset << alignof<T>()),
        <usize>(len - offset) << alignof<T>()
      );
    }
    this.length_ = len - deleteCount;
    return result;
  }

  reverse(): Array<T> {
    REVERSE<T>(this.dataStart, this.length_);
    return this;
  }

  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {
    SORT<T>(this.dataStart, this.length_, comparator);
    return this;
  }

  join(separator: string = ","): string {
    let ptr = this.dataStart;
    let len = this.length_;
    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);
    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);
    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);

    if (ASC_SHRINK_LEVEL < 1) {
      if (isString<T>())  return joinStringArray(ptr, len, separator);
    }
    // For rest objects and arrays use general join routine
    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);
    ERROR("unspported element type");
    return <string>unreachable();
  }

  flat(): T {
    if (!isArray<T>()) {
      ERROR("Cannot call flat() on Array<T> where T is not an Array.");
    }
    // Get the length and data start values
    let ptr = this.dataStart;
    let len = this.length_;

    // calculate the end size with an initial pass
    let size = 0;
    for (let i = 0; i < len; ++i) {
      let child = load<usize>(ptr + (i << alignof<T>()));
      size += child == 0 ? 0 : load<i32>(child, offsetof<T>("length_"));
    }

    // calculate the byteLength of the resulting backing ArrayBuffer
    const align = alignof<valueof<T>>();
    let byteLength = <usize>size << align;
    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));

    // create the return value and initialize it
    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));
    store<i32>(changetype<usize>(outArray), size, offsetof<T>("length_"));

    // byteLength, dataStart, and buffer are all readonly
    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>("byteLength"));
    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>("dataStart"));
    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>("buffer"));
    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);

    // set the elements
    let resultOffset: usize = 0;
    for (let i = 0; i < len; ++i) { // for each child
      let child = load<usize>(ptr + (<usize>i << alignof<T>()));

      // ignore null arrays
      if (!child) continue;

      // copy the underlying buffer data to the result buffer
      let childDataLength = <usize>load<i32>(child, offsetof<T>("length_")) << align;
      memory.copy(
        changetype<usize>(outBuffer) + resultOffset,
        load<usize>(child, offsetof<T>("dataStart")),
        childDataLength
      );

      // advance the result length
      resultOffset += childDataLength;
    }

    // if the \`valueof<T>\` type is managed, we must link each reference
    if (isManaged<valueof<T>>()) {
      for (let i = 0; i < size; ++i) {
        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));
        __link(changetype<usize>(outBuffer), ref, true);
      }
    }

    return outArray;
  }

  toString(): string {
    return this.join();
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    if (isManaged<T>()) {
      let cur = this.dataStart;
      let end = cur + (<usize>this.length_ << alignof<T>());
      while (cur < end) {
        let val = load<usize>(cur);
        if (val) __visit(val, cookie);
        cur += sizeof<usize>();
      }
    }
    __visit(changetype<usize>(this.buffer), cookie);
  }
}
`,arraybuffer:`/// <reference path="./rt/index.d.ts" />

import { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";
import { Runtime } from "shared/runtime";
import { idof } from "./builtins";
import { E_INVALIDLENGTH } from "./util/error";

export abstract class ArrayBufferView {

  readonly buffer: ArrayBuffer;
  @unsafe readonly dataStart: usize;
  readonly byteLength: i32;

  get byteOffset(): i32 {
    return <i32>(this.dataStart - changetype<usize>(this.buffer));
  }

  protected constructor(length: i32, alignLog2: i32) {
    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);
    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));
    if (ASC_RUNTIME != Runtime.Incremental) {
      memory.fill(changetype<usize>(buffer), 0, <usize>length);
    }
    this.buffer = buffer; // links
    this.dataStart = changetype<usize>(buffer);
    this.byteLength = length;
  }
}

@final export class ArrayBuffer {

  static isView<T>(value: T): bool {
    if (isNullable<T>()) {
      if (changetype<usize>(value) == 0) return false;
    }
    if (value instanceof Int8Array) return true;
    if (value instanceof Uint8Array) return true;
    if (value instanceof Uint8ClampedArray) return true;
    if (value instanceof Int16Array) return true;
    if (value instanceof Uint16Array) return true;
    if (value instanceof Int32Array) return true;
    if (value instanceof Uint32Array) return true;
    if (value instanceof Int64Array) return true;
    if (value instanceof Uint64Array) return true;
    if (value instanceof Float32Array) return true;
    if (value instanceof Float64Array) return true;
    if (value instanceof DataView) return true;
    return false;
  }

  constructor(length: i32) {
    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);
    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));
    if (ASC_RUNTIME != Runtime.Incremental) {
      memory.fill(changetype<usize>(buffer), 0, <usize>length);
    }
    return buffer;
  }

  get byteLength(): i32 {
    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;
  }

  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {
    let length = this.byteLength;
    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);
    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);
    let outSize = <usize>max(end - begin, 0);
    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);
    return out;
  }

  toString(): string {
    return "[object ArrayBuffer]";
  }
}
`,atomics:`import { ArrayBufferView } from "./arraybuffer";
import { E_INDEXOUTOFRANGE } from "./util/error";

export namespace Atomics {

  // @ts-ignore: decorator
  @inline
  export function load<T extends ArrayBufferView>(array: T, index: i32): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.load<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset
    );
  }

  // @ts-ignore: decorator
  @inline
  export function store<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): void {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    atomic.store<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function add<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.add<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function sub<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.sub<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function and<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.and<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function or<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.or<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function xor<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.xor<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function exchange<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.xchg<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function compareExchange<T extends ArrayBufferView>(
    array: T,
    index: i32,
    expectedValue: valueof<T>,
    replacementValue: valueof<T>
  ): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.cmpxchg<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      expectedValue,
      replacementValue
    );
  }

  // @ts-ignore: decorator
  @inline
  export function wait<T extends ArrayBufferView>(array: T, value: valueof<T>, timeout: i64 = -1): AtomicWaitResult {
    return atomic.wait<valueof<T>>(changetype<usize>(array.buffer) + array.byteOffset, value, timeout);
  }

  // @ts-ignore: decorator
  @inline
  export function notify<T extends ArrayBufferView>(array: T, index: i32, count: i32 = -1): i32 {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.notify(changetype<usize>(array.buffer) + (index << align) + array.byteOffset, count);
  }

  export function isLockFree(size: usize): bool {
    return size == 1 || size == 2 || size == 4;
  }
}
`,"bindings/asyncify":`@unmanaged
export class StackDescriptor {
  /** The index in linear memory of the start of the \u201Casyncify stack\u201D. */
  stackStart: usize;
  /** The index of the end of that stack region, which implies how big it is. */
  stackEnd: usize;
}

/** Starts to unwind the call stack. */
export declare function start_unwind(data: StackDescriptor): void;
/** Stops unwinding the call stack. */
export declare function stop_unwind(): void;
/** Starts to rewind the call stack. */
export declare function start_rewind(data: StackDescriptor): void;
/** Stops rewinding the call stack. */
export declare function stop_rewind(): void;
`,"bindings/dom":`import {
  _01_02_ENCODE_TT,
  _02_02_ENCODE_FLAGS,
  _02_03_ENCODE_TAG_SRC,
  _02_04_ENCODE_SEQUENCE,
  _02_14_ENCODE_TAG_DST,
  _02_26_ENCODE_FLS,
  _02_27_ENCODE_LLS,
  _06_01_ENCODE_DROPS_AMOUNT,
  _06_01_ENCODE_TL_AMOUNT,
  _06_08_ENCODE_DROPS_FEE,
  _07_03_ENCODE_SIGNING_PUBKEY_NULL,
  _08_01_ENCODE_ACCOUNT_SRC,
  _08_03_ENCODE_ACCOUNT_DST,
  tfCANONICAL,
  ttPAYMENT
} from "./encode";

@external("env", "globalThis")
export declare const globalThis: externref;

export declare namespace Math {
  @external("env", "Math.E")
  export const E: f64;
  @external("env", "Math.LN2")
  export const LN2: f64;
  @external("env", "Math.LN10")
  export const LN10: f64;
  @external("env", "Math.LOG2E")
  export const LOG2E: f64;
  @external("env", "Math.LOG10E")
  export const LOG10E: f64;
  @external("env", "Math.PI")
  export const PI: f64;
  @external("env", "Math.SQRT1_2")
  export const SQRT1_2: f64;
  @external("env", "Math.SQRT2")
  export const SQRT2: f64;
  @external("env", "Math.abs")
  export function abs(x: f64): f64;
  @external("env", "Math.acos")
  export function acos(x: f64): f64;
  @external("env", "Math.acosh")
  export function acosh(x: f64): f64;
  @external("env", "Math.asin")
  export function asin(x: f64): f64;
  @external("env", "Math.asinh")
  export function asinh(x: f64): f64;
  @external("env", "Math.atan")
  export function atan(x: f64): f64;
  @external("env", "Math.atan2")
  export function atan2(y: f64, x: f64): f64;
  @external("env", "Math.atanh")
  export function atanh(x: f64): f64;
  @external("env", "Math.cbrt")
  export function cbrt(x: f64): f64;
  @external("env", "Math.ceil")
  export function ceil(x: f64): f64;
  @external("env", "Math.clz32")
  export function clz32(x: f64): f64;
  @external("env", "Math.cos")
  export function cos(x: f64): f64;
  @external("env", "Math.cosh")
  export function cosh(x: f64): f64;
  @external("env", "Math.exp")
  export function exp(x: f64): f64;
  @external("env", "Math.expm1")
  export function expm1(x: f64): f64;
  @external("env", "Math.floor")
  export function floor(x: f64): f64;
  @external("env", "Math.fround")
  export function fround(x: f64): f32;
  @external("env", "Math.hypot")
  export function hypot(value1: f64, value2: f64): f64; // TODO: rest
  @external("env", "Math.imul")
  export function imul(a: f64, b: f64): f64;
  @external("env", "Math.log")
  export function log(x: f64): f64;
  @external("env", "Math.log10")
  export function log10(x: f64): f64;
  @external("env", "Math.log1p")
  export function log1p(x: f64): f64;
  @external("env", "Math.log2")
  export function log2(x: f64): f64;
  @external("env", "Math.max")
  export function max(value1: f64, value2: f64): f64; // TODO: rest
  @external("env", "Math.min")
  export function min(value1: f64, value2: f64): f64; // TODO: rest
  @external("env", "Math.pow")
  export function pow(base: f64, exponent: f64): f64;
  @external("env", "Math.random")
  export function random(): f64;
  @external("env", "Math.round")
  export function round(x: f64): f64;
  @external("env", "Math.sign")
  export function sign(x: f64): f64;
  @external("env", "Math.sin")
  export function sin(x: f64): f64;
  @external("env", "Math.sinh")
  export function sinh(x: f64): f64;
  @external("env", "Math.sqrt")
  export function sqrt(x: f64): f64;
  @external("env", "Math.tan")
  export function tan(x: f64): f64;
  @external("env", "Math.tanh")
  export function tanh(x: f64): f64;
  @external("env", "Math.trunc")
  export function trunc(x: f64): f64;
}

export declare namespace Reflect {
  @external("env", "Reflect.get")
  export function get(target: externref, propertyKey: string): externref;
  @external("env", "Reflect.getWithReceiver")
  @external.js("return Reflect.get(target, propertyKey, receiver);")
  export function getWithReceiver(target: externref, propertyKey: string, receiver: externref): externref;
  @external("env", "Reflect.has")
  export function has(target: externref, propertyKey: string): bool;
  @external("env", "Reflect.set")
  export function set(target: externref, propertyKey: string, value: externref): externref;
  @external("env", "Reflect.setWithReceiver")
  @external.js("return Reflect.set(target, propertyKey, value, receiver);")
  export function setWithReceiver(target: externref, propertyKey: string, value: externref , receiver: externref): externref;
  @external("env", "Reflect.apply")
  export function apply(target: externref, thisArgument: externref, argumentsList: externref): externref;
}

export declare namespace String {
  @external("env", "String.fromCodePoint")
  export function fromCodePoint(codepoint: i32): externref;
  @external("env", "String.fromCodePoints")
  @external.js("return String.fromCodePoint(...codepoints);")
  export function fromCodePoints(codepoints: i32[]): externref;
}

export declare namespace Object {
  @external("env", "Object.is")
  export function is(a: externref, b: externref): bool;
  @external("env", "Object.hasOwn")
  export function hasOwn(target: externref, propertyKey: string): bool;
  @external("env", "Object.assign")
  export function assign(target: externref, source: externref): externref;
  @external("env", "Object.keys")
  export function keys(target: externref): externref;
  @external("env", "Object.values")
  export function values(target: externref): externref;
  @external("env", "Object.entries")
  export function entries(target: externref): externref;
  @external("env", "Object.getOwnPropertyNames")
  export function getOwnPropertyNames(target: externref): externref;
}

export declare namespace Date {
  @external("env", "Date.now")
  export function now(): f64;
}

export declare namespace console {
  @external("env", "console.assert")
  export function assert(condition: bool, message: string): void;
  @external("env", "console.debug")
  export function debug(text: string): void;
  @external("env", "console.info")
  export function info(text: string): void;
  @external("env", "console.warn")
  export function warn(text: string): void;
  @external("env", "console.error")
  export function error(text: string): void;
  @external("env", "console.time")
  export function time(label: string): void;
  @external("env", "console.timeLog")
  export function timeLog(label: string): void;
  @external("env", "console.timeEnd")
  export function timeEnd(label: string): void;
}

export namespace console {
  @inline
  function log(text: string): void {
    trace(text, text.length, 0, 0, 0);
  }
}

@global @inline
export function accept(msg: string = "", err: i64 = 0): void {
  $accept(msg, msg.length, err);
  // does not return
}

@global @inline
export function emit(tx: EmitSpec): Bytes32 {
  // 288 for non-XRP transactions is bigger than
  // PREPARE_PAYMENT_SIMPLE_TRUSTLINE_SIZE in macro.h (287) because
  // macro.h is incorrect
  let buf = new ByteArray(tx.amount.isXrp() ? 248 : 288); // FIXME: w/o cbak only, so far
  let cls = <u32>ledger_seq();
  let acc = hook_account();

  let buf_out = changetype<u32>(buf);
  buf_out = _01_02_ENCODE_TT(buf_out, ttPAYMENT);
  buf_out = _02_02_ENCODE_FLAGS(buf_out, tfCANONICAL);
  buf_out = _02_03_ENCODE_TAG_SRC(buf_out, tx.sourceTag);
  buf_out = _02_04_ENCODE_SEQUENCE(buf_out, 0);
  buf_out = _02_14_ENCODE_TAG_DST(buf_out, tx.destinationTag);
  buf_out = _02_26_ENCODE_FLS(buf_out, cls + 1);
  buf_out = _02_27_ENCODE_LLS(buf_out, cls + 5);
  if (tx.amount.isXrp())
    buf_out = _06_01_ENCODE_DROPS_AMOUNT(buf_out, tx.amount.bytes);
  else
    buf_out = _06_01_ENCODE_TL_AMOUNT(buf_out, tx.amount.bytes);
  let fee_ptr = buf_out;
  buf_out = _06_08_ENCODE_DROPS_FEE(buf_out, 0);
  buf_out = _07_03_ENCODE_SIGNING_PUBKEY_NULL(buf_out);
  buf_out = _08_01_ENCODE_ACCOUNT_SRC(buf_out, changetype<u32>(acc));
  buf_out = _08_03_ENCODE_ACCOUNT_DST(buf_out, changetype<u32>(tx.account.bytes));

  // doesn't check return value
  $etxn_details(buf_out, buf.length - (buf_out - changetype<u32>(buf)));

  // ditto
  let fee = $etxn_fee_base(changetype<u32>(buf), buf.length);
  _06_08_ENCODE_DROPS_FEE(fee_ptr, fee);

  let emit_hash = new Bytes32();
  let emit_result = $emit(changetype<u32>(emit_hash), 32, changetype<u32>(buf), buf.length);
  if (emit_result < 0)
    rollback("", emit_result);

  return emit_hash;
}

@global @inline
export function emit_sto(buffer: ByteArray): Bytes32 {
  let fee_to_pay = $etxn_fee_base(changetype<u32>(buffer), buffer.length);
  if (fee_to_pay < 0)
    rollback("", fee_to_pay);

  let fee_buf = new ByteArray(9);
  _06_08_ENCODE_DROPS_FEE(changetype<u32>(fee_buf), fee_to_pay);
  let buffer2 = new ByteArray(buffer.length + 13);
  let r = $sto_emplace(changetype<u32>(buffer2), buffer2.length, changetype<u32>(buffer), buffer.length, changetype<u32>(fee_buf), 9, sfFee);
  if (r < 0)
    rollback("", r);

  buffer2.length = <i32>r;

  let emit_hash = new Bytes32();
  let emit_result = $emit(changetype<u32>(emit_hash), 32, changetype<u32>(buffer2), buffer2.length);
  if (emit_result < 0)
    rollback("", emit_result);

  return emit_hash;
}

@global @inline
export function etxn_reserve(count: u32): void {
  let r = $etxn_reserve(count);
  if (r != count)
    rollback("", r);
}

@global @inline
export function float_compare(float1: i64, float2: i64, mode: u32): i32 {
  let r = $float_compare(float1, float2, mode);
  if ((r < 0) || (r > 1))
    rollback("", r);

  return <i32>r;
}

@global @inline
export function float_divide(float1: i64, float2: i64): i64 {
  let r = $float_divide(float1, float2);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function float_int(float1: i64, dec: u32, abs: u32): i64 {
  let r = $float_int(float1, dec, abs);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function float_mulratio(float1: i64, round_up: u32, numerator: u32, denominator: u32): i64 {
  let r = $float_mulratio(float1, round_up, numerator, denominator);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function float_multiply(float1: i64, float2: i64): i64 {
  let r = $float_multiply(float1, float2);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function float_negate(float1: i64): i64 {
  let r = $float_negate(float1);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function float_set(exponent: i32, mantissa: i64): i64 {
  let r = $float_set(exponent, mantissa);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function float_sto(currency: ByteView, issuer: ByteView, float1: i64, field: i32, el: i32 = 8): ByteArray {
  let a = new ByteArray(el);
  let r = $float_sto(
    changetype<u32>(a), el,
    changetype<u32>(currency.underlying) + currency.offset, currency.length,
    changetype<u32>(issuer.underlying) + issuer.offset, issuer.length,
    float1,
    field);
  if (r < 0)
    rollback("", r);

  return a;
}

@global @inline
export function float_sto_set(data: ByteView): i64 {
  let r = $float_sto_set(changetype<u32>(data.underlying) + data.offset, data.length);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function float_sum(float1: i64, float2: i64): i64 {
  let r = $float_sum(float1, float2);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function hook_account(): ByteArray {
  let a = new ByteArray(20);
  let r = $hook_account(changetype<u32>(a), 20);
  if (r != 20)
    rollback("", r);

  return a;
}

@global @inline
export function hook_param(name: string): ByteArray {
  let a = new ByteArray(64);
  let r = $hook_param(changetype<u32>(a), 64, changetype<u32>(name), name.length);
  if (r < 0)
    r = 0;

  a.length = <i32>r;
  return a;
}

@global @inline
export function otxn_slot(sn: i32): i32 {
  let r = $otxn_slot(sn);
  if (r < 0)
    rollback("", r);

  return <i32>r;
}

@global @inline
export function rollback(msg: string = "", err: i64 = 0): void {
  $rollback(msg, msg.length, err);
  // does not return
}

@global @inline
export function slot(sn: i32, el: i32 = 64): ByteArray {
  let a = new ByteArray(el);
  let r = $slot(changetype<u32>(a), <u32>el, <u32>sn);
  if (r < 0)
    rollback("", r);

  return a;
}

@global @inline
export function slot_count(sn: i32): i32 {
  let r = $slot_count(<u32>sn);
  if (r < 0)
    rollback("", r);

  return <i32>r;
}

@global @inline
export function slot_float(sn: i32): i64 {
  let r = $slot_float(<u32>sn);
  if (r < 0)
    rollback("", r);

  return r;
}

@global @inline
export function slot_set(keylet: ByteArray, sn: i32): i32 {
  let r = $slot_set(changetype<u32>(keylet), <u32>(keylet.length), <u32>sn);
  if (r < 0)
    rollback("", r);

  return <i32>r;
}

@global @inline
export function slot_subarray(parent: i32, idx: i32, target: i32): i32 {
  let r = $slot_subarray(<u32>parent, <u32>idx, <u32>target);
  if (r < 0)
    rollback("", r);

  return <i32>r;
}

@global @inline
export function slot_subfield(parent: i32, field: i32, target: i32): i32 {
  let r = $slot_subfield(<u32>parent, <u32>field, <u32>target);
  if (r < 0)
    rollback("", r);

  return <i32>r;
}

@global @inline
export function slot_type(sn: u32, flags: u32): i32 {
  let r = $slot_type(sn, flags);
  if (r < 0)
    rollback("", r);

  return <i32>r;
}

@global @inline
export function state(key: ByteArray, el: i32 = 64): ByteArray {
  let a = new ByteArray(el);
  let r = $state(changetype<u32>(a), <u32>el, changetype<u32>(key), key.length);
  if (r < 0)
    r = 0;

  a.length = <i32>r;
  return a;
}

@global @inline
export function state_foreign(key: ByteArray, ns: ByteArray, acc: ByteArray, el: i32 = 64): ByteArray {
  let a = new ByteArray(el);
  let r = $state_foreign(changetype<u32>(a), <u32>el, changetype<u32>(key), key.length, changetype<u32>(ns), ns.length, changetype<u32>(acc), acc.length);
  if (r < 0)
    r = 0;

  a.length = <i32>r;
  return a;
}

@global @inline
export function state_set(key: ByteArray, data: ByteView): void {
  let r = $state_set(changetype<u32>(data.underlying) + data.offset, data.length, changetype<u32>(key), key.length);
  if (r < 0)
    rollback("", r);
}

@global @inline
export function sto_emplace(obj: ByteView, field: ByteView, fid: i32): ByteArray {
  let a = new ByteArray(obj.length + field.length + 4);
  let r = $sto_emplace(changetype<u32>(a), a.length, changetype<u32>(obj.underlying) + obj.offset, obj.length, changetype<u32>(field.underlying) + field.offset, field.length, fid);
  if (r < 0)
    rollback("", r);

  a.length = <i32>r;
  return a;
}

@global @inline
export function sto_erase(obj: ByteView, fid: i32): ByteView {
  let a = new ByteArray(obj.length);
  let r = $sto_erase(changetype<u32>(a), a.length, changetype<u32>(obj.underlying) + obj.offset, obj.length, fid);
  if (r == -5) { // DOESNT_EXIST
    return obj;
  }

  if (r < 0)
    rollback("", r);

  return new ByteView(a, 0, <i32>r);
}

@global @inline
export function sto_subarray(array: ByteView, index: i32): ByteView {
  let r = $sto_subarray(changetype<u32>(array.underlying) + array.offset, <u32>(array.length), <u32>index);
  if (r < 0)
    rollback("", r);

  let offset = <i32>(r >> 32);
  let length = <i32>(r & 0xFFFFFFFF);
  return new ByteView(array.underlying, array.offset + offset, length);
}

@global @inline
export function sto_subfield(obj: ByteView, fid: i32): ByteView {
  let r = $sto_subfield(changetype<u32>(obj.underlying) + obj.offset, <u32>(obj.length), <u32>fid);
  if (r < 0)
    rollback("", r);

  let offset = <i32>(r >> 32);
  let length = <i32>(r & 0xFFFFFFFF);
  return new ByteView(obj.underlying, obj.offset + offset, length);
}

@global @inline
export function trace_float(msg: string, fln: i64): void {
  $trace_float(msg, msg.length, fln);
}

@global @inline
export function trace_num(msg: string, num: i64): void {
  $trace_num(msg, msg.length, num);
  // could check return value here, but C macros don't do it either...
}

@global @inline
export function util_accid(raddr: string): ByteArray {
  let a = new ByteArray(20);
  let r = $util_accid(changetype<u32>(a), 20, changetype<u32>(raddr), raddr.length);
  if (r < 20)
    rollback("", r);

  return a;
}

@global @inline
export function util_sha512h(data: ByteView): ByteArray {
  let a = new ByteArray(32);
  let r = $util_sha512h(changetype<u32>(a), 32, changetype<u32>(data.underlying) + data.offset, data.length);
  if (r < 32)
    rollback("", r);

  return a;
}

export declare namespace document {
  /** Returns document's encoding. */
  @external("env", "document.characterSet")
  export const characterSet: string;
  /** Returns a value that indicates whether standards-compliant mode is switched on for the object. */
  @external("env", "document.compatMode")
  export const compatMode: string;
  /** Returns document's content type. */
  @external("env", "document.contentType")
  export const contentType: string;
  /** Returns a reference to the root node of the document. */
  @external("env", "document.documentElement")
  export const documentElement: externref;
  /** Returns document's URL. */
  @external("env", "document.documentURI")
  export const documentURI: string;
  /** Returns the URL of the location that referred the user to the current page. */
  @external("env", "document.referrer")
  export const referrer: string;
  /** Returns true if document has the ability of fullscreen mode, or false otherwise. */
  @external("env", "document.pictureInPictureEnabled")
  export const fullscreenEnabled: bool;
  /** Returns true if document has the ability of picture-in-picture mode, or false otherwise. */
  @external("env", "document.pictureInPictureEnabled")
  export const pictureInPictureEnabled: bool;

  /** Returns the number of child elements. */
  @external("env", "document.childElementCount")
  export const childElementCount: i32;
  /** Returns the child elements. */
  @external("env", "document.children")
  export const children: externref;
  /** Returns the first child that is an element, and null otherwise. */
  @external("env", "document.firstElementChild")
  export const firstElementChild: externref;
  /** Returns the last child that is an element, and null otherwise. */
  @external("env", "document.lastElementChild")
  export const lastElementChild: externref;

  /**
   * Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied
   * to this resource, the empty string will be returned.
   *
   * Can be set, to add a new cookie to the element's set of HTTP cookies.
   *
   * If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute),
   * a "SecurityError" DOMException will be thrown on getting and setting.
   */
  @external("env", "document.cookie")
  export let cookie: string;
  /** Represents the <body> or <frameset> node of the current document, or null if no such element exists. */
  @external("env", "document.body")
  export let body: externref;
  /** Sets or gets the security domain of the document. */
  @external("env", "document.domain")
  export let domain: string;
  /** Sets or gets the title of the document. */
  @external("env", "document.title")
  export let title: string;
  /** Sets or gets information about the current Location. */
  @external("env", "document.location")
  export let location: externref;
  /** Sets or gets the URL for the current document. */
  @external("env", "document.URL")
  export let URL: string;

  /**
   * Creates an instance of the element for the specified tag.
   * @param tagName The name of an element.
   */
  @external("env", "document.createElement")
  export function createElement(tagName: string /* , options?: ElementCreationOptions */): externref;
  /**
   * Returns a reference to the first HTMLElement object with the specified value of the ID attribute.
   * @param id String that specifies the ID value.
   */
  @external("env", "document.getElementById")
  export function getElementById(id: string): externref;
  /**
   * Returns a HTMLCollection of the elements in the object on which the method was invoked that have all the classes
   * given by classNames. The classNames argument is interpreted as a space-separated list of classes.
   * @param classNames Gets a collection of objects based on the value of the CLASS attribute.
   */
  @external("env", "document.getElementsByClassName")
  export function getElementsByClassName(classNames: string): externref;
  /**
   * Gets a collection of HTMLElement objects based on the value of the NAME or ID attribute.
   * @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.
   */
  @external("env", "document.getElementsByName")
  export function getElementsByName(elementName: string): externref;
  /** Gets a value indicating whether the object currently has focus. */
  @external("env", "document.hasFocus")
  export function hasFocus(): bool;
  /** Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes. */
  @external("env", "document.append")
  export function append(node: externref): void;
  /** Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes. */
  @external("env", "document.prepend")
  export function prepend(node: externref): void;
  /** Replace all children of node with nodes, while replacing strings in nodes with equivalent Text nodes. */
  @external("env", "document.replaceChildren")
  export function replaceChildren(node: externref): void;
  /**
   * Writes one or more HTML expressions to a document in the specified window.
   * @param content Specifies the text and HTML tags to write.
   */
  @external("env", "document.write")
  export function write(content: string): void;
  /**
   * Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window.
   * @param content Specifies the text and HTML tags to write.
   */
  @external("env", "document.writeln")
  export function writeln(content: string): void;
}

export declare namespace performance {
  @external("env", "performance.now")
  export function now(): f64;
}

export namespace crypto {
  export function getRandomValues(array: Uint8Array): void {
    let values = getRandomValuesN(array.length);
    array.set(values);
  }
  @external("env", "crypto.getRandomValuesN")
  @external.js("let a = new Uint8Array(n); crypto.getRandomValues(a); return a;")
  export declare function getRandomValuesN(n: u32): Uint8Array;
}
`,"bindings/encode":`// @ts-ignore: decorator
@lazy
export const ttPAYMENT: u8 = 0;

// @ts-ignore: decorator
@lazy
export const tfCANONICAL: u32 = 0x80000000;

// @ts-ignore: decorator
@lazy
export const atACCOUNT: u8 = 1;

// @ts-ignore: decorator
@lazy
export const atDESTINATION: u8 = 3;

// @ts-ignore: decorator
@lazy
export const amAMOUNT: u8 = 1;

// @ts-ignore: decorator
@lazy
export const amFEE: u8 = 8;

@inline
export function ENCODE_TL(buf: u32, tlamt: u32, uat: u8): u32 {
  store<u8>(buf, 0x60 + (uat & 0x0F));
  for (let i = 0; max_iterations(6), i < 48; i += 8)
    store<u64>(buf + i + 1, load<u64>(tlamt + i));
  return buf + 49;
}

@inline
export function ENCODE_TT(buf: u32, utt: u8): u32 {
  store<u8>(buf, 0x12);
  store<u8>(buf + 1, 0);
  store<u8>(buf + 2, utt);
  return buf + 3;
}

@inline
export function ENCODE_UINT32_COMMON(buf: u32, ui: u32, uf: u8): u32 {
  store<u8>(buf, 0x20 + (uf & 0x0F));
  store<u8>(buf + 1, (ui >> 24) & 0xFF);
  store<u8>(buf + 2, (ui >> 16) & 0xFF);
  store<u8>(buf + 3, (ui >> 8) & 0xFF);
  store<u8>(buf + 4, ui & 0xFF);
  return buf + 5;
}

@inline
export function ENCODE_UINT32_UNCOMMON(buf: u32, ui: u32, uf: u8): u32 {
  store<u8>(buf, 0x20);
  store<u8>(buf + 1, uf);
  // store<u32>?
  store<u8>(buf + 2, (ui >> 24) & 0xFF);
  store<u8>(buf + 3, (ui >> 16) & 0xFF);
  store<u8>(buf + 4, (ui >> 8) & 0xFF);
  store<u8>(buf + 5, ui & 0xFF);
  return buf + 6;
}

@inline
export function ENCODE_DROPS(buf: u32, udrops: u64, uat: u8): u32 {
  store<u8>(buf, 0x60 + (uat & 0x0F));
  // store<u64> (+ 1*store<u8>)?
  store<u8>(buf + 1, 0x40 + ((udrops >> 56) & 0x3F));
  store<u8>(buf + 2, (udrops >> 48) & 0xFF);
  store<u8>(buf + 3, (udrops >> 40) & 0xFF);
  store<u8>(buf + 4, (udrops >> 32) & 0xFF);
  store<u8>(buf + 5, (udrops >> 24) & 0xFF);
  store<u8>(buf + 6, (udrops >> 16) & 0xFF);
  store<u8>(buf + 7, (udrops >> 8) & 0xFF);
  store<u8>(buf + 8, udrops & 0xFF);
  return buf + 9;
}

@inline
export function ENCODE_DROPS_ARRAY(buf: u32, drops: ByteArray, uat: u8): u32 {
  store<u8>(buf, 0x60 + (uat & 0x0F));
  store<u8>(buf + 1, 0x40 + drops[0]);
  store<u8>(buf + 2, drops[1]);
  store<u8>(buf + 3, drops[2]);
  store<u8>(buf + 4, drops[3]);
  store<u8>(buf + 5, drops[4]);
  store<u8>(buf + 6, drops[5]);
  store<u8>(buf + 7, drops[6]);
  store<u8>(buf + 8, drops[7]);
  return buf + 9;
}

@inline
export function ENCODE_ACCOUNT(buf: u32, account_id: u32, uat: u8): u32 {
  store<u8>(buf, 0x80 + uat);
  store<u8>(buf + 1, 0x14);
  store<u64>(buf + 2, load<u64>(account_id));
  store<u64>(buf + 10, load<u64>(account_id + 8));
  store<u32>(buf + 18, load<u32>(account_id + 16));
  return buf + 22;
}

@inline
export function _01_02_ENCODE_TT(buf: u32, tt: u8): u32 {
  return ENCODE_TT(buf, tt);
}

@inline
export function _02_02_ENCODE_FLAGS(buf: u32, tag: u32): u32 {
  return ENCODE_UINT32_COMMON(buf, tag, 0x2);
}

@inline
export function _02_03_ENCODE_TAG_SRC(buf: u32, tag: u32): u32 {
  return ENCODE_UINT32_COMMON(buf, tag, 0x3);
}

@inline
export function _02_04_ENCODE_SEQUENCE(buf: u32, sequence: u32): u32 {
  return ENCODE_UINT32_COMMON(buf, sequence, 0x4);
}

@inline
export function _02_14_ENCODE_TAG_DST(buf: u32, tag: u32): u32 {
  return ENCODE_UINT32_COMMON(buf, tag, 0xE);
}

@inline
export function _02_26_ENCODE_FLS(buf: u32, fls: u32): u32 {
  return ENCODE_UINT32_UNCOMMON(buf, fls, 0x1A);
}

@inline
export function _02_27_ENCODE_LLS(buf: u32, lls: u32): u32 {
  return ENCODE_UINT32_UNCOMMON(buf, lls, 0x1B);
}

@inline
export function _06_01_ENCODE_DROPS_AMOUNT(buf: u32, drops: ByteArray): u32 {
  return ENCODE_DROPS_ARRAY(buf, drops, amAMOUNT);
}

@inline
export function _06_01_ENCODE_TL_AMOUNT(buf: u32, drops: ByteArray): u32 {
  return ENCODE_TL(buf, changetype<u32>(drops), amAMOUNT);
}

@inline
export function _06_08_ENCODE_DROPS_FEE(buf: u32, drops: u64): u32 {
  return ENCODE_DROPS(buf, drops, amFEE);
}

@inline
export function _07_03_ENCODE_SIGNING_PUBKEY_NULL(buf: u32): u32 {
  store<u8>(buf, 0x73);
  store<u8>(buf + 1, 0x21);
  store<u64>(buf + 2, 0);
  store<u64>(buf + 10, 0);
  store<u64>(buf + 18, 0);
  store<u64>(buf + 25, 0);
  return buf + 35;
}

@inline
export function _08_01_ENCODE_ACCOUNT_SRC(buf: u32, account_id: u32): u32 {
  return ENCODE_ACCOUNT(buf, account_id, atACCOUNT);
}

@inline
export function _08_03_ENCODE_ACCOUNT_DST(buf: u32, account_id: u32): u32 {
  return ENCODE_ACCOUNT(buf, account_id, atDESTINATION);
}
`,"bindings/node":`export declare namespace process {
  @external("env", "process.argv")
  export const argv: string[];
  @external("env", "process.exit")
  export function exit(code: i32): void;
}
`,builtins:`import { strtol, strtod, strtob } from "./util/string";

type auto = i32;

// @ts-ignore: decorator
@builtin
export declare function isBoolean<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isInteger<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isSigned<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isFloat<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isVector<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isReference<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isString<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isArray<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isArrayLike<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isFunction<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isNullable<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isDefined(expression: auto): bool;

// @ts-ignore: decorator
@builtin
export declare function isConstant(expression: auto): bool;

// @ts-ignore: decorator
@builtin
export declare function isManaged<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isVoid<T>(): bool;

// @ts-ignore
@builtin
export declare function lengthof<T>(func?: T): i32;

// @ts-ignore
@builtin
export declare function bswap<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function clz<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function ctz<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function popcnt<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function rotl<T>(value: T, shift: T): T;

// @ts-ignore: decorator
@builtin
export declare function rotr<T>(value: T, shift: T): T;

// @ts-ignore: decorator
@builtin
export declare function abs<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function max<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function min<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function ceil<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function floor<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function copysign<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function nearest<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function reinterpret<T>(value: number): T;

// @ts-ignore: decorator
@builtin
export declare function sqrt<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function trunc<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function add<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function sub<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function mul<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function div<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function eq<T>(left: T, right: T): i32;

// @ts-ignore: decorator
@builtin
export declare function ne<T>(left: T, right: T): i32;

// @ts-ignore: decorator
@builtin
export declare function rem<T>(left: T, right: T): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;

// @ts-ignore: decorator
@builtin
export declare function sizeof<T>(): usize; // | u32 / u64

// @ts-ignore: decorator
@builtin
export declare function alignof<T>(): usize; // | u32 / u64

// @ts-ignore: decorator
@builtin
export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64

// @ts-ignore: decorator
@builtin
export declare function idof<T>(): u32;

// @ts-ignore
@builtin
export declare function nameof<T>(): string;

// @ts-ignore: decorator
@builtin
export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function unreachable(): auto;

// @ts-ignore: decorator
@builtin
export declare function changetype<T>(value: auto): T;

// @ts-ignore: decorator
@builtin
export declare function assert<T>(isTrueish: T, message?: string): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function unchecked<T>(expr: T): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function call_indirect<T>(index: u32, ...args: auto[]): T;

// @ts-ignore: decorator
@builtin
export declare function instantiate<T>(...args: auto[]): T;

export namespace atomic {
  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load<T>(ptr: usize, immOffset?: usize): T;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;

  // @ts-ignore: decorator
  @builtin
  export declare function notify(ptr: usize, count: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function fence(): void;
}

// @ts-ignore: decorator
@lazy
export const enum AtomicWaitResult {
  OK = 0,
  NOT_EQUAL = 1,
  TIMED_OUT = 2
}

// @ts-ignore: decorator
@builtin
export declare function i8(value: auto): i8;

export namespace i8 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i8 = -128;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i8 =  127;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): i8 {
    return <i8>strtol<i32>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function i16(value: auto): i16;

export namespace i16 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i16 = -32768;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i16 =  32767;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): i16 {
    return <i16>strtol<i32>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function i32(value: auto): i32;

export namespace i32 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i32 = -2147483648;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i32 =  2147483647;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): i32 {
    return strtol<i32>(value, radix);
  }

  // @ts-ignore: decorator
  @builtin
  export declare function clz(value: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function ctz(value: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt(value: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function div_s(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function div_u(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function rotl(value: i32, shift: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function rotr(value: i32, shift: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function rem_s(left: i32, right: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function rem_u(left: u32, right: u32): u32;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_f32(value: f32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;

  export namespace atomic {

    // @ts-ignore: decorator
    @builtin
    export declare function load8_u(ptr: usize, immOffset?: usize): i32;

    // @ts-ignore: decorator
    @builtin
    export declare function load16_u(ptr: usize, immOffset?: usize): i32;

    // @ts-ignore: decorator
    @builtin
    export declare function load(ptr: usize, immOffset?: usize): i32;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;

    // @ts-ignore: decorator
    @builtin
    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;

    export namespace rmw8 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }

    export namespace rmw16 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }

    export namespace rmw {

      // @ts-ignore: decorator
      @builtin
      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
  }
}

// @ts-ignore: decorator
@builtin
export declare function i64(value: auto): i64;

export namespace i64 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i64 = -9223372036854775808;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i64 =  9223372036854775807;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): i64 {
    return strtol<i64>(value, radix);
  }

  // @ts-ignore: decorator
  @builtin
  export declare function clz(value: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function ctz(value: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function div_s(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function div_u(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt(value: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function rotl(value: i64, shift: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function rotr(value: i64, shift: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(left: i64, right:i64): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(left: i64, right:i64): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function rem_s(left: i64, right: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function rem_u(left: u64, right: u64): u64;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_f64(value: f64): i64;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  export namespace atomic {

    // @ts-ignore: decorator
    @builtin
    export declare function load8_u(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @builtin
    export declare function load16_u(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @builtin
    export declare function load32_u(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @builtin
    export declare function load(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @builtin
    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;

    export namespace rmw8 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }

    export namespace rmw16 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }

    export namespace rmw32 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }

    export namespace rmw {

      // @ts-ignore: decorator
      @builtin
      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
  }
}

// @ts-ignore: decorator
@builtin
export declare function isize(value: auto): isize;

export namespace isize {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()
    ? -2147483648
    : <isize>-9223372036854775808;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()
    ? 2147483647
    : <isize>9223372036854775807;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): isize {
    return <isize>strtol<i64>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function u8(value: auto): u8;

export namespace u8 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u8 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u8 = 255;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): u8 {
    return <u8>strtol<i32>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function u16(value: auto): u16;

export namespace u16 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u16 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u16 = 65535;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): u16 {
    return <u16>strtol<i32>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function u32(value: auto): u32;

export namespace u32 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u32 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u32 = 4294967295;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): u32 {
    return <u32>strtol<i32>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function u64(value: auto): u64;

export namespace u64 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u64 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u64 = 18446744073709551615;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): u64 {
    return <u64>strtol<i64>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function usize(value: auto): usize;

export namespace usize {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: usize = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()
    ? 4294967295
    : <usize>18446744073709551615;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string, radix: i32 = 0): usize {
    return <usize>strtol<i64>(value, radix);
  }
}

// @ts-ignore: decorator
@builtin
export declare function bool(value: auto): bool;

export namespace bool {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: bool = false;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: bool = true;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string): bool {
    return strtob(value);
  }
}

// @ts-ignore: decorator
@builtin
export declare function f32(value: auto): f32;

export namespace f32 {

  // @ts-ignore: decorator
  @lazy
  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f

  // @ts-ignore: decorator
  @lazy
  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f

  // @ts-ignore: decorator
  @lazy
  export const MIN_SAFE_INTEGER: f32 = -16777215;

  // @ts-ignore: decorator
  @lazy
  export const MAX_SAFE_INTEGER: f32 =  16777215;

  // @ts-ignore: decorator
  @lazy
  export const POSITIVE_INFINITY: f32 =  Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NEGATIVE_INFINITY: f32 = -Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NaN: f32 = 0.0 / 0.0;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string): f32 {
    return <f32>strtod(value);
  }

  // @ts-ignore: decorator
  @builtin
  export declare function abs(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function copysign(x: f32, y: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function max(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function min(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_i32(value: i32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(value: f32): f32;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function div(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(left: f32, right: f32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(left: f32, right: f32): i32;
}

// @ts-ignore: decorator
@builtin
export declare function f64(value: auto): f64;

export namespace f64 {

  // @ts-ignore: decorator
  @lazy
  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023

  // @ts-ignore: decorator
  @lazy
  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022

  // @ts-ignore: decorator
  @lazy
  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;

  // @ts-ignore: decorator
  @lazy
  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;

  // @ts-ignore: decorator
  @lazy
  export const POSITIVE_INFINITY: f64 =  Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NEGATIVE_INFINITY: f64 = -Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NaN: f64 = 0.0 / 0.0;

  // @ts-ignore: decorator
  @inline
  export function parse(value: string): f64 {
    return strtod(value);
  }

  // @ts-ignore: decorator
  @builtin
  export declare function abs(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function copysign(x: f64, y: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function max(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function min(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_i64(value: i64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(value: f64): f64;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function div(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(left: f64, right: f64): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(left: f64, right: f64): i32;
}

// @ts-ignore: decorator
@builtin
export declare function v128(
  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,
  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8
): v128;

export namespace v128 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat<T>(x: T): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane<T>(x: v128, idx: u8): T;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function add<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function neg<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl<T>(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr<T>(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function and(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function or(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function xor(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function andnot(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function not(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function any_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true<T>(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask<T>(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmin<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmax<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function dot<T>(a: v128, b: v128): v128; // i16 only

  // @ts-ignore: decorator
  @builtin
  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only

  // @ts-ignore: decorator
  @builtin
  export declare function abs<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function ceil<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function floor<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function trunc<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function nearest<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function eq<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_low<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_zero<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function demote_zero<T = f64>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function promote_low<T = f32>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high<T>(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i8x16(
  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,
  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8
): v128;

export namespace i8x16 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_s(x: v128, idx: u8): i8;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_u(x: v128, idx: u8): u8;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function avgr_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i16x8_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle(
    a: v128, b: v128,
    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,
    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8
  ): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;

export namespace i16x8 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i16): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_s(x: v128, idx: u8): i16;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_u(x: v128, idx: u8): u16;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function avgr_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i32x4_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i32x4_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i8x16_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i8x16_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i8x16_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i8x16_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i8x16_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i8x16_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function q15mulr_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle(
    a: v128, b: v128,
    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8
  ): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;

export namespace i32x4 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function dot_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i16x8_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i16x8_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i16x8_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i16x8_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i16x8_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i16x8_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i64x2(a: i64, b: i64): v128;

export namespace i64x2 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;

export namespace f32x4 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: f32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function div(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmin(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmax(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function demote_f64x2_zero(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function f64x2(a: f64, b: f64): v128;

export namespace f64x2 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: f64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function div(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmin(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmax(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_low_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_low_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function promote_low_f32x4(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, b: v128): v128;
}

@final
export abstract class i31 { // FIXME: usage of 'new' requires a class :(

  // @ts-ignore: decorator
  @builtin
  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }

  // @ts-ignore: decorator
  @builtin
  static get(i31expr: i31ref): i32 { return unreachable(); }
}

/* eslint-disable @typescript-eslint/no-unused-vars */

// @ts-ignore: decorator
@external("env", "abort")
@external.js("throw Error(\`\${message} in \${fileName}:\${lineNumber}:\${columnNumber}\`);")
declare function abort(
  message?: string | null,
  fileName?: string | null,
  lineNumber?: u32,
  columnNumber?: u32
): void;

// @ts-ignore: decorator
@external("env", "_g")
declare function _g(
  id: i32,
  maxiter: i32
): i32

@builtin
export declare function max_iterations(maxiter: i32): i32;

// @ts-ignore: decorator
@external("env", "accept")
declare function $accept(
  read_ptr: string,
  read_len: u32,
  err: i64
): i64

// @ts-ignore: decorator
@external("env", "emit")
declare function $emit(
  write_ptr: u32,
  write_len: u32,
  read_ptr: u32,
  read_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "etxn_details")
export declare function $etxn_details(
  write_ptr: u32,
  write_len: u32
): i64

// @ts-ignore: decorator
@external("env", "etxn_fee_base")
export declare function $etxn_fee_base(
  read_ptr: u32,
  read_len: u32
): i64

// @ts-ignore: decorator
@external("env", "etxn_reserve")
export declare function $etxn_reserve(
  count: u32
): i64

// @ts-ignore: decorator
@external("env", "float_compare")
declare function $float_compare(
  float1: i64,
  float2: i64,
  mode: u32
): i64;

// @ts-ignore: decorator
@external("env", "float_divide")
declare function $float_divide(
  float1: i64,
  float2: i64
): i64;

// @ts-ignore: decorator
@external("env", "float_int")
declare function $float_int(
  float1: i64,
  decimal_places: u32,
  abs: u32
): i64;

// @ts-ignore: decorator
@external("env", "float_mulratio")
declare function $float_mulratio(
  float1: i64,
  round_up: u32,
  numerator: u32,
  denominator: u32
): i64;

// @ts-ignore: decorator
@external("env", "float_multiply")
declare function $float_multiply(
  float1: i64,
  float2: i64
): i64;

// @ts-ignore: decorator
@external("env", "float_negate")
declare function $float_negate(
  float1: i64
): i64;

// @ts-ignore: decorator
@external("env", "float_set")
declare function $float_set(
  exponent: i32,
  mantissa: i64
): i64;

// @ts-ignore: decorator
@external("env", "float_sto")
declare function $float_sto(
  write_ptr: u32,
  write_len: u32,
  cread_ptr: u32,
  cread_len: u32,
  iread_ptr: u32,
  iread_len: u32,
  float1: i64,
  field_code: u32
): i64;

// @ts-ignore: decorator
@external("env", "float_sto_set")
declare function $float_sto_set(
  read_ptr: u32,
  read_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "float_sum")
declare function $float_sum(
  float1: i64,
  float2: i64
): i64;

// @ts-ignore: decorator
@external("env", "hook_account")
declare function $hook_account(
  write_ptr: u32,
  write_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "hook_param")
declare function $hook_param(
  write_ptr: u32,
  write_len: u32,
  read_ptr: u32,
  read_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "ledger_seq")
declare function ledger_seq(
): i64;

// @ts-ignore: decorator
@external("env", "otxn_field")
declare function otxn_field(
  write_ptr: u32,
  write_len: u32,
  field_id: u32
): i64;

// @ts-ignore: decorator
@external("env", "otxn_slot")
declare function $otxn_slot(
  slot_no: u32
): i64;

// @ts-ignore: decorator
@external("env", "rollback")
declare function $rollback(
  read_ptr: string,
  read_len: u32,
  error_code: i64
): i64;

// @ts-ignore: decorator
@external("env", "slot")
declare function $slot(
  write_ptr: u32,
  write_len: u32,
  slot_no: u32
): i64;

// @ts-ignore: decorator
@external("env", "slot_count")
declare function $slot_count(
  slot_no: u32
): i64;

// @ts-ignore: decorator
@external("env", "slot_float")
declare function $slot_float(
  slot_no: u32
): i64;

// @ts-ignore: decorator
@external("env", "slot_set")
declare function $slot_set(
  read_ptr: u32,
  read_len: u32,
  slot_no: u32
): i64;

// @ts-ignore: decorator
@external("env", "slot_subarray")
declare function $slot_subarray(
  parent_slot: u32,
  array_id: u32,
  new_slot: u32
): i64;

// @ts-ignore: decorator
@external("env", "slot_subfield")
declare function $slot_subfield(
  parent_slot: u32,
  field_id: u32,
  new_slot: u32
): i64;

// @ts-ignore: decorator
@external("env", "slot_type")
declare function $slot_type(
  slot_no: u32,
  flags: u32
): i64;

// @ts-ignore: decorator
@external("env", "state")
declare function $state(
  write_ptr: u32,
  write_len: u32,
  kread_ptr: u32,
  kread_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "state_foreign")
declare function $state_foreign(
  write_ptr: u32,
  write_len: u32,
  kread_ptr: u32,
  kread_len: u32,
  nread_ptr: u32,
  nread_len: u32,
  aread_ptr: u32,
  aread_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "state_set")
declare function $state_set(
  read_ptr: u32,
  read_len: u32,
  kread_ptr: u32,
  kread_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "sto_emplace")
declare function $sto_emplace(
  write_ptr: u32,
  write_len: u32,
  sread_ptr: u32,
  sread_len: u32,
  fread_ptr: u32,
  fread_len: u32,
  field_id: u32
): i64;

// @ts-ignore: decorator
@external("env", "sto_erase")
declare function $sto_erase(
  write_ptr: u32,
  write_len: u32,
  read_ptr: u32,
  read_len: u32,
  field_id: u32
): i64;

// @ts-ignore: decorator
@external("env", "sto_subarray")
declare function $sto_subarray(
  read_ptr: u32,
  read_len: u32,
  array_id: u32
): i64;

// @ts-ignore: decorator
@external("env", "sto_subfield")
declare function $sto_subfield(
  read_ptr: u32,
  read_len: u32,
  field_id: u32
): i64;

// @ts-ignore: decorator
@external("env", "trace")
declare function trace(
  mread_ptr: string,
  mread_len: u32,
  dread_ptr: u32,
  dread_len: u32,
  as_hex: u32
): i64;

// @ts-ignore: decorator
@external("env", "trace_float")
declare function $trace_float(
  read_ptr: string,
  read_len: u32,
  float1: i64
): i64;

// @ts-ignore: decorator
@external("env", "trace_num")
declare function $trace_num(
  read_ptr: string,
  read_len: u32,
  num: i64
): i64;

// @ts-ignore: decorator
@external("env", "util_accid")
declare function $util_accid(
  write_ptr: u32,
  write_len: u32,
  read_ptr: u32,
  read_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "util_keylet")
declare function $util_keylet(
  write_ptr: u32,
  write_len: u32,
  keylet_type: u32,
  a: u32,
  b: u32,
  c: u32,
  d: u32,
  e: u32,
  f: u32
): i64;

// @ts-ignore: decorator
@external("env", "util_sha512h")
declare function $util_sha512h(
  write_ptr: u32,
  write_len: u32,
  read_ptr: u32,
  read_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "util_verify")
declare function $util_verify(
  dread_ptr: u32,
  dread_len: u32,
  sread_ptr: u32,
  sread_len: u32,
  kread_ptr: u32,
  kread_len: u32
): i64;

// @ts-ignore: decorator
@external("env", "seed")
@external.js("return Date.now() * Math.random();")
declare function seed(): f64;

/* eslint-enable @typescript-eslint/no-unused-vars */
`,compat:`export type ReturnType<T> = returnof<T>;
export type NonNullable<T> = nonnull<T>;
`,console:`import {
  console as binding
} from "./bindings/dom";

export namespace console {

  export function assert<T>(condition: T, message: string = ""): void {
    binding.assert(!!condition, message);
  }

  export function log(message: string = ""): void {
    binding.log(message);
  }

  export function debug(message: string = ""): void {
    binding.debug(message);
  }

  export function info(message: string = ""): void {
    binding.info(message);
  }

  export function warn(message: string = ""): void {
    binding.warn(message);
  }

  export function error(message: string = ""): void {
    binding.error(message);
  }

  export function time(label: string = "default"): void {
    binding.time(label);
  }

  export function timeLog(label: string = "default"): void {
    binding.timeLog(label);
  }

  export function timeEnd(label: string = "default"): void {
    binding.timeEnd(label);
  }
}
`,copyx:`@global @inline
export function __copy1(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  store<u8>(dest, load<u8>(ptr));
  return dest + 1;
}

@global @inline
export function __copy2(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  store<u16>(dest, load<u16>(ptr));
  return dest + 2;
}

@global @inline
export function __copy3(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  store<u16>(dest, load<u16>(ptr));
  dest += 2;
  ptr += 2;
  store<u8>(dest, load<u8>(ptr));
  return dest + 1;
}

@global @inline
export function __copy4(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  store<u32>(dest, load<u32>(ptr));
  return dest + 4;
}

@global @inline
export function __copy5(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  store<u32>(dest, load<u32>(ptr));
  dest += 4;
  ptr += 4;
  store<u8>(dest, load<u8>(ptr));
  return dest + 1;
}

@global @inline
export function __copy6(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  store<u32>(dest, load<u32>(ptr));
  dest += 4;
  ptr += 4;
  store<u16>(dest, load<u16>(ptr));
  return dest + 2;
}

@global @inline
export function __copy21(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  store<u64>(dest, load<u64>(ptr));
  dest += 8;
  ptr += 8;
  store<u64>(dest, load<u64>(ptr));
  dest += 8;
  ptr += 8;
  store<u32>(dest, load<u32>(ptr));
  dest += 4;
  ptr += 4;
  store<u8>(dest, load<u8>(ptr));
  return dest + 1;
}

@global @inline
export function __copy47(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  for (let i = 0; max_iterations(5), i < 5; ++i) {
    store<u64>(dest, load<u64>(ptr));
    dest += 8;
    ptr += 8;
  }

  store<u32>(dest, load<u32>(ptr));
  dest += 4;
  ptr += 4;
  store<u16>(dest, load<u16>(ptr));
  dest += 2;
  ptr += 2;
  store<u8>(dest, load<u8>(ptr));
  return dest + 1;
}

@global @inline
export function __copy64(dest: usize, src: string): usize {
  let ptr = changetype<usize>(src);
  for (let i = 0; max_iterations(8), i < 8; ++i) {
    store<u64>(dest, load<u64>(ptr));
    dest += 8;
    ptr += 8;
  }

  return dest;
}
`,crypto:`import {
  crypto as crypto_binding
} from "bindings/dom";

export namespace crypto {
  export function getRandomValues(array: Uint8Array): void {
    crypto_binding.getRandomValues(array);
  }
}
`,dataview:`import { BLOCK_MAXSIZE } from "./rt/common";
import { ArrayBuffer } from "./arraybuffer";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from "./util/error";

// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte

export class DataView {

  readonly buffer: ArrayBuffer;
  @unsafe readonly dataStart: usize;
  readonly byteLength: i32;

  get byteOffset(): i32 {
    return <i32>(this.dataStart - changetype<usize>(this.buffer));
  }

  constructor(
    buffer: ArrayBuffer,
    byteOffset: i32 = 0,
    byteLength: i32 = buffer.byteLength
  ) {
    if (
      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |
      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)
    ) throw new RangeError(E_INVALIDLENGTH);
    this.buffer = buffer; // links
    let dataStart = changetype<usize>(buffer) + <usize>byteOffset;
    this.dataStart = dataStart;
    this.byteLength = byteLength;
  }

  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    return littleEndian
      ? load<f32>(this.dataStart + <usize>byteOffset)
      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));
  }

  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    return littleEndian
      ? load<f64>(this.dataStart + <usize>byteOffset)
      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));
  }

  getInt8(byteOffset: i32): i8 {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i8>(this.dataStart + <usize>byteOffset);
  }

  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    let result: i16 = load<i16>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u16>(result);
  }

  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    let result: i32 = load<i32>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u32>(result);
  }

  getUint8(byteOffset: i32): u8 {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>byteOffset);
  }

  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    let result: u16 = load<u16>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u16>(result);
  }

  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    let result: u32 = load<u32>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u32>(result);
  }

  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);
    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));
  }

  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);
    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));
  }

  setInt8(byteOffset: i32, value: i8): void {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i8>(this.dataStart + <usize>byteOffset, value);
  }

  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));
  }

  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));
  }

  setUint8(byteOffset: i32, value: u8): void {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u8>(this.dataStart + <usize>byteOffset, value);
  }

  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));
  }

  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));
  }

  // Non-standard additions that make sense in WebAssembly, but won't work in JS:

  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    let result: i64 = load<i64>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u64>(result);
  }

  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    let result = load<u64>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u64>(result);
  }

  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));
  }

  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));
  }

  toString(): string {
    return "[object DataView]";
  }
}
`,date:`import { E_INVALIDDATE } from "util/error";
import { Date as Date_binding } from "./bindings/dom";

// @ts-ignore: decorator
@inline const
  MILLIS_PER_DAY    = 1000 * 60 * 60 * 24,
  MILLIS_PER_HOUR   = 1000 * 60 * 60,
  MILLIS_PER_MINUTE = 1000 * 60,
  MILLIS_PER_SECOND = 1000,

  YEARS_PER_EPOCH = 400,
  DAYS_PER_EPOCH = 146097,
  EPOCH_OFFSET = 719468, // Jan 1, 1970
  MILLIS_LIMIT = 8640000000000000;

// ymdFromEpochDays returns values via globals to avoid allocations
// @ts-ignore: decorator
@lazy let _month: i32, _day: i32;

export class Date {
  private year: i32 = 0;
  private month: i32 = 0;
  private day: i32 = 0;

  @inline static UTC(
    year: i32,
    month: i32 = 0,
    day: i32 = 1,
    hour: i32 = 0,
    minute: i32 = 0,
    second: i32 = 0,
    millisecond: i32 = 0
  ): i64 {
    if (year >= 0 && year <= 99) year += 1900;
    let ms = epochMillis(year, month + 1, day, hour, minute, second, millisecond);
    if (invalidDate(ms)) throw new RangeError(E_INVALIDDATE);
    return ms;
  }

  @inline static now(): i64 {
    return <i64>Date_binding.now();
  }

  // It can parse only ISO 8601 inputs like YYYY-MM-DDTHH:MM:SS.000Z
  @inline static parse(dateString: string): Date {
    return this.fromString(dateString);
  }

  static fromString(dateTimeString: string): Date {
    if (!dateTimeString.length) throw new RangeError(E_INVALIDDATE);
    var
      hour: i32 = 0,
      min: i32 = 0,
      sec: i32 = 0,
      ms: i32 = 0;

    let dateString = dateTimeString;
    let posT = dateTimeString.indexOf("T");
    if (~posT) {
      // includes a time component
      let timeString: string;
      dateString = dateTimeString.substring(0, posT);
      timeString = dateTimeString.substring(posT + 1);
      // parse the HH-MM-SS component
      let timeParts = timeString.split(":");
      let len = timeParts.length;
      if (len <= 1) throw new RangeError(E_INVALIDDATE);

      hour = I32.parseInt(timeParts[0]);
      min  = I32.parseInt(timeParts[1]);
      if (len >= 3) {
        let secAndMs = timeParts[2];
        let posDot = secAndMs.indexOf(".");
        if (~posDot) {
          // includes milliseconds
          sec = I32.parseInt(secAndMs.substring(0, posDot));
          ms  = I32.parseInt(secAndMs.substring(posDot + 1));
        } else {
          sec = I32.parseInt(secAndMs);
        }
      }
    }
    // parse the YYYY-MM-DD component
    let parts = dateString.split("-");
    let year = I32.parseInt(parts[0]);
    let month = 1, day = 1;
    let len = parts.length;
    if (len >= 2) {
      month = I32.parseInt(parts[1]);
      if (len >= 3) {
        day = I32.parseInt(parts[2]);
      }
    }
    return new Date(epochMillis(year, month, day, hour, min, sec, ms));
  }

  constructor(private epochMillis: i64) {
    // this differs from JavaScript which prefer return NaN or "Invalid Date" string
    // instead throwing exception.
    if (invalidDate(epochMillis)) throw new RangeError(E_INVALIDDATE);

    this.year = dateFromEpoch(epochMillis);
    this.month = _month;
    this.day = _day;
  }

  @inline getTime(): i64 {
    return this.epochMillis;
  }

  setTime(time: i64): i64 {
    if (invalidDate(time)) throw new RangeError(E_INVALIDDATE);

    this.epochMillis = time;
    this.year = dateFromEpoch(time);
    this.month = _month;
    this.day = _day;

    return time;
  }

  @inline getUTCFullYear(): i32 {
    return this.year;
  }

  @inline getUTCMonth(): i32 {
    return this.month - 1;
  }

  @inline getUTCDate(): i32 {
    return this.day;
  }

  @inline getUTCDay(): i32 {
    return dayOfWeek(this.year, this.month, this.day);
  }

  getUTCHours(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_DAY)) / MILLIS_PER_HOUR;
  }

  getUTCMinutes(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_HOUR)) / MILLIS_PER_MINUTE;
  }

  getUTCSeconds(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_MINUTE)) / MILLIS_PER_SECOND;
  }

  getUTCMilliseconds(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_SECOND));
  }

  setUTCMilliseconds(millis: i32): void {
    this.setTime(this.epochMillis + (millis - this.getUTCMilliseconds()));
  }

  setUTCSeconds(seconds: i32): void {
    this.setTime(this.epochMillis + (seconds - this.getUTCSeconds()) * MILLIS_PER_SECOND);
  }

  setUTCMinutes(minutes: i32): void {
    this.setTime(this.epochMillis + (minutes - this.getUTCMinutes()) * MILLIS_PER_MINUTE);
  }

  setUTCHours(hours: i32): void {
    this.setTime(this.epochMillis + (hours - this.getUTCHours()) * MILLIS_PER_HOUR);
  }

  setUTCDate(day: i32): void {
    if (this.day == day) return;
    this.setTime(join(this.year, this.month, day, this.epochMillis));
  }

  setUTCMonth(month: i32, day: i32 = this.day): void {
    if (this.month == month + 1) return;
    this.setTime(join(this.year, month + 1, day, this.epochMillis));
  }

  setUTCFullYear(year: i32): void {
    if (this.year == year) return;
    this.setTime(join(year, this.month, this.day, this.epochMillis));
  }
}

function epochMillis(
  year: i32,
  month: i32,
  day: i32,
  hour: i32,
  minute: i32,
  second: i32,
  milliseconds: i32
): i64 {
  return (
    daysSinceEpoch(year, month, day) * MILLIS_PER_DAY +
    hour * MILLIS_PER_HOUR +
    minute * MILLIS_PER_MINUTE +
    second * MILLIS_PER_SECOND +
    milliseconds
  );
}

// @ts-ignore: decorator
@inline function floorDiv<T extends number>(a: T, b: T): T {
  return (a - (a < 0 ? b - 1 : 0)) / b as T;
}

// @ts-ignore: decorator
@inline function euclidRem<T extends number>(a: T, b: T): T {
  let m = a % b;
  return m + (m < 0 ? b : 0) as T;
}

function invalidDate(millis: i64): bool {
  // @ts-ignore
  return (millis < -MILLIS_LIMIT) | (millis > MILLIS_LIMIT);
}

// Based on "Euclidean Affine Functions and Applications to Calendar Algorithms"
// Paper: https://arxiv.org/pdf/2102.06959.pdf
function dateFromEpoch(ms: i64): i32 {
  let da = (<i32>floorDiv(ms, MILLIS_PER_DAY) * 4 + EPOCH_OFFSET * 4) | 3;
  let q0 = floorDiv(da, DAYS_PER_EPOCH); // [0, 146096]
  let r1 = <u32>da - q0 * DAYS_PER_EPOCH;
  let u1 = u64(r1 | 3) * 2939745;
  let dm1 = <u32>u1 / 11758980;
  let n1 = 2141 * dm1 + 197913;
  let year = 100 * q0 + i32(u1 >>> 32);
  let mo = n1 >>> 16;
  _day = (n1 & 0xFFFF) / 2141 + 1; // [1, 31]
  if (dm1 >= 306) { mo -= 12; ++year; }
  _month = mo; // [1, 12]
  return year;
}

// http://howardhinnant.github.io/date_algorithms.html#days_from_civil
function daysSinceEpoch(y: i32, m: i32, d: i32): i64 {
  y -= i32(m <= 2);
  let era = <u32>floorDiv(y, YEARS_PER_EPOCH);
  let yoe = <u32>y - era * YEARS_PER_EPOCH; // [0, 399]
  let doy = <u32>(153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1; // [0, 365]
  let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy; // [0, 146096]
  return <i64><i32>(era * 146097 + doe - EPOCH_OFFSET);
}

// TomohikoSakamoto algorithm from https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week
function dayOfWeek(year: i32, month: i32, day: i32): i32 {
  const tab = memory.data<u8>([0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]);

  year -= i32(month < 3);
  year += floorDiv(year, 4) - floorDiv(year, 100) + floorDiv(year, YEARS_PER_EPOCH);
  month = <i32>load<u8>(tab + month - 1);
  return euclidRem(year + month + day, 7);
}

function stringify(value: i32, padding: i32 = 2): string {
  return value.toString().padStart(padding, "0");
}

function join(year: i32, month: i32, day: i32, ms: i64): i64 {
  return daysSinceEpoch(year, month, day) * MILLIS_PER_DAY + euclidRem(ms, MILLIS_PER_DAY);
}
`,diagnostics:`// @ts-ignore: decorator
@builtin
export declare function ERROR(message?: string): void;

// @ts-ignore: decorator
@builtin
export declare function WARNING(message?: string): void;

// @ts-ignore: decorator
@builtin
export declare function INFO(message?: string): void;
`,eqx:`@global @inline
export function __eq0(left: ByteView, right: string): bool {
  return left.length == 0;
}

@global @inline
export function __eq1(left: ByteView, right: string): bool {
  return (left.length == 1) && (left[0] == right[0]);
}

@global @inline
export function __eq2(left: ByteView, right: string): bool {
  if (left.length != 2) return false;

  let ptr1 = changetype<usize>(left.underlying) + left.offset;
  let ptr2 = changetype<usize>(right);
  return load<u16>(ptr1) == load<u16>(ptr2);
}

@global @inline
export function __eq16(left: ByteView, right: string): bool {
  if (left.length != 16) return false;

  let ptr1 = changetype<usize>(left.underlying) + left.offset;
  let ptr2 = changetype<usize>(right);
  if (load<u64>(ptr1) != load<u64>(ptr2)) return false;
  ptr1 += 8;
  ptr2 += 8;
  return load<u64>(ptr1) == load<u64>(ptr2);
}

@global @inline
export function __eq18(left: ByteView, right: string): bool {
  if (left.length != 18) return false;

  let ptr1 = changetype<usize>(left.underlying) + left.offset;
  let ptr2 = changetype<usize>(right);
  if (load<u64>(ptr1) != load<u64>(ptr2)) return false;
  ptr1 += 8;
  ptr2 += 8;
  if (load<u64>(ptr1) != load<u64>(ptr2)) return false;
  ptr1 += 8;
  ptr2 += 8;
  return load<u16>(ptr1) == load<u16>(ptr2);
}
`,error:`export class Error {

  name: string  = "Error";
  stack: string = ""; // TODO

  constructor(
    public message: string = ""
  ) {}

  toString(): string {
    let message = this.message;
    return message.length
      ? this.name + ": " + message
      : this.name;
  }
}

export class RangeError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "RangeError";
  }
}

export class TypeError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "TypeError";
  }
}

export class SyntaxError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "SyntaxError";
  }
}

export class URIError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "URIError";
  }
}
`,function:`type auto = i32;

@final export abstract class Function<T> {
  private _index: u32;
  private _env: usize;

  // @ts-ignore: this on getter
  get index(this: T): u32 {
    return load<u32>(changetype<usize>(this), offsetof<Function<T>>("_index"));
  }

  // @ts-ignore: this on getter
  get name(this: T): string {
    return "";
  }

  // @ts-ignore: this on getter
  get length(this: T): i32 {
    // @ts-ignore: T is function
    return lengthof<T>();
  }

  // @ts-ignore: T is function
  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {
    return unreachable();
  }

  toString(this: T): string {
    return "function() { [native code] }";
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    // Env is either \`null\` (nop) or compiler-generated
    __visit(this._env, cookie);
  }
}
`,invoice:`export class InvoiceID {
  @inline
  constructor(public bytes: ByteArray) {
    if (bytes.length != 32)
      rollback("", bytes.length);
  }

  @inline
  toHex(): string {
    let out = __new(64, idof<string>());
    for (let i = 0; max_iterations(32), i < 32; ++i) {
      let b = this.bytes[i];
      let hi = b >> 4;
      let lo = b & 0xF;
      hi += ((hi > 9) ? 55 : 48);
      lo += ((lo > 9) ? 55 : 48);
      store<u8>(out + 2 * i, hi);
      store<u8>(out + 2 * i + 1, lo);
    }
    return changetype<string>(out);
  }
}
`,iterator:`export abstract class Iterable<T> {
  // ?
}

@final
export abstract class Iterator<T> {

  // private constructor(iterable: Iterable<T>) {
  // }

  // TODO: these need to evaluate the classId at the respective reference in order to obtain the
  // next value, i.e. arrays work differently than maps. we'd then have:
  //
  // \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Iterator layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
  //    3                   2                   1
  //  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
  // \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524
  // \u2502                             index                             \u2502
  // \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2524
  // \u2502                           reference                     \u2502 0 \u2502D\u2502
  // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2518
  // D: Done flag

  // get value(this: u64): T {
  //   ?
  // }

  // next(this: u64): Iterator<T> {
  //   ?
  // }

  done(this: u64): bool {
    return <bool>(this & 1);
  }
}
`,keylet:`// @ts-ignore: decorator
@lazy
export const KEYLET_LINE = 9;

// @ts-ignore: decorator
@lazy
export const KEYLET_SIGNERS = 14;

export class Keylet {
  @inline
  static getSigners(acc: Account): ByteArray {
    let a = new ByteArray(34);
    let b = acc.bytes;
    let r = $util_keylet(changetype<u32>(a), 34, KEYLET_SIGNERS, changetype<u32>(b), 20, 0, 0, 0, 0);
    if (r != 34)
      rollback("", r);

    return a;
  }

  @inline
  static getTrustLine(high: Account, low: Account, currency: ByteArray): ByteArray {
    let res = new ByteArray(34);
    let r = $util_keylet(changetype<u32>(res), 34, KEYLET_LINE, changetype<u32>(high.bytes), 20, changetype<u32>(low.bytes), 20, changetype<u32>(currency), currency.length);
    if (r != 34)
      rollback("", r);

    return res;
  }
}
`,map:`/// <reference path="./rt/index.d.ts" />

import { HASH } from "./util/hash";
import { E_KEYNOTFOUND } from "./util/error";

// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht

// @ts-ignore: decorator
@inline const INITIAL_CAPACITY = 4;

// @ts-ignore: decorator
@inline const FILL_FACTOR_N = 8;

// @ts-ignore: decorator
@inline const FILL_FACTOR_D = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_N = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_D = 4;

/** Structure of a map entry. */
@unmanaged class MapEntry<K,V> {
  key: K;
  value: V;
  taggedNext: usize; // LSB=1 indicates EMPTY
}

/** Empty bit. */
// @ts-ignore: decorator
@inline const EMPTY: usize = 1 << 0;

/** Size of a bucket. */
// @ts-ignore: decorator
@inline const BUCKET_SIZE = sizeof<usize>();

/** Computes the alignment of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_ALIGN<K,V>(): usize {
  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits
  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();
  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;
  return align;
}

/** Computes the aligned size of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_SIZE<K,V>(): usize {
  const align = ENTRY_ALIGN<K,V>();
  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;
  return size;
}

export class Map<K,V> {

  // buckets referencing their respective first entry, usize[bucketsMask + 1]
  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
  private bucketsMask: u32 = INITIAL_CAPACITY - 1;

  // entries in insertion order, MapEntry<K,V>[entriesCapacity]
  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());
  private entriesCapacity: i32 = INITIAL_CAPACITY;
  private entriesOffset: i32 = 0;
  private entriesCount: i32 = 0;

  constructor() {
    /* nop */
  }

  get size(): i32 {
    return this.entriesCount;
  }

  clear(): void {
    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
    this.bucketsMask = INITIAL_CAPACITY - 1;
    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());
    this.entriesCapacity = INITIAL_CAPACITY;
    this.entriesOffset = 0;
    this.entriesCount = 0;
  }

  private find(key: K, hashCode: u32): MapEntry<K,V> | null {
    let entry = load<MapEntry<K,V>>( // unmanaged!
      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE
    );
    while (entry) {
      let taggedNext = entry.taggedNext;
      if (!(taggedNext & EMPTY) && entry.key == key) return entry;
      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);
    }
    return null;
  }

  has(key: K): bool {
    return this.find(key, HASH<K>(key)) != null;
  }

  @operator("[]")
  get(key: K): V {
    let entry = this.find(key, HASH<K>(key));
    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent \`undefined\`
    return entry.value;
  }

  @operator("[]=")
  set(key: K, value: V): this {
    let hashCode = HASH<K>(key);
    let entry = this.find(key, hashCode); // unmanaged!
    if (entry) {
      entry.value = value;
      if (isManaged<V>()) {
        __link(changetype<usize>(this), changetype<usize>(value), true);
      }
    } else {
      // check if rehashing is necessary
      if (this.entriesOffset == this.entriesCapacity) {
        this.rehash(
          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty
            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N
        );
      }
      // append new entry
      let entries = this.entries;
      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());
      // link with the map
      entry.key = key;
      if (isManaged<K>()) {
        __link(changetype<usize>(this), changetype<usize>(key), true);
      }
      entry.value = value;
      if (isManaged<V>()) {
        __link(changetype<usize>(this), changetype<usize>(value), true);
      }
      ++this.entriesCount;
      // link with previous entry in bucket
      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;
      entry.taggedNext = load<usize>(bucketPtrBase);
      store<usize>(bucketPtrBase, changetype<usize>(entry));
    }
    return this;
  }

  delete(key: K): bool {
    let entry = this.find(key, HASH<K>(key));
    if (!entry) return false;
    entry.taggedNext |= EMPTY;
    --this.entriesCount;
    // check if rehashing is appropriate
    let halfBucketsMask = this.bucketsMask >> 1;
    if (
      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&
      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
    ) this.rehash(halfBucketsMask);
    return true;
  }

  private rehash(newBucketsMask: u32): void {
    let newBucketsCapacity = <i32>(newBucketsMask + 1);
    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);
    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;
    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());

    // copy old entries to new entries
    let oldPtr = changetype<usize>(this.entries);
    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();
    let newPtr = changetype<usize>(newEntries);
    while (oldPtr != oldEnd) {
      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);
      if (!(oldEntry.taggedNext & EMPTY)) {
        let newEntry = changetype<MapEntry<K,V>>(newPtr);
        let oldEntryKey = oldEntry.key;
        newEntry.key = oldEntryKey;
        newEntry.value = oldEntry.value;
        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;
        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;
        newEntry.taggedNext = load<usize>(newBucketPtrBase);
        store<usize>(newBucketPtrBase, newPtr);
        newPtr += ENTRY_SIZE<K,V>();
      }
      oldPtr += ENTRY_SIZE<K,V>();
    }

    this.buckets = newBuckets;
    this.bucketsMask = newBucketsMask;
    this.entries = newEntries;
    this.entriesCapacity = newEntriesCapacity;
    this.entriesOffset = this.entriesCount;
  }

  keys(): K[] {
    // FIXME: this is preliminary, needs iterators/closures
    let start = changetype<usize>(this.entries);
    let size = this.entriesOffset;
    let keys = new Array<K>(size);
    let length = 0;
    for (let i = 0; i < size; ++i) {
      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());
      if (!(entry.taggedNext & EMPTY)) {
        unchecked(keys[length++] = entry.key);
      }
    }
    keys.length = length;
    return keys;
  }

  values(): V[] {
    // FIXME: this is preliminary, needs iterators/closures
    let start = changetype<usize>(this.entries);
    let size = this.entriesOffset;
    let values = new Array<V>(size);
    let length = 0;
    for (let i = 0; i < size; ++i) {
      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());
      if (!(entry.taggedNext & EMPTY)) {
        unchecked(values[length++] = entry.value);
      }
    }
    values.length = length;
    return values;
  }

  toString(): string {
    return "[object Map]";
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    __visit(changetype<usize>(this.buckets), cookie);
    let entries = changetype<usize>(this.entries);
    if (isManaged<K>() || isManaged<V>()) {
      let cur = entries;
      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();
      while (cur < end) {
        let entry = changetype<MapEntry<K,V>>(cur);
        if (!(entry.taggedNext & EMPTY)) {
          if (isManaged<K>()) {
            let val = changetype<usize>(entry.key);
            if (isNullable<K>()) {
              if (val) __visit(val, cookie);
            } else __visit(val, cookie);
          }
          if (isManaged<V>()) {
            let val = changetype<usize>(entry.value);
            if (isNullable<V>()) {
              if (val) __visit(val, cookie);
            } else __visit(val, cookie);
          }
        }
        cur += ENTRY_SIZE<K,V>();
      }
    }
    __visit(entries, cookie);
  }
}
`,math:`import { Math as JSMath } from "./bindings/dom";
export { JSMath };

import {
  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,
  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut
} from "./util/math";

import {
  abs as builtin_abs,
  ceil as builtin_ceil,
  clz as builtin_clz,
  copysign as builtin_copysign,
  floor as builtin_floor,
  max as builtin_max,
  min as builtin_min,
  sqrt as builtin_sqrt,
  trunc as builtin_trunc
} from "./builtins";

// SUN COPYRIGHT NOTICE
//
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this software
// is freely granted, provided that this notice is preserved.
//
// Applies to all functions marked with a comment referring here.

/** @internal */
// @ts-ignore: decorator
@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;

/** @internal */
// @ts-ignore: decorator
@lazy @inline const PIO2_TABLE = memory.data<u64>([
  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,
  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,
  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,
  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,
  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,
  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557
]);

/** @internal */
function R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3
  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above
    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01
    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01
    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01
    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02
    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04
    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05
    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00
    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00
    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01
    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02

  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
  return p / q;
}

/** @internal */
// @ts-ignore: decorator
@inline
function expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)
  const                       // see: musl/src/math/__expo2.c
    k    = <u32>2043,
    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10
  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);
  // in directed rounding correct sign before rounding or overflow is important
  return NativeMath.exp(x - kln2) * (sign * scale) * scale;
}

/** @internal */
/* Helper function to eventually get bits of \u03C0/2 * |x|
 *
 * y = \u03C0/4 * (frac << clz(frac) >> 11)
 * return clz(frac)
 *
 * Right shift 11 bits to make upper half fit in \`double\`
 */
// @ts-ignore: decorator
@inline
function pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c
  // Bits of \u03C0/4
  const p0: u64 = 0xC4C6628B80DC1CD1;
  const p1: u64 = 0xC90FDAA22168C234;

  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64
  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75

  let shift = clz(q1);

  q1 = q1 << shift | q0 >> (64 - shift);
  q0 <<= shift;

  let lo = umuldi(p1, q1);
  let hi = res128_hi;

  let ahi = hi >> 11;
  let alo = lo >> 11 | hi << 53;
  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);

  rempio2_y0 = <f64>(ahi + u64(lo < blo));
  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);

  return shift;
}

/** @internal */
// @ts-ignore: decorator
@inline
function umuldi(u: u64, v: u64): u64 {
  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;

  u1 = u & 0xFFFFFFFF;
  v1 = v & 0xFFFFFFFF;

  u >>= 32;
  v >>= 32;

  t  = u1 * v1;
  w0 = t & 0xFFFFFFFF;
  t  = u * v1 + (t >> 32);
  w1 = t >> 32;
  t  = u1 * v + (t & 0xFFFFFFFF);

  res128_hi = u * v + w1 + (t >> 32);
  return (t << 32) + w0;
}

/** @internal */
function pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c
  let magnitude = u & 0x7FFFFFFFFFFFFFFF;
  let offset = (magnitude >> 52) - 1045;
  let shift  = offset & 63;
  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);
  let s0: u64, s1: u64, s2: u64;

  let b0 = load<u64>(tblPtr, 0 << 3);
  let b1 = load<u64>(tblPtr, 1 << 3);
  let b2 = load<u64>(tblPtr, 2 << 3);

  // Get 192 bits of 0x1p-31 / \u03C0 with \`offset\` bits skipped
  if (shift) {
    let rshift = 64 - shift;
    let b3 = load<u64>(tblPtr, 3 << 3);
    s0 = b1 >> rshift | b0 << shift;
    s1 = b2 >> rshift | b1 << shift;
    s2 = b3 >> rshift | b2 << shift;
  } else {
    s0 = b0;
    s1 = b1;
    s2 = b2;
  }

  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;

  // First 128 bits of fractional part of x/(2\u03C0)
  let blo = umuldi(s1, significand);
  let bhi = res128_hi;

  let ahi = s0 * significand;
  let clo = (s2 >> 32) * (significand >> 32);
  let plo = blo + clo;
  let phi = ahi + bhi + u64(plo < clo);

  // r: u128 = p << 2
  let rlo = plo << 2;
  let rhi = phi << 2 | plo >> 62;

  // s: i128 = r >> 127
  let slo = <i64>rhi >> 63;
  let shi = slo >> 1;
  let q   = (<i64>phi >> 62) - slo;

  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);
  let signbit = (u ^ rhi) & 0x8000000000000000;
  let coeff   = reinterpret<f64>(shifter | signbit);

  rempio2_y0 *= coeff;
  rempio2_y1 *= coeff;

  return <i32>q;
}

/** @internal */
// @ts-ignore: decorator
@inline
function rempio2(x: f64, u: u64, sign: i32): i32 {
  const
    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00
    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11
    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11
    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21
    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21
    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32
    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308

  let ix = <u32>(u >> 32) & 0x7FFFFFFF;

  if (ASC_SHRINK_LEVEL < 1) {
    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1
      let q = 1, z: f64, y0: f64, y1: f64;
      if (!sign) {
        z = x - pio2_1;
        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough
          y0 = z - pio2_1t;
          y1 = (z - y0) - pio2_1t;
        } else { // near pi/2, use 33+33+53 bit pi
          z -= pio2_2;
          y0 = z - pio2_2t;
          y1 = (z - y0) - pio2_2t;
        }
      } else { // negative x
        z = x + pio2_1;
        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough
          y0 = z + pio2_1t;
          y1 = (z - y0) + pio2_1t;
        } else { // near pi/2, use 33+33+53 bit pi
          z += pio2_2;
          y0 = z + pio2_2t;
          y1 = (z - y0) + pio2_2t;
        }
        q = -1;
      }
      rempio2_y0 = y0;
      rempio2_y1 = y1;
      return q;
    }
  }

  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)
    // Use precise Cody Waite scheme
    let q  = nearest(x * invpio2);
    let r  = x - q * pio2_1;
    let w  = q * pio2_1t; // 1st round good to 85 bit
    let j  = ix >> 20;
    let y0 = r - w;
    let hi = <u32>(reinterpret<u64>(y0) >> 32);
    let i  = j - ((hi >> 20) & 0x7FF);

    if (i > 16) { // 2nd iteration needed, good to 118
      let t = r;
      w  = q * pio2_2;
      r  = t - w;
      w  = q * pio2_2t - ((t - r) - w);
      y0 = r - w;
      hi = <u32>(reinterpret<u64>(y0) >> 32);
      i = j - ((hi >> 20) & 0x7FF);
      if (i > 49) { // 3rd iteration need, 151 bits acc
        let t = r;
        w  = q * pio2_3;
        r  = t - w;
        w  = q * pio2_3t - ((t - r) - w);
        y0 = r - w;
      }
    }
    let y1 = (r - y0) - w;
    rempio2_y0 = y0;
    rempio2_y1 = y1;
    return <i32>q;
  }
  let q = pio2_large_quot(x, u);
  return select(-q, q, sign);
}

/** @internal */
// @ts-ignore: decorator
@inline
function sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c
  const
    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01
    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03
    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04
    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06
    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08
    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10

  let z = x * x;
  let w = z * z;
  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);
  let v = z * x;
  if (!iy) {
    return x + v * (S1 + z * r);
  } else {
    return x - ((z * (0.5 * y - v * r) - y) - v * S1);
  }
}

/** @internal */
// @ts-ignore: decorator
@inline
function cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c
  const
    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02
    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03
    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05
    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07
    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09
    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11

  let z = x * x;
  let w = z * z;
  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));
  let hz = 0.5 * z;
  w = 1.0 - hz;
  return w + (((1.0 - w) - hz) + (z * r - x * y));
}

/** @internal */
function tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c
  const
    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01
    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01
    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02
    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02
    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03
    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03
    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03
    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04
    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04
    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05
    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05
    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05
    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05

  const
    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00
    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01
    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17

  let z: f64, r: f64, v: f64, w: f64, s: f64;
  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x
  let ix = hx & 0x7FFFFFFF; // high word of |x|
  let big = ix >= 0x3FE59428;
  if (big) { // |x| >= 0.6744
    if (hx < 0) { x = -x, y = -y; }
    z = pio4 - x;
    w = pio4lo - y;
    x = z + w;
    y = 0.0;
  }
  z = x * x;
  w = z * z;
  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));
  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));
  s = z * x;
  r = y + z * (s * (r + v) + y);
  r += T0 * s;
  w = x + r;
  if (big) {
    v = iy;
    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));
  }
  if (iy == 1) return w;
  let a: f64, t: f64;
  z = w;
  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);
  v = r - (z - x);  // z + v = r + x
  t = a = -one / w; // a = -1.0 / w
  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);
  s = one + t * z;
  return t + a * (s + t * v);
}

/** @internal */
function dtoi32(x: f64): i32 {
  if (ASC_SHRINK_LEVEL > 0) {
    const inv32 = 1.0 / 4294967296;
    return <i32><i64>(x - 4294967296 * floor(x * inv32));
  } else {
    let result = 0;
    let u = reinterpret<u64>(x);
    let e = (u >> 52) & 0x7FF;
    if (e <= 1023 + 30) {
      result = <i32>x;
    } else if (e <= 1023 + 30 + 53) {
      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);
      v = v << e - 1023 - 52 + 32;
      result = <i32>(v >> 32);
      result = select<i32>(-result, result, <i64>u < 0);
    }
    return result;
  }
}

// @ts-ignore: decorator
@lazy let random_seeded = false;

// @ts-ignore: decorator
@lazy let random_state0_64: u64, random_state1_64: u64;

// @ts-ignore: decorator
@lazy let random_state0_32: u32, random_state1_32: u32;

function murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche
  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher
  h *= 0xFF51AFD7ED558CCD;
  h ^= h >> 33;
  h *= 0xC4CEB9FE1A85EC53;
  h ^= h >> 33;
  return h;
}

function splitMix32(h: u32): u32 {
  h += 0x6D2B79F5;
  h  = (h ^ (h >> 15)) * (h | 1);
  h ^= h + (h ^ (h >> 7)) * (h | 61);
  return h ^ (h >> 14);
}

export namespace NativeMath {

  // @ts-ignore: decorator
  @lazy
  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354

  // @ts-ignore: decorator
  @lazy
  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942

  // @ts-ignore: decorator
  @lazy
  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402

  // @ts-ignore: decorator
  @lazy
  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074

  // @ts-ignore: decorator
  @lazy
  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765

  // @ts-ignore: decorator
  @lazy
  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846

  // @ts-ignore: decorator
  @lazy
  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440

  // @ts-ignore: decorator
  @lazy
  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880

  // @ts-ignore: decorator
  @lazy
  export let sincos_sin: f64 = 0;

  // @ts-ignore: decorator
  @lazy
  export let sincos_cos: f64 = 0;

  // @ts-ignore: decorator
  @inline export function abs(x: f64): f64 {
    return builtin_abs<f64>(x);
  }

  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above
    const
      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00
      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17
      Ox1p_120f = reinterpret<f32>(0x03800000);

    let hx = <u32>(reinterpret<u64>(x) >> 32);
    let ix = hx & 0x7FFFFFFF;
    if (ix >= 0x3FF00000) {
      let lx = <u32>reinterpret<u64>(x);
      if ((ix - 0x3FF00000 | lx) == 0) {
        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;
        return 0;
      }
      return 0 / (x - x);
    }
    if (ix < 0x3FE00000) {
      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;
      return pio2_hi - (x - (pio2_lo - x * R(x * x)));
    }
    let s: f64, w: f64, z: f64;
    if (<i32>hx < 0) {
      // z = (1.0 + x) * 0.5;
      z = 0.5 + x * 0.5;
      s = builtin_sqrt<f64>(z);
      w = R(z) * s - pio2_lo;
      return 2 * (pio2_hi - (s + w));
    }
    // z = (1.0 - x) * 0.5;
    z = 0.5 - x * 0.5;
    s = builtin_sqrt<f64>(z);
    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);
    let c = (z - df * df) / (s + df);
    w = R(z) * s + c;
    return 2 * (df + w);
  }

  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c
    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);
    let u = reinterpret<u64>(x);
    // Prevent propagation for all input values less than 1.0.
    // Note musl lib didn't fix this yet.
    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;
    let e = u >> 52 & 0x7FF;
    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));
    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));
    return log(x) + s;
  }

  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above
    const
      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00
      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17
      Ox1p_120f = reinterpret<f32>(0x03800000);

    let hx = <u32>(reinterpret<u64>(x) >> 32);
    let ix = hx & 0x7FFFFFFF;
    if (ix >= 0x3FF00000) {
      let lx = <u32>reinterpret<u64>(x);
      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;
      return 0 / (x - x);
    }
    if (ix < 0x3FE00000) {
      if (ix < 0x3E500000 && ix >= 0x00100000) return x;
      return x + x * R(x * x);
    }
    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;
    let z = 0.5 - builtin_abs<f64>(x) * 0.5;
    let s = builtin_sqrt<f64>(z);
    let r = R(z);
    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);
    else {
      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);
      let c = (z - f * f) / (s + f);
      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));
    }
    return select(-x, x, <i32>hx < 0);
  }

  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c
    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568
    let u = reinterpret<u64>(x);
    let e = u >> 52 & 0x7FF;
    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);
    if (e >= 0x3FF + 26) y = log(y) + c;
    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));
    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));
    return builtin_copysign(y, x);
  }

  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above
    const
      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01
      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01
      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01
      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00
      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17
      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17
      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17
      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17
      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01
      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01
      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01
      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,
      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02
      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02
      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02
      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02
      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02
      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02
      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02
      Ox1p_120f = reinterpret<f32>(0x03800000);

    let ix = <u32>(reinterpret<u64>(x) >> 32);
    let sx = x;
    ix &= 0x7FFFFFFF;
    let z: f64;
    if (ix >= 0x44100000) {
      if (isNaN(x)) return x;
      z = atanhi3 + Ox1p_120f;
      return builtin_copysign<f64>(z, sx);
    }
    let id: i32;
    if (ix < 0x3FDC0000) {
      if (ix < 0x3E400000) return x;
      id = -1;
    } else {
      x = builtin_abs<f64>(x);
      if (ix < 0x3FF30000) {
        if (ix < 0x3FE60000) {
          id = 0;
          x = (2.0 * x - 1.0) / (2.0 + x);
        } else {
          id = 1;
          x = (x - 1.0) / (x + 1.0);
        }
      } else {
        if (ix < 0x40038000) {
          id = 2;
          x = (x - 1.5) / (1.0 + 1.5 * x);
        } else {
          id = 3;
          x = -1.0 / x;
        }
      }
    }
    z = x * x;
    let w = z * z;
    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));
    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));
    let s3 = x * (s1 + s2);
    if (id < 0) return x - s3;
    switch (id) {
      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }
      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }
      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }
      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }
      default: unreachable();
    }
    return builtin_copysign<f64>(z, sx);
  }

  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c
    let u = reinterpret<u64>(x);
    let e = u >> 52 & 0x7FF;
    let y = builtin_abs(x);
    if (e < 0x3FF - 1) {
      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));
    } else {
      y = 0.5 * log1p(2 * (y / (1 - y)));
    }
    return builtin_copysign<f64>(y, x);
  }

  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above
    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16
    if (isNaN(x) || isNaN(y)) return x + y;
    let u = reinterpret<u64>(x);
    let ix = <u32>(u >> 32);
    let lx = <u32>u;
    u = reinterpret<u64>(y);
    let iy = <u32>(u >> 32);
    let ly = <u32>u;
    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);
    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);
    ix = ix & 0x7FFFFFFF;
    iy = iy & 0x7FFFFFFF;
    if ((iy | ly) == 0) {
      switch (m) {
        case 0:
        case 1: return  y;
        case 2: return  PI;
        case 3: return -PI;
      }
    }
    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;
    if (ix == 0x7FF00000) {
      if (iy == 0x7FF00000) {
        let t = m & 2 ? 3 * PI / 4 : PI / 4;
        return m & 1 ? -t : t;
      } else {
        let t = m & 2 ? PI : 0;
        return m & 1 ? -t : t;
      }
    }
    let z: f64;
    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;
    if ((m & 2) && iy + (64 << 20) < ix) z = 0;
    else z = atan(builtin_abs<f64>(y / x));
    switch (m) {
      case 0: return  z;
      case 1: return -z;
      case 2: return PI - (z - pi_lo);
      case 3: return (z - pi_lo) - PI;
    }
    unreachable();
    return 0;
  }

  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above
    const
      B1     = <u32>715094163,
      B2     = <u32>696219795,
      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643
      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875
      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140
      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437
      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982
      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54

    let u = reinterpret<u64>(x);
    let hx = <u32>(u >> 32) & 0x7FFFFFFF;
    if (hx >= 0x7FF00000) return x + x;
    if (hx < 0x00100000) {
      u = reinterpret<u64>(x * Ox1p54);
      hx = <u32>(u >> 32) & 0x7FFFFFFF;
      if (hx == 0) return x;
      hx = hx / 3 + B2;
    } else {
      hx = hx / 3 + B1;
    }
    u &= 1 << 63;
    u |= <u64>hx << 32;
    let t = reinterpret<f64>(u);
    let r = (t * t) * (t / x);
    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));
    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);
    let s = t * t;
    r = x / s;
    r = (r - t) / (2 * t + r);
    t = t + t * r;
    return t;
  }

  // @ts-ignore: decorator
  @inline
  export function ceil(x: f64): f64 {
    return builtin_ceil<f64>(x);
  }

  export function clz32(x: f64): f64 {
    if (!isFinite(x)) return 32;
    /*
     * Wasm (MVP) and JS have different approaches for double->int conversions.
     *
     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT
     * our float-point arguments before actual convertion to integers.
     */
    return builtin_clz(dtoi32(x));
  }

  export function cos(x: f64): f64 { // see: musl/src/math/cos.c
    let u  = reinterpret<u64>(x);
    let ux = u32(u >> 32);
    let sign = ux >> 31;

    ux &= 0x7FFFFFFF;

    // |x| ~< pi/4
    if (ux <= 0x3FE921FB) {
      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)
        return 1.0;
      }
      return cos_kern(x, 0);
    }

    // sin(Inf or NaN) is NaN
    if (ux >= 0x7FF00000) return x - x;

    // argument reduction needed
    let n  = rempio2(x, u, sign);
    let y0 = rempio2_y0;
    let y1 = rempio2_y1;

    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);
    return (n + 1) & 2 ? -x : x;
  }

  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c
    let u = reinterpret<u64>(x);
    u &= 0x7FFFFFFFFFFFFFFF;
    x = reinterpret<f64>(u);
    let w = <u32>(u >> 32);
    let t: f64;
    if (w < 0x3FE62E42) {
      if (w < 0x3FF00000 - (26 << 20)) return 1;
      t = expm1(x);
      // return 1 + t * t / (2 * (1 + t));
      return 1 + t * t / (2 + 2 * t);
    }
    if (w < 0x40862E42) {
      t = exp(x);
      return 0.5 * (t + 1 / t);
    }
    t = expo2(x, 1);
    return t;
  }

  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return exp_lut(x);
    } else {
      const
        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01
        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10
        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00
        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01
        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03
        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05
        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06
        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08
        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096
        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842
        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023

      let hx = u32(reinterpret<u64>(x) >> 32);
      let sign = hx >> 31;
      hx &= 0x7FFFFFFF;
      if (hx >= 0x4086232B) {
        if (isNaN(x)) return x;
        if (x > overflow)  return x * Ox1p1023;
        if (x < underflow) return 0;
      }
      let hi: f64, lo: f64 = 0;
      let k = 0;
      if (hx > 0x3FD62E42) {
        if (hx >= 0x3FF0A2B2) {
          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));
        } else {
          k = 1 - (sign << 1);
        }
        hi = x - k * ln2hi;
        lo = k * ln2lo;
        x = hi - lo;
      } else if (hx > 0x3E300000) {
        hi = x;
      } else return 1.0 + x;
      let xs = x * x;
      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));
      let xq = xs * xs;
      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));
      let y = 1.0 + (x * c / (2 - c) - lo + hi);
      return k == 0 ? y : scalbn(y, k);
    }
  }

  export function exp2(x: f64): f64 {
    return exp2_lut(x);
  }

  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above
    const
      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02
      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01
      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10
      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00
      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02
      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03
      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05
      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06
      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07
      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023

    let u = reinterpret<u64>(x);
    let hx = u32(u >> 32) & 0x7FFFFFFF;
    let sign = u32(u >> 63);
    let k = 0;
    if (hx >= 0x4043687A) {
      if (isNaN(x)) return x;
      if (sign) return -1;
      if (x > o_threshold) return x * Ox1p1023;
    }
    let c = 0.0, t: f64;
    if (hx > 0x3FD62E42) {
      k = select<i32>(
        1 - (sign << 1),
        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),
        hx < 0x3FF0A2B2
      );
      t = <f64>k;
      let hi = x - t * ln2_hi;
      let lo = t * ln2_lo;
      x = hi - lo;
      c = (hi - x) - lo;
    } else if (hx < 0x3C900000) return x;
    let hfx = 0.5 * x;
    let hxs = x * hfx;
    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));
    let hxq = hxs * hxs;
    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));
    t = 3.0 - r1 * hfx;
    let e = hxs * ((r1 - t) / (6.0 - x * t));
    if (k == 0) return x - (x * e - hxs);
    e = x * (e - c) - c;
    e -= hxs;
    if (k == -1) return 0.5 * (x - e) - 0.5;
    if (k == 1) {
      if (x < -0.25) return -2.0 * (e - (x + 0.5));
      return 1.0 + 2.0 * (x - e);
    }
    u = (0x3FF + k) << 52;
    let twopk = reinterpret<f64>(u);
    let y: f64;
    if (k < 0 || k > 56) {
      y = x - e + 1.0;
      if (k == 1024) y = y * 2.0 * Ox1p1023;
      else y = y * twopk;
      return y - 1.0;
    }
    u = (0x3FF - k) << 52;
    y = reinterpret<f64>(u);
    if (k < 20) y = (1 - y) - e;
    else y = 1 - (e + y);
    return (x + y) * twopk;
  }

  // @ts-ignore: decorator
  @inline
  export function floor(x: f64): f64 {
    return builtin_floor<f64>(x);
  }

  // @ts-ignore: decorator
  @inline
  export function fround(x: f64): f64 {
    return <f32>x;
  }

  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c
    const
      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1
      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),
      Ox1p_700 = reinterpret<f64>(0x1430000000000000);

    let ux = reinterpret<u64>(x);
    let uy = reinterpret<u64>(y);
    ux &= 0x7FFFFFFFFFFFFFFF;
    uy &= 0x7FFFFFFFFFFFFFFF;
    if (ux < uy) {
      let ut = ux;
      ux = uy;
      uy = ut;
    }
    let ex = i32(ux >> 52);
    let ey = i32(uy >> 52);
    y = reinterpret<f64>(uy);
    if (ey == 0x7FF) return y;
    x = reinterpret<f64>(ux);
    if (ex == 0x7FF || uy == 0) return x;
    if (ex - ey > 64) return x + y;
    let z = 1.0;
    if (ex > 0x3FF + 510) {
      z  = Ox1p700;
      x *= Ox1p_700;
      y *= Ox1p_700;
    } else if (ey < 0x3FF - 450) {
      z  = Ox1p_700;
      x *= Ox1p700;
      y *= Ox1p700;
    }
    let c = x * SPLIT;
    let h = x - c + c;
    let l = x - h;
    let hx = x * x;
    let lx = h * h - hx + (2 * h + l) * l;
    c = y * SPLIT;
    h = y - c + c;
    l = y - h;
    let hy = y * y;
    let ly = h * h - hy + (2 * h + l) * l;
    return z * builtin_sqrt(ly + lx + hy + hx);
  }

  export function imul(x: f64, y: f64): f64 {
    /*
     * Wasm (MVP) and JS have different approaches for double->int conversions.
     *
     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT
     * our float-point arguments before actual convertion to integers.
     */
    if (!isFinite(x + y)) return 0;
    return dtoi32(x) * dtoi32(y);
  }

  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return log_lut(x);
    } else {
      const
        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01
        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10
        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01
        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54

      let u = reinterpret<u64>(x);
      let hx = u32(u >> 32);
      let k = 0;
      let sign = hx >> 31;
      if (sign || hx < 0x00100000) {
        if (u << 1 == 0) return -1 / (x * x);
        if (sign) return (x - x) / 0.0;
        k -= 54;
        x *= Ox1p54;
        u = reinterpret<u64>(x);
        hx = u32(u >> 32);
      } else if (hx >= 0x7FF00000) {
        return x;
      } else if (hx == 0x3FF00000 && u << 32 == 0) {
        return 0;
      }
      hx += 0x3FF00000 - 0x3FE6A09E;
      k += (<i32>hx >> 20) - 0x3FF;
      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;
      u = <u64>hx << 32 | (u & 0xFFFFFFFF);
      x = reinterpret<f64>(u);
      let f = x - 1.0;
      let hfsq = 0.5 * f * f;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
      let r = t2 + t1;
      let dk = <f64>k;
      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;
    }
  }

  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above
    const
      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01
      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11
      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01
      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13
      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01
      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54

    let u = reinterpret<u64>(x);
    let hx = u32(u >> 32);
    let k = 0;
    let sign = hx >> 31;
    if (sign || hx < 0x00100000) {
      if (u << 1 == 0) return -1 / (x * x);
      if (sign) return (x - x) / 0.0;
      k -= 54;
      x *= Ox1p54;
      u = reinterpret<u64>(x);
      hx = u32(u >> 32);
    } else if (hx >= 0x7FF00000) {
      return x;
    } else if (hx == 0x3FF00000 && u << 32 == 0) {
      return 0;
    }
    hx += 0x3FF00000 - 0x3FE6A09E;
    k += i32(hx >> 20) - 0x3FF;
    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;
    u = <u64>hx << 32 | (u & 0xFFFFFFFF);
    x = reinterpret<f64>(u);
    let f = x - 1.0;
    let hfsq = 0.5 * f * f;
    let s = f / (2.0 + f);
    let z = s * s;
    let w = z * z;
    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
    let r = t2 + t1;
    let hi = f - hfsq;
    u = reinterpret<u64>(hi);
    u &= 0xFFFFFFFF00000000;
    hi = reinterpret<f64>(u);
    let lo = f - hi - hfsq + s * (hfsq + r);
    let val_hi = hi * ivln10hi;
    let dk = <f64>k;
    let y = dk * log10_2hi;
    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;
    w = y + val_hi;
    val_lo += (y - w) + val_hi;
    return val_lo + w;
  }

  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above
    const
      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01
      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10
      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01

    let u = reinterpret<u64>(x);
    let hx = u32(u >> 32);
    let k = 1;
    let c = 0.0, f = 0.0;
    if (hx < 0x3FDA827A || bool(hx >> 31)) {
      if (hx >= 0xBFF00000) {
        if (x == -1) return x / 0.0;
        return (x - x) / 0.0;
      }
      if (hx << 1 < 0x3CA00000 << 1) return x;
      if (hx <= 0xBFD2BEC4) {
        k = 0;
        c = 0;
        f = x;
      }
    } else if (hx >= 0x7FF00000) return x;
    if (k) {
      u = reinterpret<u64>(1 + x);
      let hu = u32(u >> 32);
      hu += 0x3FF00000 - 0x3FE6A09E;
      k = i32(hu >> 20) - 0x3FF;
      if (k < 54) {
        let uf = reinterpret<f64>(u);
        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);
        c /= uf;
      } else c = 0;
      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;
      u = <u64>hu << 32 | (u & 0xFFFFFFFF);
      f = reinterpret<f64>(u) - 1;
    }
    let hfsq = 0.5 * f * f;
    let s = f / (2.0 + f);
    let z = s * s;
    let w = z * z;
    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
    let r = t2 + t1;
    let dk = <f64>k;
    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;
  }

  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return log2_lut(x);
    } else {
      const
        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00
        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10
        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01
        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54

      let u = reinterpret<u64>(x);
      let hx = u32(u >> 32);
      let k = 0;
      let sign = hx >> 31;
      if (sign || hx < 0x00100000) {
        if (u << 1 == 0) return -1 / (x * x);
        if (sign) return (x - x) / 0.0;
        k -= 54;
        x *= Ox1p54;
        u = reinterpret<u64>(x);
        hx = u32(u >> 32);
      } else if (hx >= 0x7FF00000) {
        return x;
      } else if (hx == 0x3FF00000 && u << 32 == 0) {
        return 0;
      }
      hx += 0x3FF00000 - 0x3FE6A09E;
      k += i32(hx >> 20) - 0x3FF;
      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;
      u = <u64>hx << 32 | (u & 0xFFFFFFFF);
      x = reinterpret<f64>(u);
      let f = x - 1.0;
      let hfsq = 0.5 * f * f;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
      let r = t2 + t1;
      let hi = f - hfsq;
      u = reinterpret<u64>(hi);
      u &= 0xFFFFFFFF00000000;
      hi = reinterpret<f64>(u);
      let lo = f - hi - hfsq + s * (hfsq + r);
      let val_hi = hi * ivln2hi;
      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;
      let y = <f64>k;
      w = y + val_hi;
      val_lo += (y - w) + val_hi;
      val_hi = w;
      return val_lo + val_hi;
    }
  }

  // @ts-ignore: decorator
  @inline
  export function max(value1: f64, value2: f64): f64 {
    return builtin_max<f64>(value1, value2);
  }

  // @ts-ignore: decorator
  @inline
  export function min(value1: f64, value2: f64): f64 {
    return builtin_min<f64>(value1, value2);
  }

  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above
    // TODO: remove this fast pathes after introduced own mid-end IR with "stdlib call simplify" transforms
    if (builtin_abs<f64>(y) <= 2) {
      if (y == 2.0) return x * x;
      if (y == 0.5) {
        return select<f64>(
          builtin_abs<f64>(builtin_sqrt<f64>(x)),
          Infinity,
          x != -Infinity
        );
      }
      if (y == -1.0) return 1 / x;
      if (y == 1.0) return x;
      if (y == 0.0) return 1.0;
    }
    if (ASC_SHRINK_LEVEL < 1) {
      return pow_lut(x, y);
    } else {
      const
        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01
        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08
        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0
        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300
        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300
        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01
        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01
        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01
        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01
        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01
        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01
        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01
        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03
        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05
        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06
        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08
        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01
        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01
        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09
        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017
        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01
        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01
        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09
        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00
        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00
        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08
        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333

      let u_ = reinterpret<u64>(x);
      let hx = i32(u_ >> 32);
      let lx = <u32>u_;
      u_ = reinterpret<u64>(y);
      let hy = i32(u_ >> 32);
      let ly = <u32>u_;
      let ix = hx & 0x7FFFFFFF;
      let iy = hy & 0x7FFFFFFF;
      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN
      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN
      if ( // NaN if either arg is NaN
        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||
        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)
      ) return x + y;
      let yisint = 0, k: i32;
      if (hx < 0) {
        if (iy >= 0x43400000) yisint = 2;
        else if (iy >= 0x3FF00000) {
          k = (iy >> 20) - 0x3FF;
          let offset = select<u32>(52, 20, k > 20) - k;
          let Ly = select<u32>(ly, iy, k > 20);
          let jj = Ly >> offset;
          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);
        }
      }
      if (ly == 0) {
        if (iy == 0x7FF00000) { // y is +-inf
          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN
          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0
          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf
        }
        if (iy == 0x3FF00000) {
          if (hy >= 0) return x;
          return 1 / x;
        }
        if (hy == 0x40000000) return x * x;
        if (hy == 0x3FE00000) {
          if (hx >= 0) return builtin_sqrt(x);
        }
      }
      let ax = builtin_abs<f64>(x), z: f64;
      if (lx == 0) {
        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {
          z = ax;
          if (hy < 0) z = 1.0 / z;
          if (hx < 0) {
            if (((ix - 0x3FF00000) | yisint) == 0) {
              let d = z - z;
              z = d / d;
            } else if (yisint == 1) z = -z;
          }
          return z;
        }
      }
      let s = 1.0;
      if (hx < 0) {
        if (yisint == 0) {
          let d = x - x;
          return d / d;
        }
        if (yisint == 1) s = -1.0;
      }
      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;
      let j: i32, n: i32;
      if (iy > 0x41E00000) {
        if (iy > 0x43F00000) {
          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;
          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;
        }
        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;
        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;
        t = ax - 1.0;
        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));
        u = ivln2_h * t;
        v = t * ivln2_l - w * ivln2;
        t1 = u + v;
        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);
        t2 = v - (t1 - u);
      } else {
        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;
        n = 0;
        if (ix < 0x00100000) {
          ax *= two53;
          n -= 53;
          ix = <u32>(reinterpret<u64>(ax) >> 32);
        }
        n += (ix >> 20) - 0x3FF;
        j = ix & 0x000FFFFF;
        ix = j | 0x3FF00000;
        if (j <= 0x3988E) k = 0;
        else if (j < 0xBB67A) k = 1;
        else {
          k = 0;
          n += 1;
          ix -= 0x00100000;
        }
        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));
        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0
        u = ax - bp;
        v = 1.0 / (ax + bp);
        ss = u * v;
        s_h = ss;
        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);
        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);
        t_l = ax - (t_h - bp);
        s_l = v * ((u - s_h * t_h) - s_h * t_l);
        s2 = ss * ss;
        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
        r += s_l * (s_h + ss);
        s2 = s_h * s_h;
        t_h = 3.0 + s2 + r;
        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);
        t_l = r - ((t_h - 3.0) - s2);
        u = s_h * t_h;
        v = s_l * t_h + t_l * ss;
        p_h = u + v;
        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);
        p_l = v - (p_h - u);
        let z_h = cp_h * p_h;
        let dp_l = select<f64>(dp_l1, 0.0, k);
        let z_l = cp_l * p_h + p_l * cp + dp_l;
        t = <f64>n;
        let dp_h = select<f64>(dp_h1, 0.0, k);
        t1 = ((z_h + z_l) + dp_h) + t;
        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);
        t2 = z_l - (((t1 - t) - dp_h) - z_h);
      }
      let y1 = y;
      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);
      p_l = (y - y1) * t1 + y * t2;
      p_h = y1 * t1;
      z = p_l + p_h;
      u_ = reinterpret<u64>(z);
      j = u32(u_ >> 32);
      let i = <i32>u_;
      if (j >= 0x40900000) {
        if (((j - 0x40900000) | i) != 0) return s * huge * huge;
        if (p_l + ovt > z - p_h) return s * huge * huge;
      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {
        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;
        if (p_l <= z - p_h) return s * tiny * tiny;
      }
      i = j & 0x7FFFFFFF;
      k = (i >> 20) - 0x3FF;
      n = 0;
      if (i > 0x3FE00000) {
        n = j + (0x00100000 >> (k + 1));
        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;
        t = 0.0;
        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);
        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);
        if (j < 0) n = -n;
        p_h -= t;
      }
      t = p_l + p_h;
      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);
      u = t * lg2_h;
      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;
      z = u + v;
      w = v - (z - u);
      t = z * z;
      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
      r = (z * t1) / (t1 - 2.0) - (w + z * w);
      z = 1.0 - (r - z);
      j = u32(reinterpret<u64>(z) >> 32);
      j += n << 20;
      if ((j >> 20) <= 0) z = scalbn(z, n);
      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));
      return s * z;
    }
  }

  export function seedRandom(value: i64): void {
    // Instead zero seed use golden ratio:
    // phi = (1 + sqrt(5)) / 2
    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15
    if (value == 0) value = 0x9e3779b97f4a7c15;
    random_state0_64 = murmurHash3(value);
    random_state1_64 = murmurHash3(~random_state0_64);
    random_state0_32 = splitMix32(<u32>value);
    random_state1_32 = splitMix32(random_state0_32);
    random_seeded = true;
  }

  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc
    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));
    let s1 = random_state0_64;
    let s0 = random_state1_64;
    random_state0_64 = s0;
    s1 ^= s1 << 23;
    s1 ^= s1 >> 17;
    s1 ^= s0;
    s1 ^= s0 >> 26;
    random_state1_64 = s1;
    let r = (s0 >> 12) | 0x3FF0000000000000;
    return reinterpret<f64>(r) - 1;
  }

  export function round(x: f64): f64 {
    if (ASC_SHRINK_LEVEL > 0) {
      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);
    } else {
      let roundUp = builtin_ceil<f64>(x);
      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);
    }
  }

  export function sign(x: f64): f64 {
    if (ASC_SHRINK_LEVEL > 0) {
      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);
    } else {
      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);
    }
  }

  // @ts-ignore: decorator
  @inline
  export function signbit(x: f64): bool {
    return bool(reinterpret<u64>(x) >>> 63);
  }

  export function sin(x: f64): f64 { // see: musl/src/math/sin.c
    let u  = reinterpret<u64>(x);
    let ux = u32(u >> 32);
    let sign = ux >> 31;

    ux &= 0x7FFFFFFF;

    // |x| ~< pi/4
    if (ux <= 0x3FE921FB) {
      if (ux < 0x3E500000) { // |x| < 2**-26
        return x;
      }
      return sin_kern(x, 0.0, 0);
    }

    // sin(Inf or NaN) is NaN
    if (ux >= 0x7FF00000) return x - x;

    // argument reduction needed
    let n  = rempio2(x, u, sign);
    let y0 = rempio2_y0;
    let y1 = rempio2_y1;

    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);
    return n & 2 ? -x : x;
  }

  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c
    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;
    let a = reinterpret<f64>(u);
    let w = u32(u >> 32);
    let h = builtin_copysign(0.5, x);
    if (w < 0x40862E42) {
      let t = expm1(a);
      if (w < 0x3FF00000) {
        if (w < 0x3FF00000 - (26 << 20)) return x;
        return h * (2 * t - t * t / (t + 1));
      }
      return h * (t + t / (t + 1));
    }
    return expo2(a, 2 * h);
  }

  // @ts-ignore: decorator
  @inline
  export function sqrt(x: f64): f64 {
    return builtin_sqrt<f64>(x);
  }

  export function tan(x: f64): f64 { // see: musl/src/math/tan.c
    let u = reinterpret<u64>(x);
    let ux = u32(u >> 32);
    let sign = ux >>> 31;

    ux &= 0x7FFFFFFF;

    // |x| ~< pi/4
    if (ux <= 0x3FE921FB) {
      if (ux < 0x3E400000) { // |x| < 2**-27
        return x;
      }
      return tan_kern(x, 0.0, 1);
    }

    // tan(Inf or NaN) is NaN
    if (ux >= 0x7FF00000) return x - x;

    let n = rempio2(x, u, sign);
    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));
  }

  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c
    let u = reinterpret<u64>(x);
    u &= 0x7FFFFFFFFFFFFFFF;
    let y = reinterpret<f64>(u);
    let w = u32(u >> 32);
    let t: f64;
    if (w > 0x3FE193EA) {
      if (w > 0x40340000) {
        t = 1 - 0 / y;
      } else {
        t = expm1(2 * y);
        t = 1 - 2 / (t + 2);
      }
    } else if (w > 0x3FD058AE) {
      t = expm1(2 * y);
      t = t / (t + 2);
    } else if (w >= 0x00100000) {
      t = expm1(-2 * y);
      t = -t / (t + 2);
    } else t = y;
    return builtin_copysign<f64>(t, x);
  }

  // @ts-ignore: decorator
  @inline
  export function trunc(x: f64): f64 {
    return builtin_trunc<f64>(x);
  }

  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c
    const
      Ox1p53    = reinterpret<f64>(0x4340000000000000),
      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),
      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);

    let y = x;
    if (n > 1023) {
      y *= Ox1p1023;
      n -= 1023;
      if (n > 1023) {
        y *= Ox1p1023;
        n = builtin_min<i32>(n - 1023, 1023);
      }
    } else if (n < -1022) {
      // make sure final n < -53 to avoid double
      // rounding in the subnormal range
      y *= Ox1p_1022 * Ox1p53;
      n += 1022 - 53;
      if (n < -1022) {
        y *= Ox1p_1022 * Ox1p53;
        n = builtin_max<i32>(n + 1022 - 53, -1022);
      }
    }
    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);
  }

  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c
    if (builtin_abs<f64>(y) == 1.0) {
      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))
      // TODO: move this rule to compiler's optimization pass.
      // It could be apply for any x % C_pot, where "C_pot" is pow of two const.
      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);
    }
    let ux = reinterpret<u64>(x);
    let uy = reinterpret<u64>(y);
    let ex = i64(ux >> 52 & 0x7FF);
    let ey = i64(uy >> 52 & 0x7FF);
    let sx = ux >> 63;
    let uy1 = uy << 1;
    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {
      let m = x * y;
      return m / m;
    }
    let ux1 = ux << 1;
    if (ux1 <= uy1) {
      return x * f64(ux1 != uy1);
    }
    if (!ex) {
      ex -= builtin_clz<i64>(ux << 12);
      ux <<= 1 - ex;
    } else {
      ux &= u64(-1) >> 12;
      ux |= 1 << 52;
    }
    if (!ey) {
      ey -= builtin_clz<i64>(uy << 12);
      uy <<= 1 - ey;
    } else {
      uy &= u64(-1) >> 12;
      uy |= 1 << 52;
    }
    while (ex > ey) {
      if (ux >= uy) {
        if (ux == uy) return 0 * x;
        ux -= uy;
      }
      ux <<= 1;
      --ex;
    }
    if (ux >= uy) {
      if (ux == uy) return 0 * x;
      ux -= uy;
    }
    // for (; !(ux >> 52); ux <<= 1) --ex;
    let shift = builtin_clz<i64>(ux << 11);
    ex -= shift;
    ux <<= shift;
    if (ex > 0) {
      ux -= 1 << 52;
      ux |= ex << 52;
    } else {
      ux >>= -ex + 1;
    }
    return reinterpret<f64>(ux | (sx << 63));
  }

  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c
    let ux = reinterpret<u64>(x);
    let uy = reinterpret<u64>(y);
    let ex = i64(ux >> 52 & 0x7FF);
    let ey = i64(uy >> 52 & 0x7FF);
    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {
      let m = x * y;
      return m / m;
    }
    if (ux << 1 == 0) return x;
    let uxi = ux;
    if (!ex) {
      ex -= builtin_clz<i64>(uxi << 12);
      uxi <<= 1 - ex;
    } else {
      uxi &= u64(-1) >> 12;
      uxi |= 1 << 52;
    }
    if (!ey) {
      ey -= builtin_clz<i64>(uy << 12);
      uy <<= 1 - ey;
    } else {
      uy &= u64(-1) >> 12;
      uy |= 1 << 52;
    }
    let q: u32 = 0;
    do {
      if (ex < ey) {
        if (ex + 1 == ey) break; // goto end
        return x;
      }
      while (ex > ey) {
        if (uxi >= uy) {
          uxi -= uy;
          ++q;
        }
        uxi <<= 1;
        q <<= 1;
        --ex;
      }
      if (uxi >= uy) {
        uxi -= uy;
        ++q;
      }
      if (uxi == 0) ex = -60;
      else {
        let shift = builtin_clz<i64>(uxi << 11);
        ex -= shift;
        uxi <<= shift;
      }
      break;
    } while (false);
    // end:
    if (ex > 0) {
      uxi -= 1 << 52;
      uxi |= ex << 52;
    } else {
      uxi >>= -ex + 1;
    }
    x = reinterpret<f64>(uxi);
    y = builtin_abs<f64>(y);
    let x2 = x + x;
    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {
      x -= y;
      // ++q;
    }
    return <i64>ux < 0 ? -x : x;
  }

  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c
    let u = reinterpret<u64>(x);
    let ux = u32(u >> 32);
    let sign = ux >> 31;
    ux &= 0x7FFFFFFF;

    if (ux <= 0x3FE921FB) {  // |x| ~<= \u03C0/4
      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)
        sincos_sin = x;
        sincos_cos = 1;
        return;
      }
      sincos_sin = sin_kern(x, 0, 0);
      sincos_cos = cos_kern(x, 0);
      return;
    }
    // sin(Inf or NaN) is NaN
    if (ux >= 0x7F800000) {
      let xx = x - x;
      sincos_sin = xx;
      sincos_cos = xx;
      return;
    }
    // general argument reduction needed
    let n = rempio2(x, u, sign);
    let y0 = rempio2_y0;
    let y1 = rempio2_y1;
    let s = sin_kern(y0, y1, 1);
    let c = cos_kern(y0, y1);
    let sin = s, cos = c;
    if (n & 1) {
      sin =  c;
      cos = -s;
    }
    if (n & 2) {
      sin = -sin;
      cos = -cos;
    }
    sincos_sin = sin;
    sincos_cos = cos;
  }
}

// @ts-ignore: decorator
@lazy let rempio2f_y: f64;

// @ts-ignore: decorator
@lazy @inline const PIO2F_TABLE = memory.data<u64>([
  0xA2F9836E4E441529,
  0xFC2757D1F534DDC0,
  0xDB6295993C439041,
  0xFE5163ABDEBBC561
]);

function Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3
  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above
    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f
    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f
    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f
    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f

  let p = z * (pS0 + z * (pS1 + z * pS2));
  let q: f32 = 1 + z * qS1;
  return p / q;
}

// @ts-ignore: decorator
@inline
function expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)
  const                                // see: musl/src/math/__expo2f.c
    k    = <u32>235,
    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f
  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);
  // in directed rounding correct sign before rounding or overflow is important
  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;
}

// @ts-ignore: decorator
@inline
function pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c
  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // \u03C0 * 0x1p-65 = 8.51530395021638647334e-20

  let offset = (u >> 23) - 152;
  let shift  = u64(offset & 63);
  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);

  let b0 = load<u64>(tblPtr, 0 << 3);
  let b1 = load<u64>(tblPtr, 1 << 3);
  let lo: u64;

  if (shift > 32) {
    let b2 = load<u64>(tblPtr, 2 << 3);
    lo  = b2 >> (96 - shift);
    lo |= b1 << (shift - 32);
  } else {
    lo = b1 >> (32 - shift);
  }

  let hi = (b1 >> (64 - shift)) | (b0 << shift);
  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;
  let product = mantissa * hi + (mantissa * lo >> 32);
  let r: i64 = product << 2;
  let q = i32((product >> 62) + (r >>> 63));
  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;
  return q;
}

// @ts-ignore: decorator
@inline
function rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c
  const
    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570
    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8
    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308

  if (u < 0x4DC90FDB) { // \u03C0 * 0x1p28
    let q = nearest(x * _2_pi);
    rempio2f_y = x - q * pi2hi - q * pi2lo;
    return <i32>q;
  }

  let q = pio2f_large_quot(x, u);
  return select(-q, q, sign);
}

// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).
// @ts-ignore: decorator
@inline
function sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c
  const
    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55
    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59
    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65
    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71

  let z = x * x;
  let w = z * z;
  let r = S3 + z * S4;
  let s = z * x;
  return f32((x + s * (S1 + z * S2)) + s * w * r);
}

// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).
// @ts-ignore: decorator
@inline
function cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c
  const
    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54
    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57
    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62
    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68

  let z = x * x;
  let w = z * z;
  let r = C2 + z * C3;
  return f32(((1 + z * C0) + w * C1) + (w * z) * r);
}

// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).
// @ts-ignore: decorator
@inline
function tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c
  const
    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54
    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55
    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57
    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58
    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61
    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59

  let z = x * x;
  let r = T4 + z * T5;
  let t = T2 + z * T3;
  let w = z * z;
  let s = z * x;
  let u = T0 + z * T1;

  r = (x + s * u) + (s * w) * (t + w * r);
  return f32(odd ? -1 / r : r);
}

// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h
// @ts-ignore: decorator
@inline
function log2f(x: f64): f64 {
  const
    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736
    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129
    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505
    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375
    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150

  let i = reinterpret<i64>(x);
  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;
  x = reinterpret<f64>(i - (exponent << 52));
  x = (x - 1) / (x + 1);
  let xx = x * x;
  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));
  return (2 * log2e) * y + <f64>exponent;
}

// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h
// @ts-ignore: decorator
@inline
function exp2f(x: f64): f64 {
  const
    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1
    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1
    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2
    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3
    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3
    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4

  if (x < -1022) return 0;
  if (x >= 1024) return Infinity;

  let n = nearest(x);
  x -= n;
  let xx = x * x;
  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));
  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));
}

export namespace NativeMathf {

  // @ts-ignore: decorator
  @lazy
  export const E       = <f32>NativeMath.E;

  // @ts-ignore: decorator
  @lazy
  export const LN2     = <f32>NativeMath.LN2;

  // @ts-ignore: decorator
  @lazy
  export const LN10    = <f32>NativeMath.LN10;

  // @ts-ignore: decorator
  @lazy
  export const LOG2E   = <f32>NativeMath.LOG2E;

  // @ts-ignore: decorator
  @lazy
  export const LOG10E  = <f32>NativeMath.LOG10E;

  // @ts-ignore: decorator
  @lazy
  export const PI      = <f32>NativeMath.PI;

  // @ts-ignore: decorator
  @lazy
  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;

  // @ts-ignore: decorator
  @lazy
  export const SQRT2   = <f32>NativeMath.SQRT2;

  // @ts-ignore: decorator
  @lazy
  export let sincos_sin: f32 = 0;

  // @ts-ignore: decorator
  @lazy
  export let sincos_cos: f32 = 0;

  // @ts-ignore: decorator
  @inline
  export function abs(x: f32): f32 {
    return builtin_abs<f32>(x);
  }

  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above
    const
      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f
      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f
      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f

    let hx = reinterpret<u32>(x);
    let ix = hx & 0x7FFFFFFF;
    if (ix >= 0x3F800000) {
      if (ix == 0x3F800000) {
        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);
      }
      return 0 / (x - x);
    }
    if (ix < 0x3F000000) {
      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;
      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));
    }
    let z: f32, w: f32, s: f32;
    if (<i32>hx < 0) {
      // z = (1 + x) * 0.5;
      z = 0.5 + x * 0.5;
      s = builtin_sqrt<f32>(z);
      w = Rf(z) * s - pio2_lo;
      return 2 * (pio2_hi - (s + w));
    }
    // z = (1 - x) * 0.5;
    z = 0.5 - x * 0.5;
    s = builtin_sqrt<f32>(z);
    hx = reinterpret<u32>(s);
    let df = reinterpret<f32>(hx & 0xFFFFF000);
    let c = (z - df * df) / (s + df);
    w = Rf(z) * s + c;
    return 2 * (df + w);
  }

  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c
    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f
    let u = reinterpret<u32>(x);
    let a = u & 0x7FFFFFFF;
    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1
      let xm1 = x - 1;
      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));
    }
    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12
      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));
    }
    // x >= 0x1p12 or x <= -2 or NaN
    return log(x) + s;
  }

  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above
    const
      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f
      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f

    let sx = x;
    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;
    if (hx >= 0x3F800000) {
      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;
      return 0 / (x - x);
    }
    if (hx < 0x3F000000) {
      if (hx < 0x39800000 && hx >= 0x00800000) return x;
      return x + x * Rf(x * x);
    }
    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;
    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;
    let s = builtin_sqrt<f64>(z); // sic
    x = f32(pio2 - 2 * (s + s * Rf(z)));
    return builtin_copysign(x, sx);
  }

  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c
    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f
    let u = reinterpret<u32>(x) & 0x7FFFFFFF;
    let y = reinterpret<f32>(u);
    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;
    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));
    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));
    return builtin_copysign(y, x);
  }

  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above
    const
      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f
      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f
      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f
      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f
      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f
      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f
      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f
      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f
      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f
      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f
      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f
      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f
      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f
      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f

    let ix = reinterpret<u32>(x);
    let sx = x;
    ix &= 0x7FFFFFFF;
    let z: f32;
    if (ix >= 0x4C800000) {
      if (isNaN(x)) return x;
      z = atanhi3 + Ox1p_120f;
      return builtin_copysign(z, sx);
    }
    let id: i32;
    if (ix < 0x3EE00000) {
      if (ix < 0x39800000) return x;
      id = -1;
    } else {
      x = builtin_abs<f32>(x);
      if (ix < 0x3F980000) {
        if (ix < 0x3F300000) {
          id = 0;
          x = (2.0 * x - 1.0) / (2.0 + x);
        } else {
          id = 1;
          x = (x - 1.0) / (x + 1.0);
        }
      } else {
        if (ix < 0x401C0000) {
          id = 2;
          x = (x - 1.5) / (1.0 + 1.5 * x);
        } else {
          id = 3;
          x = -1.0 / x;
        }
      }
    }
    z = x * x;
    let w = z * z;
    let s1 = z * (aT0 + w * (aT2 + w * aT4));
    let s2 = w * (aT1 + w * aT3);
    let s3 = x * (s1 + s2);
    if (id < 0) return x - s3;
    switch (id) {
      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }
      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }
      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }
      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }
      default: unreachable();
    }
    return builtin_copysign(z, sx);
  }

  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c
    let u = reinterpret<u32>(x);
    let y = builtin_abs(x);
    if (u < 0x3F800000 - (1 << 23)) {
      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));
    } else y = 0.5 * log1p(2 * (y / (1 - y)));
    return builtin_copysign(y, x);
  }

  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above
    const
      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f
      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f

    if (isNaN(x) || isNaN(y)) return x + y;
    let ix = reinterpret<u32>(x);
    let iy = reinterpret<u32>(y);
    if (ix == 0x3F800000) return atan(y);
    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));
    ix &= 0x7FFFFFFF;
    iy &= 0x7FFFFFFF;
    if (iy == 0) {
      switch (m) {
        case 0:
        case 1: return  y;
        case 2: return  pi;
        case 3: return -pi;
      }
    }
    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;
    if (ix == 0x7F800000) {
      if (iy == 0x7F800000) {
        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;
        return m & 1 ? -t : t;
      } else {
        let t: f32 = m & 2 ? pi : 0.0;
        return m & 1 ? -t : t;
      }
    }
    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;
    let z: f32;
    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;
    else z = atan(builtin_abs<f32>(y / x));
    switch (m) {
      case 0: return  z;
      case 1: return -z;
      case 2: return pi - (z - pi_lo);
      case 3: return (z - pi_lo) - pi;
    }
    unreachable();
    return 0;
  }

  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above
    const
      B1      = <u32>709958130,
      B2      = <u32>642849266,
      Ox1p24f = reinterpret<f32>(0x4B800000);

    let u = reinterpret<u32>(x);
    let hx = u & 0x7FFFFFFF;
    if (hx >= 0x7F800000) return x + x;
    if (hx < 0x00800000) {
      if (hx == 0) return x;
      u = reinterpret<u32>(x * Ox1p24f);
      hx = u & 0x7FFFFFFF;
      hx = hx / 3 + B2;
    } else {
      hx = hx / 3 + B1;
    }
    u &= 0x80000000;
    u |= hx;
    let t = <f64>reinterpret<f32>(u);
    let r = t * t * t;
    t = t * (<f64>x + x + r) / (x + r + r);
    r = t * t * t;
    t = t * (<f64>x + x + r) / (x + r + r);
    return <f32>t;
  }

  // @ts-ignore: decorator
  @inline
  export function ceil(x: f32): f32 {
    return builtin_ceil<f32>(x);
  }

  export function clz32(x: f32): f32 {
    if (!isFinite(x)) return 32;
    return <f32>builtin_clz(dtoi32(x));
  }

  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c
    const
      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1
      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2
      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3
      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4

    let ux = reinterpret<u32>(x);
    let sign = ux >> 31;
    ux &= 0x7FFFFFFF;

    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4
      if (ux < 0x39800000) { // |x| < 2**-12
        // raise inexact if x != 0
        return 1;
      }
      return cos_kernf(x);
    }

    if (ASC_SHRINK_LEVEL < 1) {
      if (ux <= 0x407B53D1) {  // |x| ~<= 5\u03C0/4
        if (ux > 0x4016CBE3) { // |x|  ~> 3\u03C0/4
          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);
        } else {
          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);
        }
      }
      if (ux <= 0x40E231D5) {  // |x| ~<= 9\u03C0/4
        if (ux > 0x40AFEDDF) { // |x|  ~> 7\u03C0/4
          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);
        } else {
          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);
        }
      }
    }

    // cos(Inf or NaN) is NaN
    if (ux >= 0x7F800000) return x - x;

    // general argument reduction needed
    let n = rempio2f(x, ux, sign);
    let y = rempio2f_y;

    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);
    return (n + 1) & 2 ? -t : t;
  }

  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c
    let u = reinterpret<u32>(x);
    u &= 0x7FFFFFFF;
    x = reinterpret<f32>(u);
    if (u < 0x3F317217) {
      if (u < 0x3F800000 - (12 << 23)) return 1;
      let t = expm1(x);
      // return 1 + t * t / (2 * (1 + t));
      return 1 + t * t / (2 + 2 * t);
    }
    if (u < 0x42B17217) {
      let t = exp(x);
      // return 0.5 * (t + 1 / t);
      return 0.5 * t + 0.5 / t;
    }
    return expo2f(x, 1);
  }

  // @ts-ignore: decorator
  @inline
  export function floor(x: f32): f32 {
    return builtin_floor<f32>(x);
  }

  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return expf_lut(x);
    } else {
      const
        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f
        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f
        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f
        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f
        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f
        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f

      let hx = reinterpret<u32>(x);
      let sign = hx >> 31;
      hx &= 0x7FFFFFFF;
      if (hx >= 0x42AEAC50) {
        if (hx > 0x7F800000) return x; // NaN
        if (hx >= 0x42B17218) {
          if (!sign) return x * Ox1p127f;
          else if (hx >= 0x42CFF1B5) return 0;
        }
      }
      let hi: f32, lo: f32;
      let k: i32;
      if (hx > 0x3EB17218) {
        if (hx > 0x3F851592) {
          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));
        } else {
          k = 1 - (sign << 1);
        }
        hi = x - <f32>k * ln2hi;
        lo = <f32>k * ln2lo;
        x = hi - lo;
      } else if (hx > 0x39000000) {
        k = 0;
        hi = x;
        lo = 0;
      } else {
        return 1 + x;
      }
      let xx = x * x;
      let c = x - xx * (P1 + xx * P2);
      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);
      return k == 0 ? y : scalbn(y, k);
    }
  }

  export function exp2(x: f32): f32 {
    return exp2f_lut(x);
  }

  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above
    const
      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f
      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f
      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f
      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f
      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f
      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f

    let u = reinterpret<u32>(x);
    let hx = u & 0x7FFFFFFF;
    let sign = u >> 31;
    if (hx >= 0x4195B844) {
      if (hx > 0x7F800000) return x;
      if (sign) return -1;
      if (hx > 0x42B17217) { // x > log(FLT_MAX)
        x *= Ox1p127f;
        return x;
      }
    }
    let c: f32 = 0.0, t: f32, k: i32;
    if (hx > 0x3EB17218) {
      k = select<i32>(
        1 - (sign << 1),
        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),
        hx < 0x3F851592
      );
      t = <f32>k;
      let hi = x - t * ln2_hi;
      let lo = t * ln2_lo;
      x = hi - lo;
      c = (hi - x) - lo;
    } else if (hx < 0x33000000) {
      return x;
    } else k = 0;
    let hfx: f32 = 0.5 * x;
    let hxs: f32 = x * hfx;
    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);
    t  = 3.0 - r1 * hfx;
    let e = hxs * ((r1 - t) / (6.0 - x * t));
    if (k == 0) return x - (x * e - hxs);
    e  = x * (e - c) - c;
    e -= hxs;
    if (k == -1) return 0.5 * (x - e) - 0.5;
    if (k == 1) {
      if (x < -0.25) return -2.0 * (e - (x + 0.5));
      return 1.0 + 2.0 * (x - e);
    }
    u = (0x7F + k) << 23;
    let twopk = reinterpret<f32>(u);
    let y: f32;
    if (k < 0 || k > 56) {
      y = x - e + 1.0;
      if (k == 128) y = y * 2.0 * Ox1p127f;
      else y = y * twopk;
      return y - 1.0;
    }
    u = (0x7F - k) << 23;
    y = reinterpret<f32>(u);
    if (k < 20) y = (1 - y) - e;
    else y = 1 - (e + y);
    return (x + y) * twopk;
  }

  // @ts-ignore: decorator
  @inline
  export function fround(x: f32): f32 {
    return x;
  }

  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c
    const
      Ox1p90f  = reinterpret<f32>(0x6C800000),
      Ox1p_90f = reinterpret<f32>(0x12800000);

    let ux = reinterpret<u32>(x);
    let uy = reinterpret<u32>(y);
    ux &= 0x7FFFFFFF;
    uy &= 0x7FFFFFFF;
    if (ux < uy) {
      let ut = ux;
      ux = uy;
      uy = ut;
    }
    x = reinterpret<f32>(ux);
    y = reinterpret<f32>(uy);
    if (uy == 0xFF << 23) return y;
    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;
    let z: f32 = 1;
    if (ux >= (0x7F + 60) << 23) {
      z  = Ox1p90f;
      x *= Ox1p_90f;
      y *= Ox1p_90f;
    } else if (uy < (0x7F - 60) << 23) {
      z  = Ox1p_90f;
      x *= Ox1p90f;
      y *= Ox1p90f;
    }
    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));
  }

  // @ts-ignore: decorator
  @inline
  export function imul(x: f32, y: f32): f32 {
    /*
     * Wasm (MVP) and JS have different approaches for double->int conversions.
     *
     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT
     * our float-point arguments before actual convertion to integers.
     */
    if (!isFinite(x + y)) return 0;
    return <f32>(dtoi32(x) * dtoi32(y));
  }

  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return logf_lut(x);
    } else {
      const
        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f
        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f
        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f
        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f
        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f
        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f
        Ox1p25f = reinterpret<f32>(0x4C000000);

      let u = reinterpret<u32>(x);
      let k = 0;
      let sign = u >> 31;
      if (sign || u < 0x00800000) {
        if (u << 1 == 0) return -1 / (x * x);
        if (sign) return (x - x) / 0;
        k -= 25;
        x *= Ox1p25f;
        u = reinterpret<u32>(x);
      } else if (u >= 0x7F800000) {
        return x;
      } else if (u == 0x3F800000) {
        return 0;
      }
      u += 0x3F800000 - 0x3F3504F3;
      k += i32(u >> 23) - 0x7F;
      u = (u & 0x007FFFFF) + 0x3F3504F3;
      x = reinterpret<f32>(u);
      let f = x - 1.0;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * Lg4);
      let t2 = z * (Lg1 + w * Lg3);
      let r = t2 + t1;
      let hfsq = <f32>0.5 * f * f;
      let dk = <f32>k;
      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;
    }
  }

  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above
    const
      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f
      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f
      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f
      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f
      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f
      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f
      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f
      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f
      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f

    let ux = reinterpret<u32>(x);
    let k = 0;
    let sign = ux >> 31;
    if (sign || ux < 0x00800000) {
      if (ux << 1 == 0) return -1 / (x * x);
      if (sign) return (x - x) / 0.0;
      k -= 25;
      x *= Ox1p25f;
      ux = reinterpret<u32>(x);
    } else if (ux >= 0x7F800000) {
      return x;
    } else if (ux == 0x3F800000) {
      return 0;
    }
    ux += 0x3F800000 - 0x3F3504F3;
    k += i32(ux >> 23) - 0x7F;
    ux = (ux & 0x007FFFFF) + 0x3F3504F3;
    x = reinterpret<f32>(ux);
    let f = x - 1.0;
    let s = f / (2.0 + f);
    let z = s * s;
    let w = z * z;
    let t1 = w * (Lg2 + w * Lg4);
    let t2 = z * (Lg1 + w * Lg3);
    let r = t2 + t1;
    let hfsq: f32 = 0.5 * f * f;
    let hi = f - hfsq;
    ux = reinterpret<u32>(hi);
    ux &= 0xFFFFF000;
    hi = reinterpret<f32>(ux);
    let lo = f - hi - hfsq + s * (hfsq + r);
    let dk = <f32>k;
    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;
  }

  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above
    const
      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01
      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06
      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f
      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f
      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f
      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f

    let ix = reinterpret<u32>(x);
    let c: f32 = 0;
    let f: f32 = 0;
    let k = 1;
    if (ix < 0x3ED413D0 || bool(ix >> 31)) {
      if (ix >= 0xBF800000) {
        if (x == -1) return x / 0.0;
        return (x - x) / 0.0;
      }
      if (ix << 1 < 0x33800000 << 1) return x;
      if (ix <= 0xBE95F619) {
        k = 0;
        c = 0;
        f = x;
      }
    } else if (ix >= 0x7F800000) return x;
    if (k) {
      let uf: f32 = 1 + x;
      let iu = reinterpret<u32>(uf);
      iu += 0x3F800000 - 0x3F3504F3;
      k = i32(iu >> 23) - 0x7F;
      if (k < 25) {
        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);
        c /= uf;
      } else c = 0;
      iu = (iu & 0x007FFFFF) + 0x3F3504F3;
      f = reinterpret<f32>(iu) - 1;
    }
    let s = f / (2.0 + f);
    let z = s * s;
    let w = z * z;
    let t1 = w * (Lg2 + w * Lg4);
    let t2 = z * (Lg1 + w * Lg3);
    let r = t2 + t1;
    let hfsq: f32 = 0.5 * f * f;
    let dk = <f32>k;
    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;
  }

  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return log2f_lut(x);
    } else {
      const
        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f
        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04
        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f
        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f
        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f
        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f
        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f

      let ux = reinterpret<u32>(x);
      let k = 0;
      let sign = ux >> 31;
      if (sign || ux < 0x00800000) {
        if (ux << 1 == 0) return -1 / (x * x);
        if (sign) return (x - x) / 0.0;
        k -= 25;
        x *= Ox1p25f;
        ux = reinterpret<u32>(x);
      } else if (ux >= 0x7F800000) {
        return x;
      } else if (ux == 0x3F800000) {
        return 0;
      }
      ux += 0x3F800000 - 0x3F3504F3;
      k += i32(ux >> 23) - 0x7F;
      ux = (ux & 0x007FFFFF) + 0x3F3504F3;
      x = reinterpret<f32>(ux);
      let f = x - 1.0;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * Lg4);
      let t2 = z * (Lg1 + w * Lg3);
      let r = t2 + t1;
      let hfsq: f32 = 0.5 * f * f;
      let hi = f - hfsq;
      let u = reinterpret<u32>(hi);
      u &= 0xFFFFF000;
      hi = reinterpret<f32>(u);
      let lo: f32 = f - hi - hfsq + s * (hfsq + r);
      let dk = <f32>k;
      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;
    }
  }

  // @ts-ignore: decorator
  @inline
  export function max(value1: f32, value2: f32): f32 {
    return builtin_max<f32>(value1, value2);
  }

  // @ts-ignore: decorator
  @inline
  export function min(value1: f32, value2: f32): f32 {
    return builtin_min<f32>(value1, value2);
  }

  export function pow(x: f32, y: f32): f32 {
    // TODO: remove this fast pathes after introduced own mid-end IR with "stdlib call simplify" transforms
    if (builtin_abs<f32>(y) <= 2) {
      if (y == 2.0) return x * x;
      if (y == 0.5) {
        return select<f32>(
          builtin_abs<f32>(builtin_sqrt<f32>(x)),
          Infinity,
          x != -Infinity
        );
      }
      if (y == -1.0) return 1 / x;
      if (y == 1.0) return x;
      if (y == 0.0) return 1.0;
    }
    if (ASC_SHRINK_LEVEL < 1) {
      // see: musl/src/math/powf.c
      return powf_lut(x, y);
    } else {
      // based on:  jdh8/metallic/src/math/float/powf.c
      if (y == 0) return 1;
      // @ts-ignore: cast
      if (isNaN(x) | isNaN(y)) {
        return NaN;
      }
      let sign: u32 = 0;
      let uy = reinterpret<u32>(y);
      let ux = reinterpret<u32>(x);
      let sx = ux >> 31;
      ux &= 0x7FFFFFFF;
      if (sx && nearest(y) == y) {
        x = -x;
        sx = 0;
        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;
      }
      let m: u32;
      if (ux == 0x3F800000) { // x == 1
        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;
      } else if (ux == 0) {
        m = <i32>uy < 0 ? 0x7F800000 : 0;
      } else if (ux == 0x7F800000) {
        m = <i32>uy < 0 ? 0 : 0x7F800000;
      } else if (sx) {
        m = 0x7FC00000;
      } else {
        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));
      }
      return reinterpret<f32>(m | sign);
    }
  }

  // @ts-ignore: decorator
  @inline
  export function seedRandom(value: i64): void {
    NativeMath.seedRandom(value);
  }

  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c
  export function random(): f32 {
    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));

    let s0 = random_state0_32;
    let s1 = random_state1_32;
    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;

    s1 ^= s0;
    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);
    random_state1_32 = rotl<u32>(s1, 13);

    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;
  }

  export function round(x: f32): f32 {
    if (ASC_SHRINK_LEVEL > 0) {
      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);
    } else {
      let roundUp = builtin_ceil<f32>(x);
      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);
    }
  }

  export function sign(x: f32): f32 {
    if (ASC_SHRINK_LEVEL > 0) {
      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);
    } else {
      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);
    }
  }

  // @ts-ignore: decorator
  @inline
  export function signbit(x: f32): bool {
    return <bool>(reinterpret<u32>(x) >>> 31);
  }

  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c
    const
      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1
      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2
      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3
      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4

    let ux = reinterpret<u32>(x);
    let sign = ux >> 31;
    ux &= 0x7FFFFFFF;

    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4
      if (ux < 0x39800000) { // |x| < 2**-12
        return x;
      }
      return sin_kernf(x);
    }

    if (ASC_SHRINK_LEVEL < 1) {
      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4
        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4
          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);
        }
        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));
      }

      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4
        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4
          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);
        }
        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);
      }
    }

    // sin(Inf or NaN) is NaN
    if (ux >= 0x7F800000) return x - x;

    let n = rempio2f(x, ux, sign);
    let y = rempio2f_y;

    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);
    return n & 2 ? -t : t;
  }

  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c
    let u = reinterpret<u32>(x) & 0x7FFFFFFF;
    let a = reinterpret<f32>(u);
    let h = builtin_copysign<f32>(0.5, x);
    if (u < 0x42B17217) {
      let t = expm1(a);
      if (u < 0x3F800000) {
        if (u < 0x3F800000 - (12 << 23)) return x;
        return h * (2 * t - t * t / (t + 1));
      }
      return h * (t + t / (t + 1));
    }
    return expo2f(a, 2 * h);
  }

  // @ts-ignore: decorator
  @inline
  export function sqrt(x: f32): f32 {
    return builtin_sqrt<f32>(x);
  }

  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c
    const
      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2
      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2
      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2
      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2

    let ux = reinterpret<u32>(x);
    let sign = ux >> 31;
    ux &= 0x7FFFFFFF;

    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4
      if (ux < 0x39800000) { // |x| < 2**-12
        return x;
      }
      return tan_kernf(x, 0);
    }

    if (ASC_SHRINK_LEVEL < 1) {
      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4
        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4
          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);
        } else {
          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);
        }
      }
      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4
        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4
          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);
        } else {
          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);
        }
      }
    }

    // tan(Inf or NaN) is NaN
    if (ux >= 0x7F800000) return x - x;

    // argument reduction
    let n = rempio2f(x, ux, sign);
    let y = rempio2f_y;
    return tan_kernf(y, n & 1);
  }

  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c
    let u = reinterpret<u32>(x);
    u &= 0x7FFFFFFF;
    let y = reinterpret<f32>(u);
    let t: f32;
    if (u > 0x3F0C9F54) {
      if (u > 0x41200000) t = 1 + 0 / y;
      else {
        t = expm1(2 * y);
        t = 1 - 2 / (t + 2);
      }
    } else if (u > 0x3E82C578) {
      t = expm1(2 * y);
      t = t / (t + 2);
    } else if (u >= 0x00800000) {
      t = expm1(-2 * y);
      t = -t / (t + 2);
    } else t = y;
    return builtin_copysign<f32>(t, x);
  }

  // @ts-ignore: decorator
  @inline
  export function trunc(x: f32): f32 {
    return builtin_trunc<f32>(x);
  }

  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c
    const
      Ox1p24f   = reinterpret<f32>(0x4B800000),
      Ox1p127f  = reinterpret<f32>(0x7F000000),
      Ox1p_126f = reinterpret<f32>(0x00800000);

    let y = x;
    if (n > 127) {
      y *= Ox1p127f;
      n -= 127;
      if (n > 127) {
        y *= Ox1p127f;
        n = builtin_min<i32>(n - 127, 127);
      }
    } else if (n < -126) {
      y *= Ox1p_126f * Ox1p24f;
      n += 126 - 24;
      if (n < -126) {
        y *= Ox1p_126f * Ox1p24f;
        n = builtin_max<i32>(n + 126 - 24, -126);
      }
    }
    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);
  }

  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c
    if (builtin_abs<f32>(y) == 1.0) {
      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))
      // TODO: move this rule to compiler's optimization pass.
      // It could be apply for any x % C_pot, where "C_pot" is pow of two const.
      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);
    }
    let ux = reinterpret<u32>(x);
    let uy = reinterpret<u32>(y);
    let ex = i32(ux >> 23 & 0xFF);
    let ey = i32(uy >> 23 & 0xFF);
    let sm = ux & 0x80000000;
    let uy1 = uy << 1;
    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {
      let m = x * y;
      return m / m;
    }
    let ux1 = ux << 1;
    if (ux1 <= uy1) {
      return x * f32(ux1 != uy1);
    }
    if (!ex) {
      ex -= builtin_clz<u32>(ux << 9);
      ux <<= 1 - ex;
    } else {
      ux &= <u32>-1 >> 9;
      ux |= 1 << 23;
    }
    if (!ey) {
      ey -= builtin_clz<u32>(uy << 9);
      uy <<= 1 - ey;
    } else {
      uy &= u32(-1) >> 9;
      uy |= 1 << 23;
    }
    while (ex > ey) {
      if (ux >= uy) {
        if (ux == uy) return 0 * x;
        ux -= uy;
      }
      ux <<= 1;
      --ex;
    }
    if (ux >= uy) {
      if (ux == uy) return 0 * x;
      ux -= uy;
    }
    // for (; !(ux >> 23); ux <<= 1) --ex;
    let shift = <i32>builtin_clz<u32>(ux << 8);
    ex -= shift;
    ux <<= shift;
    if (ex > 0) {
      ux -= 1 << 23;
      ux |= <u32>ex << 23;
    } else {
      ux >>= -ex + 1;
    }
    return reinterpret<f32>(ux | sm);
  }

  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c
    let ux = reinterpret<u32>(x);
    let uy = reinterpret<u32>(y);
    let ex = i32(ux >> 23 & 0xFF);
    let ey = i32(uy >> 23 & 0xFF);
    let uxi = ux;
    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);
    if (ux << 1 == 0) return x;
    if (!ex) {
      ex -= builtin_clz<u32>(uxi << 9);
      uxi <<= 1 - ex;
    } else {
      uxi &= u32(-1) >> 9;
      uxi |= 1 << 23;
    }
    if (!ey) {
      ey -= builtin_clz<u32>(uy << 9);
      uy <<= 1 - ey;
    } else {
      uy &= u32(-1) >> 9;
      uy |= 1 << 23;
    }
    let q = 0;
    do {
      if (ex < ey) {
        if (ex + 1 == ey) break; // goto end
        return x;
      }
      while (ex > ey) {
        if (uxi >= uy) {
          uxi -= uy;
          ++q;
        }
        uxi <<= 1;
        q <<= 1;
        --ex;
      }
      if (uxi >= uy) {
        uxi -= uy;
        ++q;
      }
      if (uxi == 0) ex = -30;
      else {
        let shift = builtin_clz<i32>(uxi << 8);
        ex -= shift;
        uxi <<= shift;
      }
      break;
    } while (false);
    // end:
    if (ex > 0) {
      uxi -= 1 << 23;
      uxi |= <u32>ex << 23;
    } else {
      uxi >>= -ex + 1;
    }
    x = reinterpret<f32>(uxi);
    y = builtin_abs<f32>(y);
    let x2 = x + x;
    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {
      x -= y;
      // q++;
    }
    return <i32>ux < 0 ? -x : x;
  }

  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c
    const
      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2
      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2
      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2
      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2

    let ux = reinterpret<u32>(x);
    let sign = ux >> 31;
    ux &= 0x7FFFFFFF;

    if (ux <= 0x3F490FDA) {  // |x| ~<= \u03C0/4
      if (ux < 0x39800000) { // |x| < 2**-12
        sincos_sin = x;
        sincos_cos = 1;
        return;
      }
      sincos_sin = sin_kernf(x);
      sincos_cos = cos_kernf(x);
      return;
    }
    if (ASC_SHRINK_LEVEL < 1) {
      if (ux <= 0x407B53D1) {   // |x| ~<= 5\u03C0/4
        if (ux <= 0x4016CBE3) { // |x| ~<= 3\u03C0/4
          if (sign) {
            sincos_sin = -cos_kernf(x + s1pio2);
            sincos_cos =  sin_kernf(x + s1pio2);
          } else {
            sincos_sin = cos_kernf(s1pio2 - x);
            sincos_cos = sin_kernf(s1pio2 - x);
          }
          return;
        }
        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0
        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);
        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);
        return;
      }
      if (ux <= 0x40E231D5) {   // |x| ~<= 9\u03C0/4
        if (ux <= 0x40AFEDDF) { // |x| ~<= 7\u03C0/4
          if (sign) {
            sincos_sin =  cos_kernf(x + s3pio2);
            sincos_cos = -sin_kernf(x + s3pio2);
          } else {
            sincos_sin = -cos_kernf(x - s3pio2);
            sincos_cos =  sin_kernf(x - s3pio2);
          }
          return;
        }
        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);
        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);
        return;
      }
    }
    // sin(Inf or NaN) is NaN
    if (ux >= 0x7F800000) {
      let xx = x - x;
      sincos_sin = xx;
      sincos_cos = xx;
      return;
    }
    // general argument reduction needed
    let n = rempio2f(x, ux, sign);
    let y = rempio2f_y;
    let s = sin_kernf(y);
    let c = cos_kernf(y);
    let sin = s, cos = c;
    if (n & 1) {
      sin =  c;
      cos = -s;
    }
    if (n & 2) {
      sin = -sin;
      cos = -cos;
    }
    sincos_sin = sin;
    sincos_cos = cos;
  }
}

export function ipow32(x: i32, e: i32): i32 {
  let out = 1;
  if (ASC_SHRINK_LEVEL < 1) {
    if (x == 2) {
      return select<i32>(1 << e, 0, <u32>e < 32);
    }
    if (e <= 0) {
      if (x == -1) return select<i32>(-1, 1, e & 1);
      return i32(e == 0) | i32(x == 1);
    }
    else if (e == 1) return x;
    else if (e == 2) return x * x;
    else if (e < 32) {
      let log = 32 - clz(e);
      // 32 = 2 ^ 5, so need only five cases.
      // But some extra cases needs for properly overflowing
      switch (log) {
        case 5: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 4: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 3: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 2: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 1: {
          if (e & 1) out *= x;
        }
      }
      return out;
    }
  }
  while (e) {
    if (e & 1) out *= x;
    e >>>= 1;
    x *= x;
  }
  return out;
}

export function ipow64(x: i64, e: i64): i64 {
  let out: i64 = 1;
  if (ASC_SHRINK_LEVEL < 1) {
    if (x == 2) {
      return select<i64>(1 << e, 0, <u64>e < 64);
    }
    if (e <= 0) {
      if (x == -1) return select<i64>(-1, 1, e & 1);
      return i64(e == 0) | i64(x == 1);
    }
    else if (e == 1) return x;
    else if (e == 2) return x * x;
    else if (e < 64) {
      let log = 64 - <i32>clz(e);
      // 64 = 2 ^ 6, so need only six cases.
      // But some extra cases needs for properly overflowing
      switch (log) {
        case 6: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 5: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 4: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 3: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 2: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 1: {
          if (e & 1) out *= x;
        }
      }
      return out;
    }
  }
  while (e) {
    if (e & 1) out *= x;
    e >>>= 1;
    x *= x;
  }
  return out;
}

/*
TODO:
In compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains
which usually faster than exponentiation by squaring

for ipow32 and e < 32:

let b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;
switch (e) {
  case  1: return x;
  case  2: return x * x;
  case  3: return x * x * x;
  case  4: return (b = x * x) * b;
  case  5: return (b = x * x) * b * x;
  case  6: return (b = x * x) * b * b;
  case  7: return (b = x * x) * b * b * x;
  case  8: return (d = (b = x * x) * b) * d;
  case  9: return (c = x * x * x) * c * c;
  case 10: return (d = (b = x * x) * b) * d * b;
  case 11: return (d = (b = x * x) * b) * d * b * x;
  case 12: return (d = (b = x * x) * b) * d * d;
  case 13: return (d = (b = x * x) * b) * d * d * x;
  case 14: return (d = (b = x * x) * b) * d * d * b;
  case 15: return (k = (b = x * x) * b * x) * k * k;
  case 16: return (h = (d = (b = x * x) * b) * d) * h;
  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;
  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;
  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;
  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;
  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;
  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;
  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;
  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;
  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;
  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;
  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;
  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;
  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;
  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;
  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;
}

for ipow64: TODO
switch (e) {
  case 32:
  ...
  case 63:
}
*/
`,memory:`import { memcmp, memmove, memset } from "./util/memory";
import { E_NOTIMPLEMENTED } from "./util/error";

/** Memory manager interface. */
export namespace memory {

  /** Gets the size of the memory in pages. */
  // @ts-ignore: decorator
  @builtin
  export declare function size(): i32;

  /** Grows the memory by the given size in pages and returns the previous size in pages. */
  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function grow(pages: i32): i32;

  /** Fills a section in memory with the specified byte value. */
  // @ts-ignore: decorator
  @unsafe @builtin
  export function fill(dst: usize, c: u8, n: usize): void {
    memset(dst, c, n); // fallback if "bulk-memory" isn't enabled
  }

  /** Copies a section of memory to another. Has move semantics. */
  // @ts-ignore: decorator
  @unsafe @builtin
  export function copy(dst: usize, src: usize, n: usize): void {
    memmove(dst, src, n); // fallback if "bulk-memory" isn't enabled
  }

  /** Initializes a memory segment. */
  // @ts-ignore: decorator
  @unsafe
  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  /** Drops a memory segment. */
  // @ts-ignore: decorator
  @unsafe
  export function drop(segmentIndex: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  /** Repeats a section of memory at a specific address. */
  // @ts-ignore: decorator
  @unsafe
  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {
    let index: usize = 0;
    let total = srcLength * count;
    while (index < total) {
      memory.copy(dst + index, src, srcLength);
      index += srcLength;
    }
  }

  /** Compares a section of memory to another. */
  // @ts-ignore: decorator
  @inline
  export function compare(vl: usize, vr: usize, n: usize): i32 {
    return memcmp(vl, vr, n);
  }

  /** Gets a pointer to a static chunk of memory of the given size. */
  // @ts-ignore: decorator
  @builtin
  export declare function data<T>(size: T, align?: i32): usize;
}

// @ts-ignore: decorator
@builtin
export declare const __data_end: usize;

// @ts-ignore: decorator
@builtin
export declare let __stack_pointer: usize;

// @ts-ignore: decorator
@builtin
export declare const __heap_base: usize;

/** Heap memory interface. */
export namespace heap {

  /** Allocates a chunk of memory of at least the specified size. */
  // @ts-ignore: decorator
  @unsafe export function alloc(size: usize): usize {
    return __alloc(size);
  }

  /** Reallocates a chunk of memory to have at least the specified size. */
  // @ts-ignore: decorator
  @unsafe export function realloc(ptr: usize, size: usize): usize {
    return __realloc(ptr, size);
  }

  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */
  // @ts-ignore: decorator
  @unsafe export function free(ptr: usize): void {
    __free(ptr);
  }

  /** Dangerously resets the entire heap. Specific to the stub runtime. */
  // @ts-ignore: decorator
  @unsafe export function reset(): void {
    if (isDefined(__reset)) {
      __reset();
    } else {
      throw new Error(E_NOTIMPLEMENTED);
    }
  }
}
`,number:`import { itoa32, utoa32, itoa64, utoa64, dtoa } from "./util/number";
import { strtol, strtod } from "./util/string";

// @ts-ignore: decorator
@builtin @inline
export const NaN: f64 = 0 / 0;

// @ts-ignore: decorator
@builtin @inline
export const Infinity: f64 = 1 / 0;

// @ts-ignore: decorator
@builtin
export declare function isNaN<T extends number>(value: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isFinite<T extends number>(value: T): bool;

@final @unmanaged
export abstract class I8 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): i8 {
    return <i8>strtol<i32>(value, radix);
  }

  toString(this: i8, radix: i32 = 10): String {
    return itoa32(this, radix);
  }
}

@final @unmanaged
export abstract class I16 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): i16 {
    return <i16>strtol<i32>(value, radix);
  }

  toString(this: i16, radix: i32 = 10): String {
    return itoa32(this, radix);
  }
}

@final @unmanaged
export abstract class I32 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): i32 {
    return <i32>strtol<i32>(value, radix);
  }

  toString(this: i32, radix: i32 = 10): String {
    return itoa32(this, radix);
  }
}

@final @unmanaged
export abstract class I64 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): i64 {
    return strtol<i64>(value, radix);
  }

  toString(this: i64, radix: i32 = 10): String {
    return itoa64(this, radix);
  }
}

@final @unmanaged
export abstract class Isize {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: isize = isize.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: isize = isize.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): isize {
    return <isize>strtol<i64>(value, radix);
  }

  toString(this: isize, radix: i32 = 10): String {
    if (sizeof<isize>() == 4) {
      return itoa32(<i32>this, radix);
    } else {
      return itoa64(<i64>this, radix);
    }
  }
}

@final @unmanaged
export abstract class U8 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): u8 {
    return <u8>strtol<i32>(value, radix);
  }

  toString(this: u8, radix: i32 = 10): String {
    return utoa32(this, radix);
  }
}

@final @unmanaged
export abstract class U16 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): u16 {
    return <u16>strtol<i32>(value, radix);
  }

  toString(this: u16, radix: i32 = 10): String {
    return utoa32(this, radix);
  }
}

@final @unmanaged
export abstract class U32 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): u32 {
    return <u32>strtol<i32>(value, radix);
  }

  toString(this: u32, radix: i32 = 10): String {
    return utoa32(this, radix);
  }
}

@final @unmanaged
export abstract class U64 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): u64 {
    return <u64>strtol<i64>(value, radix);
  }

  toString(this: u64, radix: i32 = 10): String {
    return utoa64(this, radix);
  }
}

@final @unmanaged
export abstract class Usize {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: usize = usize.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: usize = usize.MAX_VALUE;

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): usize {
    return <usize>strtol<i64>(value, radix);
  }

  toString(this: usize, radix: i32 = 10): String {
    if (sizeof<usize>() == 4) {
      return utoa32(<u32>this, radix);
    } else {
      return utoa64(<u64>this, radix);
    }
  }
}

@final @unmanaged
export abstract class Bool {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: bool = bool.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: bool = bool.MAX_VALUE;

  toString(this: bool, radix: i32 = 0): String {
    return this ? "true" : "false";
  }
}

export { Bool as Boolean };

@final @unmanaged
export abstract class F32 {

  // @ts-ignore: decorator
  @lazy
  static readonly EPSILON: f32 = f32.EPSILON;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NaN: f32 = f32.NaN;

  static isNaN(value: f32): bool {
    return isNaN<f32>(value);
  }

  static isFinite(value: f32): bool {
    return isFinite<f32>(value);
  }

  static isSafeInteger(value: f32): bool {
    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;
  }

  static isInteger(value: f32): bool {
    return isFinite<f32>(value) && trunc<f32>(value) == value;
  }

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): f32 {
    return <f32>strtol<f64>(value, radix);
  }

  /** @deprecated */
  static parseFloat(value: string): f32 {
    return <f32>strtod(value);
  }

  toString(this: f32, radix: i32 = 0): String {
    return dtoa(this);
  }
}

@final @unmanaged
export abstract class F64 {

  // @ts-ignore: decorator
  @lazy
  static readonly EPSILON: f64 = f64.EPSILON;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NaN: f64 = f64.NaN;

  static isNaN(value: f64): bool {
    return isNaN<f64>(value);
  }

  static isFinite(value: f64): bool {
    return isFinite<f64>(value);
  }

  static isSafeInteger(value: f64): bool {
    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;
  }

  static isInteger(value: f64): bool {
    return isFinite<f64>(value) && trunc<f64>(value) == value;
  }

  /** @deprecated */
  static parseInt(value: string, radix: i32 = 0): f64 {
    return strtol<f64>(value, radix);
  }

  /** @deprecated */
  static parseFloat(value: string): f64 {
    return strtod(value);
  }

  toString(this: f64, radix: i32 = 0): String {
    return dtoa(this);
  }
}

export { F64 as Number };
`,object:`export class Object {
  static is<T>(x: T, y: T): bool {
    if (isFloat<T>()) {
      // Float pointing is special we shoulr presere following identities:
      // 0.0 !=-0.0
      // NaN == NaN
      if (sizeof<T>() == 8) {
        return (
          bool(u32(x != x) & u32(y != y) |
          u32(reinterpret<u64>(f64(x)) == reinterpret<u64>(f64(y))))
        );
      } else {
        return (
          bool(u32(x != x) & u32(y != y) |
          u32(reinterpret<u32>(f32(x)) == reinterpret<u32>(f32(y))))
        );
      }
    }
    // For references, strings, integers and booleans
    return x == y;
  }
}
`,params:`export namespace Params {
  // compiler re-directs all names inside this namespace here
  @inline
  function __get(name: string): ByteArray {
    return hook_param(name);
  }
}
`,performance:`import {
  performance as performance_binding
} from "bindings/dom";

export namespace performance {
  export function now(): f64 {
    return performance_binding.now();
  }
}
`,process:`import {
  Date as Date_binding,
  performance as performance_binding
} from "bindings/dom";

import {
  process as process_binding
} from "bindings/node";

export namespace process {

  // @ts-ignore: decorator
  @lazy export const arch = sizeof<usize>() == 4 ? "wasm32" : "wasm64";

  // @ts-ignore: decorator
  @lazy export const platform = "wasm";

  // @ts-ignore: decorator
  @lazy export const argv = lazyArgv();

  // @ts-ignore: decorator
  @lazy export const env = lazyEnv();

  // @ts-ignore: decorator
  @lazy export let exitCode = 0;

  export function exit(code: i32 = exitCode): void {
    process_binding.exit(code);
  }

  export function time(): i64 {
    return Date_binding.now();
  }

  export function hrtime(): u64 {
    let now = performance_binding.now();
    let millis = <u64>now;
    let fraction = now - <f64>millis;
    return millis * 1000000 + <u64>(fraction * 1000000);
  }
}

function lazyArgv(): string[] {
  return process_binding.argv;
}

function lazyEnv(): Map<string,string> {
  // TODO: What about Node?
  return new Map();
}
`,pubkey:`export class PubKey {
  @inline
  constructor(public bytes: ByteView) {
    if (bytes.length != 33)
      rollback("Public key wrong length.");
  }

  @inline @operator("==")
  private static __eq(left: PubKey, right: ByteArray): bool {
    if (right.length != 33)
      return false;

    let ptr1 = changetype<usize>(left.bytes.underlying) + left.bytes.offset;
    let ptr2 = changetype<usize>(right);
    if (ptr1 == ptr2) return true;

    for (let i = 0; max_iterations(4), i < 4; ++i) {
      if (load<u64>(ptr1) != load<u64>(ptr2)) return false;
      ptr1 += 8;
      ptr2 += 8;
    }

    return load<u8>(ptr1) == load<u8>(ptr2);
  }

  @inline @operator("!=")
  private static __ne(left: PubKey, right: ByteArray): bool {
    return !this.__eq(left, right);
  }

  @inline
  verify(data: ByteView, sig: ByteView): void {
    if (!$util_verify(
      changetype<u32>(data.underlying) + data.offset,
      data.length,
      changetype<u32>(sig.underlying) + sig.offset,
      sig.length,
      changetype<u32>(this.bytes.underlying) + this.bytes.offset,
      this.bytes.length)) {
      rollback("Invalid Signature.");
    }
  }
}
`,reference:`@unmanaged
abstract class Ref {
}

@final @unmanaged
export abstract class Funcref extends Ref {
}

@final @unmanaged
export abstract class Externref extends Ref {
}

@final @unmanaged
export abstract class Anyref extends Ref {
}

@final @unmanaged
export abstract class Eqref extends Ref {
}

@final @unmanaged
export abstract class I31ref extends Ref {
}

@final @unmanaged
export abstract class Dataref extends Ref {
}

@final @unmanaged
export abstract class Arrayref extends Ref {
}
`,regexp:`export class RegExp {

  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)
  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }

  // @binding(CALL_THIS, [ STRING ], PASS_THRU)
  test(search: string): bool { throw new Error("unreachable"); }

  // @binding(CALL_THIS, [], STRING)
  toString(): string { throw new Error("unreachable"); }

}
`,rt:`import { Typeinfo, TypeinfoFlags } from "./shared/typeinfo";
import { E_INDEXOUTOFRANGE } from "./util/error";
import { OBJECT, TOTAL_OVERHEAD } from "./rt/common";
import { ArrayBufferView } from "./arraybuffer";

// @ts-ignore: decorator
@builtin
export declare const __rtti_base: usize;

// @ts-ignore: decorator
@builtin @unsafe
export declare function __visit_globals(cookie: u32): void;

// @ts-ignore: decorator
@builtin @unsafe
export declare function __visit_members(ref: usize, cookie: u32): void;

// @ts-ignore: decorator
@unsafe
export function __typeinfo(id: u32): TypeinfoFlags {
  let ptr = __rtti_base;
  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);
  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;
}

// @ts-ignore: decorator
@unsafe
export function __instanceof(ptr: usize, classId: u32): bool { // keyword
  let id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;
  let rttiBase = __rtti_base;
  if (id <= load<u32>(rttiBase)) {
    do if (id == classId) return true;
    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);
  }
  return false;
}

// @ts-ignore: decorator
@unsafe
export function __newBuffer(size: usize, id: u32, data: usize = 0): usize {
  let buffer = __new(size, id);
  if (data) memory.copy(buffer, data, size);
  return buffer;
}

// @ts-ignore: decorator
@unsafe
export function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {
  let bufferSize = <usize>length << alignLog2;
  // make sure \`buffer\` is tracked by the shadow stack
  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));
  // ...since allocating the array may trigger GC steps
  let array = __new(offsetof<i32[]>(), id);
  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>("buffer"));
  __link(array, changetype<usize>(buffer), false);
  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>("dataStart"));
  store<i32>(array, bufferSize, offsetof<ArrayBufferView>("byteLength"));
  store<i32>(array, length, offsetof<i32[]>("length_"));
  return array;
}

// @ts-ignore: decorator
@global @unsafe
function __tostack(ptr: usize): usize { // eslint-disable-line
  return ptr;
}

// These are provided by the respective implementation, included as another entry file by asc:

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __alloc(size: usize): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __realloc(ptr: usize, size: usize): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __free(ptr: usize): void;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __new(size: usize, id: u32): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __renew(ptr: usize, size: usize): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __collect(): void;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __visit(ptr: usize, cookie: u32): void;
`,"rt/common":`// Alignment guarantees

// @ts-ignore: decorator
@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128
// @ts-ignore: decorator
@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;
// @ts-ignore: decorator
@inline export const AL_MASK: usize = AL_SIZE - 1;

// Extra debugging

// @ts-ignore: decorator
@inline export const DEBUG = true;
// @ts-ignore: decorator
@inline export const TRACE = false;
// @ts-ignore: decorator
@inline export const RTRACE = isDefined(ASC_RTRACE);
// @ts-ignore: decorator
@inline export const PROFILE = isDefined(ASC_PROFILE);

// Memory manager

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Memory manager block layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524
// \u2502                           MM info                             \u2502 -4
// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561
// \u2502                              ...                              \u2502
@unmanaged export class BLOCK {
  /** Memory manager info. */
  mmInfo: usize;
}

/** Overhead of a memory manager block. */
// @ts-ignore: decorator
@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();

/** Maximum size of a memory manager block's payload. */
// @ts-ignore: decorator
@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;

// Garbage collector

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Garbage collector object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524
// \u2502                     Memory manager block                      \u2502 -20
// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561
// \u2502                            GC info                            \u2502 -16
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                            GC info                            \u2502 -12
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                            RT id                              \u2502 -8
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                            RT size                            \u2502 -4
// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561
// \u2502                              ...                              \u2502
@unmanaged export class OBJECT extends BLOCK {
  /** Garbage collector info. */
  gcInfo: u32;
  /** Garbage collector info. */
  gcInfo2: u32;
  /** Runtime class id. */
  rtId: u32;
  /** Runtime object size. */
  rtSize: u32;
}

/** Overhead of a garbage collector object. Excludes memory manager block overhead. */
// @ts-ignore: decorator
@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;

/** Maximum size of a garbage collector object's payload. */
// @ts-ignore: decorator
@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;

/** Total of memory manager and garbage collector overhead. */
// @ts-ignore: decorator
@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;
`,"rt/index-incremental":`import "rt/tlsf";
import "rt/itcms";
`,"rt/index-minimal":`import "rt/tlsf";
import "rt/tcms";
`,"rt/index-stub":`import "rt/stub";
`,"rt/itcms":`import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from "./common";
import { onvisit, oncollect, oninterrupt, onyield } from "./rtrace";
import { TypeinfoFlags } from "../shared/typeinfo";
import { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from "../util/error";

// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===
// Adapted from Bach Le's \u03BCgc, see: https://github.com/bullno1/ugc

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Colors \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
// \u2502 Color       \u2502 Meaning                                         \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502 WHITE*      \u2502 Unprocessed                                     \u2502
// \u2502 BLACK*      \u2502 Processed                                       \u2502
// \u2502 GRAY        \u2502 Processed with unprocessed children             \u2502
// \u2502 TRANSPARENT \u2502 Manually pinned (always reachable)              \u2502
// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518
// * flipped between cycles

// @ts-ignore: decorator
@lazy let white = 0;
// @ts-ignore: decorator
@inline const gray = 2;
// @ts-ignore: decorator
@inline const transparent = 3;
// @ts-ignore: decorator
@inline const COLOR_MASK = 3;

/** Size in memory of all objects currently managed by the GC. */
// @ts-ignore: decorator
@lazy let total: usize = 0;

/** Currently transitioning from SWEEP to MARK state. */
// @ts-ignore: decorator
@inline const STATE_IDLE = 0;
/** Currently marking reachable objects. */
// @ts-ignore: decorator
@inline const STATE_MARK = 1;
/** Currently sweeping unreachable objects. */
// @ts-ignore: decorator
@inline const STATE_SWEEP = 2;
/** Current collector state. */
// @ts-ignore: decorator
@lazy let state = STATE_IDLE;

// @ts-ignore: decorator
@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy let iter: Object; // null

function initLazy(space: Object): Object {
  space.nextWithColor = changetype<usize>(space);
  space.prev = space;
  return space;
}

/** Visit cookie indicating scanning of an object. */
// @ts-ignore: decorator
@inline const VISIT_SCAN = 0;

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Managed object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524
// \u2502                      Memory manager block                     \u2502
// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2561
// \u2502                              next                         \u2502 C \u2502 = nextWithColor
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524
// \u2502                              prev                             \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                              rtId                             \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                              rtSize                           \u2502
// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561
// \u2502                               ...                             \u2502
// C: color

/** Represents a managed object in memory, consisting of a header followed by the object's data. */
@unmanaged class Object extends BLOCK {
  /** Pointer to the next object with color flags stored in the alignment bits. */
  nextWithColor: usize; // *u32
  /** Pointer to the previous object. */
  prev: Object; // *u32
  /** Runtime id. */
  rtId: u32;
  /** Runtime size. */
  rtSize: u32;

  /** Gets the pointer to the next object. */
  get next(): Object {
    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);
  }

  /** Sets the pointer to the next object. */
  set next(obj: Object) {
    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);
  }

  /** Gets this object's color. */
  get color(): i32 {
    return i32(this.nextWithColor & COLOR_MASK);
  }

  /** Sets this object's color. */
  set color(color: i32) {
    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;
  }

  /** Gets the size of this object in memory. */
  get size(): usize {
    return BLOCK_OVERHEAD + (this.mmInfo & ~3);
  }

  /** Tests if this object is pointerfree. */
  get isPointerfree(): bool {
    let rtId = this.rtId;
    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;
  }

  /** Unlinks this object from its list. */
  unlink(): void {
    let next = this.next;
    if (next == null) {
      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);
      return; // static data not yet linked
    }
    let prev = this.prev;
    if (DEBUG) assert(prev);
    next.prev = prev;
    prev.next = next;
  }

  /** Links this object to the specified list, with the given color. */
  linkTo(list: Object, withColor: i32): void {
    let prev = list.prev;
    this.nextWithColor = changetype<usize>(list) | withColor;
    this.prev = prev;
    prev.next = this;
    list.prev = this;
  }

  /** Marks this object as gray, that is reachable with unscanned children. */
  makeGray(): void {
    if (this == iter) iter = assert(this.prev);
    this.unlink();
    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);
  }
}

/** Visits all objects considered to be program roots. */
function visitRoots(cookie: u32): void {
  __visit_globals(cookie);
  let pn = pinSpace;
  let iter = pn.next;
  while (iter != pn) {
    if (DEBUG) assert(iter.color == transparent);
    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);
    iter = iter.next;
  }
}

/** Visits all objects on the stack. */
function visitStack(cookie: u32): void {
  let ptr = __stack_pointer;
  while (ptr < __heap_base) {
    __visit(load<usize>(ptr), cookie);
    ptr += sizeof<usize>();
  }
}

/** Performs a single step according to the current state. */
function step(): usize {
  // Magic constants responsible for pause times. Obtained experimentally
  // using the compiler compiling itself. 2048 budget pro run by default.
  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;
  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;
  let obj: Object;
  switch (state) {
    case STATE_IDLE: {
      state = STATE_MARK;
      visitCount = 0;
      visitRoots(VISIT_SCAN);
      iter = toSpace;
      return visitCount * MARKCOST;
    }
    case STATE_MARK: {
      let black = i32(!white);
      obj = iter.next;
      while (obj != toSpace) {
        iter = obj;
        if (obj.color != black) { // skip already-blacks (pointerfree)
          obj.color = black;
          visitCount = 0;
          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);
          return visitCount * MARKCOST;
        }
        obj = obj.next;
      }
      visitCount = 0;
      visitRoots(VISIT_SCAN);
      obj = iter.next;
      if (obj == toSpace) {
        visitStack(VISIT_SCAN);
        obj = iter.next;
        while (obj != toSpace) {
          if (obj.color != black) {
            obj.color = black;
            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);
          }
          obj = obj.next;
        }
        let from = fromSpace;
        fromSpace = toSpace;
        toSpace = from;
        white = black;
        iter = from.next;
        state = STATE_SWEEP;
      }
      return visitCount * MARKCOST;
    }
    case STATE_SWEEP: {
      obj = iter;
      if (obj != toSpace) {
        iter = obj.next;
        if (DEBUG) assert(obj.color == i32(!white)); // old white
        free(obj);
        return SWEEPCOST;
      }
      toSpace.nextWithColor = changetype<usize>(toSpace);
      toSpace.prev = toSpace;
      state = STATE_IDLE;
      break;
    }
  }
  return 0;
}

/** Frees an object. */
function free(obj: Object): void {
  if (changetype<usize>(obj) < __heap_base) {
    obj.nextWithColor = 0; // may become linked again
    obj.prev = changetype<Object>(0);
  } else {
    total -= obj.size;
    if (isDefined(__finalize)) {
      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);
    }
    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);
  }
}

// Garbage collector interface

// @ts-ignore: decorator
@global @unsafe
export function __new(size: usize, id: i32): usize {
  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  if (total >= threshold) interrupt();
  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);
  obj.rtId = id;
  obj.rtSize = <u32>size;
  obj.linkTo(fromSpace, white); // inits next/prev
  total += obj.size;
  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;
  // may be visited before being fully initialized, so must fill
  memory.fill(ptr, 0, size);
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __renew(oldPtr: usize, size: usize): usize {
  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);
  // Update object size if its block is large enough
  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {
    oldObj.rtSize = <u32>size;
    return oldPtr;
  }
  // If not the same object anymore, we have to move it move it due to the
  // shadow stack potentially still referencing the old object
  let newPtr = __new(size, oldObj.rtId);
  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));
  return newPtr;
}

// @ts-ignore: decorator
@global @unsafe
export function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {
  // Write barrier is unnecessary if non-incremental
  if (!childPtr) return;
  if (DEBUG) assert(parentPtr);
  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);
  if (child.color == white) {
    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);
    let parentColor = parent.color;
    if (parentColor == i32(!white)) {
      // Maintain the invariant that no black object may point to a white object.
      if (expectMultiple) {
        // Move the barrier "backward". Suitable for containers receiving multiple stores.
        // Avoids a barrier for subsequent objects stored into the same container.
        parent.makeGray();
      } else {
        // Move the barrier "forward". Suitable for objects receiving isolated stores.
        child.makeGray();
      }
    } else if (parentColor == transparent && state == STATE_MARK) {
      // Pinned objects are considered 'black' during the mark phase.
      child.makeGray();
    }
  }
}

// @ts-ignore: decorator
@lazy let visitCount = 0;

// @ts-ignore: decorator
@global @unsafe
export function __visit(ptr: usize, cookie: i32): void {
  if (!ptr) return;
  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (RTRACE) if (!onvisit(obj)) return;
  if (obj.color == white) {
    obj.makeGray();
    ++visitCount;
  }
}

// @ts-ignore: decorator
@global @unsafe
export function __pin(ptr: usize): usize {
  if (ptr) {
    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
    if (obj.color == transparent) {
      throw new Error(E_ALREADY_PINNED);
    }
    obj.unlink(); // from fromSpace
    obj.linkTo(pinSpace, transparent);
  }
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __unpin(ptr: usize): void {
  if (!ptr) return;
  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (obj.color != transparent) {
    throw new Error(E_NOT_PINNED);
  }
  if (state == STATE_MARK) {
    // We may be right at the point after marking roots for the second time and
    // entering the sweep phase, in which case the object would be missed if it
    // is not only pinned but also a root. Make sure it isn't missed.
    obj.makeGray();
  } else {
    obj.unlink();
    obj.linkTo(fromSpace, white);
  }
}

// @ts-ignore: decorator
@global @unsafe
export function __collect(): void {
  if (TRACE) trace("GC (full) at", 1, total);
  if (state > STATE_IDLE) {
    // finish current cycle
    while (state != STATE_IDLE) step();
  }
  // perform a full cycle
  step();
  while (state != STATE_IDLE) step();
  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;
  if (TRACE) trace("GC (full) done at cur/max", 2, total, memory.size() << 16);
  if (RTRACE || PROFILE) oncollect(total);
}

// Garbage collector automation

/** How often to interrupt. The default of 1024 means "interrupt each 1024 bytes allocated". */
// @ts-ignore: decorator
@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;
/** How long to interrupt. The default of 200% means "run at double the speed of allocations". */
// @ts-ignore: decorator
@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;
/** How long to idle. The default of 200% means "wait for memory to double before kicking in again". */
// @ts-ignore: decorator
@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;

/** Threshold of memory used by objects to exceed before interrupting again. */
// @ts-ignore: decorator
@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;

/** Performs a reasonable amount of incremental GC steps. */
function interrupt(): void {
  if (PROFILE) oninterrupt(total);
  if (TRACE) trace("GC (auto) at", 1, total);
  let budget: isize = GRANULARITY * STEPFACTOR / 100;
  do {
    budget -= step();
    if (state == STATE_IDLE) {
      if (TRACE) trace("\u2514 GC (auto) done at cur/max", 2, total, memory.size() << 16);
      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;
      if (PROFILE) onyield(total);
      return;
    }
  } while (budget > 0);
  if (TRACE) trace("\u2514 GC (auto) ongoing at", 1, total);
  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);
  if (PROFILE) onyield(total);
}
`,"rt/rtrace":`import { BLOCK } from "./common";

export declare function oninit(heapBase: usize): void;

// Memory Allocator
export declare function onalloc(block: BLOCK): void;
export declare function onresize(block: BLOCK, oldSizeInclOverhead: usize): void;
export declare function onmove(oldBlock: BLOCK, newBlock: BLOCK): void;
export declare function onfree(block: BLOCK): void;

// Garbage collector
export declare function onvisit(block: BLOCK): bool;
export declare function oncollect(total: usize): void;
export declare function oninterrupt(total: usize): void;
export declare function onyield(total: usize): void;
`,"rt/stub":`import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from "./common";
import { E_ALLOCATION_TOO_LARGE } from "../util/error";

// === A minimal runtime stub ===

// @ts-ignore: decorator
@lazy let startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
// @ts-ignore: decorator
@lazy let offset: usize = startOffset;

@inline function maybeGrowMemory(newOffset: usize): void {
  // assumes newOffset is aligned
  let pagesBefore = memory.size();
  let maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;
  if (newOffset > maxOffset) {
      unreachable(); // out of memory
  }
  offset = newOffset;
}

// @ts-ignore: decorator
@inline function computeSize(size: usize): usize {
  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
}

// @ts-ignore: decorator
@unsafe @global
export function __alloc(size: usize): usize {
  if (size > BLOCK_MAXSIZE)
    unreachable();

  let block = changetype<BLOCK>(offset);
  let ptr = offset + BLOCK_OVERHEAD;
  let payloadSize = computeSize(size);
  maybeGrowMemory(ptr + payloadSize);
  block.mmInfo = payloadSize;
  return ptr;
}

// @ts-ignore: decorator
@unsafe @global
export function __realloc(ptr: usize, size: usize): usize {
  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned
  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);
  let actualSize = block.mmInfo;
  let isLast = ptr + actualSize == offset;
  let payloadSize = computeSize(size);
  if (size > actualSize) {
    if (isLast) { // last block: grow
      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
      maybeGrowMemory(ptr + payloadSize);
      block.mmInfo = payloadSize;
    } else { // copy to new block at least double the size
      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));
      memory.copy(newPtr, ptr, actualSize);
      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);
    }
  } else if (isLast) { // last block: shrink
    offset = ptr + payloadSize;
    block.mmInfo = payloadSize;
  }
  return ptr;
}

// @ts-ignore: decorator
@unsafe @global
export function __free(ptr: usize): void {
  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned
  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);
  if (ptr + block.mmInfo == offset) { // last block: discard
    offset = changetype<usize>(block);
  }
}

// @ts-ignore: decorator
@unsafe @global
export function __reset(): void { // special
  offset = startOffset;
}

// @ts-ignore: decorator
@unsafe @global
export function __new(size: usize, id: u32): usize {
  let ptr = __alloc(OBJECT_OVERHEAD + size);
  let object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);
  object.gcInfo = 0;
  object.gcInfo2 = 0;
  object.rtId = id;
  object.rtSize = <u32>size;
  return ptr + OBJECT_OVERHEAD;
}

// @ts-ignore: decorator
@unsafe @global
export function __renew(oldPtr: usize, size: usize): usize {
  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);
  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;
  return newPtr + OBJECT_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {
  // nop
}

// @ts-ignore: decorator
@global @unsafe
export function __pin(ptr: usize): usize {
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __unpin(ptr: usize): void {
  // nop
}

// @ts-ignore: decorator
@global @unsafe
function __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars
  // nop
}

// @ts-ignore: decorator
@global @unsafe
export function __collect(): void {
  // nop
}
`,"rt/tcms":`import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE } from "./common";
import { onvisit, oncollect } from "./rtrace";
import { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from "../util/error";

// === TCMS: A Two-Color Mark & Sweep garbage collector ===

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Colors \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
// \u2502 Color       \u2502 Meaning                                         \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502 WHITE*      \u2502 Unreachable                                     \u2502
// \u2502 BLACK*      \u2502 Reachable                                       \u2502
// \u2502 TRANSPARENT \u2502 Manually pinned (always reachable)              \u2502
// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518
// * flipped between cycles

// @ts-ignore: decorator
@lazy let white = 0;
// @ts-ignore: decorator
@inline const transparent = 3;
// @ts-ignore: decorator
@inline const COLOR_MASK = 3;

/** Size in memory of all objects currently managed by the GC. */
// @ts-ignore: decorator
@lazy let total: usize = 0;

// @ts-ignore: decorator
@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));

function initLazy(space: Object): Object {
  space.nextWithColor = changetype<usize>(space);
  space.prev = space;
  return space;
}

/** Visit cookie indicating scanning of an object. */
// @ts-ignore: decorator
@inline const VISIT_SCAN = 0;

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Managed object layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524
// \u2502                      Memory manager block                     \u2502
// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2561
// \u2502                              next                         \u2502 C \u2502 = nextWithColor
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2524
// \u2502                              prev                             \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                              rtId                             \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                              rtSize                           \u2502
// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561
// \u2502                               ...                             \u2502
// C: color

/** Represents a managed object in memory, consisting of a header followed by the object's data. */
@unmanaged class Object extends BLOCK {
  /** Pointer to the next object with color flags stored in the alignment bits. */
  nextWithColor: usize; // *u32
  /** Pointer to the previous object. */
  prev: Object; // *u32
  /** Runtime id. */
  rtId: u32;
  /** Runtime size. */
  rtSize: u32;

  /** Gets the pointer to the next object. */
  get next(): Object {
    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);
  }

  /** Sets the pointer to the next object. */
  set next(obj: Object) {
    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);
  }

  /** Gets this object's color. */
  get color(): i32 {
    return i32(this.nextWithColor & COLOR_MASK);
  }

  /** Sets this object's color. */
  set color(color: i32) {
    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;
  }

  /** Gets the size of this object in memory. */
  get size(): usize {
    return BLOCK_OVERHEAD + (this.mmInfo & ~3);
  }

  /** Unlinks this object from its list. */
  unlink(): void {
    let next = this.next;
    if (next == null) {
      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);
      return; // static data not yet linked
    }
    let prev = this.prev;
    if (DEBUG) assert(prev);
    next.prev = prev;
    prev.next = next;
  }

  /** Links this object to the specified list, with the given color. */
  linkTo(list: Object, withColor: i32): void {
    let prev = list.prev;
    this.nextWithColor = changetype<usize>(list) | withColor;
    this.prev = prev;
    prev.next = this;
    list.prev = this;
  }
}

// Garbage collector interface

// @ts-ignore: decorator
@global @unsafe
export function __new(size: usize, id: i32): usize {
  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);
  obj.rtId = id;
  obj.rtSize = <u32>size;
  obj.linkTo(fromSpace, white);
  total += obj.size;
  return changetype<usize>(obj) + TOTAL_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __renew(oldPtr: usize, size: usize): usize {
  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);
  if (oldPtr < __heap_base) { // move to heap for simplicity
    let newPtr = __new(size, oldObj.rtId);
    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));
    return newPtr;
  }
  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  total -= oldObj.size;
  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;
  let newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);
  newObj.rtSize = <u32>size;

  // Replace with new object
  newObj.next.prev = newObj;
  newObj.prev.next = newObj;

  total += newObj.size;
  return newPtr;
}

// @ts-ignore: decorator
@global @unsafe
export function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {
  // nop
}

// @ts-ignore: decorator
@global @unsafe
export function __visit(ptr: usize, cookie: i32): void {
  if (!ptr) return;
  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (RTRACE) if (!onvisit(obj)) return;
  if (obj.color == white) {
    obj.unlink(); // from fromSpace
    obj.linkTo(toSpace, i32(!white));
  }
}

// @ts-ignore: decorator
@global @unsafe
export function __pin(ptr: usize): usize {
  if (ptr) {
    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
    if (obj.color == transparent) {
      throw new Error(E_ALREADY_PINNED);
    }
    obj.unlink(); // from fromSpace
    obj.linkTo(pinSpace, transparent);
  }
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __unpin(ptr: usize): void {
  if (!ptr) return;
  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (obj.color != transparent) {
    throw new Error(E_NOT_PINNED);
  }
  obj.unlink(); // from pinSpace
  obj.linkTo(fromSpace, white);
}

// @ts-ignore: decorator
@global @unsafe
export function __collect(): void {
  if (TRACE) trace("GC at", 1, total);

  // Mark roots (add to toSpace)
  __visit_globals(VISIT_SCAN);

  // Mark direct members of pinned objects (add to toSpace)
  let pn = pinSpace;
  let iter = pn.next;
  while (iter != pn) {
    if (DEBUG) assert(iter.color == transparent);
    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);
    iter = iter.next;
  }

  // Mark what's reachable from toSpace
  let black = i32(!white);
  let to = toSpace;
  iter = to.next;
  while (iter != to) {
    if (DEBUG) assert(iter.color == black);
    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);
    iter = iter.next;
  }

  // Sweep what's left in fromSpace
  let from = fromSpace;
  iter = from.next;
  while (iter != from) {
    if (DEBUG) assert(iter.color == white);
    let newNext = iter.next;
    if (changetype<usize>(iter) < __heap_base) {
      iter.nextWithColor = 0; // may become linked again
      iter.prev = changetype<Object>(0);
    } else {
      total -= iter.size;
      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);
      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);
    }
    iter = newNext;
  }
  from.nextWithColor = changetype<usize>(from);
  from.prev = from;

  // Flip spaces and colors
  fromSpace = to;
  toSpace = from;
  white = black;

  if (TRACE) trace("GC done at", 1, total);
  if (RTRACE) oncollect(total);
}
`,"rt/tlsf":`import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from "./common";
import { oninit, onalloc, onresize, onmove, onfree } from "./rtrace";
import { E_ALLOCATION_TOO_LARGE } from "../util/error";

// === The TLSF (Two-Level Segregate Fit) memory allocator ===
// see: http://www.gii.upv.es/tlsf/

// - \`ffs(x)\` is equivalent to \`ctz(x)\` with x != 0
// - \`fls(x)\` is equivalent to \`sizeof(x) * 8 - clz(x) - 1\`

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block size interpretation (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u256B\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524
// \u2502 |                    FL                       \u2502 SB = SL + AL  \u2502 \u25C4\u2500 usize
// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2568\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518
// FL: first level, SL: second level, AL: alignment, SB: small block

// @ts-ignore: decorator
@inline const SL_BITS: u32 = 4;
// @ts-ignore: decorator
@inline const SL_SIZE: u32 = 1 << SL_BITS;

// @ts-ignore: decorator
@inline const SB_BITS: u32 = SL_BITS + AL_BITS;
// @ts-ignore: decorator
@inline const SB_SIZE: u32 = 1 << SB_BITS;

// @ts-ignore: decorator
@inline const FL_BITS: u32 = 31 - SB_BITS;

// [00]: < 256B (SB)  [12]: < 1M
// [01]: < 512B       [13]: < 2M
// [02]: < 1K         [14]: < 4M
// [03]: < 2K         [15]: < 8M
// [04]: < 4K         [16]: < 16M
// [05]: < 8K         [17]: < 32M
// [06]: < 16K        [18]: < 64M
// [07]: < 32K        [19]: < 128M
// [08]: < 64K        [20]: < 256M
// [09]: < 128K       [21]: < 512M
// [10]: < 256K       [22]: <= 1G - OVERHEAD
// [11]: < 512K
// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead

// Tags stored in otherwise unused alignment bits

// @ts-ignore: decorator
@inline const FREE: usize = 1 << 0;
// @ts-ignore: decorator
@inline const LEFTFREE: usize = 1 << 1;
// @ts-ignore: decorator
@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Block layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u253C\u2500\u253C\u2500\u2524            \u2510
// \u2502                          size                             \u2502L\u2502F\u2502 \u25C4\u2500\u2510 info   overhead
// \u255E>ptr\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2567\u2550\u2561   \u2502        \u2518
// \u2502                        if free: \u25C4 prev                        \u2502 \u25C4\u2500\u2524 usize
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502
// \u2502                        if free: next \u25BA                        \u2502 \u25C4\u2500\u2524
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502
// \u2502                             ...                               \u2502   \u2502 >= 0
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502
// \u2502                        if free: back \u25B2                        \u2502 \u25C4\u2500\u2518
// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 >= MIN SIZE
// F: FREE, L: LEFTFREE
@unmanaged export class Block extends BLOCK {

  /** Previous free block, if any. Only valid if free, otherwise part of payload. */
  prev: Block | null;
  /** Next free block, if any. Only valid if free, otherwise part of payload. */
  next: Block | null;

  // If the block is free, there is a 'back'reference at its end pointing at its start.
}

// Block constants. A block must have a minimum size of three pointers so it can hold \`prev\`,
// \`next\` and \`back\` if free.

// @ts-ignore: decorator
@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back
// @ts-ignore: decorator
// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts

/** Gets the left block of a block. Only valid if the left block is free. */
// @ts-ignore: decorator
@inline function GETFREELEFT(block: Block): Block {
  return load<Block>(changetype<usize>(block) - sizeof<usize>());
}

/** Gets the right block of a block by advancing to the right by its size. */
// @ts-ignore: decorator
@inline function GETRIGHT(block: Block): Block {
  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));
}

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Root layout (32-bit) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524          \u2510
// \u2502        0        |           flMap                            S\u2502 \u25C4\u2500\u2500\u2500\u2500\u2510
// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502
// \u2502                           slMap[0] S                          \u2502 \u25C4\u2500\u2510  \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502  \u2502
// \u2502                           slMap[1]                            \u2502 \u25C4\u2500\u2524  \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  u32 \u2502
// \u2502                           slMap[22]                           \u2502 \u25C4\u2500\u2518  \u2502
// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561    usize
// \u2502                            head[0]                            \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502
// \u2502                              ...                              \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2502
// \u2502                           head[367]                           \u2502 \u25C4\u2500\u2500\u2500\u2500\u2524
// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561      \u2502
// \u2502                             tail                              \u2502 \u25C4\u2500\u2500\u2500\u2500\u2518
// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   SIZE   \u2518
// S: Small blocks map
@unmanaged class Root {
  /** First level bitmap. */
  flMap: usize;
}

// Root constants. Where stuff is stored inside of the root structure.

// @ts-ignore: decorator
@inline const SL_START: usize = sizeof<usize>();
// @ts-ignore: decorator
@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());
// @ts-ignore: decorator
@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;
// @ts-ignore: decorator
@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();
// @ts-ignore: decorator
@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();

// @ts-ignore: decorator
@lazy export let ROOT: Root;

/** Gets the second level map of the specified first level. */
// @ts-ignore: decorator
@inline function GETSL(root: Root, fl: usize): u32 {
  return load<u32>(
    changetype<usize>(root) + (fl << alignof<u32>()),
    SL_START
  );
}

/** Sets the second level map of the specified first level. */
// @ts-ignore: decorator
@inline function SETSL(root: Root, fl: usize, slMap: u32): void {
  store<u32>(
    changetype<usize>(root) + (fl << alignof<u32>()),
    slMap,
    SL_START
  );
}

/** Gets the head of the free list for the specified combination of first and second level. */
// @ts-ignore: decorator
@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {
  return load<Block>(
    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),
    HL_START
  );
}

/** Sets the head of the free list for the specified combination of first and second level. */
// @ts-ignore: decorator
@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {
  store<Block | null>(
    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),
    head,
    HL_START
  );
}

/** Gets the tail block.. */
// @ts-ignore: decorator
@inline function GETTAIL(root: Root): Block {
  return load<Block>(
    changetype<usize>(root),
    HL_END
  );
}

/** Sets the tail block. */
// @ts-ignore: decorator
@inline function SETTAIL(root: Root, tail: Block): void {
  store<Block>(
    changetype<usize>(root),
    tail,
    HL_END
  );
}

/** Inserts a previously used block back into the free list. */
function insertBlock(root: Root, block: Block): void {
  if (DEBUG) assert(block); // cannot be null
  let blockInfo = block.mmInfo;
  if (DEBUG) assert(blockInfo & FREE); // must be free

  let right = GETRIGHT(block);
  let rightInfo = right.mmInfo;

  // merge with right block if also free
  if (rightInfo & FREE) {
    removeBlock(root, right);
    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags
    right = GETRIGHT(block);
    rightInfo = right.mmInfo;
    // 'back' is set below
  }

  // merge with left block if also free
  if (blockInfo & LEFTFREE) {
    let left = GETFREELEFT(block);
    let leftInfo = left.mmInfo;
    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags
    removeBlock(root, left);
    block = left;
    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags
    // 'back' is set below
  }

  right.mmInfo = rightInfo | LEFTFREE;
  // reference to right is no longer used now, hence rightInfo is not synced

  // we now know the size of the block
  let size = blockInfo & ~TAGS_MASK;
  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size
  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match

  // set 'back' to itself at the end of block
  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);

  // mapping_insert
  let fl: usize, sl: u32;
  if (size < SB_SIZE) {
    fl = 0;
    sl = <u32>(size >> AL_BITS);
  } else {
    const inv: usize = sizeof<usize>() * 8 - 1;
    let boundedSize = min(size, BLOCK_MAXSIZE);
    fl = inv - clz<usize>(boundedSize);
    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));
    fl -= SB_BITS - 1;
  }
  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range

  // perform insertion
  let head = GETHEAD(root, fl, sl);
  block.prev = null;
  block.next = head;
  if (head) head.prev = block;
  SETHEAD(root, fl, sl, block);

  // update first and second level maps
  root.flMap |= (1 << fl);
  SETSL(root, fl, GETSL(root, fl) | (1 << sl));
}

/** Removes a free block from internal lists. */
function removeBlock(root: Root, block: Block): void {
  let blockInfo = block.mmInfo;
  if (DEBUG) assert(blockInfo & FREE); // must be free
  let size = blockInfo & ~TAGS_MASK;
  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid

  // mapping_insert
  let fl: usize, sl: u32;
  if (size < SB_SIZE) {
    fl = 0;
    sl = <u32>(size >> AL_BITS);
  } else {
    const inv: usize = sizeof<usize>() * 8 - 1;
    let boundedSize = min(size, BLOCK_MAXSIZE);
    fl = inv - clz<usize>(boundedSize);
    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));
    fl -= SB_BITS - 1;
  }
  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range

  // link previous and next free block
  let prev = block.prev;
  let next = block.next;
  if (prev) prev.next = next;
  if (next) next.prev = prev;

  // update head if we are removing it
  if (block == GETHEAD(root, fl, sl)) {
    SETHEAD(root, fl, sl, next);

    // clear second level map if head is empty now
    if (!next) {
      let slMap = GETSL(root, fl);
      SETSL(root, fl, slMap &= ~(1 << sl));

      // clear first level map if second level is empty now
      if (!slMap) root.flMap &= ~(1 << fl);
    }
  }
  // note: does not alter left/back because it is likely that splitting
  // is performed afterwards, invalidating those changes. so, the caller
  // must perform those updates.
}

/** Searches for a free block of at least the specified size. */
function searchBlock(root: Root, size: usize): Block | null {
  // size was already asserted by caller

  // mapping_search
  let fl: usize, sl: u32;
  if (size < SB_SIZE) {
    fl = 0;
    sl = <u32>(size >> AL_BITS);
  } else {
    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl
    const inv: usize = sizeof<usize>() * 8 - 1;
    const invRound = inv - SL_BITS;
    let requestSize = size < halfMaxSize
      ? size + (1 << (invRound - clz<usize>(size))) - 1
      : size;
    fl = inv - clz<usize>(requestSize);
    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));
    fl -= SB_BITS - 1;
  }
  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range

  // search second level
  let slMap = GETSL(root, fl) & (~0 << sl);
  let head: Block | null = null;
  if (!slMap) {
    // search next larger first level
    let flMap = root.flMap & (~0 << (fl + 1));
    if (!flMap) {
      head = null;
    } else {
      fl = ctz<usize>(flMap);
      slMap = GETSL(root, fl);
      if (DEBUG) assert(slMap);  // can't be zero if fl points here
      head = GETHEAD(root, fl, ctz<u32>(slMap));
    }
  } else {
    head = GETHEAD(root, fl, ctz<u32>(slMap));
  }
  return head;
}

/** Prepares the specified block before (re-)use, possibly splitting it. */
function prepareBlock(root: Root, block: Block, size: usize): void {
  // size was already asserted by caller

  let blockInfo = block.mmInfo;
  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is

  // split if the block can hold another MINSIZE block incl. overhead
  let remaining = (blockInfo & ~TAGS_MASK) - size;
  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {
    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE

    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);
    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE
    insertBlock(root, spare); // also sets 'back'

  // otherwise tag block as no longer FREE and right as no longer LEFTFREE
  } else {
    block.mmInfo = blockInfo & ~FREE;
    GETRIGHT(block).mmInfo &= ~LEFTFREE;
  }
}

/** Adds more memory to the pool. */
function addMemory(root: Root, start: usize, end: usize): bool {
  if (DEBUG) assert(start <= end); // must be valid
  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
  end &= ~AL_MASK;

  let tail = GETTAIL(root);
  let tailInfo: usize = 0;
  if (tail) { // more memory
    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);

    // merge with current tail if adjacent
    const offsetToTail = AL_SIZE;
    if (start - offsetToTail == changetype<usize>(tail)) {
      start -= offsetToTail;
      tailInfo = tail.mmInfo;
    } else {
      // We don't do this, but a user might \`memory.grow\` manually
      // leading to non-adjacent pages managed by TLSF.
    }

  } else if (DEBUG) { // first memory
    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root
  }

  // check if size is large enough for a free block and the tail block
  let size = end - start;
  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {
    return false;
  }

  // left size is total minus its own and the zero-length tail's header
  let leftSize = size - 2 * BLOCK_OVERHEAD;
  let left = changetype<Block>(start);
  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);
  left.prev = null;
  left.next = null;

  // tail is a zero-length used block
  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);
  tail.mmInfo = 0 | LEFTFREE;
  SETTAIL(root, tail);

  insertBlock(root, left); // also merges with free left before tail / sets 'back'

  return true;
}

/** Grows memory to fit at least another block of the specified size. */
function growMemory(root: Root, size: usize): void {
  if (ASC_LOW_MEMORY_LIMIT) {
    unreachable();
    return;
  }
  // Here, both rounding performed in searchBlock ...
  const halfMaxSize = BLOCK_MAXSIZE >> 1;
  if (size < halfMaxSize) { // don't round last fl
    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;
    size += (1 << (invRound - clz<usize>(size))) - 1;
  }
  // and additional BLOCK_OVERHEAD must be taken into account. If we are going
  // to merge with the tail block, that's one time, otherwise it's two times.
  let pagesBefore = memory.size();
  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));
  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);
  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory
  if (memory.grow(pagesWanted) < 0) {
    if (memory.grow(pagesNeeded) < 0) unreachable();
  }
  let pagesAfter = memory.size();
  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);
}

/** Computes the size (excl. header) of a block. */
function computeSize(size: usize): usize {
  // Size must be large enough and aligned minus preceeding overhead
  return size <= BLOCK_MINSIZE
    ? BLOCK_MINSIZE
    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
}

/** Prepares and checks an allocation size. */
function prepareSize(size: usize): usize {
  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  return computeSize(size);
}

/** Initializes the root structure. */
function initialize(): void {
  if (isDefined(ASC_RTRACE)) oninit(__heap_base);
  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;
  let pagesBefore = memory.size();
  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);
  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();
  let root = changetype<Root>(rootOffset);
  root.flMap = 0;
  SETTAIL(root, changetype<Block>(0));
  for (let fl: usize = 0; fl < FL_BITS; ++fl) {
    SETSL(root, fl, 0);
    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {
      SETHEAD(root, fl, sl, null);
    }
  }
  let memStart = rootOffset + ROOT_SIZE;
  if (ASC_LOW_MEMORY_LIMIT) {
    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;
    if (memStart <= memEnd) addMemory(root, memStart, memEnd);
    else unreachable(); // low memory limit already exceeded
  } else {
    addMemory(root, memStart, memory.size() << 16);
  }
  ROOT = root;
}

/** Allocates a block of the specified size. */
export function allocateBlock(root: Root, size: usize): Block {
  let payloadSize = prepareSize(size);
  let block = searchBlock(root, payloadSize);
  if (!block) {
    growMemory(root, payloadSize);
    block = changetype<Block>(searchBlock(root, payloadSize));
    if (DEBUG) assert(block); // must be found now
  }
  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit
  removeBlock(root, block);
  prepareBlock(root, block, payloadSize);
  if (isDefined(ASC_RTRACE)) onalloc(block);
  return block;
}

/** Reallocates a block to the specified size. */
export function reallocateBlock(root: Root, block: Block, size: usize): Block {
  let payloadSize = prepareSize(size);
  let blockInfo = block.mmInfo;
  let blockSize = blockInfo & ~TAGS_MASK;

  // possibly split and update runtime size if it still fits
  if (payloadSize <= blockSize) {
    prepareBlock(root, block, payloadSize);
    if (isDefined(ASC_RTRACE)) {
      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);
    }
    return block;
  }

  // merge with right free block if merger is large enough
  let right = GETRIGHT(block);
  let rightInfo = right.mmInfo;
  if (rightInfo & FREE) {
    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);
    if (mergeSize >= payloadSize) {
      removeBlock(root, right);
      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;
      prepareBlock(root, block, payloadSize);
      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);
      return block;
    }
  }

  // otherwise move the block
  return moveBlock(root, block, size);
}

/** Moves a block to a new one of the specified size. */
function moveBlock(root: Root, block: Block, newSize: usize): Block {
  let newBlock = allocateBlock(root, newSize);
  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);
  if (changetype<usize>(block) >= __heap_base) {
    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);
    freeBlock(root, block);
  }
  return newBlock;
}

/** Frees a block. */
export function freeBlock(root: Root, block: Block): void {
  if (isDefined(ASC_RTRACE)) onfree(block);
  block.mmInfo = block.mmInfo | FREE;
  insertBlock(root, block);
}

/** Checks that a used block is valid to be freed or reallocated. */
function checkUsedBlock(ptr: usize): Block {
  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);
  assert(
    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned
    !(block.mmInfo & FREE)           // must be used
  );
  return block;
}

// @ts-ignore: decorator
@global @unsafe
export function __alloc(size: usize): usize {
  if (!ROOT) initialize();
  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __realloc(ptr: usize, size: usize): usize {
  if (!ROOT) initialize();
  return (ptr < __heap_base
    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))
    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))
  ) + BLOCK_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __free(ptr: usize): void {
  if (ptr < __heap_base) return;
  if (!ROOT) initialize();
  freeBlock(ROOT, checkUsedBlock(ptr));
}
`,set:`/// <reference path="./rt/index.d.ts" />

import { HASH } from "./util/hash";

// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht

// @ts-ignore: decorator
@inline const INITIAL_CAPACITY = 4;

// @ts-ignore: decorator
@inline const FILL_FACTOR_N = 8;

// @ts-ignore: decorator
@inline const FILL_FACTOR_D = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_N = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_D = 4;

/** Structure of a set entry. */
@unmanaged class SetEntry<K> {
  key: K;
  taggedNext: usize; // LSB=1 indicates EMPTY
}

/** Empty bit. */
// @ts-ignore: decorator
@inline const EMPTY: usize = 1 << 0;

/** Size of a bucket. */
// @ts-ignore: decorator
@inline const BUCKET_SIZE = sizeof<usize>();

/** Computes the alignment of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_ALIGN<T>(): usize {
  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits
  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;
  return align;
}

/** Computes the aligned size of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_SIZE<T>(): usize {
  const align = ENTRY_ALIGN<T>();
  const size = (offsetof<SetEntry<T>>() + align) & ~align;
  return size;
}

export class Set<T> {

  // buckets referencing their respective first entry, usize[bucketsMask + 1]
  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
  private bucketsMask: u32 = INITIAL_CAPACITY - 1;

  // entries in insertion order, SetEntry<K>[entriesCapacity]
  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());
  private entriesCapacity: i32 = INITIAL_CAPACITY;
  private entriesOffset: i32 = 0;
  private entriesCount: i32 = 0;

  constructor() {
    /* nop */
  }

  get size(): i32 {
    return this.entriesCount;
  }

  clear(): void {
    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
    this.bucketsMask = INITIAL_CAPACITY - 1;
    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());
    this.entriesCapacity = INITIAL_CAPACITY;
    this.entriesOffset = 0;
    this.entriesCount = 0;
  }

  private find(key: T, hashCode: u32): SetEntry<T> | null {
    let entry = load<SetEntry<T>>( // unmanaged!
      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE
    );
    while (entry) {
      let taggedNext = entry.taggedNext;
      if (!(taggedNext & EMPTY) && entry.key == key) return entry;
      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);
    }
    return null;
  }

  @operator("[]")
  has(key: T): bool {
    return this.find(key, HASH<T>(key)) != null;
  }

  add(key: T): this {
    let hashCode = HASH<T>(key);
    let entry = this.find(key, hashCode); // unmanaged!
    if (!entry) {
      // check if rehashing is necessary
      if (this.entriesOffset == this.entriesCapacity) {
        this.rehash(
          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty
            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N
        );
      }
      // append new entry
      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());
      entry.key = key;
      if (isManaged<T>()) {
        __link(changetype<usize>(this), changetype<usize>(key), true);
      }
      ++this.entriesCount;
      // link with previous entry in bucket
      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;
      entry.taggedNext = load<usize>(bucketPtrBase);
      store<usize>(bucketPtrBase, changetype<usize>(entry));
    }
    return this;
  }

  @operator("[]=")
  private __set(key: T, value: bool): void {
    if (value) this.add(key);
    else this.delete(key);
  }

  delete(key: T): bool {
    let entry = this.find(key, HASH<T>(key)); // unmanaged!
    if (!entry) return false;
    entry.taggedNext |= EMPTY;
    --this.entriesCount;
    // check if rehashing is appropriate
    let halfBucketsMask = this.bucketsMask >> 1;
    if (
      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&
      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
    ) this.rehash(halfBucketsMask);
    return true;
  }

  private rehash(newBucketsMask: u32): void {
    let newBucketsCapacity = <i32>(newBucketsMask + 1);
    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);
    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;
    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());

    // copy old entries to new entries
    let oldPtr = changetype<usize>(this.entries);
    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();
    let newPtr = changetype<usize>(newEntries);
    while (oldPtr != oldEnd) {
      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!
      if (!(oldEntry.taggedNext & EMPTY)) {
        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!
        let oldEntryKey = oldEntry.key;
        newEntry.key = oldEntryKey;
        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;
        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;
        newEntry.taggedNext = load<usize>(newBucketPtrBase);
        store<usize>(newBucketPtrBase, newPtr);
        newPtr += ENTRY_SIZE<T>();
      }
      oldPtr += ENTRY_SIZE<T>();
    }

    this.buckets = newBuckets;
    this.bucketsMask = newBucketsMask;
    this.entries = newEntries;
    this.entriesCapacity = newEntriesCapacity;
    this.entriesOffset = this.entriesCount;
  }

  values(): T[] {
    // FIXME: this is preliminary, needs iterators/closures
    let start = changetype<usize>(this.entries);
    let size = this.entriesOffset;
    let values = new Array<T>(size);
    let length = 0;
    for (let i = 0; i < size; ++i) {
      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());
      if (!(entry.taggedNext & EMPTY)) {
        unchecked(values[length++] = entry.key);
      }
    }
    values.length = length;
    return values;
  }

  toString(): string {
    return "[object Set]";
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    __visit(changetype<usize>(this.buckets), cookie);
    let entries = changetype<usize>(this.entries);
    if (isManaged<T>()) {
      let cur = entries;
      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();
      while (cur < end) {
        let entry = changetype<SetEntry<T>>(cur);
        if (!(entry.taggedNext & EMPTY)) {
          let val = changetype<usize>(entry.key);
          if (isNullable<T>()) {
            if (val) __visit(val, cookie);
          } else __visit(val, cookie);
        }
        cur += ENTRY_SIZE<T>();
      }
    }
    __visit(entries, cookie);
  }
}
`,"shared/feature":`// This file is shared with the compiler and must remain portable

/** Indicates specific features to activate. */
export const enum Feature {
  /** No additional features. */
  None = 0,
  /** Sign extension operations. */
  SignExtension = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops
  /** Mutable global imports and exports. */
  MutableGlobals = 1 << 1, // see: https://github.com/WebAssembly/mutable-global
  /** Non-trapping float to integer operations. */
  NontrappingF2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions
  /** Bulk memory operations. */
  BulkMemory = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations
  /** SIMD types and operations. */
  Simd = 1 << 4, // see: https://github.com/WebAssembly/simd
  /** Threading and atomic operations. */
  Threads = 1 << 5, // see: https://github.com/WebAssembly/threads
  /** Exception handling operations. */
  ExceptionHandling = 1 << 6, // see: https://github.com/WebAssembly/exception-handling
  /** Tail call operations. */
  TailCalls = 1 << 7, // see: https://github.com/WebAssembly/tail-call
  /** Reference types. */
  ReferenceTypes = 1 << 8, // see: https://github.com/WebAssembly/reference-types
  /** Multi value types. */
  MultiValue = 1 << 9, // see: https://github.com/WebAssembly/multi-value
  /** Garbage collection. */
  GC = 1 << 10, // see: https://github.com/WebAssembly/gc
  /** Memory64. */
  Memory64 = 1 << 11, // see: https://github.com/WebAssembly/memory64
  /** Relaxed SIMD. */
  RelaxedSimd = 1 << 12, // see: https://github.com/WebAssembly/relaxed-simd
  /** Extended const expressions. */
  ExtendedConst = 1 << 13, // see: https://github.com/WebAssembly/extended-const
  /** Reference typed strings. */
  Stringref = 1 << 14, // see: https://github.com/WebAssembly/stringref
}

/** Gets the name of the specified feature one would specify on the command line. */
export function featureToString(feature: Feature): string {
  switch (feature) {
    case Feature.SignExtension: return "sign-extension";
    case Feature.MutableGlobals: return "mutable-globals";
    case Feature.NontrappingF2I: return "nontrapping-f2i";
    case Feature.BulkMemory: return "bulk-memory";
    case Feature.Simd: return "simd";
    case Feature.Threads: return "threads";
    case Feature.ExceptionHandling: return "exception-handling";
    case Feature.TailCalls: return "tail-calls";
    case Feature.ReferenceTypes: return "reference-types";
    case Feature.MultiValue: return "multi-value";
    case Feature.GC: return "gc";
    case Feature.Memory64: return "memory64";
    case Feature.RelaxedSimd: return "relaxed-simd";
    case Feature.ExtendedConst: return "extended-const";
    case Feature.Stringref: return "stringref";
  }
  assert(false);
  return "";
}
`,"shared/runtime":`// This file is shared with the compiler and must remain portable

/** Runtime types. */
export enum Runtime {
  /** Simple bump allocator without GC. */
  Stub = 0,
  /** Stop the world semi-automatic GC. */
  Minimal = 1,
  /** incremental GC. */
  Incremental = 2,
}
`,"shared/target":`// This file is shared with the compiler and must remain portable

/** Compilation target. */
export enum Target {
  /** Portable. */
  Js = 0,
  /** WebAssembly with 32-bit pointers. */
  Wasm32 = 1,
  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */
  Wasm64 = 2,
}
`,"shared/typeinfo":`// This file is shared with the compiler and must remain portable

// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Typeinfo interpretation \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524 \u25C4\u2500 __rtti_base
// \u2502                             count                             \u2502
// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2510
// \u2502                      Typeinfo#flags [id=0]                    \u2502 id < count
// \u251C \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2524
// \u2502                      Typeinfo#base  [id=0]                    \u2502
// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
// \u2502                              ...                              \u2502

/** Runtime type information data structure. */
@unmanaged
export class Typeinfo {
  /** Flags describing the shape of this class type. */
  flags: TypeinfoFlags = TypeinfoFlags.NONE;
  /** Base class id or \`0\` if none. */
  base: u32 = 0;
}

/** Runtime type information flags. */
export const enum TypeinfoFlags {
  /** No specific flags. */
  NONE = 0,
  /** Type is an \`ArrayBufferView\`. */
  ARRAYBUFFERVIEW = 1 << 0,
  /** Type is an \`Array\`. */
  ARRAY = 1 << 1,
  /** Type is a \`StaticArray\`. */
  STATICARRAY = 1 << 2,
  /** Type is a \`Set\`. */
  SET = 1 << 3,
  /** Type is a \`Map\`. */
  MAP = 1 << 4,
  /** Type has no outgoing pointers. */
  POINTERFREE = 1 << 5,
  /** Value alignment of 1 byte. */
  VALUE_ALIGN_0 = 1 << 6,
  /** Value alignment of 2 bytes. */
  VALUE_ALIGN_1 = 1 << 7,
  /** Value alignment of 4 bytes. */
  VALUE_ALIGN_2 = 1 << 8,
  /** Value alignment of 8 bytes. */
  VALUE_ALIGN_3 = 1 << 9,
  /** Value alignment of 16 bytes. */
  VALUE_ALIGN_4 = 1 << 10,
  /** Value is a signed type. */
  VALUE_SIGNED = 1 << 11,
  /** Value is a float type. */
  VALUE_FLOAT = 1 << 12,
  /** Value type is nullable. */
  VALUE_NULLABLE = 1 << 13,
  /** Value type is managed. */
  VALUE_MANAGED = 1 << 14,
  /** Key alignment of 1 byte. */
  KEY_ALIGN_0 = 1 << 15,
  /** Key alignment of 2 bytes. */
  KEY_ALIGN_1 = 1 << 16,
  /** Key alignment of 4 bytes. */
  KEY_ALIGN_2 = 1 << 17,
  /** Key alignment of 8 bytes. */
  KEY_ALIGN_3 = 1 << 18,
  /** Key alignment of 16 bytes. */
  KEY_ALIGN_4 = 1 << 19,
  /** Key is a signed type. */
  KEY_SIGNED = 1 << 20,
  /** Key is a float type. */
  KEY_FLOAT = 1 << 21,
  /** Key type is nullable. */
  KEY_NULLABLE = 1 << 22,
  /** Key type is managed. */
  KEY_MANAGED = 1 << 23
}
`,staticarray:`/// <reference path="./rt/index.d.ts" />

import { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";
import { Runtime } from "shared/runtime";
import { COMPARATOR, SORT } from "./util/sort";
import { REVERSE, FILL } from "./util/bytes";
import { idof } from "./builtins";
import { Array } from "./array";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from "./util/error";
import { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from "./util/string";

@final
export class StaticArray<T> {
  [key: number]: T;

  // Note that the interface of StaticArray instances must be a semantically
  // compatible subset of Array<T> in order for syntax highlighting to work
  // properly, for instance when creating static arrays from array literals.
  // The additionally provided static methods take care of dealing with static
  // arrays exclusively, without having to convert to Array<T> first.

  static fromArray<T>(source: Array<T>): StaticArray<T> {
    let length = source.length;
    let outSize = <usize>length << alignof<T>();
    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));
    if (isManaged<T>()) {
      let sourcePtr = source.dataStart;
      for (let i = 0; i < length; ++i) {
        let off = <usize>i << alignof<T>();
        let ref = load<usize>(sourcePtr + off);
        store<usize>(changetype<usize>(out) + off, ref);
        __link(changetype<usize>(out), ref, true);
      }
    } else {
      memory.copy(changetype<usize>(out), source.dataStart, outSize);
    }
    return out;
  }

  /** @deprecated Please use source.concat<StaticArray<T>> instead. */
  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {
    return source.concat<StaticArray<T>>(other);
  }

  /** @deprecated Please use source.slice<StaticArray<T>> instead. */
  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {
    return source.slice<StaticArray<T>>(start, end);
  }

  constructor(length: i32) {
    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);
    let outSize = <usize>length << alignof<T>();
    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));
    if (ASC_RUNTIME != Runtime.Incremental) {
      memory.fill(changetype<usize>(out), 0, outSize);
    }
    return out;
  }

  get length(): i32 {
    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();
  }

  at(index: i32): T {
    let len = this.length;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  @operator("[]") private __get(index: i32): T {
    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);
    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  @unsafe @operator("{}") private __uget(index: i32): T {
    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));
  }

  @operator("[]=") private __set(index: i32, value: T): void {
    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);
    this.__uset(index, value);
  }

  @unsafe @operator("{}=") private __uset(index: i32, value: T): void {
    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);
    if (isManaged<T>()) {
      __link(changetype<usize>(this), changetype<usize>(value), true);
    }
  }

  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {
    if (isManaged<T>()) {
      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);
      __link(changetype<usize>(this), changetype<usize>(value), false);
    } else {
      FILL<T>(changetype<usize>(this), this.length, value, start, end);
    }
    return this;
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {
    let ptr = changetype<usize>(this);
    let len = this.length;

    end = min<i32>(end, len);

    let to    = target < 0 ? max(len + target, 0) : min(target, len);
    let from  = start < 0 ? max(len + start, 0) : min(start, len);
    let last  = end < 0 ? max(len + end, 0) : min(end, len);
    let count = min(last - from, len - to);

    memory.copy( // is memmove
      ptr + (<usize>to << alignof<T>()),
      ptr + (<usize>from << alignof<T>()),
      <usize>count << alignof<T>()
    );
    return this;
  }

  includes(value: T, fromIndex: i32 = 0): bool {
    if (isFloat<T>()) {
      let length = this.length;
      if (length == 0 || fromIndex >= length) return false;
      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);
      while (fromIndex < length) {
        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));
        // @ts-ignore
        if (elem == value || isNaN(elem) & isNaN(value)) return true;
        ++fromIndex;
      }
      return false;
    } else {
      return this.indexOf(value, fromIndex) >= 0;
    }
  }

  indexOf(value: T, fromIndex: i32 = 0): i32 {
    let length = this.length;
    if (length == 0 || fromIndex >= length) return -1;
    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);
    while (fromIndex < length) {
      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      ++fromIndex;
    }
    return -1;
  }

  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {
    let length = this.length;
    if (length == 0) return -1;
    if (fromIndex < 0) fromIndex = length + fromIndex;
    else if (fromIndex >= length) fromIndex = length - 1;
    while (fromIndex >= 0) {
      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      --fromIndex;
    }
    return -1;
  }

  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {
    let sourceLen = this.length;
    let otherLen = other.length;
    let outLen = sourceLen + otherLen;
    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {
      throw new Error(E_INVALIDLENGTH);
    }
    let sourceSize = <usize>sourceLen << alignof<T>();
    let out!: U;

    if (out instanceof Array<T>) {
      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));
      let outStart = changetype<Array<T>>(out).dataStart;
      let otherStart = changetype<Array<T>>(other).dataStart;
      let thisStart = changetype<usize>(this);

      if (isManaged<T>()) {
        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {
          let ref = load<usize>(thisStart + offset);
          store<usize>(outStart + offset, ref);
          __link(changetype<usize>(out), ref, true);
        }
        outStart += sourceSize;
        let otherSize = <usize>otherLen << alignof<T>();
        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {
          let ref = load<usize>(otherStart + offset);
          store<usize>(outStart + offset, ref);
          __link(changetype<usize>(out), ref, true);
        }
      } else {
        memory.copy(outStart, thisStart, sourceSize);
        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());
      }
    } else if (out instanceof StaticArray<T>) {
      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));
      let outStart = changetype<usize>(out);
      let otherStart = changetype<usize>(other);
      let thisStart = changetype<usize>(this);

      if (isManaged<T>()) {
        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {
          let ref = load<usize>(thisStart + offset);
          store<usize>(outStart + offset, ref);
          __link(outStart, ref, true);
        }
        outStart += sourceSize;
        let otherSize = <usize>otherLen << alignof<T>();
        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {
          let ref = load<usize>(otherStart + offset);
          store<usize>(outStart + offset, ref);
          __link(outStart, ref, true);
        }
      } else {
        memory.copy(outStart, thisStart, sourceSize);
        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());
      }
    } else {
      ERROR("Only Array<T> and StaticArray<T> accept for 'U' parameter");
    }
    return out;
  }

  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {
    let length = this.length;
    start = start < 0 ? max(start + length, 0) : min(start, length);
    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);
    length = max(end - start, 0);

    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());
    let size = <usize>length << alignof<T>();
    let out!: U;

    if (out instanceof Array<T>) {
      // return Array
      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));
      let outStart = changetype<Array<T>>(out).dataStart;
      if (isManaged<T>()) {
        let off: usize = 0;
        while (off < size) {
          let ref = load<usize>(sourceStart + off);
          store<usize>(outStart + off, ref);
          __link(changetype<usize>(out), ref, true);
          off += sizeof<usize>();
        }
      } else {
        memory.copy(outStart, sourceStart, size);
      }
    } else if (out instanceof StaticArray<T>) {
      // return StaticArray
      out = changetype<U>(__new(size, idof<StaticArray<T>>()));
      let outStart = changetype<usize>(out);
      if (isManaged<T>()) {
        let off: usize = 0;
        while (off < size) {
          let ref = load<usize>(sourceStart + off);
          store<usize>(outStart + off, ref);
          __link(outStart, ref, true);
          off += sizeof<usize>();
        }
      } else {
        memory.copy(outStart, sourceStart, size);
      }
    } else {
      ERROR("Only Array<T> and StaticArray<T> accept for 'U' parameter");
    }
    return out;
  }

  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {
    for (let i = 0, len = this.length; i < len; ++i) {
      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;
    }
    return -1;
  }

  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {
    for (let i = this.length - 1; i >= 0; --i) {
      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;
    }
    return -1;
  }

  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {
    for (let i = 0, len = this.length; i < len; ++i) {
      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);
    }
  }

  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {
    let len = this.length;
    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));
    let outStart = out.dataStart;
    for (let i = 0; i < len; ++i) {
      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);
      store<U>(outStart + (<usize>i << alignof<U>()), result);
      if (isManaged<U>()) {
        __link(changetype<usize>(out), changetype<usize>(result), true);
      }
    }
    return out;
  }

  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {
    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));
    for (let i = 0, len = this.length; i < len; ++i) {
      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));
      if (fn(value, i, this)) result.push(value);
    }
    return result;
  }

  reduce<U>(
    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,
    initialValue: U
  ): U {
    let acc = initialValue;
    for (let i = 0, len = this.length; i < len; ++i) {
      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);
    }
    return acc;
  }

  reduceRight<U>(
    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,
    initialValue: U
  ): U {
    let acc = initialValue;
    for (let i = this.length - 1; i >= 0; --i) {
      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);
    }
    return acc;
  }

  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {
    for (let i = 0, len = this.length; i < len; ++i) {
      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;
    }
    return true;
  }

  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {
    for (let i = 0, len = this.length; i < len; ++i) {
      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;
    }
    return false;
  }

  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {
    SORT<T>(changetype<usize>(this), this.length, comparator);
    return this;
  }

  join(separator: string = ","): string {
    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);
    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);
    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);
    if (ASC_SHRINK_LEVEL < 1) {
      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);
    }
    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);
    ERROR("unspported element type");
    return <string>unreachable();
  }

  reverse(): StaticArray<T> {
    REVERSE<T>(changetype<usize>(this), this.length);
    return this;
  }

  toString(): string {
    return this.join();
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    if (isManaged<T>()) {
      let cur = changetype<usize>(this);
      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;
      while (cur < end) {
        let val = load<usize>(cur);
        if (val) __visit(val, cookie);
        cur += sizeof<usize>();
      }
    }
  }
}

// variable-length, cannot be compared
@final
export class ByteArray {
  [key: number]: u8;

  @inline
  constructor(length: i32) {
    return changetype<ByteArray>(__new(length, idof<StaticArray<u8>>()));
  }

  @inline get length(): i32 {
    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;
  }

  @inline set length(length: i32) {
    changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize = <u32>length;
  }

  @inline @operator("[]")
  private __get(index: i32): u8 {
    return load<u8>(changetype<usize>(this) + <usize>index);
  }

  @inline @operator("[]=")
  private __set(index: i32, value: u8): void {
    store<u8>(changetype<usize>(this) + <usize>index, value);
  }

  @operator.prefix("!")
  private static __not(a: ByteArray | null): bool {
    return changetype<usize>(a) == 0 || !changetype<ByteArray>(a).length;
  }

  @inline
  static fromUInt(v: u32): ByteArray {
    let a = new ByteArray(4);
    a[0] = <u8>((v >> 24) & 0xFF);
    a[1] = <u8>((v >> 16) & 0xFF);
    a[2] = <u8>((v >> 8) & 0xFF);
    a[3] = <u8>(v & 0xFF);
    return a;
  }

  @inline
  toUInt(): u32 {
    return (<u32>(this[0]) << 24) + (<u32>(this[1]) << 16) + (<u32>(this[2]) << 8) + <u32>(this[3]);
  }

  @inline
  static fromUShort(v: u16): ByteArray {
    let a = new ByteArray(2);
    a[0] = <u8>((v >> 8) & 0xFF);
    a[1] = <u8>(v & 0xFF);
    return a;
  }

  @inline
  toUShort(): u16 {
    return (<u16>(this[0]) << 8) + <u16>(this[1]);
  }
}

export class ByteView {
  [key: number]: u8;

  @inline
  constructor(public underlying: ByteArray, public offset: i32, public length: i32) {
  }

  @inline @operator("[]")
  private __get(index: i32): u8 {
    return this.underlying[this.offset + index];
  }

  @inline @operator("[]=")
  private __set(index: i32, value: u8): void {
    this.underlying[this.offset + index] = value;
  }

  @inline @builtin @operator("==")
  private static __eq(left: ByteView, right: string): bool {
    return false; // shouldn't even get here
  }

  @inline @builtin @operator("!=")
  private static __neq(left: ByteView, right: string): bool {
    return false; // shouldn't even get here
  }

  @inline
  toUInt(): u32 {
    return (<u32>(this[0]) << 24) + (<u32>(this[1]) << 16) + (<u32>(this[2]) << 8) + <u32>(this[3]);
  }
}

export abstract class BytesBase {
  [key: number]: u8;

  abstract get length(): i32;

  @inline @operator("[]")
  private __get(index: i32): u8 {
    return load<u8>(changetype<usize>(this) + <usize>index);
  }

  @inline @operator("[]=")
  private __set(index: i32, value: u8): void {
    // this looks like a reasonable check, but actually gets compiled
    // into very strange (and often satisfied) conditions - maybe
    // classes backed by linear memory cannot have virtual functions?
    // if (<u32>index >= <u32>(this.length)) unreachable();
    this.__uset(index, value);
  }

  @unsafe @inline @operator("{}=") private __uset(index: i32, value: u8): void {
    store<u8>(changetype<usize>(this) + <usize>index, value);
  }
};

@final
export class Bytes8 extends BytesBase {
  @inline
  constructor() {
    super();
    return changetype<Bytes8>(__new(8, idof<StaticArray<u8>>()));
  }

  override get length(): i32 {
    return 8;
  }

  @inline @operator("==")
  private static __eq(left: Bytes8, right: Bytes8): bool {
    let ptr1 = changetype<usize>(left);
    let ptr2 = changetype<usize>(right);
    if (ptr1 == ptr2) return true;

    return load<u64>(ptr1) == load<u64>(ptr2);
  }

  @inline @operator("!=")
  private static __ne(left: Bytes8, right: Bytes8): bool {
    return !this.__eq(left, right);
  }
}

@final
export class Bytes32 extends BytesBase {
  @inline
  constructor() {
    super();
    return changetype<Bytes32>(__new(32, idof<StaticArray<u8>>()));
  }

  override get length(): i32 {
    return 32;
  }

  @inline @operator("==")
  private static __eq(left: Bytes32, right: Bytes32): bool {
    let ptr1 = changetype<usize>(left);
    let ptr2 = changetype<usize>(right);
    if (ptr1 == ptr2) return true;

    for (let i = 0; max_iterations(4), i < 4; ++i) {
      if (load<u64>(ptr1) != load<u64>(ptr2)) return false;
      ptr1 += 8;
      ptr2 += 8;
    }

    return true;
  }

  @inline @operator("!=")
  private static __ne(left: Bytes32, right: Bytes32): bool {
    return !this.__eq(left, right);
  }
}
`,string:`/// <reference path="./rt/index.d.ts" />

import { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";
import { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from "./util/string";
import { SPECIALS_UPPER, casemap, bsearch } from "./util/casemap";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from "./util/error";
import { idof } from "./builtins";
import { Array } from "./array";

@final export abstract class String {

  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());

  static fromChar(c: u8): String {
    let out = __new(1, idof<String>());
    store<u8>(out, c);
    return changetype<String>(out);
  }

  static fromCharCodes(units: Array<i32>): String {
    let length = units.length;
    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));
    let ptr = units.dataStart;
    for (let i = 0; i < length; ++i) {
      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));
    }
    return out;
  }

  static fromCodePoint(code: i32): String {
    let hasSur = <u32>code > 0xFFFF;
    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));
    if (!hasSur) {
      store<u16>(changetype<usize>(out), <u16>code);
    } else {
      // Checks valid code point range
      assert(<u32>code <= 0x10FFFF);
      code -= 0x10000;
      let hi = (code & 0x03FF) | 0xDC00;
      let lo = code >>> 10 | 0xD800;
      store<u32>(changetype<usize>(out), lo | hi << 16);
    }
    return out;
  }

  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }

  get length(): i32 {
    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;
  }

  @operator("[]") charAt(pos: i32): u8 {
    return load<u8>(changetype<usize>(this) + <usize>pos);
  }

  @operator("+") private static __concat(left: String, right: String): String {
    return left.concat(right);
  }

  concat(other: String): String {
    let thisSize: isize = this.length << 1;
    let otherSize: isize = other.length << 1;
    let outSize: usize = thisSize + otherSize;
    if (outSize == 0) return changetype<String>("");
    let out = changetype<String>(__new(outSize, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);
    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);
    return out;
  }

  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {
    end = min(max(end, 0), this.length);
    let searchLength = <isize>search.length;
    let searchStart = <isize>end - searchLength;
    if (searchStart < 0) return false;
    // @ts-ignore: string <-> String
    return !compareImpl(this, searchStart, search, 0, searchLength);
  }

  @operator("==") private static __eq(left: String | null, right: String | null): bool {
    if (changetype<usize>(left) == changetype<usize>(right)) return true;
    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;
    let leftLength = changetype<string>(left).length;
    if (leftLength != changetype<string>(right).length) return false;
    // @ts-ignore: string <-> String
    return !compareImpl(left, 0, right, 0, leftLength);
  }

  @operator.prefix("!")
  private static __not(str: String | null): bool {
    return changetype<usize>(str) == 0 || !changetype<string>(str).length;
  }

  @operator("!=")
  private static __ne(left: String | null, right: String | null): bool {
    return !this.__eq(left, right);
  }

  @operator(">") private static __gt(left: String, right: String): bool {
    if (changetype<usize>(left) == changetype<usize>(right)) return false;
    let leftLength  = left.length;
    if (!leftLength) return false;
    let rightLength = right.length;
    if (!rightLength) return true;
    // @ts-ignore: string <-> String
    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));
    return res ? res > 0 : leftLength > rightLength;
  }

  @operator(">=") private static __gte(left: String, right: String): bool {
    return !this.__lt(left, right);
  }

  @operator("<") private static __lt(left: String, right: String): bool {
    if (changetype<usize>(left) == changetype<usize>(right)) return false;
    let rightLength = right.length;
    if (!rightLength) return false;
    let leftLength  = left.length;
    if (!leftLength) return true;
    // @ts-ignore: string <-> String
    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));
    return res ? res < 0 : leftLength < rightLength;
  }

  @operator("<=") private static __lte(left: String, right: String): bool {
    return !this.__gt(left, right);
  }

  includes(search: String, start: i32 = 0): bool {
    return this.indexOf(search, start) != -1;
  }

  indexOf(search: String, start: i32 = 0): i32 {
    let searchLen = <isize>search.length;
    if (!searchLen) return 0;
    let len = <isize>this.length;
    if (!len) return -1;
    let searchStart = min(max(<isize>start, 0), len);
    for (len -= searchLen; searchStart <= len; ++searchStart) {
      // @ts-ignore: string <-> String
      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;
    }
    return -1;
  }

  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {
    let searchLen = <isize>search.length;
    if (!searchLen) return this.length;
    let len = this.length;
    if (!len) return -1;
    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);
    for (; searchStart >= 0; --searchStart) {
      // @ts-ignore: string <-> String
      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;
    }
    return -1;
  }

  // TODO: implement full locale comparison with locales and Collator options
  localeCompare(other: String): i32 {
    if (changetype<usize>(other) == changetype<usize>(this)) return 0;
    let alen = this.length;
    let blen = other.length;
    // @ts-ignore: string <-> String
    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));
    res = res ? res : alen - blen;
    // normalize to [-1, 1] range
    return i32(res > 0) - i32(res < 0);
  }

  startsWith(search: String, start: i32 = 0): bool {
    let len = <isize>this.length;
    let searchStart = min(max(<isize>start, 0), len);
    let searchLength = <isize>search.length;
    if (searchLength + searchStart > len) return false;
    // @ts-ignore: string <-> String
    return !compareImpl(this, searchStart, search, 0, searchLength);
  }

  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy
    let intStart: isize = start;
    let end: isize = length;
    let len: isize = this.length;
    if (intStart < 0) intStart = max(len + intStart, 0);
    let size = min(max(end, 0), len - intStart) << 1;
    if (size <= 0) return changetype<String>("");
    let out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);
    return out;
  }

  substring(start: i32, end: i32 = i32.MAX_VALUE): String {
    let len: isize = this.length;
    let finalStart = min<isize>(max(start, 0), len);
    let finalEnd = min<isize>(max(end, 0), len);
    let fromPos = min<isize>(finalStart, finalEnd) << 1;
    let toPos = max<isize>(finalStart, finalEnd) << 1;
    let size = toPos - fromPos;
    if (!size) return changetype<String>("");
    if (!fromPos && toPos == len << 1) return this;
    let out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);
    return out;
  }

  trim(): String {
    let len = this.length;
    let size: usize = len << 1;
    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {
      size -= 2;
    }
    let offset: usize = 0;
    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {
      offset += 2; size -= 2;
    }
    if (!size) return changetype<String>("");
    if (!offset && size == len << 1) return this;
    let out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);
    return out;
  }

  @inline
  trimLeft(): String {
    return this.trimStart();
  }

  @inline
  trimRight(): String {
    return this.trimEnd();
  }

  trimStart(): String {
    let size = <usize>this.length << 1;
    let offset: usize = 0;
    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {
      offset += 2;
    }
    if (!offset) return this;
    size -= offset;
    if (!size) return changetype<String>("");
    let out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);
    return out;
  }

  trimEnd(): String {
    let originalSize = <usize>this.length << 1;
    let size = originalSize;
    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {
      size -= 2;
    }
    if (!size) return changetype<String>("");
    if (size == originalSize) return this;
    let out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this), size);
    return out;
  }

  padStart(length: i32, pad: string = " "): String {
    let thisSize = <usize>this.length << 1;
    let targetSize = <usize>length << 1;
    let padSize = <usize>pad.length << 1;
    if (targetSize < thisSize || !padSize) return this;
    let prependSize = targetSize - thisSize;
    let out = changetype<String>(__new(targetSize, idof<String>()));
    if (prependSize > padSize) {
      let repeatCount = (prependSize - 2) / padSize;
      let restBase = repeatCount * padSize;
      let restSize = prependSize - restBase;
      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);
      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);
    } else {
      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);
    }
    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);
    return out;
  }

  padEnd(length: i32, pad: string = " "): String {
    let thisSize = <usize>this.length << 1;
    let targetSize = <usize>length << 1;
    let padSize = <usize>pad.length << 1;
    if (targetSize < thisSize || !padSize) return this;
    let appendSize = targetSize - thisSize;
    let out = changetype<String>(__new(targetSize, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);
    if (appendSize > padSize) {
      let repeatCount = (appendSize - 2) / padSize;
      let restBase = repeatCount * padSize;
      let restSize = appendSize - restBase;
      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);
      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);
    } else {
      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);
    }
    return out;
  }

  repeat(count: i32 = 0): String {
    let length = this.length;

    // Most browsers can't handle strings 1 << 28 chars or longer
    if (count < 0 || <u64>length * count > (1 << 28)) {
      throw new RangeError(E_INVALIDLENGTH);
    }

    if (count == 0 || !length) return changetype<String>("");
    if (count == 1) return this;
    let out = changetype<String>(__new((length * count) << 1, idof<String>()));
    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);
    return out;
  }

  replace(search: String, replacement: String): String {
    let len: usize = this.length;
    let slen: usize = search.length;
    if (len <= slen) {
      return len < slen ? this : select<String>(replacement, this, search == this);
    }
    let index: isize = this.indexOf(search);
    if (~index) {
      let rlen: usize = replacement.length;
      len -= slen;
      let olen = len + rlen;
      if (olen) {
        let out = changetype<String>(__new(olen << 1, idof<String>()));
        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);
        memory.copy(
          changetype<usize>(out) + (index << 1),
          changetype<usize>(replacement),
          rlen << 1
        );
        memory.copy(
          changetype<usize>(out) + ((index + rlen) << 1),
          changetype<usize>(this) + ((index + slen) << 1),
          (len - index) << 1
        );
        return out;
      }
    }
    return this;
  }

  replaceAll(search: String, replacement: String): String {
    let thisLen: usize = this.length;
    let searchLen: usize = search.length;
    if (thisLen <= searchLen) {
      return thisLen < searchLen
        ? this
        : select<String>(replacement, this, search == this);
    }
    let replaceLen: usize = replacement.length;
    if (!searchLen) {
      if (!replaceLen) return this;
      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'
      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));
      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);
      let offset = replaceLen;
      for (let i: usize = 0; i < thisLen; ++i) {
        store<u16>(
          changetype<usize>(out) + (offset++ << 1),
          load<u16>(changetype<usize>(this) + (i << 1))
        );
        memory.copy(
          changetype<usize>(out) + (offset << 1),
          changetype<usize>(replacement),
          replaceLen << 1
        );
        offset += replaceLen;
      }
      return out;
    }
    let prev: isize = 0, next: isize = 0;
    if (searchLen == replaceLen) {
      // Fast path when search and replacement have same length
      let outSize = thisLen << 1;
      let out = changetype<String>(__new(outSize, idof<String>()));
      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);
      while (~(next = <isize>this.indexOf(search, <i32>prev))) {
        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);
        prev = next + searchLen;
      }
      return out;
    }
    let out: String | null = null, offset: usize = 0, outSize = thisLen;
    while (~(next = <isize>this.indexOf(search, <i32>prev))) {
      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));
      let chunk = next - prev;
      if (offset + chunk + replaceLen > outSize) {
        outSize <<= 1;
        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));
      }
      memory.copy(
        changetype<usize>(out) + (offset << 1),
        changetype<usize>(this) + (prev << 1),
        chunk << 1
      );
      offset += chunk;
      memory.copy(
        changetype<usize>(out) + (offset << 1),
        changetype<usize>(replacement),
        replaceLen << 1
      );
      offset += replaceLen;
      prev = next + searchLen;
    }
    if (out) {
      let rest = thisLen - prev;
      if (offset + rest > outSize) {
        outSize <<= 1;
        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));
      }
      if (rest) {
        memory.copy(
          changetype<usize>(out) + (offset << 1),
          changetype<usize>(this) + (prev << 1),
          rest << 1
        );
      }
      rest += offset;
      if (outSize > rest) {
        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));
      }
      return out;
    }
    return this;
  }

  slice(start: i32, end: i32 = i32.MAX_VALUE): String {
    let len = this.length;
    start = start < 0 ? max(start + len, 0) : min(start, len);
    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);
    len   = end - start;
    if (len <= 0) return changetype<String>("");
    let out = changetype<String>(__new(len << 1, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);
    return out;
  }

  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {
    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));
    if (changetype<usize>(separator) == 0) return [ this ];
    let length: isize = this.length;
    let sepLen = changetype<string>(separator).length;
    if (limit < 0) limit = i32.MAX_VALUE;
    if (!sepLen) {
      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));
      // split by chars
      length = min<isize>(length, <isize>limit);
      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));
      // @ts-ignore: cast
      let resultStart = result.dataStart as usize;
      for (let i: isize = 0; i < length; ++i) {
        let charStr = changetype<String>(__new(2, idof<String>()));
        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));
        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr
        __link(changetype<usize>(result), changetype<usize>(charStr), true);
      }
      return result;
    } else if (!length) {
      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));
      // @ts-ignore: cast
      store<usize>(result.dataStart as usize, changetype<usize>("")); // static ""
      return result;
    }
    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));
    let end = 0, start = 0, i = 0;
    while (~(end = this.indexOf(changetype<string>(separator), start))) {
      let len = end - start;
      if (len > 0) {
        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));
        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);
        result.push(out);
      } else {
        result.push(changetype<String>(""));
      }
      if (++i == limit) return result;
      start = end + sepLen;
    }
    if (!start) { // also means: loop above didn't do anything
      result.push(this);
      return result;
    }
    let len = length - start;
    if (len > 0) {
      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));
      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);
      result.push(out);
    } else {
      result.push(changetype<String>("")); // static ""
    }
    return result;
  }

  toLowerCase(): String {
    let len = <usize>this.length;
    if (!len) return this;
    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));
    let j: usize = 0;
    for (let i: usize = 0; i < len; ++i, ++j) {
      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));
      if (isAscii(c)) {
        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));
      } else {
        // check and read surrogate pair
        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {
          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);
          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {
            let c0 = c;
            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;
            ++i;
            if (c >= 0x20000) {
              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));
              ++j;
              continue;
            }
          }
        }
        // check special casing for lower table. It has one ently so instead lookup we just inline this.
        if (c == 0x0130) {
          // 0x0130 -> [0x0069, 0x0307]
          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);
          ++j;
        } else if (c == 0x03A3) { // '\u03A3'
          // \u03A3 maps to \u03C3 but except at the end of a word where it maps to \u03C2
          let sigma = 0x03C3; // \u03C3
          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {
            sigma = 0x03C2; // \u03C2
          }
          store<u16>(changetype<usize>(codes) + (j << 1), sigma);
        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {
          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling
          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);
        } else {
          let code = casemap(c, 0) & 0x1FFFFF;
          if (code < 0x10000) {
            store<u16>(changetype<usize>(codes) + (j << 1), code);
          } else {
            // store as surrogare pair
            code -= 0x10000;
            let lo = (code >>> 10) | 0xD800;
            let hi = (code & 0x03FF) | 0xDC00;
            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));
            ++j;
          }
        }
      }
    }
    return changetype<String>(__renew(changetype<usize>(codes), j << 1));
  }

  toUpperCase(): String {
    let len = <usize>this.length;
    if (!len) return this;
    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));
    let specialsPtr = changetype<usize>(SPECIALS_UPPER);
    let specialsLen = SPECIALS_UPPER.length;
    let j: usize = 0;
    for (let i: usize = 0; i < len; ++i, ++j) {
      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));
      if (isAscii(c)) {
        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));
      } else {
        // check and read surrogate pair
        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {
          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);
          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {
            let c0 = c;
            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;
            ++i;
            if (c >= 0x20000) {
              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));
              ++j;
              continue;
            }
          }
        }
        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling
        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {
          // monkey patch
          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);
        } else {
          let index: usize = -1;
          // Fast range check. See first and last rows in specialsUpper table
          if (c - 0x00DF <= 0xFB17 - 0x00DF) {
            index = <usize>bsearch(c, specialsPtr, specialsLen);
          }
          if (~index) {
            // load next 3 code points from row with \`index\` offset for specialsUpper table
            let ab = load<u32>(specialsPtr + (index << 1), 2);
            let cc = load<u16>(specialsPtr + (index << 1), 6);
            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);
            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);
            j += 1 + usize(cc != 0);
          } else {
            let code = casemap(c, 1) & 0x1FFFFF;
            if (code < 0x10000) {
              store<u16>(changetype<usize>(codes) + (j << 1), code);
            } else {
              // store as surrogare pair
              code -= 0x10000;
              let lo = (code >>> 10) | 0xD800;
              let hi = (code & 0x03FF) | 0xDC00;
              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));
              ++j;
            }
          }
        }
      }
    }
    return changetype<String>(__renew(changetype<usize>(codes), j << 1));
  }

  toString(): String {
    return this;
  }
}

// @ts-ignore: nolib
export type string = String;

export function parseInt(str: string, radix: i32 = 0): f64 {
  return strtol<f64>(str, radix);
}

export function parseFloat(str: string): f64 {
  return strtod(str);
}

@global @inline
export function newStringBuffer(size: usize): usize {
  return __new(size, idof<String>());
}

@global @inline
export function convertStringBuffer(buf: usize, size: usize): string {
  return changetype<string>(buf - size);
}

// Encoding helpers
export namespace String {

  export namespace UTF8 {

    export const enum ErrorMode {
      WTF8,
      REPLACE,
      ERROR
    }

    export function byteLength(str: string, nullTerminated: bool = false): i32 {
      let strOff = changetype<usize>(str);
      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;
      let bufLen = i32(nullTerminated);
      while (strOff < strEnd) {
        let c1 = <u32>load<u16>(strOff);
        if (c1 < 128) {
          // @ts-ignore: cast
          if (nullTerminated & !c1) break;
          bufLen += 1;
        } else if (c1 < 2048) {
          bufLen += 2;
        } else {
          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {
            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {
              bufLen += 4; strOff += 4;
              continue;
            }
          }
          bufLen += 3;
        }
        strOff += 2;
      }
      return bufLen;
    }

    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {
      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));
      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);
      return buf;
    }

    // @ts-ignore: decorator
    @unsafe
    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {
      let strEnd = str + (<usize>len << 1);
      let bufOff = buf;
      while (str < strEnd) {
        let c1 = <u32>load<u16>(str);
        if (c1 < 128) {
          store<u8>(bufOff, c1);
          bufOff++;
          // @ts-ignore: cast
          if (nullTerminated & !c1) return bufOff - buf;
        } else if (c1 < 2048) {
          let b0 = c1 >> 6 | 192;
          let b1 = c1 & 63 | 128;
          store<u16>(bufOff, b1 << 8 | b0);
          bufOff += 2;
        } else {
          // D800: 11011 0 0000000000 Lead
          // DBFF: 11011 0 1111111111
          // DC00: 11011 1 0000000000 Trail
          // DFFF: 11011 1 1111111111
          // F800: 11111 0 0000000000 Mask
          // FC00: 11111 1 0000000000
          if ((c1 & 0xF800) == 0xD800) {
            if (c1 < 0xDC00 && str + 2 < strEnd) {
              let c2 = <u32>load<u16>(str, 2);
              if ((c2 & 0xFC00) == 0xDC00) {
                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);
                let b0 = c1 >> 18 | 240;
                let b1 = c1 >> 12 & 63 | 128;
                let b2 = c1 >> 6  & 63 | 128;
                let b3 = c1       & 63 | 128;
                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);
                bufOff += 4; str += 4;
                continue;
              }
            }
            if (errorMode != ErrorMode.WTF8) { // unlikely
              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);
              c1 = 0xFFFD;
            }
          }
          let b0 = c1 >> 12 | 224;
          let b1 = c1 >> 6  & 63 | 128;
          let b2 = c1       & 63 | 128;
          store<u16>(bufOff, b1 << 8 | b0);
          store<u8>(bufOff, b2, 2);
          bufOff += 3;
        }
        str += 2;
      }
      if (nullTerminated) {
        store<u8>(bufOff++, 0);
      }
      return bufOff - buf;
    }

    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {
      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);
    }

    // @ts-ignore: decorator
    @unsafe
    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {
      let bufOff = buf;
      let bufEnd = buf + len;
      assert(bufEnd >= bufOff); // guard wraparound
      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte
      let strOff = changetype<usize>(str);
      while (bufOff < bufEnd) {
        let u0 = <u32>load<u8>(bufOff); ++bufOff;
        if (!(u0 & 128)) {
          // @ts-ignore: cast
          if (nullTerminated & !u0) break;
          store<u16>(strOff, u0);
        } else {
          if (bufEnd == bufOff) break;
          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;
          if ((u0 & 224) == 192) {
            store<u16>(strOff, (u0 & 31) << 6 | u1);
          } else {
            if (bufEnd == bufOff) break;
            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              if (bufEnd == bufOff) break;
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;
              ++bufOff;
            }
            if (u0 < 0x10000) {
              store<u16>(strOff, u0);
            } else {
              u0 -= 0x10000;
              let lo = u0 >> 10 | 0xD800;
              let hi = (u0 & 0x03FF) | 0xDC00;
              store<u32>(strOff, lo | (hi << 16));
              strOff += 2;
            }
          }
        }
        strOff += 2;
      }
      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));
    }
  }

  export namespace UTF16 {

    export function byteLength(str: string): i32 {
      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;
    }

    export function encode(str: string): ArrayBuffer {
      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));
      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));
      return buf;
    }

    // @ts-ignore: decorator
    @unsafe
    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {
      let size = <usize>len << 1;
      memory.copy(buf, changetype<usize>(str), size);
      return size;
    }

    export function decode(buf: ArrayBuffer): String {
      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);
    }

    // @ts-ignore: decorator
    @unsafe
    export function decodeUnsafe(buf: usize, len: usize): String {
      let str = changetype<String>(__new(len &= ~1, idof<String>()));
      memory.copy(changetype<usize>(str), buf, len);
      return str;
    }
  }
}

export class TemplateStringsArray extends Array<string> {
  readonly raw: string[];
}
`,symbol:`import { Map } from "./map";

// @ts-ignore: decorator
@lazy let stringToId: Map<string, usize>;

// @ts-ignore: decorator
@lazy let idToString: Map<usize, string>;

// @ts-ignore: decorator
@lazy let nextId: usize = 12; // Symbol.unscopables + 1

@unmanaged @final abstract class _Symbol {

  // TODO: all of the following default symbols are unused currently yet add to
  // binary size if #toString becomes compiled. Ultimately we'll most likely want
  // to remove the unsupported ones and only keep what's actually supported.

  // @ts-ignore: decorator
  @lazy
  static readonly hasInstance: symbol = changetype<symbol>(1);

  // @ts-ignore: decorator
  @lazy
  static readonly isConcatSpreadable: symbol = changetype<symbol>(2);

  // @ts-ignore: decorator
  @lazy
  static readonly isRegExp: symbol = changetype<symbol>(3);

  // @ts-ignore: decorator
  @lazy
  static readonly iterator: symbol = changetype<symbol>(3);

  // @ts-ignore: decorator
  @lazy
  static readonly match: symbol = changetype<symbol>(4);

  // @ts-ignore: decorator
  @lazy
  static readonly replace: symbol = changetype<symbol>(5);

  // @ts-ignore: decorator
  @lazy
  static readonly search: symbol = changetype<symbol>(6);

  // @ts-ignore: decorator
  @lazy
  static readonly species: symbol = changetype<symbol>(7);

  // @ts-ignore: decorator
  @lazy
  static readonly split: symbol = changetype<symbol>(8);

  // @ts-ignore: decorator
  @lazy
  static readonly toPrimitive: symbol = changetype<symbol>(9);

  // @ts-ignore: decorator
  @lazy
  static readonly toStringTag: symbol = changetype<symbol>(10);

  // @ts-ignore: decorator
  @lazy
  static readonly unscopables: symbol = changetype<symbol>(11);

  static for(key: string): symbol {
    if (!stringToId) { stringToId = new Map(); idToString = new Map(); }
    else if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));
    let id = nextId++;
    if (!id) unreachable(); // out of ids
    stringToId.set(key, id);
    idToString.set(id, key);
    return changetype<symbol>(id);
  }

  static keyFor(sym: symbol): string | null {
    return idToString != null && idToString.has(changetype<usize>(sym))
      ? idToString.get(changetype<usize>(sym))
      : null;
  }

  toString(): string {
    let id = changetype<usize>(this);
    let str = "";
    switch (<u32>id) {
      case 1:  { str = "hasInstance"; break; }
      case 2:  { str = "isConcatSpreadable"; break; }
      case 3:  { str = "isRegExp"; break; }
      case 4:  { str = "match"; break; }
      case 5:  { str = "replace"; break; }
      case 6:  { str = "search"; break; }
      case 7:  { str = "species"; break; }
      case 8:  { str = "split"; break; }
      case 9:  { str = "toPrimitive"; break; }
      case 10: { str = "toStringTag"; break; }
      case 11: { str = "unscopables"; break; }
      default: {
        if (idToString != null && idToString.has(id)) str = idToString.get(id);
        break;
      }
    }
    return "Symbol(" + str + ")";
  }
}

export function Symbol(description: string | null = null): symbol {
  let id = nextId++;
  if (!id) unreachable(); // out of ids
  return changetype<symbol>(id);
}

export type Symbol = _Symbol;

// @ts-ignore: nolib
export type symbol = _Symbol;
`,table:`import { E_NOTIMPLEMENTED } from "./util/error";

export namespace table {

  export function copy(dst: u32, src: u32, n: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  export function drop(elementIndex: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }
}
`,transaction:`// @ts-ignore: decorator
@lazy
export const COMPARE_EQUAL = 1;

// @ts-ignore: decorator
@lazy
export const COMPARE_LESS = 2;

// @ts-ignore: decorator
@lazy
export const COMPARE_GREATER = 4;

// @ts-ignore: decorator
@lazy
export const sfTransactionType = ((1 << 16) + 2);

// @ts-ignore: decorator
@lazy
export const sfSignerWeight = ((1 << 16) + 3);

// @ts-ignore: decorator
@lazy
export const sfFlags = ((2 << 16) + 2);

// @ts-ignore: decorator
@lazy
export const sfSourceTag = ((2 << 16) + 3);

// @ts-ignore: decorator
@lazy
export const sfSequence = ((2 << 16) + 4);

// @ts-ignore: decorator
@lazy
export const sfFirstLedgerSequence = ((2 << 16) + 26);

// @ts-ignore: decorator
@lazy
export const sfLastLedgerSequence = ((2 << 16) + 27);

// @ts-ignore: decorator
@lazy
export const sfSignerQuorum = ((2 << 16) + 35);

// @ts-ignore: decorator
@lazy
export const sfInvoiceID = ((5 << 16) + 17);

// @ts-ignore: decorator
@lazy
export const sfAmount = ((6 << 16) + 1);

// @ts-ignore: decorator
@lazy
export const sfLowLimit = ((6 << 16) + 6);

// @ts-ignore: decorator
@lazy
export const sfHighLimit = ((6 << 16) + 7);

// @ts-ignore: decorator
@lazy
export const sfFee = ((6 << 16) + 8);

// @ts-ignore: decorator
@lazy
export const sfSigningPubKey = ((7 << 16) + 3);

// @ts-ignore: decorator
@lazy
export const sfTxnSignature = ((7 << 16) + 4);

// @ts-ignore: decorator
@lazy
export const sfMemoData = ((7 << 16) + 13);

// @ts-ignore: decorator
@lazy
export const sfMemoFormat = ((7 << 16) + 14);

// @ts-ignore: decorator
@lazy
export const sfAccount = ((8 << 16) + 1);

// @ts-ignore: decorator
@lazy
export const sfMemo = ((14 << 16) + 10);

// @ts-ignore: decorator
@lazy
export const sfEmitDetails = ((14 << 16) + 13);

// @ts-ignore: decorator
@lazy
export const sfSigners = ((15 << 16) + 3);

// @ts-ignore: decorator
@lazy
export const sfSignerEntries = ((15 << 16) + 4);

// @ts-ignore: decorator
@lazy
export const sfTemplate = ((15 << 16) + 5);

// @ts-ignore: decorator
@lazy
export const sfMemos = ((15 << 16) + 9);

export class Tx {
  @inline
  static get Account(): Account {
    let a = new ByteArray(20);
    let r = otxn_field(changetype<u32>(a), 20, sfAccount);
    if (r != 20)
      rollback("", r);

    return new Account(a);
  }

  @inline
  static get Amount(): Amount {
    let a = new ByteArray(48);
    let r = otxn_field(changetype<u32>(a), 48, sfAmount);
    if (r == 8)
      a.length = 8;
    else if (r != 48)
      rollback("", r);

    return new Amount(a);
  }

  @inline
  static get InvoiceID(): ByteArray {
    let a = new ByteArray(32);
    let r = otxn_field(changetype<u32>(a), 32, sfInvoiceID);
    if (r < 0)
      r = 0;

    a.length = <i32>r;
    return a;
  }

  @inline
  static get Memos(): ByteArray {
    let a = new ByteArray(2048);
    let r = otxn_field(changetype<u32>(a), 2048, sfMemos);
    if (r < 0)
      r = 0;

    a.length = <i32>r;
    return a;
  }
}

export class EmitSpec {
  account: Account;
  amount: Amount;
  sourceTag: u32;
  destinationTag: u32;
}
`,typedarray:`import { COMPARATOR, SORT } from "./util/sort";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from "./util/error";
import { joinIntegerArray, joinFloatArray } from "./util/string";
import { REVERSE, FILL } from "./util/bytes";
import { idof } from "./builtins";
import { ArrayBufferView } from "./arraybuffer";

export class Int8Array extends ArrayBufferView {
  [key: number]: i8;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();

  constructor(length: i32) {
    super(length, alignof<i8>());
  }

  get length(): i32 {
    return this.byteLength;
  }

  @operator("[]")
  private __get(index: i32): i8 {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i8>(this.dataStart + <usize>index);
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i8 {
    return load<i8>(this.dataStart + <usize>index);
  }

  @operator("[]=")
  private __set(index: i32, value: native<i8>): void {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i8>(this.dataStart + <usize>index, value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<i8>): void {
    store<i8>(this.dataStart + <usize>index, value);
  }

  at(index: i32): i8 {
    let len = this.byteLength;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i8>(this.dataStart + <usize>index);
  }

  includes(searchElement: i8, fromIndex: i32 = 0): bool {
    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);
  }

  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {
    FILL<u8>(this.dataStart, this.length, u8(value), start, end);
    return this;
  }

  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {
    SORT<i8>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {
    return SLICE<Int8Array, i8>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {
    return SUBARRAY<Int8Array, i8>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {
    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);
  }

  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {
    return MAP<Int8Array, i8>(this, fn);
  }

  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {
    return FILTER<Int8Array, i8>(this, fn);
  }

  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {
    return FIND_INDEX<Int8Array, i8>(this, fn);
  }

  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {
    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);
  }

  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {
    return SOME<Int8Array, i8>(this, fn);
  }

  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {
    return EVERY<Int8Array, i8>(this, fn);
  }

  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {
    FOREACH<Int8Array, i8>(this, fn);
  }

  reverse(): Int8Array {
    REVERSE<u8>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i8>(this.dataStart, this.length, separator);
  }

  toString(): string {
    return this.join();
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {
    return WRAP<Int8Array, i8>(buffer, byteOffset, length);
  }
}

export class Uint8Array extends ArrayBufferView {
  [key: number]: u8;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();

  constructor(length: i32) {
    super(length, alignof<u8>());
  }

  get length(): i32 {
    return this.byteLength;
  }

  @operator("[]")
  private __get(index: i32): u8 {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u8 {
    return load<u8>(this.dataStart + <usize>index);
  }

  @operator("[]=")
  private __set(index: i32, value: native<u8>): void {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u8>(this.dataStart + <usize>index, value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<u8>): void {
    store<u8>(this.dataStart + <usize>index, value);
  }

  at(index: i32): u8 {
    let len = this.byteLength;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  includes(searchElement: u8, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);
  }

  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {
    FILL<u8>(this.dataStart, this.length, u8(value), start, end);
    return this;
  }

  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {
    SORT<u8>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {
    return SLICE<Uint8Array, u8>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {
    return SUBARRAY<Uint8Array, u8>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {
    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);
  }

  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {
    return MAP<Uint8Array, u8>(this, fn);
  }

  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {
    return FILTER<Uint8Array, u8>(this, fn);
  }

  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {
    return FIND_INDEX<Uint8Array, u8>(this, fn);
  }

  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);
  }

  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {
    return SOME<Uint8Array, u8>(this, fn);
  }

  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {
    return EVERY<Uint8Array, u8>(this, fn);
  }

  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {
    FOREACH<Uint8Array, u8>(this, fn);
  }

  reverse(): Uint8Array {
    REVERSE<u8>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u8>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {
    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);
  }
}

export class Uint8ClampedArray extends ArrayBufferView {
  [key: number]: u8;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();

  constructor(length: i32) {
    super(length, alignof<u8>());
  }

  get length(): i32 {
    return this.byteLength;
  }

  @operator("[]")
  private __get(index: i32): u8 {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u8 {
    return load<u8>(this.dataStart + <usize>index);
  }

  @operator("[]=")
  private __set(index: i32, value: native<u8>): void {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<u8>): void {
    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));
  }

  at(index: i32): u8 {
    let len = this.byteLength;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  includes(searchElement: u8, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);
  }

  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    value = ~(value >> 31) & (((255 - value) >> 31) | value);
    FILL<u8>(this.dataStart, this.length, u8(value), start, end);
    return this;
  }

  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {
    SORT<u8>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    return SLICE<Uint8ClampedArray, u8>(this, begin, end);
  }

  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);
  }

  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {
    return MAP<Uint8ClampedArray, u8>(this, fn);
  }

  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {
    return FILTER<Uint8ClampedArray, u8>(this, fn);
  }

  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {
    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);
  }

  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {
    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);
  }

  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {
    return SOME<Uint8ClampedArray, u8>(this, fn);
  }

  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {
    return EVERY<Uint8ClampedArray, u8>(this, fn);
  }

  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {
    FOREACH<Uint8ClampedArray, u8>(this, fn);
  }

  reverse(): Uint8ClampedArray {
    REVERSE<u8>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u8>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {
    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);
  }
}

export class Int16Array extends ArrayBufferView {
  [key: number]: i16;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();

  constructor(length: i32) {
    super(length, alignof<i16>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<i16>();
  }

  @operator("[]")
  private __get(index: i32): i16 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i16 {
    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));
  }

  @operator("[]=")
  private __set(index: i32, value: native<i16>): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<i16>): void {
    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);
  }

  at(index: i32): i16 {
    let len = this.byteLength >>> alignof<i16>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));
  }

  includes(searchElement: i16, fromIndex: i32 = 0): bool {
    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);
  }

  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {
    FILL<u16>(this.dataStart, this.length, u16(value), start, end);
    return this;
  }

  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {
    SORT<i16>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {
    return SLICE<Int16Array, i16>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {
    return SUBARRAY<Int16Array, i16>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {
    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);
  }

  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {
    return MAP<Int16Array, i16>(this, fn);
  }

  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {
    return FILTER<Int16Array, i16>(this, fn);
  }

  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {
    return FIND_INDEX<Int16Array, i16>(this, fn);
  }

  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {
    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);
  }

  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {
    return SOME<Int16Array, i16>(this, fn);
  }

  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {
    return EVERY<Int16Array, i16>(this, fn);
  }

  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {
    FOREACH<Int16Array, i16>(this, fn);
  }

  reverse(): Int16Array {
    REVERSE<u16>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i16>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {
    return WRAP<Int16Array, i16>(buffer, byteOffset, length);
  }
}

export class Uint16Array extends ArrayBufferView {
  [key: number]: u16;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();

  constructor(length: i32) {
    super(length, alignof<u16>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<u16>();
  }

  @operator("[]")
  private __get(index: i32): u16 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u16 {
    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));
  }

  @operator("[]=")
  private __set(index: i32, value: native<u16>): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<u16>): void {
    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);
  }

  at(index: i32): u16 {
    let len = this.byteLength >>> alignof<u16>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));
  }

  includes(searchElement: u16, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);
  }

  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {
    FILL<u16>(this.dataStart, this.length, u16(value), start, end);
    return this;
  }

  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {
    SORT<u16>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {
    return SLICE<Uint16Array, u16>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {
    return SUBARRAY<Uint16Array, u16>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {
    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);
  }

  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {
    return MAP<Uint16Array, u16>(this, fn);
  }

  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {
    return FILTER<Uint16Array, u16>(this, fn);
  }

  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {
    return FIND_INDEX<Uint16Array, u16>(this, fn);
  }

  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);
  }

  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {
    return SOME<Uint16Array, u16>(this, fn);
  }

  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {
    return EVERY<Uint16Array, u16>(this, fn);
  }

  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {
    FOREACH<Uint16Array, u16>(this, fn);
  }

  reverse(): Uint16Array {
    REVERSE<u16>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u16>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {
    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);
  }
}

export class Int32Array extends ArrayBufferView {
  [key: number]: i32;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();

  constructor(length: i32) {
    super(length, alignof<i32>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<i32>();
  }

  @operator("[]")
  private __get(index: i32): i32 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i32 {
    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));
  }

  @operator("[]=")
  private __set(index: i32, value: i32): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: i32): void {
    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);
  }

  at(index: i32): i32 {
    let len = this.byteLength >>> alignof<i32>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));
  }

  includes(searchElement: i32, fromIndex: i32 = 0): bool {
    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);
  }

  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {
    FILL<u32>(this.dataStart, this.length, u32(value), start, end);
    return this;
  }

  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {
    SORT<i32>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {
    return SLICE<Int32Array, i32>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {
    return SUBARRAY<Int32Array, i32>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {
    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);
  }

  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {
    return MAP<Int32Array, i32>(this, fn);
  }

  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {
    return FILTER<Int32Array, i32>(this, fn);
  }

  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {
    return FIND_INDEX<Int32Array, i32>(this, fn);
  }

  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {
    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);
  }

  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {
    return SOME<Int32Array, i32>(this, fn);
  }

  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {
    return EVERY<Int32Array, i32>(this, fn);
  }

  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {
    FOREACH<Int32Array, i32>(this, fn);
  }

  reverse(): Int32Array {
    REVERSE<u32>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i32>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {
    return WRAP<Int32Array, i32>(buffer, byteOffset, length);
  }
}

export class Uint32Array extends ArrayBufferView {
  [key: number]: u32;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();

  constructor(length: i32) {
    super(length, alignof<u32>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<u32>();
  }

  @operator("[]")
  private __get(index: i32): u32 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u32 {
    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));
  }

  @operator("[]=")
  private __set(index: i32, value: u32): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: u32): void {
    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);
  }

  at(index: i32): u32 {
    let len = this.byteLength >>> alignof<u32>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));
  }

  includes(searchElement: u32, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);
  }

  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {
    FILL<u32>(this.dataStart, this.length, value, start, end);
    return this;
  }

  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {
    SORT<u32>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {
    return SLICE<Uint32Array, u32>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {
    return SUBARRAY<Uint32Array, u32>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {
    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);
  }

  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {
    return MAP<Uint32Array, u32>(this, fn);
  }

  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {
    return FILTER<Uint32Array, u32>(this, fn);
  }

  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {
    return FIND_INDEX<Uint32Array, u32>(this, fn);
  }

  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);
  }

  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {
    return SOME<Uint32Array, u32>(this, fn);
  }

  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {
    return EVERY<Uint32Array, u32>(this, fn);
  }

  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {
    FOREACH<Uint32Array, u32>(this, fn);
  }

  reverse(): Uint32Array {
    REVERSE<u32>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u32>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {
    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);
  }
}

export class Int64Array extends ArrayBufferView {
  [key: number]: i64;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();

  constructor(length: i32) {
    super(length, alignof<i64>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<i64>();
  }

  @operator("[]")
  private __get(index: i32): i64 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i64 {
    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));
  }

  @operator("[]=")
  private __set(index: i32, value: i64): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: i64): void {
    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);
  }

  at(index: i32): i64 {
    let len = this.byteLength >>> alignof<i64>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));
  }

  includes(searchElement: i64, fromIndex: i32 = 0): bool {
    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);
  }

  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {
    FILL<u64>(this.dataStart, this.length, u64(value), start, end);
    return this;
  }

  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {
    SORT<i64>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {
    return SLICE<Int64Array, i64>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {
    return SUBARRAY<Int64Array, i64>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {
    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);
  }

  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {
    return MAP<Int64Array, i64>(this, fn);
  }

  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {
    return FILTER<Int64Array, i64>(this, fn);
  }

  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {
    return FIND_INDEX<Int64Array, i64>(this, fn);
  }

  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {
    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);
  }

  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {
    return SOME<Int64Array, i64>(this, fn);
  }

  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {
    return EVERY<Int64Array, i64>(this, fn);
  }

  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {
    FOREACH<Int64Array, i64>(this, fn);
  }

  reverse(): Int64Array {
    REVERSE<u64>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i64>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {
    return WRAP<Int64Array, i64>(buffer, byteOffset, length);
  }
}

export class Uint64Array extends ArrayBufferView {
  [key: number]: u64;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();

  constructor(length: i32) {
    super(length, alignof<u64>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<u64>();
  }

  @operator("[]")
  private __get(index: i32): u64 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u64 {
    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));
  }

  @operator("[]=")
  private __set(index: i32, value: u64): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: u64): void {
    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);
  }

  at(index: i32): u64 {
    let len = this.byteLength >>> alignof<u64>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));
  }

  includes(searchElement: u64, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);
  }

  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {
    FILL<u64>(this.dataStart, this.length, value, start, end);
    return this;
  }

  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {
    SORT<u64>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {
    return SLICE<Uint64Array, u64>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {
    return SUBARRAY<Uint64Array, u64>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {
    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);
  }

  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {
    return MAP<Uint64Array, u64>(this, fn);
  }

  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {
    return FILTER<Uint64Array, u64>(this, fn);
  }

  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {
    return FIND_INDEX<Uint64Array, u64>(this, fn);
  }

  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);
  }

  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {
    return SOME<Uint64Array, u64>(this, fn);
  }

  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {
    return EVERY<Uint64Array, u64>(this, fn);
  }

  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {
    FOREACH<Uint64Array, u64>(this, fn);
  }

  reverse(): Uint64Array {
    REVERSE<u64>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u64>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {
    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);
  }
}

export class Float32Array extends ArrayBufferView {
  [key: number]: f32;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();

  constructor(length: i32) {
    super(length, alignof<f32>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<f32>();
  }

  @operator("[]")
  private __get(index: i32): f32 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): f32 {
    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));
  }

  @operator("[]=")
  private __set(index: i32, value: f32): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: f32): void {
    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);
  }

  at(index: i32): f32 {
    let len = this.byteLength >>> alignof<f32>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));
  }

  includes(searchElement: f32, fromIndex: i32 = 0): bool {
    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);
  }

  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {
    FILL<f32>(this.dataStart, this.length, value, start, end);
    return this;
  }

  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {
    SORT<f32>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {
    return SLICE<Float32Array, f32>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {
    return SUBARRAY<Float32Array, f32>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {
    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);
  }

  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {
    return MAP<Float32Array, f32>(this, fn);
  }

  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {
    return FILTER<Float32Array, f32>(this, fn);
  }

  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {
    return FIND_INDEX<Float32Array, f32>(this, fn);
  }

  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {
    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);
  }

  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {
    return SOME<Float32Array, f32>(this, fn);
  }

  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {
    return EVERY<Float32Array, f32>(this, fn);
  }

  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {
    FOREACH<Float32Array, f32>(this, fn);
  }

  reverse(): Float32Array {
    REVERSE<f32>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinFloatArray<f32>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {
    return WRAP<Float32Array, f32>(buffer, byteOffset, length);
  }
}

export class Float64Array extends ArrayBufferView {
  [key: number]: f64;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();

  constructor(length: i32) {
    super(length, alignof<f64>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<f64>();
  }

  @operator("[]")
  private __get(index: i32): f64 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): f64 {
    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));
  }

  @operator("[]=")
  private __set(index: i32, value: f64): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: f64): void {
    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);
  }

  at(index: i32): f64 {
    let len = this.byteLength >>> alignof<f64>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));
  }

  includes(searchElement: f64, fromIndex: i32 = 0): bool {
    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);
  }

  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {
    FILL<f64>(this.dataStart, this.length, value, start, end);
    return this;
  }

  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {
    SORT<f64>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {
    return SLICE<Float64Array, f64>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {
    return SUBARRAY<Float64Array, f64>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {
    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);
  }

  reduce<T extends number>(
    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);
  }

  reduceRight<T extends number>(
    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);
  }

  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {
    return MAP<Float64Array, f64>(this, fn);
  }

  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {
    return FILTER<Float64Array, f64>(this, fn);
  }

  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {
    return FIND_INDEX<Float64Array, f64>(this, fn);
  }

  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {
    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);
  }

  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {
    return SOME<Float64Array, f64>(this, fn);
  }

  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {
    return EVERY<Float64Array, f64>(this, fn);
  }

  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {
    FOREACH<Float64Array, f64>(this, fn);
  }

  reverse(): Float64Array {
    REVERSE<f64>(this.dataStart, this.length);
    return this;
  }

  join(separator: string = ","): string {
    return joinFloatArray<f64>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {
    SET(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {
    return WRAP<Float64Array, f64>(buffer, byteOffset, length);
  }
}

// @ts-ignore: decorator
@inline
function SLICE<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  start: i32,
  end: i32
): TArray {
  let len = array.length;
  start  = start < 0 ? max(start + len, 0) : min(start, len);
  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);
  len = max(end - start, 0);
  let slice = instantiate<TArray>(len);
  memory.copy(
    slice.dataStart,
    array.dataStart + (<usize>start << alignof<T>()),
    <usize>len << alignof<T>()
  );
  return slice;
}

// @ts-ignore: decorator
@inline
function SUBARRAY<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  begin: i32,
  end: i32
): TArray {
  let len = array.length;
  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);
  end   = end   < 0 ? max(len + end,   0) : min(end,   len);
  end   = max(end, begin);

  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  let buf = changetype<usize>(array.buffer);
  store<usize>(changetype<usize>(out), buf, offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), buf, false);
  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>("dataStart"));
  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>("byteLength"));
  return out;
}

// @ts-ignore: decorator
@inline
function COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  target: i32,
  start: i32,
  end: i32
): TArray {
  let len = array.length;
  let ptr = array.dataStart;

  end   = min<i32>(end, len);
  let to    = target < 0 ? max(len + target, 0) : min(target, len);
  let from  = start < 0 ? max(len + start, 0) : min(start, len);
  let last  = end < 0 ? max(len + end, 0) : min(end, len);
  let count = min(last - from, len - to);

  memory.copy(
    ptr + (<usize>to << alignof<T>()),
    ptr + (<usize>from << alignof<T>()),
    <usize>count << alignof<T>()
  );
  return array;
}

// @ts-ignore: decorator
@inline
function REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(
  array: TArray,
  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,
  initialValue: TRet
): TRet {
  let ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);
  }
  return initialValue;
}

// @ts-ignore: decorator
@inline
function REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(
  array: TArray,
  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,
  initialValue: TRet
): TRet {
  let ptr = array.dataStart;
  for (let i = array.length - 1; i >= 0; i--) {
    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);
  }
  return initialValue;
}

// @ts-ignore: decorator
@inline
function MAP<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  fn: (value: T, index: i32, self: TArray) => T,
): TArray {
  let len = array.length;
  let ptr = array.dataStart;

  let byteLength = len << alignof<T>();
  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));
  for (let i = 0; i < len; i++) {
    store<T>(
      changetype<usize>(buf) + (<usize>i << alignof<T>()),
      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)
    );
  }
  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), changetype<usize>(buf), false);
  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>("dataStart"));
  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));
  return out;
}

// @ts-ignore: decorator
@inline
function FILTER<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  fn: (value: T, index: i32, self: TArray) => bool,
): TArray {
  let len = array.length;
  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));
  let dataStart  = array.dataStart;
  let j: usize = 0;
  for (let i = 0; i < len; i++) {
    let value = load<T>(dataStart + (<usize>i << alignof<T>()));
    if (fn(value, i, array)) {
      store<T>(
        changetype<usize>(buf) + (j++ << alignof<T>()),
        value
      );
    }
  }
  // shrink output buffer
  let byteLength = j << alignof<T>();
  let data = __renew(changetype<usize>(buf), byteLength);
  store<usize>(changetype<usize>(out), data, offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), data, false);
  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));
  store<usize>(changetype<usize>(out), data, offsetof<TArray>("dataStart"));
  return out;
}

// @ts-ignore: decorator
@inline
function FIND_INDEX<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): i32 {
  let ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): i32 {
  let ptr = array.dataStart;
  for (let i = array.length - 1; i >= 0; --i) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function INCLUDES<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  searchElement: T,
  fromIndex: i32,
): bool {
  if (isFloat<T>()) {
    let index: isize = fromIndex;
    let len: isize = array.length;
    if (len == 0 || index >= len) return false;
    if (index < 0) index = max(len + index, 0);
    let dataStart = array.dataStart;
    while (index < len) {
      let elem = load<T>(dataStart + (index << alignof<T>()));
      // @ts-ignore
      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;
      ++index;
    }
    return false;
  } else {
    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;
  }
}

// @ts-ignore: decorator
@inline
function INDEX_OF<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  searchElement: T,
  fromIndex: i32,
): i32 {
  let index: isize = fromIndex;
  let len: isize = array.length;
  if (len == 0 || index >= len) return -1;
  if (index < 0) index = max(len + index, 0);
  let dataStart = array.dataStart;
  while (index < len) {
    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;
    ++index;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  searchElement: T,
  fromIndex: i32,
): i32 {
  let index: isize = fromIndex;
  let len: isize = array.length;
  if (len == 0) return -1;
  if (index < 0) index = len + index; // no need to clamp
  else if (index >= len) index = len - 1;
  let dataStart = array.dataStart;
  while (index >= 0) {
    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;
    --index;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function SOME<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): bool {
  let ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;
  }
  return false;
}

// @ts-ignore: decorator
@inline
function EVERY<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): bool {
  let ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;
    return false;
  }
  return true;
}

// @ts-ignore: decorator
@inline
function FOREACH<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => void,
): void {
  let ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);
  }
}

// @ts-ignore: decorator
@inline
function WRAP<TArray extends ArrayBufferView, T>(
  buffer: ArrayBuffer,
  byteOffset: i32 = 0,
  len: i32 = -1
): TArray {
  let byteLength: i32;
  let bufferByteLength = buffer.byteLength;
  const mask: u32 = sizeof<T>() - 1;
  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {
    throw new RangeError(E_INDEXOUTOFRANGE);
  }
  if (len < 0) {
    if (len == -1) {
      if (bufferByteLength & mask) {
        throw new RangeError(E_INVALIDLENGTH);
      }
      byteLength = bufferByteLength - byteOffset;
    } else {
      throw new RangeError(E_INVALIDLENGTH);
    }
  } else {
    byteLength = len << alignof<T>();
    if (byteOffset + byteLength > bufferByteLength) {
      throw new RangeError(E_INVALIDLENGTH);
    }
  }
  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), changetype<usize>(buffer), false);
  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));
  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>("dataStart"));
  return out;
}

// @ts-ignore: decorator
@inline
function SET<
  TArray extends ArrayLike<number>,
  UArray extends ArrayLike<number>
>(
  target: TArray,
  source: UArray,
  offset: i32 = 0
): void {
  // need to assert at compile time that U is not a reference or a function
  if (isReference<valueof<UArray>>()) {
    ERROR(E_NOTIMPLEMENTED);
  }
  let sourceLen = source.length;
  if (offset < 0 || sourceLen + offset > target.length) {
    // offset is out of bounds
    throw new RangeError(E_INDEXOUTOFRANGE);
  }
  // @ts-ignore: dataStart
  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));
  // @ts-ignore: dataStart
  let sourceStart = source.dataStart;
  // if the types align and match, use memory.copy() instead of manual loop
  if (
    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&
    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&
    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)
  ) {
    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));
  } else {
    for (let i = 0; i < sourceLen; i++) {
      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));
      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));
      // if TArray is Uint8ClampedArray, then values must be clamped
      if (target instanceof Uint8ClampedArray) {
        if (isFloat<valueof<UArray>>()) {
          store<valueof<TArray>>(ptr,
            isFinite<valueof<UArray>>(value)
              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))
              : 0
          );
        } else {
          if (!isSigned<valueof<UArray>>()) {
            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));
          } else if (sizeof<valueof<TArray>>() <= 4) {
            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));
          } else {
            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));
          }
        }
      } else {
        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {
          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);
        } else {
          store<valueof<TArray>>(ptr, <valueof<TArray>>value);
        }
      }
    }
  }
}
`,uri:`import { encode, decode, URI_UNSAFE, URL_UNSAFE } from "./util/uri";

export function encodeURI(str: string): string {
  return changetype<string>(encode(changetype<usize>(str), str.length, URI_UNSAFE));
}

export function decodeURI(str: string): string {
  return changetype<string>(decode(changetype<usize>(str), str.length, false));
}

export function encodeURIComponent(str: string): string {
  return changetype<string>(encode(changetype<usize>(str), str.length, URL_UNSAFE));
}

export function decodeURIComponent(str: string): string {
  return changetype<string>(decode(changetype<usize>(str), str.length, true));
}
`,"util/bytes":`export function REVERSE<T>(ptr: usize, len: usize): void {
  if (len > 1) {
    let
      i: usize = 0,
      tail: usize,
      hlen: usize = len >> 1;

    if (ASC_SHRINK_LEVEL < 1) {
      if (sizeof<T>() == 1) {
        // TODO: Decide later: Does we need this fast path cases?
        //
        // if (len == 4) {
        //   store<u32>(ptr, bswap(load<u32>(ptr)));
        //   return;
        // }
        // if (len == 8) {
        //   store<u64>(ptr, bswap(load<u64>(ptr)));
        //   return;
        // }
        tail = len - 8;
        while (i + 7 < hlen) {
          let front = ptr + i;
          let back  = ptr + tail - i;
          let temp  = bswap(load<u64>(front));
          store<u64>(front, bswap(load<u64>(back)));
          store<u64>(back, temp);
          i += 8;
        }
      }

      if (sizeof<T>() == 2) {
        tail = len - 2;
        while (i + 1 < hlen) {
          let front = ptr + (i << 1);
          let back  = ptr + (tail - i << 1);
          let temp  = rotr(load<u32>(back), 16);
          store<u32>(back, rotr(load<u32>(front), 16));
          store<u32>(front, temp);
          i += 2;
        }
      }
    }

    tail = len - 1;
    while (i < hlen) {
      let front = ptr + (i << alignof<T>());
      let back  = ptr + (tail - i << alignof<T>());
      let temp  = load<T>(front);
      store<T>(front, load<T>(back));
      store<T>(back, temp);
      i++;
    }
  }
}

export function FILL<T>(
  ptr: usize,
  len: usize,
  value: T,
  start: isize,
  end: isize
): void {
  start = start < 0 ? max(len + start, 0) : min(start, len);
  end   = end   < 0 ? max(len + end,   0) : min(end,   len);

  if (sizeof<T>() == 1) {
    if (start < end) {
      memory.fill(
        ptr + <usize>start,
        u8(value),
        <usize>(end - start)
      );
    }
  } else {
    if (ASC_SHRINK_LEVEL <= 1) {
      if (isInteger<T>()) {
        // @ts-ignore
        if (value == <T>0 | value == <T>-1) {
          if (start < end) {
            memory.fill(
              ptr + (<usize>start << alignof<T>()),
              u8(value),
              <usize>(end - start) << alignof<T>()
            );
          }
          return;
        }
      } else if (isFloat<T>()) {
        // for floating non-negative zeros we can use fast memory.fill
        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||
            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {
          if (start < end) {
            memory.fill(
              ptr + (<usize>start << alignof<T>()),
              0,
              <usize>(end - start) << alignof<T>()
            );
          }
          return;
        }
      }
    }
    for (; start < end; ++start) {
      store<T>(ptr + (<usize>start << alignof<T>()), value);
    }
  }
}
`,"util/casemap":`// Total tables size: ~5 kb (usually compressed to ~4 kb)
// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h

// @ts-ignore: decorator
@lazy @inline const TAB = memory.data<u8>([
  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,
  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,
  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,
  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,
  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,
  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,
  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,
  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,
  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,
  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,
  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,
  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,
  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,
  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,
  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,
  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,
  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,
  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,
  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,
  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,
  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,
  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,
  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,
  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,
  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,
  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,
  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,
  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,
  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,
  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,
  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,
  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,
  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,
  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,
  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,
  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,
  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,
  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,
  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0
]);

// @ts-ignore: decorator
@lazy @inline const RULES = memory.data<i32>([
  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,
  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,
  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,
  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,
  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,
  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,
  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,
  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,
  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,
  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,
  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,
  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,
  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,
  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,
  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,
  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,
  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,
  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,
  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,
  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,
  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,
  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,
  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,
  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,
  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,
  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,
  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,
  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,
  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,
  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,
  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,
  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,
  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,
  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,
  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,
  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,
  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,
  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,
  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,
  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200
]);

// @ts-ignore: decorator
@lazy @inline const RULE_BASES = memory.data<u8>([
  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,
  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,
  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
]);

// @ts-ignore: decorator
@lazy @inline const EXCEPTIONS = memory.data<u8>([
  48, 12,  49, 13,  120, 14,  127, 15,
  128, 16,  129, 17,  134, 18,  137, 19,
  138, 19,  142, 20,  143, 21,  144, 22,
  147, 19,  148, 23,  149, 24,  150, 25,
  151, 26,  154, 27,  156, 25,  157, 28,
  158, 29,  159, 30,  166, 31,  169, 31,
  174, 31,  177, 32,  178, 32,  183, 33,
  191, 34,  197, 35,  200, 35,  203, 35,
  221, 36,  242, 35,  246, 37,  247, 38,
  32, 45,  58, 46,  61, 47,  62, 48,
  63, 49,  64, 49,  67, 50,  68, 51,
  69, 52,  80, 53,  81, 54,  82, 55,
  83, 56,  84, 57,  89, 58,  91, 59,
  92, 60,  97, 61,  99, 62,  101, 63,
  102, 64,  104, 65,  105, 66,  106, 64,
  107, 67,  108, 68,  111, 66,  113, 69,
  114, 70,  117, 71,  125, 72,  130, 73,
  135, 74,  137, 75,  138, 76,  139, 76,
  140, 77,  146, 78,  157, 79,  158, 80,
  69, 87,  123, 29,  124, 29,  125, 29,
  127, 88,  134, 89,  136, 90,  137, 90,
  138, 90,  140, 91,  142, 92,  143, 92,
  172, 93,  173, 94,  174, 94,  175, 94,
  194, 95,  204, 96,  205, 97,  206, 97,
  207, 98,  208, 99,  209, 100,  213, 101,
  214, 102,  215, 103,  240, 104,  241, 105,
  242, 106,  243, 107,  244, 108,  245, 109,
  249, 110,  253, 45,  254, 45,  255, 45,
  80, 105,  81, 105,  82, 105,  83, 105,
  84, 105,  85, 105,  86, 105,  87, 105,
  88, 105,  89, 105,  90, 105,  91, 105,
  92, 105,  93, 105,  94, 105,  95, 105,
  130, 0,  131, 0,  132, 0,  133, 0,
  134, 0,  135, 0,  136, 0,  137, 0,
  192, 117,  207, 118,  128, 137,  129, 138,
  130, 139,  133, 140,  134, 141,  112, 157,
  113, 157,  118, 158,  119, 158,  120, 159,
  121, 159,  122, 160,  123, 160,  124, 161,
  125, 161,  179, 162,  186, 163,  187, 163,
  188, 164,  190, 165,  195, 162,  204, 164,
  218, 166,  219, 166,  229, 106,  234, 167,
  235, 167,  236, 110,  243, 162,  248, 168,
  249, 168,  250, 169,  251, 169,  252, 164,
  38, 176,  42, 177,  43, 178,  78,  179,
  132,  8,  98, 186,  99, 187,  100, 188,
  101, 189,  102, 190,  109, 191,  110, 192,
  111, 193,  112, 194,  126, 195,  127, 195,
  125, 207,  141, 208,  148, 209,  171, 210,
  172, 211,  173, 212,  176, 213,  177, 214,
  178, 215,  196, 216,  197, 217,  198, 218
]);

/* Special Case Mappings
 * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt
 */

/*
@lazy @inline
const SPECIALS_LOWER: StaticArray<u16> = [
  0x0130,  0x0069, 0x0307, 0x0000,
];
*/

// @ts-ignore: decorator
@lazy @inlne
export const SPECIALS_UPPER: StaticArray<u16> = [
  // String#toUpperCase needs .length
  0x00DF,  0x0053, 0x0053, 0x0000,
  0x0149,  0x02BC, 0x004E, 0x0000,
  0x01F0,  0x004A, 0x030C, 0x0000,
  0x0390,  0x0399, 0x0308, 0x0301,
  0x03B0,  0x03A5, 0x0308, 0x0301,
  0x0587,  0x0535, 0x0552, 0x0000,
  0x1E96,  0x0048, 0x0331, 0x0000,
  0x1E97,  0x0054, 0x0308, 0x0000,
  0x1E98,  0x0057, 0x030A, 0x0000,
  0x1E99,  0x0059, 0x030A, 0x0000,
  0x1E9A,  0x0041, 0x02BE, 0x0000,
  0x1F50,  0x03A5, 0x0313, 0x0000,
  0x1F52,  0x03A5, 0x0313, 0x0300,
  0x1F54,  0x03A5, 0x0313, 0x0301,
  0x1F56,  0x03A5, 0x0313, 0x0342,
  0x1F80,  0x1F08, 0x0399, 0x0000,
  0x1F81,  0x1F09, 0x0399, 0x0000,
  0x1F82,  0x1F0A, 0x0399, 0x0000,
  0x1F83,  0x1F0B, 0x0399, 0x0000,
  0x1F84,  0x1F0C, 0x0399, 0x0000,
  0x1F85,  0x1F0D, 0x0399, 0x0000,
  0x1F86,  0x1F0E, 0x0399, 0x0000,
  0x1F87,  0x1F0F, 0x0399, 0x0000,
  0x1F88,  0x1F08, 0x0399, 0x0000,
  0x1F89,  0x1F09, 0x0399, 0x0000,
  0x1F8A,  0x1F0A, 0x0399, 0x0000,
  0x1F8B,  0x1F0B, 0x0399, 0x0000,
  0x1F8C,  0x1F0C, 0x0399, 0x0000,
  0x1F8D,  0x1F0D, 0x0399, 0x0000,
  0x1F8E,  0x1F0E, 0x0399, 0x0000,
  0x1F8F,  0x1F0F, 0x0399, 0x0000,
  0x1F90,  0x1F28, 0x0399, 0x0000,
  0x1F91,  0x1F29, 0x0399, 0x0000,
  0x1F92,  0x1F2A, 0x0399, 0x0000,
  0x1F93,  0x1F2B, 0x0399, 0x0000,
  0x1F94,  0x1F2C, 0x0399, 0x0000,
  0x1F95,  0x1F2D, 0x0399, 0x0000,
  0x1F96,  0x1F2E, 0x0399, 0x0000,
  0x1F97,  0x1F2F, 0x0399, 0x0000,
  0x1F98,  0x1F28, 0x0399, 0x0000,
  0x1F99,  0x1F29, 0x0399, 0x0000,
  0x1F9A,  0x1F2A, 0x0399, 0x0000,
  0x1F9B,  0x1F2B, 0x0399, 0x0000,
  0x1F9C,  0x1F2C, 0x0399, 0x0000,
  0x1F9D,  0x1F2D, 0x0399, 0x0000,
  0x1F9E,  0x1F2E, 0x0399, 0x0000,
  0x1F9F,  0x1F2F, 0x0399, 0x0000,
  0x1FA0,  0x1F68, 0x0399, 0x0000,
  0x1FA1,  0x1F69, 0x0399, 0x0000,
  0x1FA2,  0x1F6A, 0x0399, 0x0000,
  0x1FA3,  0x1F6B, 0x0399, 0x0000,
  0x1FA4,  0x1F6C, 0x0399, 0x0000,
  0x1FA5,  0x1F6D, 0x0399, 0x0000,
  0x1FA6,  0x1F6E, 0x0399, 0x0000,
  0x1FA7,  0x1F6F, 0x0399, 0x0000,
  0x1FA8,  0x1F68, 0x0399, 0x0000,
  0x1FA9,  0x1F69, 0x0399, 0x0000,
  0x1FAA,  0x1F6A, 0x0399, 0x0000,
  0x1FAB,  0x1F6B, 0x0399, 0x0000,
  0x1FAC,  0x1F6C, 0x0399, 0x0000,
  0x1FAD,  0x1F6D, 0x0399, 0x0000,
  0x1FAE,  0x1F6E, 0x0399, 0x0000,
  0x1FAF,  0x1F6F, 0x0399, 0x0000,
  0x1FB2,  0x1FBA, 0x0399, 0x0000,
  0x1FB3,  0x0391, 0x0399, 0x0000,
  0x1FB4,  0x0386, 0x0399, 0x0000,
  0x1FB6,  0x0391, 0x0342, 0x0000,
  0x1FB7,  0x0391, 0x0342, 0x0399,
  0x1FBC,  0x0391, 0x0399, 0x0000,
  0x1FC2,  0x1FCA, 0x0399, 0x0000,
  0x1FC3,  0x0397, 0x0399, 0x0000,
  0x1FC4,  0x0389, 0x0399, 0x0000,
  0x1FC6,  0x0397, 0x0342, 0x0000,
  0x1FC7,  0x0397, 0x0342, 0x0399,
  0x1FCC,  0x0397, 0x0399, 0x0000,
  0x1FD2,  0x0399, 0x0308, 0x0300,
  0x1FD3,  0x0399, 0x0308, 0x0301,
  0x1FD6,  0x0399, 0x0342, 0x0000,
  0x1FD7,  0x0399, 0x0308, 0x0342,
  0x1FE2,  0x03A5, 0x0308, 0x0300,
  0x1FE3,  0x03A5, 0x0308, 0x0301,
  0x1FE4,  0x03A1, 0x0313, 0x0000,
  0x1FE6,  0x03A5, 0x0342, 0x0000,
  0x1FE7,  0x03A5, 0x0308, 0x0342,
  0x1FF2,  0x1FFA, 0x0399, 0x0000,
  0x1FF3,  0x03A9, 0x0399, 0x0000,
  0x1FF4,  0x038F, 0x0399, 0x0000,
  0x1FF6,  0x03A9, 0x0342, 0x0000,
  0x1FF7,  0x03A9, 0x0342, 0x0399,
  0x1FFC,  0x03A9, 0x0399, 0x0000,
  0xFB00,  0x0046, 0x0046, 0x0000,
  0xFB01,  0x0046, 0x0049, 0x0000,
  0xFB02,  0x0046, 0x004C, 0x0000,
  0xFB03,  0x0046, 0x0046, 0x0049,
  0xFB04,  0x0046, 0x0046, 0x004C,
  0xFB05,  0x0053, 0x0054, 0x0000,
  0xFB06,  0x0053, 0x0054, 0x0000,
  0xFB13,  0x0544, 0x0546, 0x0000,
  0xFB14,  0x0544, 0x0535, 0x0000,
  0xFB15,  0x0544, 0x053B, 0x0000,
  0xFB16,  0x054E, 0x0546, 0x0000,
  0xFB17,  0x0544, 0x053D, 0x0000
];

// @ts-ignore: decorator
@lazy @inline const MT = memory.data<i32>([
  2048, 342, 57
]);

// Special binary search routine for Special Casing Tables
// @ts-ignore: decorator
@inline
export function bsearch(key: u32, ptr: usize, max: i32): i32 {
  let min = 0;
  while (min <= max) {
    let mid = (min + max) >>> 3 << 2;
    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;
    if (cmp == 0) return mid; // found
    else if (cmp >>> 31) min = mid + 4; // < 0
    else max = mid - 4; // > 0
  }
  return -1; // not found
}

// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c
export function casemap(c: u32, dir: i32): i32 {
  // if (c >= 0x20000) return c;
  let c0 = c as i32;
  let b = c >> 8;
  c &= 255;

  let x = c / 3;
  let y = c % 3;

  /* lookup entry in two-level base-6 table */
  // v = tab[(tab[b] as i32) * 86 + x] as u32;
  let v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);
  // v = (v * mt[y] >> 11) % 6;
  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;
  /* use the bit vector out of the tables as an index into
   * a block-specific set of rules and decode the rule into
   * a type and a case-mapping delta. */
  // r = rules[(ruleBases[b] as u32) + v];
  let r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));
  let rt: u32 = r & 255;
  let rd: i32 = r >> 8;
  /* rules 0/1 are simple lower/upper case with a delta.
   * apply according to desired mapping direction. */
  if (rt < 2) return c0 + (rd & -(rt ^ dir));
  /* binary search. endpoints of the binary search for
   * this block are stored in the rule delta field. */
  let xn: u32 = rd & 0xff;
  let xb: u32 = rd >>> 8;
  while (xn) {
    let h = xn >> 1;
    // let t = exceptions[(xb + h) * 2 + 0] as u32;
    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);
    if (t == c) {
      // r = rules[exceptions[(xb + h) * 2 + 1]];
      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));
      rt = r & 255;
      rd = r >> 8;
      if (rt < 2) return c0 + (rd & -(rt ^ dir));
      /* Hard-coded for the four exceptional titlecase */
      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);
    } else if (t > c) {
      xn = h;
    } else {
      xb += h;
      xn -= h;
    }
  }
  return c0;
}
`,"util/error":`// Common error messages for use across the standard library. Keeping error messages compact
// and reusing them where possible ensures minimal static data in binaries.

// @ts-ignore: decorator
@lazy @inline
export const E_INDEXOUTOFRANGE: string = "Index out of range";

// @ts-ignore: decorator
@lazy @inline
export const E_VALUEOUTOFRANGE: string = "Value out of range";

// @ts-ignore: decorator
@lazy @inline
export const E_INVALIDLENGTH: string = "Invalid length";

// @ts-ignore: decorator
@lazy @inline
export const E_EMPTYARRAY: string = "Array is empty";

// @ts-ignore: decorator
@lazy @inline
export const E_HOLEYARRAY: string = "Element type must be nullable if array is holey";

// @ts-ignore: decorator
@lazy @inline
export const E_NOTIMPLEMENTED: string = "Not implemented";

// @ts-ignore: decorator
@lazy @inline
export const E_KEYNOTFOUND: string = "Key does not exist";

// @ts-ignore: decorator
@lazy @inline
export const E_ALLOCATION_TOO_LARGE: string = "Allocation too large";

// @ts-ignore: decorator
@lazy @inline
export const E_ALREADY_PINNED: string = "Object already pinned";

// @ts-ignore: decorator
@lazy @inline
export const E_NOT_PINNED: string = "Object is not pinned";

// @ts-ignore: decorator
@lazy @inline
export const E_URI_MALFORMED: string = "URI malformed";

// @ts-ignore: decorator
@lazy @inline
export const E_INVALIDDATE: string = "Invalid Date";

// @ts-ignore: decorator
@lazy @inline
export const E_UNPAIRED_SURROGATE: string = "Unpaired surrogate";
`,"util/hash":`export function HASH<T>(key: T): u32 {
  if (isString<T>()) {
    return hashStr(changetype<string>(key));
  } else if (isReference<T>()) {
    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));
    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));
  } else if (isFloat<T>()) {
    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));
    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));
  } else {
    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());
    if (sizeof<T>() == 8) return hash64(u64(key));
  }
  return unreachable();
}

// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash

// primes
// @ts-ignore: decorator
@inline const XXH32_P1: u32 = 2654435761;
// @ts-ignore: decorator
@inline const XXH32_P2: u32 = 2246822519;
// @ts-ignore: decorator
@inline const XXH32_P3: u32 = 3266489917;
// @ts-ignore: decorator
@inline const XXH32_P4: u32 = 668265263;
// @ts-ignore: decorator
@inline const XXH32_P5: u32 = 374761393;
// @ts-ignore: decorator
@inline const XXH32_SEED: u32 = 0;

// @ts-ignore: decorator
@inline
function hash32(key: u32, len: u32 = 4): u32 {
  let h: u32 = XXH32_SEED + XXH32_P5 + len;
  h += key * XXH32_P3;
  h  = rotl(h, 17) * XXH32_P4;
  h ^= h >> 15;
  h *= XXH32_P2;
  h ^= h >> 13;
  h *= XXH32_P3;
  h ^= h >> 16;
  return h;
}

// @ts-ignore: decorator
@inline
function hash64(key: u64): u32 {
  let h: u32 = XXH32_SEED + XXH32_P5 + 8;
  h += <u32>key * XXH32_P3;
  h  = rotl(h, 17) * XXH32_P4;
  h += <u32>(key >> 32) * XXH32_P3;
  h  = rotl(h, 17) * XXH32_P4;
  h ^= h >> 15;
  h *= XXH32_P2;
  h ^= h >> 13;
  h *= XXH32_P3;
  h ^= h >> 16;
  return h;
}

// @ts-ignore: decorator
@inline
function mix(h: u32, key: u32): u32 {
  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;
}

// @ts-ignore: decorator
@inline
function hashStr(key: string): u32 {
  if (changetype<usize>(key) == 0) return XXH32_SEED;

  let h: u32 = key.length << 1;
  let len: usize = h;
  let pos = changetype<usize>(key);

  if (len >= 16) {
    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;
    let s2 = XXH32_SEED + XXH32_P2;
    let s3 = XXH32_SEED;
    let s4 = XXH32_SEED - XXH32_P1;

    let end = len + pos - 16;
    while (pos <= end) {
      s1 = mix(s1, load<u32>(pos    ));
      s2 = mix(s2, load<u32>(pos,  4));
      s3 = mix(s3, load<u32>(pos,  8));
      s4 = mix(s4, load<u32>(pos, 12));
      pos += 16;
    }
    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);
  } else {
    h += XXH32_SEED + XXH32_P5;
  }

  let end = changetype<usize>(key) + len - 4;
  while (pos <= end) {
    h += load<u32>(pos) * XXH32_P3;
    h = rotl(h, 17) * XXH32_P4;
    pos += 4;
  }

  end = changetype<usize>(key) + len;
  while (pos < end) {
    h += <u32>load<u8>(pos) * XXH32_P5;
    h = rotl(h, 11) * XXH32_P1;
    pos++;
  }

  h ^= h >> 15;
  h *= XXH32_P2;
  h ^= h >> 13;
  h *= XXH32_P3;
  h ^= h >> 16;
  return h;
}
`,"util/math":`//
// Lookup data for exp2f
//

// @ts-ignore: decorator
@inline const EXP2F_TABLE_BITS = 5;

// @ts-ignore: decorator
@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([
  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)
  // used for computing 2^(k/N) for an int |k| < 150 N as
  // double(tab[k%N] + (k << 52-BITS))
  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,
  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,
  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,
  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,
  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,
  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,
  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,
  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540
]);

// ULP error: 0.502 (nearest rounding.)
// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)
// Wrong count: 168353 (all nearest rounding wrong results with fma.)
// @ts-ignore: decorator
@inline
export function exp2f_lut(x: f32): f32 {
  const
    N      = 1 << EXP2F_TABLE_BITS,
    N_MASK = N - 1,
    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52
    Ox127f = reinterpret<f32>(0x7F000000);

  const
    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5
    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3
    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1

  let xd = <f64>x;
  let ix = reinterpret<u32>(x);
  let ux = ix >> 20 & 0x7FF;
  if (ux >= 0x430) {
    // |x| >= 128 or x is nan.
    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0
    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN
    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)
    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)
  }

  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.
  let kd = xd + shift;
  let ki = reinterpret<u64>(kd);
  let r  = xd - (kd - shift);
  let t: u64, y: f64, s: f64;

  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)
  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));
  t += ki << (52 - EXP2F_TABLE_BITS);
  s  = reinterpret<f64>(t);
  y  = C2 * r + 1;
  y += (C0 * r + C1) * (r  * r);
  y *= s;

  return <f32>y;
}

// ULP error: 0.502 (nearest rounding.)
// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)
// Wrong count: 170635 (all nearest rounding wrong results with fma.)
// @ts-ignore: decorator
@inline
export function expf_lut(x: f32): f32 {
  const
    N        = 1 << EXP2F_TABLE_BITS,
    N_MASK   = N - 1,
    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52
    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0
    Ox1p127f = reinterpret<f32>(0x7F000000);

  const
    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5
    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3
    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1

  let xd = <f64>x;
  let ix = reinterpret<u32>(x);
  let ux = ix >> 20 & 0x7FF;
  if (ux >= 0x42B) {
    // |x| >= 88 or x is nan.
    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0
    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN
    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)
    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)
  }

  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.
  let z = InvLn2N * xd;

  // Round and convert z to int, the result is in [-150*N, 128*N] and
  // ideally ties-to-even rule is used, otherwise the magnitude of r
  // can be bigger which gives larger approximation error.
  let kd = <f64>(z + shift);
  let ki = reinterpret<u64>(kd);
  let r  = z - (kd - shift);
  let s: f64, y: f64, t: u64;

  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)
  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));
  t += ki << (52 - EXP2F_TABLE_BITS);
  s  = reinterpret<f64>(t);
  z  = C0 * r + C1;
  y  = C2 * r + 1;
  y += z * (r * r);
  y *= s;

  return <f32>y;
}

//
// Lookup data for log2f
//

// @ts-ignore: decorator
@inline const LOG2F_TABLE_BITS = 4;

// @ts-ignore: decorator
@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([
  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,
  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,
  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,
  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,
  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,
  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,
  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,
  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,
  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,
  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,
  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,
  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,
  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,
  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,
  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,
  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2
]);

// ULP error: 0.752 (nearest rounding.)
// Relative error: 1.9 * 2^-26 (before rounding.)
// @ts-ignore: decorator
@inline
export function log2f_lut(x: f32): f32 {
  const
    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,
    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f

  const
    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2
    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2
    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1
    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0

  let ux = reinterpret<u32>(x);
  // Fix sign of zero with downward rounding when x==1.
  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;
  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {
    // x < 0x1p-126 or inf or nan.
    if (ux * 2 == 0) return -Infinity;
    if (ux == 0x7F800000) return x; // log2(inf) == inf.
    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);
    // x is subnormal, normalize it.
    ux = reinterpret<u32>(x * Ox1p23f);
    ux -= 23 << 23;
  }
  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  let tmp  = ux - 0x3F330000;
  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;
  let top  = tmp & 0xFF800000;
  let iz   = ux - top;
  let k    = <i32>tmp >> 23;

  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());
  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());
  let z    = <f64>reinterpret<f32>(iz);

  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k
  let r  = z * invc - 1;
  let y0 = logc + <f64>k;

  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.
  let y  = A1 * r + A2;
  let p  = A3 * r + y0;
  let r2 = r * r;
  y += A0 * r2;
  y  = y * r2 + p;

  return <f32>y;
}

//
// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c
//

// @ts-ignore: decorator
@inline const LOGF_TABLE_BITS = 4;

// @ts-ignore: decorator
@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([
  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,
  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,
  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,
  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,
  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,
  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,
  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,
  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,
  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,
  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,
  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,
  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,
  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,
  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,
  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,
  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2
]);

// ULP error: 0.818 (nearest rounding.)
// Relative error: 1.957 * 2^-26 (before rounding.)
// @ts-ignore: decorator
@inline
export function logf_lut(x: f32): f32 {
  const
    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,
    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f

  const
    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;
    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2
    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2
    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2

  let ux = reinterpret<u32>(x);
  // Fix sign of zero with downward rounding when x==1.
  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;
  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {
    // x < 0x1p-126 or inf or nan.
    if ((ux << 1) == 0) return -Infinity;
    if (ux == 0x7F800000) return x; // log(inf) == inf.
    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);
    // x is subnormal, normalize it.
    ux = reinterpret<u32>(x * Ox1p23f);
    ux -= 23 << 23;
  }
  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  let tmp = ux - 0x3F330000;
  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;
  let k   = <i32>tmp >> 23;
  let iz  = ux - (tmp & 0x1FF << 23);

  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());
  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());

  let z = <f64>reinterpret<f32>(iz);

  // log(x) = log1p(z/c-1) + log(c) + k*Ln2
  let r = z * invc - 1;
  let y0 = logc + <f64>k * Ln2;

  // Pipelined polynomial evaluation to approximate log1p(r).
  let r2 = r * r;
  let y  = A1 * r + A2;
  y += A0 * r2;
  y = y * r2 + (y0 + r);

  return <f32>y;
}

//
// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c
//

// @ts-ignore: decorator
@inline
function zeroinfnanf(ux: u32): bool {
  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;
}

// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is
// the bit representation of a non-zero finite floating-point value.
// @ts-ignore: decorator
@inline
function checkintf(iy: u32): i32 {
  let e = iy >> 23 & 0xFF;
  if (e < 0x7F     ) return 0;
  if (e > 0x7F + 23) return 2;
  e = 1 << (0x7F + 23 - e);
  if (iy & (e - 1)) return 0;
  if (iy &  e     ) return 1;
  return 2;
}

// Subnormal input is normalized so ix has negative biased exponent.
// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.
// @ts-ignore: decorator
@inline
function log2f_inline(ux: u32): f64 {
  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;

  const
    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2
    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2
    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2
    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1
    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0

  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  let tmp  = ux - 0x3F330000;
  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);
  let top  = tmp & 0xFF800000;
  let uz   = ux - top;
  let k    = <i32>top >> 23;

  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());
  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());
  let z    = <f64>reinterpret<f32>(uz);

  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k
  let r  = z * invc - 1;
  let y0 = logc + <f64>k;

  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.
  let y = A0 * r + A1;
  let p = A2 * r + A3;
  let q = A4 * r + y0;

  r *= r;
  q += p * r;
  y  = y * (r * r) + q;

  return y;
}

// The output of log2 and thus the input of exp2 is either scaled by N
// (in case of fast toint intrinsics) or not.  The unscaled xd must be
// in [-1021,1023], sign_bias sets the sign of the result.
// @ts-ignore: decorator
@inline
function exp2f_inline(xd: f64, signBias: u32): f32 {
  const
    N      = 1 << EXP2F_TABLE_BITS,
    N_MASK = N - 1,
    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52

  const
    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5
    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3
    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1

  // x = k/N + r with r in [-1/(2N), 1/(2N)]
  let kd = <f64>(xd + shift);
  let ki = reinterpret<u64>(kd);
  let r  = xd - (kd - shift);
  let t: u64, z: f64, y: f64, s: f64;

  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)
  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));
  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);
  s  = reinterpret<f64>(t);
  z  = C0 * r + C1;
  y  = C2 * r + 1;
  y += z * (r * r);
  y *= s;
  return <f32>y;
}

// @ts-ignore: decorator
@inline
function xflowf(sign: u32, y: f32): f32 {
  return select<f32>(-y, y, sign) * y;
}

// @ts-ignore: decorator
@inline
function oflowf(sign: u32): f32 {
  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f
}

// @ts-ignore: decorator
@inline
function uflowf(sign: u32): f32 {
  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f
}

// @ts-ignore: decorator
@inline
export function powf_lut(x: f32, y: f32): f32 {
  const
    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f
    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6
    LOWER_LIMIT = -150.0,
    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);

  let signBias: u32 = 0;
  let ix = reinterpret<u32>(x);
  let iy = reinterpret<u32>(y);
  let ny = 0;

  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {
    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).
    if (ny) {
      if ((iy << 1) == 0) return 1.0;
      if (ix == 0x3F800000) return NaN; // original: 1.0
      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;
      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0
      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.
      return y * y;
    }
    if (zeroinfnanf(ix)) {
      let x2 = x * x;
      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;
      return <i32>iy < 0 ? 1 / x2 : x2;
    }
    // x and y are non-zero finite.
    if (<i32>ix < 0) {
      // Finite x < 0.
      let yint = checkintf(iy);
      if (yint == 0) return (x - x) / (x - x);
      if (yint == 1) signBias = SIGN_BIAS;
      ix &= 0x7FFFFFFF;
    }
    if (ix < 0x00800000) {
      // Normalize subnormal x so exponent becomes negative.
      ix = reinterpret<u32>(x * Ox1p23f);
      ix &= 0x7FFFFFFF;
      ix -= 23 << 23;
    }
  }
  let logx = log2f_inline(ix);
  let ylogx = y * logx; // cannot overflow, y is single prec.
  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47
    // |y * log(x)| >= 126
    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow
    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow
  }
  return exp2f_inline(ylogx, signBias);
}

//
// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c
//

// @ts-ignore: decorator
@inline const EXP_TABLE_BITS = 7;

// @ts-ignore: decorator
@lazy @inline const EXP_DATA_TAB = memory.data<u64>([
  0x0000000000000000, 0x3FF0000000000000,
  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,
  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,
  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,
  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,
  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,
  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,
  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,
  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,
  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,
  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,
  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,
  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,
  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,
  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,
  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,
  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,
  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,
  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,
  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,
  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,
  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,
  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,
  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,
  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,
  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,
  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,
  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,
  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,
  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,
  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,
  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,
  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,
  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,
  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,
  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,
  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,
  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,
  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,
  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,
  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,
  0xBC9312607A28698A, 0x3FEEDA4504AC801C,
  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,
  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,
  0x3C4363ED60C2AC11, 0x3FEECE086061892D,
  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,
  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,
  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,
  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,
  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,
  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,
  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,
  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,
  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,
  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,
  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,
  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,
  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,
  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,
  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,
  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,
  0xBC845378892BE9AE, 0x3FEEA34634CCC320,
  0xBC93CEDD78565858, 0x3FEEA23882552225,
  0x3C5710AA807E1964, 0x3FEEA155D44CA973,
  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,
  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,
  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,
  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,
  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,
  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,
  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,
  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,
  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,
  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,
  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,
  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,
  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,
  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,
  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,
  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,
  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,
  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,
  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,
  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,
  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,
  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,
  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,
  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,
  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,
  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,
  0xBC87C50422622263, 0x3FEECC667B5DE565,
  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,
  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,
  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,
  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,
  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,
  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,
  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,
  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,
  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,
  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,
  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,
  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,
  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,
  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,
  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,
  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,
  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,
  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,
  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,
  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,
  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,
  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,
  0xBC82919E2040220F, 0x3FEF60E316C98398,
  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,
  0x3C843A59AC016B4B, 0x3FEF7321F301B460,
  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,
  0xBC892AB93B470DC9, 0x3FEF864614F5A129,
  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,
  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,
  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,
  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,
  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,
  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,
  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,
  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,
  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,
  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1
]);

// Handle cases that may overflow or underflow when computing the result that
// is scale*(1+TMP) without intermediate rounding. The bit representation of
// scale is in SBITS, however it has a computed exponent that may have
// overflown into the sign bit so that needs to be adjusted before using it as
// a double.  (int32_t)KI is the k used in the argument reduction and exponent
// adjustment of scale, positive k here means the result may overflow and
// negative k means the result may underflow.
// @ts-ignore: decorator
@inline
function specialcase(tmp: f64, sbits: u64, ki: u64): f64 {
  const
    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022
    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009

  let scale: f64;
  if (!(ki & 0x80000000)) {
    // k > 0, the exponent of scale might have overflowed by <= 460.
    sbits -= u64(1009) << 52;
    scale = reinterpret<f64>(sbits);
    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009
  }
  // k < 0, need special care in the subnormal range.
  sbits += u64(1022) << 52;
  // Note: sbits is signed scale.
  scale = reinterpret<f64>(sbits);
  let y = scale + scale * tmp;
  if (abs(y) < 1.0) {
    // Round y to the right precision before scaling it into the subnormal
    // range to avoid double rounding that can cause 0.5+E/2 ulp error where
    // E is the worst-case ulp error outside the subnormal range.  So this
    // is only useful if the goal is better than 1 ulp worst-case error.
    let one = copysign(1.0, y);
    let lo = scale - y + scale * tmp;
    let hi = one + y;
    lo = one - hi + y + lo;
    y  = (hi + lo) - one;
    // Fix the sign of 0.
    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);
  }
  return y * Ox1p_1022;
}

// @ts-ignore: decorator
@inline
export function exp_lut(x: f64): f64 {
  const
    N      = 1 << EXP_TABLE_BITS,
    N_MASK = N - 1;

  const
    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0
    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8
    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47
    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;

  const
    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)
    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)
    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)
    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)

  let ux = reinterpret<u64>(x);
  let abstop = u32(ux >> 52) & 0x7FF;
  if (abstop - 0x3C9 >= 0x03F) {
    if (abstop - 0x3C9 >= 0x80000000) return 1;
    if (abstop >= 0x409) {
      if (ux == 0xFFF0000000000000) return 0;
      if (abstop >= 0x7FF) {
        return 1.0 + x;
      } else {
        return select<f64>(0, Infinity, <i64>ux < 0);
      }
    }
    // Large x is special cased below.
    abstop = 0;
  }

  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]
  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]
  let z = InvLn2N * x;
  // #if TOINT_INTRINSICS
  // 	kd = roundtoint(z);
  // 	ki = converttoint(z);
  // #elif EXP_USE_TOINT_NARROW
  // 	// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.
  // let kd = z + shift;
  // let ki = reinterpret<u64>(kd) >> 16;
  // let kd = <f64><i32>ki;
  // #else
  // z - kd is in [-1, 1] in non-nearest rounding modes.
  let kd = z + shift;
  let ki = reinterpret<u64>(kd);
  kd -= shift;
  // #endif
  let r = x + kd * NegLn2hiN + kd * NegLn2loN;
  // 2^(k/N) ~= scale * (1 + tail).
  let idx = usize((ki & N_MASK) << 1);
  let top = ki << (52 - EXP_TABLE_BITS);

  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]
  // This is only a valid scale when -1023*N < k < 1024*N
  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]
  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).
  // Evaluation is optimized assuming superscalar pipelined execution.
  let r2 = r * r;
  // Without fma the worst case error is 0.25/N ulp larger.
  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.
  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);
  if (abstop == 0) return specialcase(tmp, sbits, ki);
  let scale = reinterpret<f64>(sbits);
  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
  // is no spurious underflow here even without fma.
  return scale + scale * tmp;
}

//
// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c
//

// Handle cases that may overflow or underflow when computing the result that
// is scale*(1+TMP) without intermediate rounding.  The bit representation of
// scale is in SBITS, however it has a computed exponent that may have
// overflown into the sign bit so that needs to be adjusted before using it as
// a double.  (int32_t)KI is the k used in the argument reduction and exponent
// adjustment of scale, positive k here means the result may overflow and
// negative k means the result may underflow.
// @ts-ignore: decorator
@inline
function specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {
  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022
  let scale: f64;
  if ((ki & 0x80000000) == 0) {
    // k > 0, the exponent of scale might have overflowed by 1
    sbits -= u64(1) << 52;
    scale = reinterpret<f64>(sbits);
    return 2 * (scale * tmp + scale);
  }
  // k < 0, need special care in the subnormal range
  sbits += u64(1022) << 52;
  scale = reinterpret<f64>(sbits);
  let y = scale * tmp + scale;
  if (y < 1.0) {
    // Round y to the right precision before scaling it into the subnormal
    // range to avoid double rounding that can cause 0.5+E/2 ulp error where
    // E is the worst-case ulp error outside the subnormal range. So this
    // is only useful if the goal is better than 1 ulp worst-case error.
    let hi: f64, lo: f64;
    lo = scale - y + scale * tmp;
    hi = 1.0 + y;
    lo = 1.0 - hi + y + lo;
    y = (hi + lo) - 1.0;
  }
  return y * Ox1p_1022;
}

// @ts-ignore: decorator
@inline
export function exp2_lut(x: f64): f64 {
  const
    N      = 1 << EXP_TABLE_BITS,
    N_MASK = N - 1,
    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52

  const
    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1
    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3
    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5
    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7
    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10

  let ux = reinterpret<u64>(x);
  let abstop = u32(ux >> 52) & 0x7ff;
  if (abstop - 0x3C9 >= 0x03F) {
    if (abstop - 0x3C9 >= 0x80000000) return 1.0;
    if (abstop >= 0x409) {
      if (ux == 0xFFF0000000000000) return 0;
      if (abstop >= 0x7FF) return 1.0 + x;
      if (<i64>ux >= 0) return Infinity;
      else if (ux >= 0xC090CC0000000000) return 0;
    }
    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.
  }

  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].
  // x = k/N + r, with int k and r in [-1/2N, 1/2N]
  let kd = x + shift;
  let ki = reinterpret<u64>(kd);
  kd -= shift; // k/N for int k
  let r = x - kd;
  // 2^(k/N) ~= scale * (1 + tail)
  let idx = usize((ki & N_MASK) << 1);
  let top = ki << (52 - EXP_TABLE_BITS);

  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])
  // This is only a valid scale when -1023*N < k < 1024*N
  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]
  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).
  // Evaluation is optimized assuming superscalar pipelined execution
  let r2 = r * r;
  // Without fma the worst case error is 0.5/N ulp larger.
  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.
  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);
  if (abstop == 0) return specialcase2(tmp, sbits, ki);
  let scale = reinterpret<f64>(sbits);
  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there
  // is no spurious underflow here even without fma.
  return scale * tmp + scale;
}

//
// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c
//

// @ts-ignore: decorator
@inline const LOG2_TABLE_BITS = 6;

/* Algorithm:

  x = 2^k z
  log2(x) = k + log2(c) + log2(z/c)
  log2(z/c) = poly(z/c - 1)

where z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls
into the ith one, then table entries are computed as

  tab[i].invc = 1/c
  tab[i].logc = (double)log2(c)
  tab2[i].chi = (double)c
  tab2[i].clo = (double)(c - (double)c)

where c is near the center of the subinterval and is chosen by trying +-2^29
floating point invc candidates around 1/center and selecting one for which

  1) the rounding error in 0x1.8p10 + logc is 0,
  2) the rounding error in z - chi - clo is < 0x1p-64 and
  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).

Note: 1) ensures that k + logc can be computed without rounding error, 2)
ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a
single rounding error when there is no fast fma for z*invc - 1, 3) ensures
that logc + poly(z/c - 1) has small error, however near x == 1 when
|log2(x)| < 0x1p-4, this is not enough so that is special cased. */

// @ts-ignore: decorator
@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([
  //            invc                  ,                logc
  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),
  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),
  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),
  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),
  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),
  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),
  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),
  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),
  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),
  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),
  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),
  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),
  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),
  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),
  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),
  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),
  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),
  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),
  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),
  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),
  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),
  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),
  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),
  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),
  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),
  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),
  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),
  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),
  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),
  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),
  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),
  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),
  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),
  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),
  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),
  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),
  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),
  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),
  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),
  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),
  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),
  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),
  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),
  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),
  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),
  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),
  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),
  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),
  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),
  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),
  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),
  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),
  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),
  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),
  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),
  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),
  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),
  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),
  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),
  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),
  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),
  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),
  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),
  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)
]);

// @ts-ignore: decorator
@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([
  //              chi                 ,                 clo
  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),
  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),
  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),
  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),
  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),
  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),
  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),
  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),
  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),
  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),
  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),
  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),
  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),
  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),
  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),
  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),
  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),
  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),
  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),
  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),
  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),
  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),
  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),
  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),
  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),
  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),
  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),
  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),
  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),
  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),
  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),
  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),
  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),
  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),
  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),
  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),
  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),
  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),
  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),
  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),
  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),
  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),
  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),
  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),
  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),
  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),
  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),
  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),
  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),
  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),
  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),
  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),
  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),
  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),
  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),
  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),
  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),
  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),
  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),
  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),
  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),
  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),
  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),
  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)
]);

// @ts-ignore: decorator
@inline
export function log2_lut(x: f64): f64 {
  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;

  const
    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)
    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)

  const
    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0
    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33
    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52

  const
    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1
    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2
    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2
    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2
    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3
    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3
    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3
    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3
    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3
    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3

  const
    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1
    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2
    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2
    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2
    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3
    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3

  let ix = reinterpret<u64>(x);
  if (ix - LO < HI - LO) {
    let r = x - 1.0;
    // #if __FP_FAST_FMA
    //     hi = r * InvLn2hi;
    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);
    // #else
    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);
    let rlo = r - rhi;
    let hi  = rhi * InvLn2hi;
    let lo  = rlo * InvLn2hi + r * InvLn2lo;
    // #endif
    let r2 = r * r; // rounding error: 0x1p-62
    let r4 = r2 * r2;
    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)
    let p = r2 * (B0 + r * B1);
    let y = hi + p;
    lo += hi - y + p;
    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +
          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));
    return y + lo;
  }
  let top = u32(ix >> 48);
  if (top - 0x0010 >= 0x7ff0 - 0x0010) {
    // x < 0x1p-1022 or inf or nan.
    if ((ix << 1) == 0) return -1.0 / (x * x);
    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf
    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);
    // x is subnormal, normalize it.
    ix = reinterpret<u64>(x * Ox1p52);
    ix -= u64(52) << 52;
  }

  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  let tmp  = ix - 0x3FE6000000000000;
  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);
  let k    = <i64>tmp >> 52;
  let iz   = ix - (tmp & 0xFFF0000000000000);

  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;
  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;
  let z    = reinterpret<f64>(iz);
  let kd   = <f64>k;

  // log2(x) = log2(z/c) + log2(c) + k.
  // r ~= z/c - 1, |r| < 1/(2*N).
  // #if __FP_FAST_FMA
  // 	// rounding error: 0x1p-55/N.
  // 	r = __builtin_fma(z, invc, -1.0);
  // 	t1 = r * InvLn2hi;
  // 	t2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);
  // #else
  // rounding error: 0x1p-55/N + 0x1p-65.
  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;
  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;

  let r   = (z - chi - clo) * invc;
  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);
  let rlo = r - rhi;
  let t1  = rhi * InvLn2hi;
  let t2  = rlo * InvLn2hi + r * InvLn2lo;
  // #endif

  // hi + lo = r/ln2 + log2(c) + k
  let t3 = kd + logc;
  let hi = t3 + t1;
  let lo = t3 - hi + t1 + t2;

  // log2(r+1) = r/ln2 + r^2*poly(r)
  // Evaluation is optimized assuming superscalar pipelined execution
  let r2 = r * r; // rounding error: 0x1p-54/N^2
  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).
  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).
  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);
  return lo + r2 * p + hi;
}

//
// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c
//

// @ts-ignore: decorator
@inline const LOG_TABLE_BITS = 7;

/* Algorithm:

  x = 2^k z
  log(x) = k ln2 + log(c) + log(z/c)
  log(z/c) = poly(z/c - 1)

where z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls
into the ith one, then table entries are computed as

  tab[i].invc = 1/c
  tab[i].logc = (double)log(c)
  tab2[i].chi = (double)c
  tab2[i].clo = (double)(c - (double)c)

where c is near the center of the subinterval and is chosen by trying +-2^29
floating point invc candidates around 1/center and selecting one for which

  1) the rounding error in 0x1.8p9 + logc is 0,
  2) the rounding error in z - chi - clo is < 0x1p-66 and
  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).

Note: 1) ensures that k*ln2hi + logc can be computed without rounding error,
2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to
a single rounding error when there is no fast fma for z*invc - 1, 3) ensures
that logc + poly(z/c - 1) has small error, however near x == 1 when
|log(x)| < 0x1p-4, this is not enough so that is special cased.*/

// @ts-ignore: decorator
@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([
  //              invc                ,                 logc
  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),
  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),
  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),
  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),
  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),
  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),
  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),
  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),
  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),
  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),
  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),
  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),
  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),
  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),
  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),
  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),
  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),
  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),
  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),
  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),
  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),
  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),
  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),
  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),
  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),
  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),
  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),
  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),
  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),
  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),
  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),
  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),
  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),
  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),
  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),
  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),
  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),
  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),
  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),
  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),
  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),
  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),
  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),
  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),
  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),
  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),
  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),
  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),
  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),
  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),
  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),
  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),
  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),
  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),
  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),
  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),
  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),
  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),
  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),
  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),
  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),
  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),
  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),
  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),
  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),
  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),
  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),
  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),
  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),
  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),
  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),
  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),
  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),
  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),
  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),
  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),
  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),
  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),
  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),
  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),
  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),
  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),
  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),
  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),
  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),
  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),
  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),
  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),
  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),
  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),
  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),
  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),
  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),
  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),
  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),
  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),
  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),
  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),
  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),
  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),
  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),
  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),
  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),
  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),
  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),
  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),
  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),
  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),
  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),
  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),
  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),
  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),
  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),
  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),
  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),
  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),
  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),
  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),
  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),
  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),
  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),
  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),
  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),
  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),
  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),
  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),
  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),
  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)
]);

// @ts-ignore: decorator
@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([
  //               chi                ,                  clo
  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),
  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),
  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),
  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),
  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),
  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),
  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),
  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),
  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),
  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),
  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),
  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),
  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),
  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),
  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),
  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),
  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),
  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),
  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),
  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),
  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),
  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),
  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),
  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),
  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),
  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),
  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),
  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),
  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),
  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),
  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),
  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),
  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),
  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),
  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),
  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),
  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),
  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),
  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),
  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),
  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),
  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),
  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),
  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),
  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),
  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),
  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),
  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),
  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),
  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),
  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),
  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),
  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),
  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),
  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),
  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),
  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),
  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),
  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),
  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),
  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),
  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),
  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),
  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),
  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),
  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),
  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),
  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),
  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),
  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),
  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),
  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),
  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),
  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),
  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),
  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),
  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),
  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),
  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),
  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),
  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),
  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),
  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),
  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),
  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),
  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),
  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),
  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),
  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),
  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),
  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),
  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),
  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),
  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),
  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),
  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),
  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),
  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),
  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),
  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),
  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),
  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),
  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),
  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),
  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),
  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),
  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),
  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),
  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),
  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),
  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),
  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),
  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),
  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),
  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),
  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),
  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),
  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),
  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),
  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),
  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),
  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),
  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),
  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),
  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),
  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),
  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),
  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)
]);

// @ts-ignore: decorator
@inline
export function log_lut(x: f64): f64 {
  const N_MASK = (1 << LOG_TABLE_BITS) - 1;

  const
    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1
    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2
    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3
    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3
    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3
    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3
    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4
    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4
    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4
    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4
    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4

  const
    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1
    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2
    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3
    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3
    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3

  const
    LO: u64 = 0x3FEE000000000000,
    HI: u64 = 0x3FF1090000000000;

  const
    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1
    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45
    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27
    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52

  let ix = reinterpret<u64>(x);
  if (ix - LO < HI - LO) {
    let r  = x - 1.0;
    let r2 = r * r;
    let r3 = r2 * r;
    let y =
      r3 * (B1 + r * B2 + r2 * B3 +
      r3 * (B4 + r * B5 + r2 * B6 +
      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));
    // Worst-case error is around 0.507 ULP
    let w   = r * Ox1p27;
    let rhi = r + w - w;
    let rlo = r - rhi;
    w = rhi * rhi * B0; // B[0] == -0.5
    let hi = r + w;
    let lo = r - hi + w;
    lo += B0 * rlo * (rhi + r);
    return y + lo + hi;
  }
  let top = u32(ix >> 48);
  if (top - 0x0010 >= 0x7FF0 - 0x0010) {
    // x < 0x1p-1022 or inf or nan
    if ((ix << 1) == 0) return -1.0 / (x * x);
    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf
    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);
    // x is subnormal, normalize it
    ix = reinterpret<u64>(x * Ox1p52);
    ix -= u64(52) << 52;
  }

  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  let tmp  = ix - 0x3FE6000000000000;
  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);
  let k    = <i64>tmp >> 52;
  let iz   = ix - (tmp & (u64(0xFFF) << 52));

  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;
  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;
  let z    = reinterpret<f64>(iz);

  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.
  // r ~= z/c - 1, |r| < 1/(2*N)
  // #if __FP_FAST_FMA
  // 	// rounding error: 0x1p-55/N
  // 	r = __builtin_fma(z, invc, -1.0);
  // #else
  // rounding error: 0x1p-55/N + 0x1p-66
  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi
  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo
  let r = (z - chi - clo) * invc;
  // #endif
  let kd = <f64>k;

  // hi + lo = r + log(c) + k*Ln2
  let w  = kd * Ln2hi + logc;
  let hi = w + r;
  let lo = w - hi + r + kd * Ln2lo;

  // log(x) = lo + (log1p(r) - r) + hi
  let r2 = r * r; // rounding error: 0x1p-54/N^2
  // Worst case error if |y| > 0x1p-5:
  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)
  // Worst case error if |y| > 0x1p-4:
  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).
  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;
}

//
// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c
//

// @ts-ignore: decorator
@inline const POW_LOG_TABLE_BITS = 7;

/* Algorithm:

  x = 2^k z
  log(x) = k ln2 + log(c) + log(z/c)
  log(z/c) = poly(z/c - 1)

where z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals
and z falls into the ith one, then table entries are computed as

  tab[i].invc = 1/c
  tab[i].logc = round(0x1p43*log(c))/0x1p43
  tab[i].logctail = (double)(log(c) - logc)

where c is chosen near the center of the subinterval such that 1/c has only a
few precision bits so z/c - 1 is exactly representible as double:

  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2

Note: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,
the last few bits of logc are rounded away so k*ln2hi + logc has no rounding
error and the interval for z is selected such that near x == 1, where log(x)
is tiny, large cancellation error is avoided in logc + poly(z/c - 1). */

// @ts-ignore: decorator
@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([
  //             invc                 ,pad,               logc                 ,               logctail
  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),
  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),
  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),
  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),
  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),
  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),
  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),
  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),
  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),
  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),
  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),
  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),
  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),
  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),
  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),
  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),
  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),
  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),
  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),
  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),
  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),
  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),
  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),
  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),
  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),
  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),
  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),
  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),
  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),
  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),
  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),
  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),
  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),
  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),
  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),
  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),
  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),
  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),
  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),
  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),
  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),
  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),
  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),
  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),
  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),
  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),
  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),
  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),
  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),
  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),
  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),
  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),
  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),
  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),
  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),
  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),
  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),
  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),
  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),
  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),
  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),
  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),
  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),
  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),
  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),
  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),
  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),
  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),
  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),
  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),
  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),
  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),
  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),
  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),
  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,
  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,
  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),
  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),
  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),
  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),
  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),
  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),
  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),
  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),
  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),
  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),
  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),
  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),
  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),
  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),
  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),
  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),
  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),
  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),
  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),
  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),
  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),
  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),
  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),
  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),
  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),
  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),
  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),
  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),
  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),
  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),
  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),
  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),
  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),
  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),
  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),
  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),
  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),
  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),
  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),
  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),
  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),
  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),
  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),
  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),
  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),
  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),
  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),
  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),
  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),
  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),
  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),
  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)
]);

// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is
// the bit representation of a non-zero finite floating-point value.
// @ts-ignore: decorator
@inline
function checkint(iy: u64): i32 {
  let e = iy >> 52 & 0x7FF;
  if (e < 0x3FF     ) return 0;
  if (e > 0x3FF + 52) return 2;
  e = u64(1) << (0x3FF + 52 - e);
  if (iy & (e - 1)) return 0;
  if (iy &  e     ) return 1;
  return 2;
}

// @ts-ignore: decorator
@inline
function xflow(sign: u32, y: f64): f64 {
  return select(-y, y, sign) * y;
}

// @ts-ignore: decorator
@inline
function uflow(sign: u32): f64 {
  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767
}

// @ts-ignore: decorator
@inline
function oflow(sign: u32): f64 {
  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769
}

// Returns 1 if input is the bit representation of 0, infinity or nan.
// @ts-ignore: decorator
@inline
function zeroinfnan(u: u64): bool {
  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;
}

// @ts-ignore: decorator
@lazy let log_tail: f64 = 0;

// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about
// additional 15 bits precision. IX is the bit representation of x, but
// normalized in the subnormal range using the sign bit for the exponent.
// @ts-ignore: decorator
@inline
function log_inline(ix: u64): f64 {
  const N = 1 << POW_LOG_TABLE_BITS;
  const N_MASK = N - 1;

  const
    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),
    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);

  const
    A0 = reinterpret<f64>(0xBFE0000000000000),
    A1 = reinterpret<f64>(0xBFE5555555555560),
    A2 = reinterpret<f64>(0x3FE0000000000006),
    A3 = reinterpret<f64>(0x3FE999999959554E),
    A4 = reinterpret<f64>(0xBFE555555529A47A),
    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),
    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);

  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  let tmp = ix - 0x3fE6955500000000;
  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);
  let k   = <i64>tmp >> 52;
  let iz  = ix - (tmp & u64(0xFFF) << 52);
  let z   = reinterpret<f64>(iz);
  let kd  = <f64>k;

  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).
  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc
  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc
  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail

  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and
  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.
  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.
  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);
  let zlo = z - zhi;
  let rhi = zhi * invc - 1.0;
  let rlo = zlo * invc;
  let r   = rhi + rlo;

  // k * Ln2 + log(c) + r.
  let t1  = kd * Ln2hi + logc;
  let t2  = t1 + r;
  let lo1 = kd * Ln2lo + logctail;
  let lo2 = t1 - t2 + r;

  // Evaluation is optimized assuming superscalar pipelined execution.
  let ar  = A0 * r; // A[0] = -0.5
  let ar2 = r * ar;
  let ar3 = r * ar2;
  // k * Ln2 + log(c) + r + A[0] * r * r.
  let arhi  = A0  * rhi;
  let arhi2 = rhi * arhi;
  let hi    = t2  + arhi2;
  let lo3   = rlo * (ar + arhi);
  let lo4   = t2 - hi + arhi2;

  // p = log1p(r) - r - A[0] * r * r.
  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));
  let lo = lo1 + lo2 + lo3 + lo4 + p;
  let y  = hi + lo;
  log_tail = hi - y + lo;

  return y;
}

// @ts-ignore: decorator
@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;

// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.
// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.
// @ts-ignore: decorator
@inline
function exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {
  const N      = 1 << EXP_TABLE_BITS;
  const N_MASK = N - 1;

  const
    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0
    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8
    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47
    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52

  const
    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)
    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)
    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)
    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)

  let abstop: u32;
  let ki: u64, top: u64, sbits: u64;
  let idx: usize;
  // double_t for better performance on targets with FLT_EVAL_METHOD==2.
  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;

  let ux = reinterpret<u64>(x);
  abstop = u32(ux >> 52) & 0x7FF;
  if (abstop - 0x3C9 >= 0x03F) {
    if (abstop - 0x3C9 >= 0x80000000) {
      // Avoid spurious underflow for tiny x.
      // Note: 0 is common input.
      return select(-1.0, 1.0, sign_bias);
    }
    if (abstop >= 0x409) { // top12(1024.0)
      // Note: inf and nan are already handled.
      return <i64>ux < 0
        ? uflow(sign_bias)
        : oflow(sign_bias);
    }
    // Large x is special cased below.
    abstop = 0;
  }

  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].
  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].
  z = InvLn2N * x;

  // #if TOINT_INTRINSICS
  //   kd = roundtoint(z);
  //   ki = converttoint(z);
  // #elif EXP_USE_TOINT_NARROW
  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.
  //   kd = eval_as_double(z + shift);
  //   ki = asuint64(kd) >> 16;
  //   kd = (double_t)(int32_t)ki;
  // #else
  // z - kd is in [-1, 1] in non-nearest rounding modes
  kd  = z + shift;
  ki  = reinterpret<u64>(kd);
  kd -= shift;
  // #endif
  r = x + kd * NegLn2hiN + kd * NegLn2loN;
  // The code assumes 2^-200 < |xtail| < 2^-8/N
  r += xtail;
  // 2^(k/N) ~= scale * (1 + tail)
  idx = usize((ki & N_MASK) << 1);
  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);

  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));
  // This is only a valid scale when -1023*N < k < 1024*N
  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;
  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).
  // Evaluation is optimized assuming superscalar pipelined execution.
  r2 = r * r;
  // Without fma the worst case error is 0.25/N ulp larger.
  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp
  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);
  if (abstop == 0) return specialcase(tmp, sbits, ki);
  scale = reinterpret<f64>(sbits);
  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
  // is no spurious underflow here even without fma.
  return scale + scale * tmp;
}

// @ts-ignore: decorator
@inline
export function pow_lut(x: f64, y: f64): f64 {
  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52

  let sign_bias: u32 = 0;
  let ix = reinterpret<u64>(x);
  let iy = reinterpret<u64>(y);
  let topx = ix >> 52;
  let topy = iy >> 52;

  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {
    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0
    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.
    // Special cases: (x < 0x1p-126 or inf or nan) or
    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).
    if (zeroinfnan(iy)) {
      if ((iy << 1) == 0) return 1.0;
      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0
      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;
      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0
      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.
      return y * y;
    }
    if (zeroinfnan(ix)) {
      let x2 = x * x;
      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;
      return <i64>iy < 0 ? 1 / x2 : x2;
    }
    // Here x and y are non-zero finite
    if (<i64>ix < 0) {
      // Finite x < 0
      let yint = checkint(iy);
      if (yint == 0) return (x - x) / (x - x);
      if (yint == 1) sign_bias = SIGN_BIAS;
      ix   &= 0x7FFFFFFFFFFFFFFF;
      topx &= 0x7FF;
    }
    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {
      // Note: sign_bias == 0 here because y is not odd.
      if (ix == 0x3FF0000000000000) return 1;
      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).
      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;
    }
    if (topx == 0) {
      // Normalize subnormal x so exponent becomes negative.
      ix = reinterpret<u64>(x * Ox1p52);
      ix &= 0x7FFFFFFFFFFFFFFF;
      ix -= u64(52) << 52;
    }
  }

  let hi = log_inline(ix);
  let lo = log_tail;
  let ehi: f64, elo: f64;
  // #if __FP_FAST_FMA
  //   ehi = y * hi;
  //   elo = y * lo + __builtin_fma(y, hi, -ehi);
  // #else
  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);
  let ylo = y - yhi;
  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);
  let llo = hi - lhi + lo;
  ehi = yhi * lhi;
  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.
  // #endif
  return exp_inline(ehi, elo, sign_bias);
}
`,"util/memory":`export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c
  let w: u32, x: u32;

  // copy 1 byte each until src is aligned to 4 bytes
  while (n && (src & 3)) {
    store<u8>(dest++, load<u8>(src++));
    n--;
  }

  // if dst is aligned to 4 bytes as well, copy 4 bytes each
  if ((dest & 3) == 0) {
    while (n >= 16) {
      store<u32>(dest     , load<u32>(src     ));
      store<u32>(dest +  4, load<u32>(src +  4));
      store<u32>(dest +  8, load<u32>(src +  8));
      store<u32>(dest + 12, load<u32>(src + 12));
      src += 16; dest += 16; n -= 16;
    }
    if (n & 8) {
      store<u32>(dest    , load<u32>(src    ));
      store<u32>(dest + 4, load<u32>(src + 4));
      dest += 8; src += 8;
    }
    if (n & 4) {
      store<u32>(dest, load<u32>(src));
      dest += 4; src += 4;
    }
    if (n & 2) { // drop to 2 bytes each
      store<u16>(dest, load<u16>(src));
      dest += 2; src += 2;
    }
    if (n & 1) { // drop to 1 byte
      store<u8>(dest++, load<u8>(src++));
    }
    return;
  }

  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each
  // doing shifts if faster when copying enough bytes (here: 32 or more)
  if (n >= 32) {
    switch (<u32>dest & 3) {
      // known to be != 0
      case 1: {
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        n -= 3;
        while (n >= 17) {
          x = load<u32>(src + 1);
          store<u32>(dest, w >> 24 | x << 8);
          w = load<u32>(src + 5);
          store<u32>(dest + 4, x >> 24 | w << 8);
          x = load<u32>(src + 9);
          store<u32>(dest + 8, w >> 24 | x << 8);
          w = load<u32>(src + 13);
          store<u32>(dest + 12, x >> 24 | w << 8);
          src += 16; dest += 16; n -= 16;
        }
        break;
      }
      case 2: {
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        n -= 2;
        while (n >= 18) {
          x = load<u32>(src + 2);
          store<u32>(dest, w >> 16 | x << 16);
          w = load<u32>(src + 6);
          store<u32>(dest + 4, x >> 16 | w << 16);
          x = load<u32>(src + 10);
          store<u32>(dest + 8, w >> 16 | x << 16);
          w = load<u32>(src + 14);
          store<u32>(dest + 12, x >> 16 | w << 16);
          src += 16; dest += 16; n -= 16;
        }
        break;
      }
      case 3: {
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        n -= 1;
        while (n >= 19) {
          x = load<u32>(src + 3);
          store<u32>(dest, w >> 8 | x << 24);
          w = load<u32>(src + 7);
          store<u32>(dest + 4, x >> 8 | w << 24);
          x = load<u32>(src + 11);
          store<u32>(dest + 8, w >> 8 | x << 24);
          w = load<u32>(src + 15);
          store<u32>(dest + 12, x >> 8 | w << 24);
          src += 16; dest += 16; n -= 16;
        }
        break;
      }
    }
  }

  // copy remaining bytes one by one
  if (n & 16) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 8) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 4) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 2) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 1) {
    store<u8>(dest++, load<u8>(src++));
  }
}

// @ts-ignore: decorator
@inline
export function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c
  if (dest == src) return;
  if (ASC_SHRINK_LEVEL < 1) {
    if (src - dest - n <= -(n << 1)) {
      memcpy(dest, src, n);
      return;
    }
  }
  if (dest < src) {
    if (ASC_SHRINK_LEVEL < 2) {
      if ((src & 7) == (dest & 7)) {
        while (dest & 7) {
          if (!n) return;
          --n;
          store<u8>(dest++, load<u8>(src++));
        }
        while (n >= 8) {
          store<u64>(dest, load<u64>(src));
          n    -= 8;
          dest += 8;
          src  += 8;
        }
      }
    }
    while (n) {
      store<u8>(dest++, load<u8>(src++));
      --n;
    }
  } else {
    if (ASC_SHRINK_LEVEL < 2) {
      if ((src & 7) == (dest & 7)) {
        while ((dest + n) & 7) {
          if (!n) return;
          store<u8>(dest + --n, load<u8>(src + n));
        }
        while (n >= 8) {
          n -= 8;
          store<u64>(dest + n, load<u64>(src + n));
        }
      }
    }
    while (n) {
      store<u8>(dest + --n, load<u8>(src + n));
    }
  }
}

// @ts-ignore: decorator
@inline
export function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset
  if (ASC_SHRINK_LEVEL > 1) {
    while (n) {
      store<u8>(dest++, c);
      --n;
    }
  } else {
    // fill head and tail with minimal branching
    if (!n) return;
    let dend = dest + n;
    store<u8>(dest, c);
    store<u8>(dend - 1, c);
    if (n <= 2) return;
    store<u8>(dest, c, 1);
    store<u8>(dest, c, 2);
    store<u8>(dend - 2, c);
    store<u8>(dend - 3, c);
    if (n <= 6) return;
    store<u8>(dest, c, 3);
    store<u8>(dend - 4, c);
    if (n <= 8) return;

    // advance pointer to align it at 4-byte boundary
    let k: usize = -dest & 3;
    dest += k;
    n -= k;
    n &= -4;

    let c32: u32 = <u32>-1 / 255 * c;

    // fill head/tail up to 28 bytes each in preparation
    dend = dest + n;
    store<u32>(dest, c32);
    store<u32>(dend - 4, c32);
    if (n <= 8) return;
    store<u32>(dest, c32, 4);
    store<u32>(dest, c32, 8);
    store<u32>(dend - 12, c32);
    store<u32>(dend - 8, c32);
    if (n <= 24) return;
    store<u32>(dest, c32, 12);
    store<u32>(dest, c32, 16);
    store<u32>(dest, c32, 20);
    store<u32>(dest, c32, 24);
    store<u32>(dend - 28, c32);
    store<u32>(dend - 24, c32);
    store<u32>(dend - 20, c32);
    store<u32>(dend - 16, c32);

    // align to a multiple of 8
    k = 24 + (dest & 4);
    dest += k;
    n -= k;

    // copy 32 bytes each
    let c64: u64 = <u64>c32 | (<u64>c32 << 32);
    while (n >= 32) {
      store<u64>(dest, c64);
      store<u64>(dest, c64, 8);
      store<u64>(dest, c64, 16);
      store<u64>(dest, c64, 24);
      n -= 32;
      dest += 32;
    }
  }
}

// @ts-ignore: decorator
@inline
export function memcmp(vl: usize, vr: usize, n: usize): i32 {
  if (vl == vr) return 0;
  if (ASC_SHRINK_LEVEL < 2) {
    if ((vl & 7) == (vr & 7)) {
      while (vl & 7) {
        if (!n) return 0;
        let a = <i32>load<u8>(vl);
        let b = <i32>load<u8>(vr);
        if (a != b) return a - b;
        n--; vl++; vr++;
      }
      while (n >= 8) {
        if (load<u64>(vl) != load<u64>(vr)) break;
        vl += 8;
        vr += 8;
        n  -= 8;
      }
    }
  }
  while (n--) {
    let a = <i32>load<u8>(vl);
    let b = <i32>load<u8>(vr);
    if (a != b) return a - b;
    vl++; vr++;
  }
  return 0;
}
`,"util/number":`/// <reference path="../rt/index.d.ts" />

import { idof } from "../builtins";
import { CharCode } from "./string";

// @ts-ignore: decorator
@inline
export const MAX_DOUBLE_LENGTH = 28;

// @ts-ignore: decorator
@lazy @inline const POWERS10 = memory.data<u32>([
  1,
  10,
  100,
  1000,
  10000,
  100000,
  1000000,
  10000000,
  100000000,
  1000000000
]);

/*
  Lookup table for pairwise char codes in range [0-99]

  "00", "01", "02", "03", "04", "05", "06", "07", "08", "09",
  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49",
  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59",
  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69",
  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79",
  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"
*/
// @ts-ignore: decorator
@lazy @inline const DIGITS = memory.data<u32>([
  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,
  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,
  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,
  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,
  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,
  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,
  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,
  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,
  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,
  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,
  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,
  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,
  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,
  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,
  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,
  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,
  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,
  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,
  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,
  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039
]);

// Lookup table for pairwise char codes in range [0x00-0xFF]
// @ts-ignore: decorator
@lazy @inline const HEX_DIGITS =
"000102030405060708090a0b0c0d0e0f\\
101112131415161718191a1b1c1d1e1f\\
202122232425262728292a2b2c2d2e2f\\
303132333435363738393a3b3c3d3e3f\\
404142434445464748494a4b4c4d4e4f\\
505152535455565758595a5b5c5d5e5f\\
606162636465666768696a6b6c6d6e6f\\
707172737475767778797a7b7c7d7e7f\\
808182838485868788898a8b8c8d8e8f\\
909192939495969798999a9b9c9d9e9f\\
a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\
b0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\
c0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\
d0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\
e0e1e2e3e4e5e6e7e8e9eaebecedeeef\\
f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";

// @ts-ignore: decorator
@lazy @inline const ANY_DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz";

// @ts-ignore: decorator
@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */
  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,
   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,
   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,
   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,
   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,
    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,
    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,
    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,
    907,   933,   960,   986,  1013,  1039,  1066
/* eslint-enable indent */]);

// 1e-348, 1e-340, ..., 1e340
// @ts-ignore: decorator
@lazy @inline const FRC_POWERS = memory.data<u64>([
  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,
  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,
  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,
  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,
  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,
  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,
  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,
  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,
  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,
  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,
  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,
  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,
  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,
  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,
  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,
  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,
  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,
  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,
  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,
  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,
  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,
  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B
]);

// @ts-ignore: decorator
@inline
export function isPowerOf2<T extends number>(value: T): bool {
  return popcnt<T>(value) == 1;
}

// Count number of decimals for u32 values
// In our case input value always non-zero so we can simplify some parts
export function decimalCount32(value: u32): u32 {
  if (value < 100000) {
    if (value < 100) {
      return 1 + u32(value >= 10);
    } else {
      return 3 + u32(value >= 10000) + u32(value >= 1000);
    }
  } else {
    if (value < 10000000) {
      return 6 + u32(value >= 1000000);
    } else {
      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);
    }
  }
}

// Count number of decimals for u64 values
// In our case input value always greater than 2^32-1 so we can skip some parts
export function decimalCount64High(value: u64): u32 {
  if (value < 1000000000000000) {
    if (value < 1000000000000) {
      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);
    } else {
      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);
    }
  } else {
    if (value < 100000000000000000) {
      return 16 + u32(value >= 10000000000000000);
    } else {
      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);
    }
  }
}

function ulog_base(num: u64, base: i32): u32 {
  if (isPowerOf2(base)) {
    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;
  }
  let b64 = u64(base), b = b64, e: u32 = 1;
  while (num >= b) {
    num /= b;
    b *= b;
    e <<= 1;
  }
  while (num >= 1) {
    num /= b64;
    e++;
  }
  return e - 1;
}

function utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {
  while (num >= 10000) {
    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate
    let t = num / 10000;
    let r = num % 10000;
    num = t;

    let d1 = r / 100;
    let d2 = r % 100;

    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));
    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));

    offset -= 4;
    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));
  }

  if (num >= 100) {
    let t  = num / 100;
    let d1 = num % 100;
    num = t;
    offset -= 2;
    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));
    store<u32>(buffer + (offset << 1), digits);
  }

  if (num >= 10) {
    offset -= 2;
    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));
    store<u32>(buffer + (offset << 1), digits);
  } else {
    offset -= 1;
    let digit = CharCode._0 + num;
    store<u16>(buffer + (offset << 1), digit);
  }
}

function utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {
  while (num >= 100000000) {
    let t = num / 100000000;
    let r = <usize>(num - t * 100000000);
    num = t;

    let b = r / 10000;
    let c = r % 10000;

    let b1 = b / 100;
    let b2 = b % 100;
    let c1 = c / 100;
    let c2 = c % 100;

    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));
    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));

    offset -= 4;
    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));

    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));
    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));

    offset -= 4;
    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));
  }

  utoa32_dec_lut(buffer, <u32>num, offset);
}

function utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {
  const lut = changetype<usize>(HEX_DIGITS);
  while (offset >= 2) {
    offset -= 2;
    store<u32>(
      buffer + (offset << 1),
      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))
    );
    num >>= 8;
  }
  if (offset & 1) {
    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));
  }
}

function utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {
  do {
    let t = num / 10;
    let r = <u32>(num % 10);
    num = changetype<T>(t);
    offset--;
    store<u16>(buffer + (offset << 1), CharCode._0 + r);
  } while (num);
}

function utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {
  do {
    let d = num & 0x0F | CharCode._0;
    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);
    offset--;
    store<u16>(buffer + (offset << 1), d);
    // @ts-ignore: type
    num >>= 4;
  } while (num);
}

// @ts-ignore: decorator
@inline
export function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_dec_simple<u32>(buffer, num, offset);
  } else {
    utoa32_dec_lut(buffer, num, offset);
  }
}

// @ts-ignore: decorator
@inline
function utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_hex_simple<u32>(buffer, num, offset);
  } else {
    utoa_hex_lut(buffer, num, offset);
  }
}

// @ts-ignore: decorator
@inline
function utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_dec_simple<u64>(buffer, num, offset);
  } else {
    utoa64_dec_lut(buffer, num, offset);
  }
}

// @ts-ignore: decorator
@inline
function utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_hex_simple<u64>(buffer, num, offset);
  } else {
    utoa_hex_lut(buffer, num, offset);
  }
}

function utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {
  const lut = changetype<usize>(ANY_DIGITS);
  let base = u64(radix);
  if ((radix & (radix - 1)) == 0) { // for radix which pow of two
    let shift = u64(ctz(radix) & 7);
    let mask = base - 1;
    do {
      offset--;
      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));
      num >>= shift;
    } while (num);
  } else {
    do {
      offset--;
      let q = num / base;
      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));
      num = q;
    } while (num);
  }
}

export function utoa32(value: u32, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";
  let out: String;

  if (radix == 10) {
    let decimals = decimalCount32(value);
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa32_dec_core(changetype<usize>(out), value, decimals);
  } else if (radix == 16) {
    let decimals = (31 - clz(value) >> 2) + 1;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa32_hex_core(changetype<usize>(out), value, decimals);
  } else {
    let decimals = ulog_base(value, radix);
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_any_core(changetype<usize>(out), value, decimals, radix);
  }
  return out;
}

export function itoa32(value: i32, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";

  let sign = (value >>> 31) << 1;
  if (sign) value = -value;
  let out: String;

  if (radix == 10) {
    let decimals = decimalCount32(value);
    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));
    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);
  } else if (radix == 16) {
    let decimals = (31 - clz(value) >> 2) + 1;
    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));
    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);
  } else {
    let val32 = u32(value);
    let decimals = ulog_base(val32, radix);
    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));
    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);
  }
  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);
  return out;
}

export function utoa64(value: u64, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";
  let out: String;

  if (radix == 10) {
    if (value <= u32.MAX_VALUE) {
      let val32    = <u32>value;
      let decimals = decimalCount32(val32);
      out = changetype<String>(__new(decimals << 1, idof<String>()));
      utoa32_dec_core(changetype<usize>(out), val32, decimals);
    } else {
      let decimals = decimalCount64High(value);
      out = changetype<String>(__new(decimals << 1, idof<String>()));
      utoa64_dec_core(changetype<usize>(out), value, decimals);
    }
  } else if (radix == 16) {
    let decimals = (63 - u32(clz(value)) >> 2) + 1;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_hex_core(changetype<usize>(out), value, decimals);
  } else {
    let decimals = ulog_base(value, radix);
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_any_core(changetype<usize>(out), value, decimals, radix);
  }
  return out;
}

export function itoa64(value: i64, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";

  let sign = u32(value >>> 63) << 1;
  if (sign) value = -value;
  let out: String;

  if (radix == 10) {
    if (<u64>value <= <u64>u32.MAX_VALUE) {
      let val32    = <u32>value;
      let decimals = decimalCount32(val32);
      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));
      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);
    } else {
      let decimals = decimalCount64High(value);
      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));
      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);
    }
  } else if (radix == 16) {
    let decimals = (63 - u32(clz(value)) >> 2) + 1;
    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));
    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);
  } else {
    let decimals = ulog_base(value, radix);
    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));
    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);
  }
  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);
  return out;
}

// @ts-ignore: decorator
@lazy let _K: i32 = 0;

// // @ts-ignore: decorator
// @lazy
// let _frc: u64 = 0;

// @ts-ignore: decorator
@lazy let _exp: i32 = 0;

// @ts-ignore: decorator
@lazy let _frc_minus: u64 = 0;

// @ts-ignore: decorator
@lazy let _frc_plus:  u64 = 0;

// @ts-ignore: decorator
@lazy let _frc_pow: u64 = 0;

// @ts-ignore: decorator
@lazy let _exp_pow: i32 = 0;

// @ts-ignore: decorator
@inline
function umul64f(u: u64, v: u64): u64 {
  let u0 = u & 0xFFFFFFFF;
  let v0 = v & 0xFFFFFFFF;

  let u1 = u >> 32;
  let v1 = v >> 32;

  let l = u0 * v0;
  let t = u1 * v0 + (l >> 32);
  let w = u0 * v1 + (t & 0xFFFFFFFF);

  w += 0x7FFFFFFF; // rounding

  t >>= 32;
  w >>= 32;

  return u1 * v1 + t + w;
}

// @ts-ignore: decorator
@inline
function umul64e(e1: i32, e2: i32): i32 {
  return e1 + e2 + 64; // where 64 is significand size
}

// @ts-ignore: decorator
@inline
function normalizedBoundaries(f: u64, e: i32): void {
  let frc = (f << 1) + 1;
  let exp = e - 1;
  let off = <i32>clz<u64>(frc);
  frc <<= off;
  exp  -= off;

  let m = 1 + i32(f == 0x0010000000000000);

  _frc_plus  = frc;
  _frc_minus = ((f << m) - 1) << e - m - exp;
  _exp = exp;
}

// @ts-ignore: decorator
@inline
function grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {
  let lastp = buffer + ((len - 1) << 1);
  let digit = load<u16>(lastp);
  while (
    rest < wp_w &&
    delta - rest >= ten_kappa && (
      rest + ten_kappa < wp_w ||
      wp_w - rest > rest + ten_kappa - wp_w
    )
  ) {
    --digit;
    rest += ten_kappa;
  }
  store<u16>(lastp, digit);
}

// @ts-ignore: decorator
@inline
function getCachedPower(minExp: i32): void {
  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114
  let dk = (-61 - minExp) * c + 347;	            // dk must be positive, so can do ceiling in positive
  let k = <i32>dk;
  k += i32(k != dk); // conversion with ceil

  let index = (k >> 3) + 1;
  _K = 348 - (index << 3);	// decimal exponent no need lookup table
  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));
  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));
}

// @ts-ignore: decorator
@inline
function grisu2(value: f64, buffer: usize, sign: i32): i32 {

  // frexp routine
  let uv  = reinterpret<u64>(value);
  let exp = i32((uv & 0x7FF0000000000000) >>> 52);
  let sid = uv & 0x000FFFFFFFFFFFFF;
  let frc = (u64(exp != 0) << 52) + sid;
  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);

  normalizedBoundaries(frc, exp);
  getCachedPower(_exp);

  // normalize
  let off = <i32>clz<u64>(frc);
  frc <<= off;
  exp  -= off;

  let frc_pow = _frc_pow;
  let exp_pow = _exp_pow;

  let w_frc = umul64f(frc, frc_pow);
  let w_exp = umul64e(exp, exp_pow);

  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;
  let wp_exp = umul64e(_exp, exp_pow);

  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;
  let delta  = wp_frc - wm_frc;

  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);
}

function genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {
  let one_exp = -mp_exp;
  let one_frc = (<u64>1) << one_exp;
  let mask    = one_frc - 1;

  let wp_w_frc = mp_frc - w_frc;

  let p1 = u32(mp_frc >> one_exp);
  let p2 = mp_frc & mask;

  let kappa = <i32>decimalCount32(p1);
  let len = sign;

  while (kappa > 0) {
    let d: u32;
    switch (kappa) {
      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }
      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }
      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }
      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }
      case  6: { d = p1 /     100000; p1 %=     100000; break; }
      case  5: { d = p1 /      10000; p1 %=      10000; break; }
      case  4: { d = p1 /       1000; p1 %=       1000; break; }
      case  3: { d = p1 /        100; p1 %=        100; break; }
      case  2: { d = p1 /         10; p1 %=         10; break; }
      case  1: { d = p1;              p1 =           0; break; }
      default: { d = 0; break; }
    }

    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);

    --kappa;
    let tmp = ((<u64>p1) << one_exp) + p2;
    if (tmp <= delta) {
      _K += kappa;
      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);
      return len;
    }
  }

  while (true) {
    p2    *= 10;
    delta *= 10;

    let d = p2 >> one_exp;
    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);

    p2 &= mask;
    --kappa;
    if (p2 < delta) {
      _K += kappa;
      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));
      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);
      return len;
    }
  }
}

// @ts-ignore: decorator
@inline
function genExponent(buffer: usize, k: i32): i32 {
  let sign = k < 0;
  if (sign) k = -k;
  let decimals = decimalCount32(k) + 1;
  utoa32_dec_core(buffer, k, decimals);
  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));
  return decimals;
}

function prettify(buffer: usize, length: i32, k: i32): i32 {
  if (!k) {
    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));
    return length + 2;
  }

  let kk = length + k;
  if (length <= kk && kk <= 21) {
    // 1234e7 -> 12340000000
    for (let i = length; i < kk; ++i) {
      store<u16>(buffer + (i << 1), CharCode._0);
    }
    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));
    return kk + 2;
  } else if (kk > 0 && kk <= 21) {
    // 1234e-2 -> 12.34
    let ptr = buffer + (kk << 1);
    memory.copy(
      ptr + 2,
      ptr,
      -k << 1
    );
    store<u16>(buffer + (kk << 1), CharCode.DOT);
    return length + 1;
  } else if (-6 < kk && kk <= 0) {
    // 1234e-6 -> 0.001234
    let offset = 2 - kk;
    memory.copy(
      buffer + (offset << 1),
      buffer,
      length << 1
    );
    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));
    for (let i = 2; i < offset; ++i) {
      store<u16>(buffer + (i << 1), CharCode._0);
    }
    return length + offset;
  } else if (length == 1) {
    // 1e30
    store<u16>(buffer, CharCode.e, 2);
    length = genExponent(buffer + 4, kk - 1);
    return length + 2;
  } else {
    let len = length << 1;
    memory.copy(
      buffer + 4,
      buffer + 2,
      len - 2
    );
    store<u16>(buffer,       CharCode.DOT, 2);
    store<u16>(buffer + len, CharCode.e,   2);
    length += genExponent(buffer + len + 4, kk - 1);
    return length + 2;
  }
}

function dtoa_core(buffer: usize, value: f64): i32 {
  let sign = i32(value < 0);
  if (sign) {
    value = -value;
    store<u16>(buffer, CharCode.MINUS);
  }
  // assert(value > 0 && value <= 1.7976931348623157e308);
  let len = grisu2(value, buffer, sign);
  len = prettify(buffer + (sign << 1), len - sign, _K);
  return len + sign;
}

// @ts-ignore: decorator
@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);

export function dtoa(value: f64): String {
  if (value == 0) return "0.0";
  if (!isFinite(value)) {
    if (isNaN(value)) return "NaN";
    return select<String>("-Infinity", "Infinity", value < 0);
  }
  let size = dtoa_core(dtoa_buf, value) << 1;
  let result = changetype<String>(__new(size, idof<String>()));
  memory.copy(changetype<usize>(result), dtoa_buf, size);
  return result;
}

export function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {
  let sign: u32 = 0;
  if (isSigned<T>()) {
    sign = u32(value < 0);
    if (sign) {
      if (sizeof<T>() == 1) {
        if (value == -0x80) {
          // -0x80  ->  -128
          store<u64>(buffer,
            <u64>CharCode.MINUS |
            <u64>(CharCode._0 + 1) << 16 |
            <u64>(CharCode._0 + 2) << 32 |
            <u64>(CharCode._0 + 8) << 48
          );
          return 4;
        }
      }
      if (sizeof<T>() == 2) {
        if (value == -0x8000) {
          // -0x8000  ->  -32768
          store<u64>(buffer,
            <u64>CharCode.MINUS |
            <u64>(CharCode._0 + 3) << 16 |
            <u64>(CharCode._0 + 2) << 32 |
            <u64>(CharCode._0 + 7) << 48
          ); // -327
          store<u32>(buffer + 8,
            (CharCode._0 + 6) << 0 |
            (CharCode._0 + 8) << 16
          ); // 68
          return 6;
        }
      }
      store<u16>(buffer, CharCode.MINUS);
      // @ts-ignore
      value = -value;
    }
  }
  let dest = buffer + (sign << 1);
  if (ASC_SHRINK_LEVEL <= 1) {
    if (isSigned<T>()) {
      if (sizeof<T>() <= 4) {
        if (<u32>value < 10) {
          store<u16>(dest, value | CharCode._0);
          return 1 + sign;
        }
      } else {
        if (<u64>value < 10) {
          store<u16>(dest, value | CharCode._0);
          return 1 + sign;
        }
      }
    } else {
      if (value < 10) {
        store<u16>(buffer, value | CharCode._0);
        return 1;
      }
    }
  }
  let decimals: u32 = 0;
  if (sizeof<T>() <= 4) {
    let val32 = <u32>value;
    decimals = decimalCount32(val32);
    utoa32_dec_core(dest, val32, decimals);
  } else {
    if (<u64>value <= <u64>u32.MAX_VALUE) {
      let val32 = <u32>value;
      decimals = decimalCount32(val32);
      utoa32_dec_core(dest, val32, decimals);
    } else {
      let val64 = <u64>value;
      decimals = decimalCount64High(val64);
      utoa64_dec_core(dest, val64, decimals);
    }
  }
  return sign + decimals;
}

export function dtoa_buffered(buffer: usize, value: f64): u32 {
  if (value == 0) {
    store<u16>(buffer, CharCode._0);
    store<u16>(buffer, CharCode.DOT, 2);
    store<u16>(buffer, CharCode._0,  4);
    return 3;
  }
  if (!isFinite(value)) {
    if (isNaN(value)) {
      store<u16>(buffer, CharCode.N);
      store<u16>(buffer, CharCode.a, 2);
      store<u16>(buffer, CharCode.N, 4);
      return 3;
    } else {
      let sign = value < 0;
      if (sign) {
        store<u16>(buffer, CharCode.MINUS); // -
        buffer += 2;
      }
      store<u64>(buffer, 0x690066006E0049, 0); // ifnI
      store<u64>(buffer, 0x7900740069006E, 8); // ytin
      return 8 + u32(sign);
    }
  }
  return dtoa_core(buffer, value);
}
`,"util/sort":`import { compareImpl } from "./string";

type Comparator<T> = (a: T, b: T) => i32;

// @ts-ignore: decorator
@lazy @inline const EMPTY = u32.MAX_VALUE;
// @ts-ignore: decorator
@inline const INSERTION_SORT_THRESHOLD = 48;
// @ts-ignore: decorator
@inline const MIN_RUN_LENGTH = 32;

// @ts-ignore: decorator
@inline
function log2u(n: u32): u32 {
  return 31 - clz(n);
}

// @ts-ignore: decorator
@inline
export function COMPARATOR<T>(): Comparator<T> {
  if (isInteger<T>()) {
    if (isSigned<T>() && sizeof<T>() <= 4) {
      return (a, b) => i32(a) - i32(b);
    } else {
      return (a, b) => i32(a > b) - i32(a < b);
    }
  } else if (isFloat<T>()) {
    if (sizeof<T>() == 4) {
      return (a, b) => {
        let ia = reinterpret<i32>(f32(a));
        let ib = reinterpret<i32>(f32(b));
        ia ^= ia >> 31 >>> 1;
        ib ^= ib >> 31 >>> 1;
        return i32(ia > ib) - i32(ia < ib);
      };
    } else {
      return (a, b) => {
        let ia = reinterpret<i64>(f64(a));
        let ib = reinterpret<i64>(f64(b));
        ia ^= ia >> 63 >>> 1;
        ib ^= ib >> 63 >>> 1;
        return i32(ia > ib) - i32(ia < ib);
      };
    }
  } else if (isString<T>()) {
    return (a, b) => {
      if (
        changetype<usize>(a) == changetype<usize>(b) ||
        changetype<usize>(a) == 0 ||
        changetype<usize>(b) == 0
      ) return 0;
      let alen = changetype<string>(a).length;
      let blen = changetype<string>(b).length;
      if (!(alen | blen)) return 0;
      if (!alen) return -1;
      if (!blen) return  1;
      let res = compareImpl(
        changetype<string>(a), 0,
        changetype<string>(b), 0,
        <usize>min(alen, blen)
      );
      return res ? res : alen - blen;
    };
  } else {
    return (a, b) => i32(a > b) - i32(a < b);
  }
}

// Power Sort implementation (stable) from paper "Nearly-Optimal Mergesorts"
// https://arxiv.org/pdf/1805.04154.pdf
// This method usually outperform TimSort.
// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt
export function SORT<T>(
  ptr: usize,
  len: i32,
  comparator: Comparator<T>
): void {
  if (len <= INSERTION_SORT_THRESHOLD) {
    if (len <= 1) return;
    if (ASC_SHRINK_LEVEL < 1) {
      switch (len) {
        case 3: {
          let a = load<T>(ptr, 0);
          let b = load<T>(ptr, 1 << alignof<T>());
          let c = comparator(a, b) > 0;
          store<T>(ptr, select<T>(b, a, c), 0);
          a = select<T>(a, b, c);
          b = load<T>(ptr, 2 << alignof<T>());
          c = comparator(a, b) > 0;
          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());
          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());
        }
        case 2: {
          let a = load<T>(ptr, 0);
          let b = load<T>(ptr, 1 << alignof<T>());
          let c = comparator(a, b) > 0;
          store<T>(ptr, select<T>(b, a, c), 0);
          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());
          return;
        }
      }
    }
    insertionSort<T>(ptr, 0, len - 1, 0, comparator);
    return;
  }

  let lgPlus2         = log2u(len) + 2;
  let lgPlus2Size     = lgPlus2 << alignof<u32>();
  let leftRunStartBuf = __alloc(lgPlus2Size << 1);
  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;

  for (let i: u32 = 0; i < lgPlus2; ++i) {
    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);
  }

  let buffer = __alloc(len << alignof<T>());

  let hi   = len - 1;
  let endA = extendRunRight<T>(ptr, 0, hi, comparator);
  let lenA = endA + 1;

  if (lenA < MIN_RUN_LENGTH) {
    endA = min(hi, MIN_RUN_LENGTH - 1);
    insertionSort<T>(ptr, 0, endA, lenA, comparator);
  }

  let top: u32 = 0, startA = 0;
  while (endA < hi) {
    let startB = endA + 1;
    let endB = extendRunRight<T>(ptr, startB, hi, comparator);
    let lenB = endB - startB + 1;

    if (lenB < MIN_RUN_LENGTH) {
      endB = min(hi, startB + MIN_RUN_LENGTH - 1);
      insertionSort<T>(ptr, startB, endB, lenB, comparator);
    }

    let k = nodePower(0, hi, startA, startB, endB);

    for (let i = top; i > k; --i) {
      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));
      if (start != EMPTY) {
        mergeRuns<T>(
          ptr,
          start,
          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,
          endA,
          buffer,
          comparator
        );
        startA = start;
        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);
      }
    }

    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);
    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);
    startA = startB;
    endA = endB;
    top = k;
  }

  for (let i = top; i != 0; --i) {
    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));
    if (start != EMPTY) {
      mergeRuns<T>(
        ptr,
        start,
        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,
        hi,
        buffer,
        comparator
      );
    }
  }
  // dealloc aux buffers
  __free(buffer);
  __free(leftRunStartBuf);
}

function insertionSort<T>(
  ptr: usize,
  left: i32,
  right: i32,
  presorted: i32,
  comparator: Comparator<T>
): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    // slightly improved original insertion sort
    for (let i = left + presorted; i <= right; ++i) {
      let j = i - 1;
      let a = load<T>(ptr + (<usize>i << alignof<T>()));
      while (j >= left) {
        let b = load<T>(ptr + (<usize>j << alignof<T>()));
        if (comparator(a, b) < 0) {
          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;
        } else break;
      }
      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());
    }
  } else {
    // even-odd two-way insertion sort which allow increase minRunLen
    let range = right - left + 1;
    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);
    for (; i <= right; i += 2) {
      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);
      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());
      let min = b, max = a;
      if (comparator(a, b) <= 0) {
        min = a, max = b;
      }
      let j = i - 1;
      while (j >= left) {
        a = load<T>(ptr + (<usize>j << alignof<T>()));
        if (comparator(a, max) > 0) {
          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;
        } else break;
      }
      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());
      while (j >= left) {
        a = load<T>(ptr + (<usize>j << alignof<T>()));
        if (comparator(a, min) > 0) {
          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;
        } else break;
      }
      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());
    }
  }
}

function nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {
  let n: u64 = right - left + 1;
  let s = startB - (left << 1);
  let l = startA + s;
  let r = endB   + s + 1;
  let a = (<u64>l << 30) / n;
  let b = (<u64>r << 30) / n;
  return clz(<u32>(a ^ b));
}

function extendRunRight<T>(
  ptr: usize,
  i: i32,
  right: i32,
  comparator: Comparator<T>
): i32 {
  if (i == right) return i;
  let j = i;
  if (comparator(
    load<T>(ptr + (<usize>  j << alignof<T>())),
    load<T>(ptr + (<usize>++j << alignof<T>()))
  ) > 0) {
    while (
      j < right &&
      (comparator(
        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),
        load<T>(ptr + (<usize>j << alignof<T>()))
      ) >>> 31) // < 0
    ) ++j;
    // reverse
    let k = j;
    while (i < k) {
      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));
      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;
      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;
    }
  } else {
    while (
      j < right &&
      comparator(
        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),
        load<T>(ptr + (<usize>j << alignof<T>()))
      ) >= 0
    ) ++j;
  }
  return j;
}

// Merges arr[l..m - 1] and arr[m..r]
function mergeRuns<T>(
  ptr: usize,
  l: i32,
  m: i32,
  r: i32,
  buffer: usize,
  comparator: Comparator<T>
): void {
  --m;
  let i: i32, j: i32, t = r + m;
  for (i = m + 1; i > l; --i) {
    store<T>(
      buffer + (<usize>(i - 1) << alignof<T>()),
      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))
    );
  }
  for (j = m; j < r; ++j) {
    store<T>(
      buffer + (<usize>(t - j) << alignof<T>()),
      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())
    );
  }
  for (let k = l; k <= r; ++k) {
    let a = load<T>(buffer + (<usize>j << alignof<T>()));
    let b = load<T>(buffer + (<usize>i << alignof<T>()));
    if (comparator(a, b) < 0) {
      store<T>(ptr + (<usize>k << alignof<T>()), a);
      --j;
    } else {
      store<T>(ptr + (<usize>k << alignof<T>()), b);
      ++i;
    }
  }
}
`,"util/string":`import {
  itoa32,
  utoa32,
  itoa64,
  utoa64,
  dtoa,
  itoa_buffered,
  dtoa_buffered,
  MAX_DOUBLE_LENGTH
} from "./number";

import {
  ipow32
} from "../math";

// All tables are stored as two staged lookup tables (static tries)
// because the full range of Unicode symbols can't be efficiently
// represented as-is in memory (see Unicode spec ch 5, p.196):
// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf
// Tables have been generated using these forked musl tools:
// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable

// Lookup table to check if a character is alphanumeric or not
// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h
// size: 3904 bytes
// @ts-ignore
@inline @lazy const ALPHA_TABLE = memory.data<u8>([
  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,
  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,
  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,
  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,
  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,
  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,
  16,16,125,16,16,16,
  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,
  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,
  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,
  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,
  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,
  31,254,225,255,
  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,
  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,
  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,
  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,
  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,
  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,
  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,
  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,
  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,
  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,
  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,
  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,
  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,
  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,
  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,
  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,
  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,
  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,
  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,
  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,
  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,
  63,
  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,
  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,
  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,
  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,
  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,
  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,
  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,
  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,
  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,
  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,
  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,
  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,
  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,
  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,
  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,
  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,
  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,
  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,
  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,
  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,
  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,
  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,
  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,
  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,
  255,
  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,
  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,
  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,
  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,
  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,
  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,
  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,
  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,
  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,
  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,
  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,
  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,
  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,
  0,0,0,0,0,0,0,0,0,0,0,0,
  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,
  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,
  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,
  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,
  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,
  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,
  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,
  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,
  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,
  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,
  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,
  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,
  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,
  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,
  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,
  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,
  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,
  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,
  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,
  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,
  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,
  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,
  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,
  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,
  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,
  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,
  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,
  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,
  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,
  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,
  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,
  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,
  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,
  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,
  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,
  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3
]);

// size: 1568 bytes (compressed to ~1380 bytes after binaryen)
// @ts-ignore: decorator
@lazy @inline const CASED = memory.data<u8>([
  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,
  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,
  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,
  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,
  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,
  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,
  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,
  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,
  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,
  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,
  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,
  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,
  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,
  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,
  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,
  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,
  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,
  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,
  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,
  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,
  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,
  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,
  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,
  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,
  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0
]);

// size: 2976 bytes (compressed to ~2050 bytes after binaryen)
// @ts-ignore: decorator
@lazy @inline const CASE_IGNORABLES = memory.data<u8>([
  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,
  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,
  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,
  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,
  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,
  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,
  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,
  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,
  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,
  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,
  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,
  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,
  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,
  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,
  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,
  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,
  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,
  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,
  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,
  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,
  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,
  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,
  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,
  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,
  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,
  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,
  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,
  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,
  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,
  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,
  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,
  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,
  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,
  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,
  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,
  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,
  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,
  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,
  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,
  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,
  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,
  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,
  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,
  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,
  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,
  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,
  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,
  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,
  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,
  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,
  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,
  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,
  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,
  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,248
]);

// @ts-ignore: decorator
@lazy @inline const LOWER127 = memory.data<u8>([
  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
  64,
  97,98,99,100,101,102,103,104,105,106,107,108,109,
  110,111,112,113,114,115,116,117,118,119,120,121,122,
  91,92,93,94,95,96,
  97,98,99,100,101,102,103,104,105,106,107,108,109,
  110,111,112,113,114,115,116,117,118,119,120,121,122,
  123,124,125,126,127
]);

// @ts-ignore: decorator
@lazy @inline const UPPER127 = memory.data<u8>([
  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
  64,
  65,66,67,68,69,70,71,72,73,74,75,76,77,
  78,79,80,81,82,83,84,85,86,87,88,89,90,
  91,92,93,94,95,96,
  65,66,67,68,69,70,71,72,73,74,75,76,77,
  78,79,80,81,82,83,84,85,86,87,88,89,90,
  123,124,125,126,127
]);

// 23 * 8 = 184 bytes
// @ts-ignore: decorator
@lazy @inline const POWERS10 = memory.data<f64>([
  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,
  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
  1e20, 1e21, 1e22
]);

// @ts-ignore: decorator
@inline
export const enum CharCode {
  PERCENT = 0x25,
  PLUS = 0x2B,
  MINUS = 0x2D,
  DOT = 0x2E,
  _0 = 0x30,
  _1 = 0x31,
  _2 = 0x32,
  _3 = 0x33,
  _4 = 0x34,
  _5 = 0x35,
  _6 = 0x36,
  _7 = 0x37,
  _8 = 0x38,
  _9 = 0x39,
  A = 0x41,
  B = 0x42,
  E = 0x45,
  I = 0x49,
  N = 0x4E,
  O = 0x4F,
  X = 0x58,
  Z = 0x5A,
  a = 0x61,
  b = 0x62,
  e = 0x65,
  n = 0x6E,
  o = 0x6F,
  u = 0x75,
  x = 0x78,
  z = 0x7A
}

// @ts-ignore: decorator
@inline
export function isAscii(c: u32): bool {
  return !(c >> 7);
}

// @ts-ignore: decorator
@inline
export function isLower8(c: u32): bool {
  return c - CharCode.a < 26;
}

// @ts-ignore: decorator
@inline
export function isUpper8(c: u32): bool {
  return c - CharCode.A < 26;
}

export function isSpace(c: u32): bool {
  if (c < 0x1680) { // < <LS> (1)
    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>
    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0
    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);
  }
  if (c - 0x2000 <= 0x200A - 0x2000) return true;
  switch (c) {
    case 0x1680: // <LS> (1)
    case 0x2028: // <LS> (2)
    case 0x2029: // <PS>
    case 0x202F: // <NNS>
    case 0x205F: // <MMSP>
    case 0x3000: // <IS>
    case 0xFEFF: return true; // <ZWNBSP>
  }
  return false;
}

export function isAlpha(c: u32): bool {
  if (isAscii(c)) return (c | 32) - CharCode.a < 26;
  if (c < 0x20000) {
    // @ts-ignore: cast
    return stagedBinaryLookup(ALPHA_TABLE, c);
  }
  return c < 0x2FFFE;
}

// @ts-ignore: decorator
@inline
export function isCased(c: u32): bool {
  // @ts-ignore: cast
  return c < 0x1F18A && stagedBinaryLookup(CASED, c);
}

// @ts-ignore: decorator
@inline
export function isCaseIgnorable(c: u32): bool {
  // @ts-ignore: cast
  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);
}

// @ts-ignore: decorator
@inline
export function isFinalSigma(buffer: usize, index: isize, len: isize): bool {
  const lookaheadLimit = 30; // max lookahead limit
  let found = false;
  let pos = index;
  let minPos = max(0, pos - lookaheadLimit);
  while (pos > minPos) {
    let c = codePointBefore(buffer, pos);
    if (!isCaseIgnorable(c)) {
      if (isCased(c)) {
        found = true;
      } else {
        return false;
      }
    }
    pos -= isize(c >= 0x10000) + 1;
  }
  if (!found) return false;
  pos = index + 1;
  let maxPos = min(pos + lookaheadLimit, len);
  while (pos < maxPos) {
    let c = <u32>load<u16>(buffer + (pos << 1));
    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {
      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);
      if ((c1 & 0xFC00) == 0xDC00) {
        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;
      }
    }
    if (!isCaseIgnorable(c)) {
      return !isCased(c);
    }
    pos += isize(c >= 0x10000) + 1;
  }
  return true;
}

// @ts-ignore: decorator
@inline
function codePointBefore(buffer: usize, index: isize): i32 {
  if (index <= 0) return -1;
  let c = <u32>load<u16>(buffer + (index - 1 << 1));
  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {
    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));
    if ((c1 & 0xFC00) == 0xD800) {
      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;
    }
  }
  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;
}

// Search routine for two-staged lookup tables
function stagedBinaryLookup(table: usize, c: u32): bool {
  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);
}

export function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {
  let ptr1 = changetype<usize>(str1) + (index1 << 1);
  let ptr2 = changetype<usize>(str2) + (index2 << 1);
  if (ASC_SHRINK_LEVEL < 2) {
    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {
      do {
        if (load<u64>(ptr1) != load<u64>(ptr2)) break;
        ptr1 += 8;
        ptr2 += 8;
        len  -= 4;
      } while (len >= 4);
    }
  }
  while (len--) {
    let a = <i32>load<u16>(ptr1);
    let b = <i32>load<u16>(ptr2);
    if (a != b) return a - b;
    ptr1 += 2;
    ptr2 += 2;
  }
  return 0;
}

// @ts-ignore: decorator
@inline
export function toLower8(c: u32): u32 {
  if (ASC_SHRINK_LEVEL > 0) {
    return c | u32(isUpper8(c)) << 5;
  } else {
    return <u32>load<u8>(LOWER127 + c);
  }
}

// @ts-ignore: decorator
@inline
export function toUpper8(c: u32): u32 {
  if (ASC_SHRINK_LEVEL > 0) {
    return c & ~(u32(isLower8(c)) << 5);
  } else {
    return <u32>load<u8>(UPPER127 + c);
  }
}

/** Parses a string to an integer (usually), using the specified radix. */
export function strtol<T>(str: string, radix: i32 = 0): T {
  let len = str.length;
  if (!len) {
    if (isFloat<T>()) {
      // @ts-ignore: cast
      return <T>NaN;
    } else {
      // @ts-ignore: cast
      return <T>0;
    }
  }

  let ptr = changetype<usize>(str) /* + HEAD -> offset */;
  let code = <u32>load<u16>(ptr);

  // trim white spaces
  while (isSpace(code)) {
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  // determine sign
  // @ts-ignore
  let sign: T = 1;
  if (code == CharCode.MINUS || code == CharCode.PLUS) {
    if (!--len) {
      if (isFloat<T>()) {
        // @ts-ignore: cast
        return <T>NaN;
      } else {
        // @ts-ignore: cast
        return <T>0;
      }
    }
    if (code == CharCode.MINUS) {
      // @ts-ignore: type
      sign = -1;
    }
    code = <u32>load<u16>(ptr += 2);
  }

  // See https://tc39.es/ecma262/#sec-parseint-string-radix
  if (radix) {
    if (radix < 2 || radix > 36) {
      if (isFloat<T>()) {
        // @ts-ignore: cast
        return <T>NaN;
      } else {
        // @ts-ignore: cast
        return <T>0;
      }
    }
    // handle case as parseInt("0xFF", 16) by spec
    if (radix == 16) {
      if (
        len > 2 &&
        code == CharCode._0 &&
        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x
      ) {
        ptr += 4; len -= 2;
      }
    }
  } else {
    // determine radix by literal prefix
    if (code == CharCode._0 && len > 2) {
      switch (<u32>load<u16>(ptr, 2) | 32) {
        case CharCode.b: {
          ptr += 4; len -= 2;
          radix = 2;
          break;
        }
        case CharCode.o: {
          ptr += 4; len -= 2;
          radix = 8;
          break;
        }
        case CharCode.x: {
          ptr += 4; len -= 2;
          radix = 16;
          break;
        }
      }
    }
    if (!radix) radix = 10;
  }

  // calculate value
  // @ts-ignore: type
  let num: T = 0;
  let initial = len - 1;
  while (len--) {
    code = <u32>load<u16>(ptr);
    if (code - CharCode._0 < 10) {
      code -= CharCode._0;
    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {
      code -= CharCode.A - 10;
    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {
      code -= CharCode.a - 10;
    }
    if (code >= <u32>radix) {
      if (initial == len) {
        if (isFloat<T>()) {
          // @ts-ignore: cast
          return <T>NaN;
        } else {
          // @ts-ignore: cast
          return <T>0;
        }
      }
      break;
    }
    // @ts-ignore: type
    num = num * radix + code;
    ptr += 2;
  }
  // @ts-ignore: type
  return sign * num;
}

export function strtod(str: string): f64 {
  let len = str.length;
  if (!len) return NaN;

  let ptr  = changetype<usize>(str);
  let code = <u32>load<u16>(ptr);

  let sign = 1.0;
  // skip white spaces
  while (len && isSpace(code)) {
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  if (!len) return NaN;

  // try parse '-' or '+'
  if (code == CharCode.MINUS) {
    if (!--len) return NaN;
    code = <u32>load<u16>(ptr += 2);
    sign = -1;
  } else if (code == CharCode.PLUS) {
    if (!--len) return NaN;
    code = <u32>load<u16>(ptr += 2);
  }

  // try parse Infinity
  if (len >= 8 && code == CharCode.I) {
    if (
      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI
      load<u64>(ptr, 8) == 0x7900740069006E    // ytin
    ) {
      return Infinity * sign;
    }
    return NaN;
  }
  // validate next symbol
  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {
    return NaN;
  }
  let savedPtr = ptr;
  // skip zeros
  while (code == CharCode._0) {
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  if (len <= 0) return 0.0 * sign;
  const capacity = 19; // int(64 * 0.3010)
  let pointed = false;
  let consumed = 0;
  let position = 0;
  let x: u64 = 0;
  if (code == CharCode.DOT) {
    let noDigits = !(savedPtr - ptr);
    ptr += 2; --len;
    if (!len && noDigits) return NaN;
    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;
    if (len <= 0) return 0.0 * sign;
    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;
  }
  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {
    if (digit < 10) {
      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);
      ++consumed;
    } else {
      position = consumed;
      pointed = true;
    }
    if (!--len) break;
    code = <u32>load<u16>(ptr += 2);
  }

  if (!pointed) position = consumed;
  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);
}

export function strtob(str: string): bool {
  let size: usize = str.length << 1;
  let offset: usize = 0;
  if (size > 8) {
    // try trim end whitespaces first
    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;
    if (size > 8) {
      // trim start whitespaces
      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;
      size -= offset;
    }
  }
  if (size != 8) return false;
  // "true" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)
  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;
}

export function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {
  let lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) return select("true", "false", load<bool>(dataStart));

  let sepLen = separator.length;
  let valueLen = 5; // max possible length of element len("false")
  let estLen = (valueLen + sepLen) * lastIndex + valueLen;
  let result = changetype<string>(__new(estLen << 1, idof<string>()));
  let offset = 0;
  let value: bool;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<bool>(dataStart + i);
    valueLen = 4 + i32(!value);
    memory.copy(
      changetype<usize>(result) + (<usize>offset << 1),
      changetype<usize>(select("true", "false", value)),
      <usize>valueLen << 1
    );
    offset += valueLen;
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<bool>(dataStart + <usize>lastIndex);
  valueLen = 4 + i32(!value);
  memory.copy(
    changetype<usize>(result) + (<usize>offset << 1),
    changetype<usize>(select("true", "false", value)),
    valueLen << 1
  );
  offset += valueLen;

  if (estLen > offset) return result.substring(0, offset);
  return result;
}

export function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {
  let lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) {
    let value = load<T>(dataStart);
    if (isSigned<T>()) {
      if (sizeof<T>() <= 4) {
        // @ts-ignore: type
        return changetype<string>(itoa32(<i32>value, 10));
      } else {
        // @ts-ignore: type
        return changetype<string>(itoa64(<i32>value, 10));
      }
    } else {
      if (sizeof<T>() <= 4) {
        // @ts-ignore: type
        return changetype<string>(utoa32(<u32>value, 10));
      } else {
        // @ts-ignore: type
        return changetype<string>(utoa64(<u64>value, 10));
      }
    }
  }

  let sepLen = separator.length;
  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());
  let estLen = (valueLen + sepLen) * lastIndex + valueLen;
  let result = changetype<string>(__new(estLen << 1, idof<string>()));
  let offset = 0;
  let value: T;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<T>(dataStart + (<usize>i << alignof<T>()));
    // @ts-ignore: type
    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));
  // @ts-ignore: type
  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);
  if (estLen > offset) return result.substring(0, offset);
  return result;
}

export function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {
  let lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) {
    return changetype<string>(dtoa(
      // @ts-ignore: type
      load<T>(dataStart))
    );
  }

  const valueLen = MAX_DOUBLE_LENGTH;
  let sepLen = separator.length;
  let estLen = (valueLen + sepLen) * lastIndex + valueLen;
  let result = changetype<string>(__new(estLen << 1, idof<string>()));
  let offset = 0;
  let value: T;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<T>(dataStart + (<usize>i << alignof<T>()));
    // @ts-ignore: type
    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));
  // @ts-ignore: type
  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);
  if (estLen > offset) return result.substring(0, offset);
  return result;
}

export function joinStringArray(dataStart: usize, length: i32, separator: string): string {
  let lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) {
    // @ts-ignore: type
    return load<string>(dataStart) || "";
  }
  let estLen = 0;
  let value: string;
  for (let i = 0; i < length; ++i) {
    value = load<string>(dataStart + (<usize>i << alignof<string>()));
    if (changetype<usize>(value) != 0) estLen += value.length;
  }
  let offset = 0;
  let sepLen = separator.length;
  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));
  for (let i = 0; i < lastIndex; ++i) {
    value = load<string>(dataStart + (<usize>i << alignof<string>()));
    if (changetype<usize>(value) != 0) {
      let valueLen = value.length;
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(value),
        <usize>valueLen << 1
      );
      offset += valueLen;
    }
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));
  if (changetype<usize>(value) != 0) {
    memory.copy(
      changetype<usize>(result) + (<usize>offset << 1),
      changetype<usize>(value),
      <usize>value.length << 1
    );
  }
  return result;
}

export function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {
  let lastIndex = length - 1;
  if (lastIndex < 0) return "";
  let value: T;
  if (!lastIndex) {
    value = load<T>(dataStart);
    // @ts-ignore: type
    return value != null ? value.toString() : "";
  }
  let result = "";
  let sepLen = separator.length;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<T>(dataStart + (<usize>i << alignof<T>()));
    // @ts-ignore: type
    if (value != null) result += value.toString();
    if (sepLen) result += separator;
  }
  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));
  // @ts-ignore: type
  if (value != null) result += value.toString();
  return result;
}

// @ts-ignore: decorator
@inline
function scientific(significand: u64, exp: i32): f64 {
  if (!significand || exp < -342) return 0;
  if (exp > 308) return Infinity;
  // Try use fast path
  // Use fast path for string-to-double conversion if possible
  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion
  // Simple integer
  let significandf = <f64>significand;
  if (!exp) return significandf;
  if (exp > 22 && exp <= 22 + 15) {
    significandf *= pow10(exp - 22);
    exp = 22;
  }
  if (significand <= 9007199254740991 && abs(exp) <= 22) {
    if (exp > 0) return significandf * pow10(exp);
    return significandf / pow10(-exp);
  } else if (exp < 0) {
    return scaledown(significand, exp);
  } else {
    return scaleup(significand, exp);
  }
}

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function scaledown(significand: u64, exp: i32): f64 {
  const denom: u64 = 6103515625; // 1e14 * 0x1p-14
  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32

  let shift = clz(significand);
  significand <<= shift;
  shift = exp - shift;

  for (; exp <= -14; exp += 14) {
    let q = significand / denom;
    let r = significand % denom;
    let s = clz(q);
    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));
    shift -= s;
  }
  let b = <u64>ipow32(5, -exp);
  let q = significand / b;
  let r = significand % b;
  let s = clz(q);
  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);
  shift -= s;

  return NativeMath.scalbn(<f64>significand, <i32>shift);
}

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function scaleup(significand: u64, exp: i32): f64 {
  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;
  let shift = ctz(significand);
  significand >>= shift;
  shift += exp;

  __fixmulShift = shift;
  for (; exp >= 13; exp -= 13) {
    significand = fixmul(significand, coeff);
  }
  significand = fixmul(significand, <u32>ipow32(5, exp));
  shift = __fixmulShift;
  return NativeMath.scalbn(<f64>significand, <i32>shift);
}

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function parseExp(ptr: usize, len: i32): i32 {
  let sign = 1, magnitude = 0;
  let code = <u32>load<u16>(ptr);
  // check code is 'e' or 'E'
  if ((code | 32) != CharCode.e) return 0;

  if (!--len) return 0;
  code = <u32>load<u16>(ptr += 2);
  if (code == CharCode.MINUS) {
    if (!--len) return 0;
    code = <u32>load<u16>(ptr += 2);
    sign = -1;
  } else if (code == CharCode.PLUS) {
    if (!--len) return 0;
    code = <u32>load<u16>(ptr += 2);
  }
  // skip zeros
  while (code == CharCode._0) {
    if (!--len) return 0;
    code = <u32>load<u16>(ptr += 2);
  }
  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {
    if (magnitude >= 3200) return sign * 3200;
    magnitude = 10 * magnitude + digit;
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  return sign * magnitude;
}

// @ts-ignore: decorator
@lazy let __fixmulShift: u64 = 0;

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function fixmul(a: u64, b: u32): u64 {
  let low  = (a & 0xFFFFFFFF) * b;
  let high = (a >> 32) * b + (low >> 32);
  let overflow = <u32>(high >> 32);
  let space = clz(overflow);
  let revspace: u64 = 32 - space;
  __fixmulShift += revspace;
  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);
}

// @ts-ignore: decorator
@inline
function pow10(n: i32): f64 {
  // argument \`n\` should bounds in [0, 22] range
  return load<f64>(POWERS10 + (n << alignof<f64>()));
}
`,"util/uri":`import { E_URI_MALFORMED } from "./error";
import { CharCode } from "./string";

// Truncated lookup boolean table that helps us quickly determine
// if a char needs to be escaped for URIs (RFC 2396).
// @ts-ignore: decorator
@lazy export const URI_UNSAFE = memory.data<u8>([
/* skip 32 + 1 always set to '1' head slots
  */ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*
  skip 128 + 1 always set to '1' tail slots */
]);

// Truncated lookup boolean table that helps us quickly determine
// if a char needs to be escaped for URLs (RFC 3986).
// @ts-ignore: decorator
@lazy export const URL_UNSAFE = memory.data<u8>([
/* skip 32 + 1 always set to '1' head slots
  */ 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*
  skip 128 + 1 always set to '1' tail slots */
]);

// Truncated lookup boolean table for determine reserved chars: ;/?:@&=+$,#
// @ts-ignore: decorator
@lazy export const URI_RESERVED = memory.data<u8>([
  /*  skip 32 + 3 always set to '0' head slots
        */ 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1,
  1, /* skip 191 always set to '0' tail slots */
]);

export function encode(src: usize, len: usize, table: usize): usize {
  if (!len) return src;

  let i: usize = 0, offset: usize = 0, outSize = len << 1;
  let dst = __new(outSize, idof<String>());

  while (i < len) {
    let org = i;
    let c: u32, c1: u32;
    // fast scan a check chars until it valid ASCII
    // and safe for copying withoud escaping.
    do {
      c = <u32>load<u16>(src + (i << 1));
      // is it valid ASII and safe?
      if (c - 33 < 94) { // 127 - 33
        if (load<u8>(table + (c - 33))) break;
      } else break;
    } while (++i < len);

    // if we have some safe range of sequence just copy it without encoding
    if (i > org) {
      let size = i - org << 1;
      if (offset + size > outSize) {
        outSize = offset + size;
        dst = __renew(dst, outSize);
      }
      // TODO: should we optimize for short cases like 2 byte size?
      memory.copy(
        dst + offset,
        src + (org << 1),
        size
      );
      offset += size;
      // return if we reach end on input string
      if (i >= len) break;
    }

    // decode UTF16 with checking for unpaired surrogates
    if (c >= 0xD800) {
      if (c >= 0xDC00 && c <= 0xDFFF) {
        throw new URIError(E_URI_MALFORMED);
      }
      if (c <= 0xDBFF) {
        if (i >= len) {
          throw new URIError(E_URI_MALFORMED);
        }
        c1 = <u32>load<u16>(src + (++i << 1));
        if (c1 < 0xDC00 || c1 > 0xDFFF) {
          throw new URIError(E_URI_MALFORMED);
        }
        c = (((c & 0x3FF) << 10) | (c1 & 0x3FF)) + 0x10000;
      }
    }

    let estSize = offset + (c < 0x80 ? 1 * 6 : 4 * 6);
    if (estSize > outSize) {
      // doubling estimated size but only for greater than one
      // input lenght due to we already estemated it for worst case
      outSize = len > 1 ? estSize << 1 : estSize;
      dst = __renew(dst, outSize);
    }

    if (c < 0x80) {
      // encode ASCII unsafe code point
      storeHex(dst, offset, c);
      offset += 6;
    } else {
      // encode UTF-8 unsafe code point
      if (c < 0x800) {
        storeHex(dst, offset, (c >> 6) | 0xC0);
        offset += 6;
      } else {
        if (c < 0x10000) {
          storeHex(dst, offset, (c >> 12) | 0xE0);
          offset += 6;
        } else {
          storeHex(dst, offset, (c >> 18) | 0xF0);
          offset += 6;
          storeHex(dst, offset, (c >> 12 & 0x3F) | 0x80);
          offset += 6;
        }
        storeHex(dst, offset, (c >> 6 & 0x3F) | 0x80);
        offset += 6;
      }
      storeHex(dst, offset, (c & 0x3F) | 0x80);
      offset += 6;
    }
    ++i;
  }
  // shink output string buffer if necessary
  if (outSize > offset) {
    dst = __renew(dst, offset);
  }
  return dst;
}

export function decode(src: usize, len: usize, component: bool): usize {
  if (!len) return src;

  let i: usize = 0, offset: usize = 0, ch: u32 = 0;
  let dst = __new(len << 1, idof<String>());

  while (i < len) {
    let org = i;
    while (i < len && (ch = load<u16>(src + (i << 1))) != CharCode.PERCENT) i++;

    if (i > org) {
      let size = i - org << 1;
      // TODO: should we optimize for short cases like 2 byte size?
      memory.copy(
        dst + offset,
        src + (org << 1),
        size
      );
      offset += size;
      if (i >= len) break;
    }

    // decode hex
    if (
      i + 2 >= len ||
      ch != CharCode.PERCENT ||
      (ch = loadHex(src, i + 1 << 1)) == -1
    ) throw new URIError(E_URI_MALFORMED);

    i += 3;
    if (ch < 0x80) {
      if (!component && isReserved(ch)) {
        ch = CharCode.PERCENT;
        i -= 2;
      }
    } else {
      // decode UTF-8 sequence
      let nb = utf8LenFromUpperByte(ch);
      // minimal surrogate: 2 => 0x80, 3 => 0x800, 4 => 0x10000, _ => -1
      let lo: u32 = 1 << (17 * nb >> 2) - 1;
      // mask: 2 => 31, 3 => 15, 4 => 7, _ =>  0
      ch &= nb ? (0x80 >> nb) - 1 : 0;

      while (--nb != 0) {
        let c1: u32;
        // decode hex
        if (
          i + 2 >= len ||
          load<u16>(src + (i << 1)) != CharCode.PERCENT ||
          (c1 = loadHex(src, i + 1 << 1)) == -1
        ) throw new URIError(E_URI_MALFORMED);

        i += 3;
        if ((c1 & 0xC0) != 0x80) {
          ch = 0;
          break;
        }
        ch = (ch << 6) | (c1 & 0x3F);
      }

      // check if UTF8 code point properly fit into invalid UTF16 encoding
      if (ch < lo || lo == -1 || ch > 0x10FFFF || (ch >= 0xD800 && ch < 0xE000)) {
        throw new URIError(E_URI_MALFORMED);
      }

      // encode UTF16
      if (ch >= 0x10000) {
        ch -= 0x10000;
        let lo = ch >> 10 | 0xD800;
        let hi = (ch & 0x03FF) | 0xDC00;
        store<u32>(dst + offset, lo | (hi << 16));
        offset += 4;
        continue;
      }
    }
    store<u16>(dst + offset, ch);
    offset += 2;
  }

  assert(offset <= (len << 1));
  // shink output string buffer if necessary
  if ((len << 1) > offset) {
    dst = __renew(dst, offset);
  }
  return dst;
}

function storeHex(dst: usize, offset: usize, ch: u32): void {
  // @ts-ignore: decorator
  const HEX_CHARS = memory.data<u8>([
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46
  ]);

  store<u16>(dst + offset, CharCode.PERCENT, 0); // %
  store<u32>(
    dst + offset,
    <u32>load<u8>(HEX_CHARS + (ch >> 4 & 0x0F)) |
    <u32>load<u8>(HEX_CHARS + (ch      & 0x0F)) << 16,
    2
  ); // XX
}

function loadHex(src: usize, offset: usize): u32 {
  let c0 = <u32>load<u16>(src + offset, 0);
  let c1 = <u32>load<u16>(src + offset, 2);
  return isHex(c0) && isHex(c1)
    ? fromHex(c0) << 4 | fromHex(c1)
    : -1;
}

// @ts-ignore: decorator
@inline function fromHex(ch: u32): u32 {
  return (ch | 32) % 39 - 9;
}

// @ts-ignore: decorator
@inline function utf8LenFromUpperByte(c0: u32): u32 {
  // same as
  // if (c0 - 0xC0 <= 0xDF - 0xC0) return 2;
  // if (c0 - 0xE0 <= 0xEF - 0xE0) return 3;
  // if (c0 - 0xF0 <= 0xF7 - 0xF0) return 4;
  // return 0;
  return c0 - 0xC0 < 56
    ? clz(~(c0 << 24))
    : 0;
}

// @ts-ignore: decorator
@inline function isReserved(ch: u32): bool {
  return ch - 35 < 30
    ? <bool>load<u8>(URI_RESERVED + (ch - 35))
    : false;
}

// @ts-ignore: decorator
@inline function isHex(ch: u32): bool {
  return (ch - CharCode._0 < 10) || ((ch | 32) - CharCode.a < 6);
}
`,vector:`/** Vector abstraction. */
@final @unmanaged
export abstract class V128 {
}
`},kc={assembly:`/**
 * Environment definitions for compiling AssemblyScript to WebAssembly using asc.
 * @module std/assembly
 *//***/

/// <reference no-default-lib="true"/>

// Types

/** An 8-bit signed integer. */
declare type i8 = number;
/** A 16-bit signed integer. */
declare type i16 = number;
/** A 32-bit signed integer. */
declare type i32 = number;
/** A 64-bit signed integer. */
declare type i64 = number;
/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */
declare type isize = number;
/** An 8-bit unsigned integer. */
declare type u8 = number;
/** A 16-bit unsigned integer. */
declare type u16 = number;
/** A 32-bit unsigned integer. */
declare type u32 = number;
/** A 64-bit unsigned integer. */
declare type u64 = number;
/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */
declare type usize = number;
/** A 1-bit unsigned integer. */
declare type bool = boolean | number;
/** A 32-bit float. */
declare type f32 = number;
/** A 64-bit float. */
declare type f64 = number;
/** A 128-bit vector. */
declare type v128 = object;
/** Function reference. */
declare type funcref = object | null;
/** External reference. */
declare type externref = object | null;
/** Any reference. */
declare type anyref = object | null;
/** Equatable reference. */
declare type eqref = object | null;
/** 31-bit integer reference. */
declare type i31ref = object | null;
/** Data reference. */
declare type dataref = object | null;
/** Array reference. */
declare type arrayref = object | null;
/** String reference. */
declare type stringref = object | null;
/** WTF-8 string view. */
declare type stringview_wtf8 = object | null;
/** WTF-16 string view. */
declare type stringview_wtf16 = object | null;
/** String iterator. */
declare type stringview_iter = object | null;

// Compiler hints

/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */
declare const ASC_TARGET: i32;
/** Runtime type. 0 = Stub, 1 = Minimal, 2 = Incremental. */
declare const ASC_RUNTIME: i32;
/** Provided noAssert option. */
declare const ASC_NO_ASSERT: bool;
/** Provided memoryBase option. */
declare const ASC_MEMORY_BASE: i32;
/** Provided tableBase option. */
declare const ASC_TABLE_BASE: i32;
/** Provided optimizeLevel option. */
declare const ASC_OPTIMIZE_LEVEL: i32;
/** Provided shrinkLevel option. */
declare const ASC_SHRINK_LEVEL: i32;
/** Provided lowMemoryLimit option. */
declare const ASC_LOW_MEMORY_LIMIT: i32;
/** Provided noExportRuntime option. */
declare const ASC_NO_EXPORT_RUNTIME: i32;
/** Whether the sign extension feature is enabled. */
declare const ASC_FEATURE_SIGN_EXTENSION: bool;
/** Whether the mutable globals feature is enabled. */
declare const ASC_FEATURE_MUTABLE_GLOBALS: bool;
/** Whether the non-trapping float-to-int feature is enabled. */
declare const ASC_FEATURE_NONTRAPPING_F2I: bool;
/** Whether the bulk memory feature is enabled. */
declare const ASC_FEATURE_BULK_MEMORY: bool;
/** Whether the SIMD feature is enabled. */
declare const ASC_FEATURE_SIMD: bool;
/** Whether the threads feature is enabled. */
declare const ASC_FEATURE_THREADS: bool;
/** Whether the exception handling feature is enabled. */
declare const ASC_FEATURE_EXCEPTION_HANDLING: bool;
/** Whether the tail calls feature is enabled. */
declare const ASC_FEATURE_TAIL_CALLS: bool;
/** Whether the reference types feature is enabled. */
declare const ASC_FEATURE_REFERENCE_TYPES: bool;
/** Whether the multi value types feature is enabled. */
declare const ASC_FEATURE_MULTI_VALUE: bool;
/** Whether the garbage collection feature is enabled. */
declare const ASC_FEATURE_GC: bool;
/** Whether the memory64 feature is enabled. */
declare const ASC_FEATURE_MEMORY64: bool;
/** Whether the relaxed SIMD feature is enabled. */
declare const ASC_FEATURE_RELAXED_SIMD: bool;
/** Whether the extended const expression feature is enabled. */
declare const ASC_FEATURE_EXTENDED_CONST: bool;
/** Whether the string references feature is enabled. */
declare const ASC_FEATURE_STRINGREF: bool;
/** Major version of the compiler. */
declare const ASC_VERSION_MAJOR: i32;
/** Minor version of the compiler. */
declare const ASC_VERSION_MINOR: i32;
/** Patch version of the compiler. */
declare const ASC_VERSION_PATCH: i32;

// Builtins

/** Performs the sign-agnostic reverse bytes **/
declare function bswap<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;
/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */
declare function clz<T extends i32 | i64>(value: T): T;
/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */
declare function ctz<T extends i32 | i64>(value: T): T;
/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */
declare function popcnt<T extends i32 | i64>(value: T): T;
/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */
declare function rotl<T extends i32 | i64>(value: T, shift: T): T;
/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */
declare function rotr<T extends i32 | i64>(value: T, shift: T): T;
/** Computes the absolute value of an integer or float. */
declare function abs<T extends i32 | i64 | f32 | f64>(value: T): T;
/** Determines the maximum of two integers or floats. If either operand is \`NaN\`, returns \`NaN\`. */
declare function max<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Determines the minimum of two integers or floats. If either operand is \`NaN\`, returns \`NaN\`. */
declare function min<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Performs the ceiling operation on a 32-bit or 64-bit float. */
declare function ceil<T extends f32 | f64>(value: T): T;
/** Composes a 32-bit or 64-bit float from the magnitude of \`x\` and the sign of \`y\`. */
declare function copysign<T extends f32 | f64>(x: T, y: T): T;
/** Performs the floor operation on a 32-bit or 64-bit float. */
declare function floor<T extends f32 | f64>(value: T): T;
/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */
declare function nearest<T extends f32 | f64>(value: T): T;
/** Reinterprets the bits of the specified value as type \`T\`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */
declare function reinterpret<T extends i32 | i64 | f32 | f64>(value: number): T;
/** Selects one of two pre-evaluated values depending on the condition. */
declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;
/** Calculates the square root of a 32-bit or 64-bit float. */
declare function sqrt<T extends f32 | f64>(value: T): T;
/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */
declare function trunc<T extends f32 | f64>(value: T): T;
/** Computes the sum of two integers or floats. */
declare function add<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Computes the difference of two integers or floats. */
declare function sub<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Computes the product of two integers or floats. */
declare function mul<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Computes the quotient of two integers or floats. */
declare function div<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Return 1 if two numbers are equal to each other, 0 otherwise. */
declare function eq<T extends i32 | i64 | f32 | f64>(left: T, right: T): i32;
/** Return 0 if two numbers are equal to each other, 1 otherwise. */
declare function ne<T extends i32 | i64 | f32 | f64>(left: T, right: T): i32;
/** Computes the remainder of two integers. */
declare function rem<T extends i32 | i64>(left: T, right: T): T;
/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */
declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;
/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */
declare function store<T>(ptr: usize, value: T, immOffset?: usize, immAlign?: usize): void;
/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression. */
declare function unreachable(): never;

/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */
declare const NaN: f32 | f64;
/** Positive infinity as a 32-bit or 64-bit float depending on context. */
declare const Infinity: f32 | f64;
/** Data end offset. */
declare const __data_end: usize;
/** Stack pointer offset. */
declare let __stack_pointer: usize;
/** Heap base offset. */
declare const __heap_base: usize;
/** Determines the byte size of the specified underlying core type. Compiles to a constant. */
declare function sizeof<T>(): usize;
/** Determines the alignment (log2) of the specified underlying core type. Compiles to a constant. */
declare function alignof<T>(): usize;
/** Determines the end offset of the given class type. Compiles to a constant. */
declare function offsetof<T>(): usize;
/** Determines the offset of the specified field within the given class type. Compiles to a constant. */
declare function offsetof<T>(fieldName: keyof T | string): usize;
/** Determines the offset of the specified field within the given class type. Returns the class type's end offset if field name has been omitted. Compiles to a constant. */
declare function offsetof<T>(fieldName?: string): usize;
/** Determines the name of a given type. */
declare function nameof<T>(value?: T): string;
/** Determines the unique runtime id of a class type. Compiles to a constant. */
declare function idof<T>(): u32;
/** Changes the type of any value of \`usize\` kind to another one of \`usize\` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/
declare function changetype<T>(value: any): T;
/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */
declare function unchecked<T>(value: T): T;
/** Emits a \`call_indirect\` instruction, calling the specified function in the function table by index with the specified arguments. Does result in a runtime error if the arguments do not match the called function. */
declare function call_indirect<T>(index: u32, ...args: unknown[]): T;
/** Instantiates a new instance of \`T\` using the specified constructor arguments. */
declare function instantiate<T>(...args: any[]): T;
/** Tests if a 32-bit or 64-bit float is \`NaN\`. */
declare function isNaN<T extends f32 | f64>(value: T): bool;
/** Tests if a 32-bit or 64-bit float is finite, that is not \`NaN\` or +/-\`Infinity\`. */
declare function isFinite<T extends f32 | f64>(value: T): bool;
/** Tests if the specified type *or* expression is of a boolean type. */
declare function isBoolean<T>(value?: any): value is number;
/** Tests if the specified type *or* expression is of an integer type and not a reference. Compiles to a constant. */
declare function isInteger<T>(value?: any): value is number;
/** Tests if the specified type *or* expression can represent negative numbers. Compiles to a constant. */
declare function isSigned<T>(value?: any): value is number;
/** Tests if the specified type *or* expression is of a float type. Compiles to a constant. */
declare function isFloat<T>(value?: any): value is number;
/** Tests if the specified type *or* expression is of a v128 type. Compiles to a constant. */
declare function isVector<T>(value?: any): value is v128;
/** Tests if the specified type *or* expression is of a reference type. Compiles to a constant. */
declare function isReference<T>(value?: any): value is object | string;
/** Tests if the specified type *or* expression can be used as a string. Compiles to a constant. */
declare function isString<T>(value?: any): value is string | String;
/** Tests if the specified type *or* expression can be used as an array. Compiles to a constant. */
declare function isArray<T>(value?: any): value is Array<any>;
/** Tests if the specified type *or* expression can be used as an array like object. Compiles to a constant. */
declare function isArrayLike<T>(value?: any): value is ArrayLike<any>;
/** Tests if the specified type *or* expression is of a function type. Compiles to a constant. */
declare function isFunction<T>(value?: any): value is (...args: any) => any;
/** Tests if the specified type *or* expression is of a nullable reference type. Compiles to a constant. */
declare function isNullable<T>(value?: any): bool;
/** Tests if the specified expression resolves to a defined element. Compiles to a constant. */
declare function isDefined(expression: any): bool;
/** Tests if the specified expression evaluates to a constant value. Compiles to a constant. */
declare function isConstant(expression: any): bool;
/** Tests if the specified type *or* expression is of a managed type. Compiles to a constant. */
declare function isManaged<T>(value?: any): bool;
/** Tests if the specified type is void. Compiles to a constant. */
declare function isVoid<T>(): bool;
/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */
declare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model \`: T != null\`?
/** Parses an integer string to a 64-bit float. */
declare function parseInt(str: string, radix?: i32): f64;
/** Parses a string to a 64-bit float. */
declare function parseFloat(str: string): f64;
/** Returns the 64-bit floating-point remainder of \`x/y\`. */
declare function fmod(x: f64, y: f64): f64;
/** Returns the 32-bit floating-point remainder of \`x/y\`. */
declare function fmodf(x: f32, y: f32): f32;
/** Returns the number of parameters in the given function signature type. */
declare function lengthof<T extends (...args: any[]) => any>(func?: T): i32;
/** Encodes a text string as a valid Uniform Resource Identifier (URI). */
declare function encodeURI(str: string): string;
/** Encodes a text string as a valid component of a Uniform Resource Identifier (URI). */
declare function encodeURIComponent(str: string): string;
/** Decodes a Uniform Resource Identifier (URI) previously created by encodeURI. */
declare function decodeURI(str: string): string;
/** Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent. */
declare function decodeURIComponent(str: string): string;

/** Atomic operations. */
declare namespace atomic {
  /** Atomically loads an integer value from memory and returns it. */
  export function load<T>(ptr: usize, immOffset?: usize): T;
  /** Atomically stores an integer value to memory. */
  export function store<T>(ptr: usize, value: T, immOffset?: usize): void;
  /** Atomically adds an integer value in memory. */
  export function add<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically subtracts an integer value in memory. */
  export function sub<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically performs a bitwise AND operation on an integer value in memory. */
  export function and<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically performs a bitwise OR operation on an integer value in memory. */
  export function or<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically performs a bitwise XOR operation on an integer value in memory. */
  export function xor<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically exchanges an integer value in memory. */
  export function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically compares and exchanges an integer value in memory if the condition is met. */
  export function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;
  /** Performs a wait operation on an address in memory suspending this agent if the integer condition is met. */
  export function wait<T>(ptr: usize, expected: T, timeout?: i64): AtomicWaitResult;
  /** Performs a notify operation on an address in memory waking up suspended agents. */
  export function notify(ptr: usize, count?: i32): i32;
  /** Performs a fence operation, preserving synchronization guarantees of higher level languages. */
  export function fence(): void;
}

/** Describes the result of an atomic wait operation. */
declare enum AtomicWaitResult {
  /** Woken by another agent. */
  OK,
  /** Loaded value did not match the expected value. */
  NOT_EQUAL,
  /** Not woken before the timeout expired. */
  TIMED_OUT
}

/** Converts any other numeric value to an 8-bit signed integer. */
declare function i8(value: any): i8;
declare namespace i8 {
  /** Smallest representable value. */
  export const MIN_VALUE: i8;
  /** Largest representable value. */
  export const MAX_VALUE: i8;
}
/** Converts any other numeric value to a 16-bit signed integer. */
declare function i16(value: any): i16;
declare namespace i16 {
  /** Smallest representable value. */
  export const MIN_VALUE: i16;
  /** Largest representable value. */
  export const MAX_VALUE: i16;
}
/** Converts any other numeric value to a 32-bit signed integer. */
declare function i32(value: any): i32;
declare namespace i32 {
  /** Smallest representable value. */
  export const MIN_VALUE: i32;
  /** Largest representable value. */
  export const MAX_VALUE: i32;
  /** Converts a string to an i32 of this type. */
  export function parse(value: string, radix?: i32): i32;
  /** Loads an 8-bit signed integer value from memory and returns it as a 32-bit integer. */
  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */
  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads a 16-bit signed integer value from memory and returns it as a 32-bit integer. */
  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */
  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads a 32-bit integer value from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Stores a 32-bit integer value to memory as an 8-bit integer. */
  export function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 32-bit integer value to memory as a 16-bit integer. */
  export function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 32-bit integer value to memory. */
  export function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;
  /** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */
  export function clz(value: i32): i32;
  /** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */
  export function ctz(value: i32): i32;
  /** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */
  export function popcnt(value: i32): i32;
  /** Performs the sign-agnostic rotate left operation on a 32-bit integer. */
  export function rotl(value: i32, shift: i32): i32;
  /** Performs the sign-agnostic rotate right operation on a 32-bit integer. */
  export function rotr(value: i32, shift: i32): i32;
  /** Reinterprets the bits of the specified 32-bit float as a 32-bit integer. */
  export function reinterpret_f32(value: f32): i32;
  /** Computes the sum of two 32-bit integers. */
  export function add(left: i32, right: i32): i32;
  /** Computes the difference of two 32-bit integers. */
  export function sub(left: i32, right: i32): i32;
  /** Computes the product of two 32-bit integers. */
  export function mul(left: i32, right: i32): i32;
  /** Computes the signed quotient of two 32-bit integers. */
  export function div_s(left: i32, right: i32): i32;
  /** Computes the unsigned quotient of two 32-bit integers. */
  export function div_u(left: i32, right: i32): i32;
  /** Return 1 if two 32-bit integers are equal to each other, 0 otherwise. */
  export function eq(left: i32, right: i32): i32;
  /** Return 0 if two 32-bit integers are equal to each other, 1 otherwise. */
  export function ne(left: i32, right: i32): i32;
  /** Computes the signed remainder of two 32-bit integers. */
  export function rem_s(left: i32, right: i32): i32;
  /** Computes the unsigned remainder of two 32-bit integers. */
  export function rem_u(left: u32, right: u32): u32;

  /** Atomic 32-bit integer operations. */
  export namespace atomic {
    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */
    export function load8_u(ptr: usize, immOffset?: usize): i32;
    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */
    export function load16_u(ptr: usize, immOffset?: usize): i32;
    /** Atomically loads a 32-bit integer value from memory and returns it. */
    export function load(ptr: usize, immOffset?: usize): i32;
    /** Atomically stores a 32-bit integer value to memory as an 8-bit integer. */
    export function store8(ptr: usize, value: i32, immOffset?: usize): void;
    /** Atomically stores a 32-bit integer value to memory as a 16-bit integer. */
    export function store16(ptr: usize, value: i32, immOffset?: usize): void;
    /** Atomically stores a 32-bit integer value to memory. */
    export function store(ptr: usize, value: i32, immOffset?: usize): void;
    /** Performs a wait operation on a 32-bit integer value in memory suspending this agent if the condition is met. */
    export function wait(ptr: usize, expected: i32, timeout?: i64): AtomicWaitResult;
    /** Atomic 32-bit integer read-modify-write operations on 8-bit values. */
    export namespace rmw8 {
      /** Atomically adds an 8-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically subtracts an 8-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise AND operation an 8-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise OR operation an 8-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise XOR operation an 8-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically exchanges an 8-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
    /** Atomic 32-bit integer read-modify-write operations on 16-bit values. */
    export namespace rmw16 {
      /** Atomically adds a 16-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically adds a 16-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise AND operation a 16-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise OR operation a 16-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise XOR operation a 16-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically exchanges a 16-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
    /** Atomic 32-bit integer read-modify-write operations. */
    export namespace rmw {
      /** Atomically adds a 32-bit integer value in memory. */
      export function add(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically subtracts a 32-bit integer value in memory. */
      export function sub(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise AND operation a 32-bit integer value in memory. */
      export function and(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise OR operation a 32-bit integer value in memory. */
      export function or(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise XOR operation a 32-bit integer value in memory. */
      export function xor(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically exchanges a 32-bit integer value in memory. */
      export function xchg(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically compares and exchanges a 32-bit integer value in memory if the condition is met. */
      export function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
  }
}
/** Converts any other numeric value to a 64-bit signed integer. */
declare function i64(value: any): i64;
declare namespace i64 {
  /** Smallest representable value. */
  export const MIN_VALUE: i64;
  /** Largest representable value. */
  export const MAX_VALUE: i64;
  /** Converts a string to an i64 of this type. */
  export function parse(value: string, radix?: i32): i64;
  /** Loads an 8-bit signed integer value from memory and returns it as a 64-bit integer. */
  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */
  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 16-bit signed integer value from memory and returns it as a 64-bit integer. */
  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */
  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 32-bit signed integer value from memory and returns it as a 64-bit integer. */
  export function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */
  export function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 64-bit unsigned integer value from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Stores a 64-bit integer value to memory as an 8-bit integer. */
  export function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 64-bit integer value to memory as a 16-bit integer. */
  export function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 64-bit integer value to memory as a 32-bit integer. */
  export function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 64-bit integer value to memory. */
  export function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Performs the sign-agnostic count leading zero bits operation on a 64-bit integer. All zero bits are considered leading if the value is zero. */
  export function clz(value: i64): i64;
  /** Performs the sign-agnostic count tailing zero bits operation on a 64-bit integer. All zero bits are considered trailing if the value is zero. */
  export function ctz(value: i64): i64;
  /** Performs the sign-agnostic count number of one bits operation on a 64-bit integer. */
  export function popcnt(value: i64): i64;
  /** Performs the sign-agnostic rotate left operation on a 64-bit integer. */
  export function rotl(value: i64, shift: i64): i64;
  /** Performs the sign-agnostic rotate right operation on a 64-bit integer. */
  export function rotr(value: i64, shift: i64): i64;
  /** Reinterprets the bits of the specified 64-bit float as a 64-bit integer. */
  export function reinterpret_f64(value: f64): i64;
  /** Computes the sum of two 64-bit integers. */
  export function add(left: i64, right: i64): i64;
  /** Computes the difference of two 64-bit integers. */
  export function sub(left: i64, right: i64): i64;
  /** Computes the product of two 64-bit integers. */
  export function mul(left: i64, right: i64): i64;
  /** Computes the signed quotient of two 64-bit integers. */
  export function div_s(left: i64, right: i64): i64;
  /** Computes the unsigned quotient of two 64-bit integers. */
  export function div_u(left: i64, right: i64): i64;
  /** Return 1 if two 64-bit integers are equal to each other, 0 otherwise. */
  export function eq(left: i64, right: i64): i32;
  /** Return 0 if two 64-bit integers are equal to each other, 1 otherwise. */
  export function ne(left: i64, right: i64): i32;
  /** Computes the signed remainder of two 64-bit integers. */
  export function rem_s(left: i64, right: i64): i64;
  /** Computes the unsigned remainder of two 64-bit integers. */
  export function rem_u(left: u64, right: u64): u64;

  /** Atomic 64-bit integer operations. */
  export namespace atomic {
    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */
    export function load8_u(ptr: usize, immOffset?: usize): i64;
    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */
    export function load16_u(ptr: usize, immOffset?: usize): i64;
    /** Atomically loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */
    export function load32_u(ptr: usize, immOffset?: usize): i64;
    /** Atomically loads a 64-bit integer value from memory and returns it. */
    export function load(ptr: usize, immOffset?: usize): i64;
    /** Atomically stores a 64-bit integer value to memory as an 8-bit integer. */
    export function store8(ptr: usize, value: i64, immOffset?: usize): void;
    /** Atomically stores a 64-bit integer value to memory as a 16-bit integer. */
    export function store16(ptr: usize, value: i64, immOffset?: usize): void;
    /** Atomically stores a 64-bit integer value to memory as a 32-bit integer. */
    export function store32(ptr: usize, value: i64, immOffset?: usize): void;
    /** Atomically stores a 64-bit integer value to memory. */
    export function store(ptr: usize, value: i64, immOffset?: usize): void;
    /** Performs a wait operation on a 64-bit integer value in memory suspending this agent if the condition is met. */
    export function wait(ptr: usize, expected: i64, timeout?: i64): AtomicWaitResult;
    /** Atomic 64-bit integer read-modify-write operations on 8-bit values. */
    export namespace rmw8 {
      /** Atomically adds an 8-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts an 8-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on an 8-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on an 8-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on an 8-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges an 8-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
    /** Atomic 64-bit integer read-modify-write operations on 16-bit values. */
    export namespace rmw16 {
      /** Atomically adds a 16-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts a 16-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on a 16-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on a 16-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on a 16-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges a 16-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
    /** Atomic 64-bit integer read-modify-write operations on 32-bit values. */
    export namespace rmw32 {
      /** Atomically adds a 32-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts a 32-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on a 32-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on a 32-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on a 32-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges a 32-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges a 32-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
    /** Atomic 64-bit integer read-modify-write operations. */
    export namespace rmw {
      /** Atomically adds a 64-bit integer value in memory. */
      export function add(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts a 64-bit integer value in memory. */
      export function sub(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on a 64-bit integer value in memory. */
      export function and(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on a 64-bit integer value in memory. */
      export function or(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on a 64-bit integer value in memory. */
      export function xor(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges a 64-bit integer value in memory. */
      export function xchg(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges a 64-bit integer value in memory if the condition is met. */
      export function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
  }
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */
declare let isize: typeof i32 | typeof i64;
/** Converts any other numeric value to an 8-bit unsigned integer. */
declare function u8(value: any): u8;
declare namespace u8 {
  /** Smallest representable value. */
  export const MIN_VALUE: u8;
  /** Largest representable value. */
  export const MAX_VALUE: u8;
  /** Converts a string to an u8 of this type. */
  export function parse(value: string, radix?: i32): u8;
}
/** Converts any other numeric value to a 16-bit unsigned integer. */
declare function u16(value: any): u16;
declare namespace u16 {
  /** Smallest representable value. */
  export const MIN_VALUE: u16;
  /** Largest representable value. */
  export const MAX_VALUE: u16;
  /** Converts a string to an u16 of this type. */
  export function parse(value: string, radix?: i32): u16;
}
/** Converts any other numeric value to a 32-bit unsigned integer. */
declare function u32(value: any): u32;
declare namespace u32 {
  /** Smallest representable value. */
  export const MIN_VALUE: u32;
  /** Largest representable value. */
  export const MAX_VALUE: u32;
  /** Converts a string to an u32 of this type. */
  export function parse(value: string, radix?: i32): u32;
}
/** Converts any other numeric value to a 64-bit unsigned integer. */
declare function u64(value: any): u64;
declare namespace u64 {
  /** Smallest representable value. */
  export const MIN_VALUE: u64;
  /** Largest representable value. */
  export const MAX_VALUE: u64;
  /** Converts a string to an u64 of this type. */
  export function parse(value: string, radix?: i32): u64;
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */
declare let usize: typeof u32 | typeof u64;
/** Converts any other numeric value to a 1-bit unsigned integer. */
declare function bool(value: any): bool;
declare namespace bool {
  /** Smallest representable value. */
  export const MIN_VALUE: bool;
  /** Largest representable value. */
  export const MAX_VALUE: bool;
  /** Converts a string to an bool of this type. */
  export function parse(value: string): bool;
}
/** Converts any other numeric value to a 32-bit float. */
declare function f32(value: any): f32;
declare namespace f32 {
  /** Smallest representable value. */
  export const MIN_VALUE: f32;
  /** Largest representable value. */
  export const MAX_VALUE: f32;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f32;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f32;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f32;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f32;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f32;
  /** Not a number value. */
  export const NaN: f32;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f32;
  /** Converts a string to an f32 of this type. */
  export function parse(value: string, radix?: i32): f32;
  /** Loads a 32-bit float from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;
  /** Stores a 32-bit float to memory. */
  export function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;
  /** Computes the sum of two 32-bit floats. */
  export function add(left: f32, right: f32): f32;
  /** Computes the difference of two 32-bit floats. */
  export function sub(left: f32, right: f32): f32;
  /** Computes the product of two 32-bit floats. */
  export function mul(left: f32, right: f32): f32;
  /** Computes the quotient of two 32-bit floats. */
  export function div(left: f32, right: f32): f32;
  /** Return 1 two 32-bit floats are equal to each other, 0 otherwise. */
  export function eq(left: f32, right: f32): i32;
  /** Return 0 two 32-bit floats are equal to each other, 1 otherwise. */
  export function ne(left: f32, right: f32): i32;
  /** Computes the absolute value of a 32-bit float. */
  export function abs(value: f32): f32;
  /** Determines the maximum of two 32-bit floats. If either operand is \`NaN\`, returns \`NaN\`. */
  export function max(left: f32, right: f32): f32;
  /** Determines the minimum of two 32-bit floats. If either operand is \`NaN\`, returns \`NaN\`. */
  export function min(left: f32, right: f32): f32;
  /** Performs the ceiling operation on a 32-bit float. */
  export function ceil(value: f32): f32;
  /** Composes a 32-bit float from the magnitude of \`x\` and the sign of \`y\`. */
  export function copysign(x: f32, y: f32): f32;
  /** Performs the floor operation on a 32-bit float. */
  export function floor(value: f32): f32;
  /** Rounds to the nearest integer tied to even of a 32-bit float. */
  export function nearest(value: f32): f32;
  /** Reinterprets the bits of the specified 32-bit integer as a 32-bit float. */
  export function reinterpret_i32(value: i32): f32;
  /** Calculates the square root of a 32-bit float. */
  export function sqrt(value: f32): f32;
  /** Rounds to the nearest integer towards zero of a 32-bit float. */
  export function trunc(value: f32): f32;
}
/** Converts any other numeric value to a 64-bit float. */
declare function f64(value: any): f64;
declare namespace f64 {
  /** Smallest representable value. */
  export const MIN_VALUE: f64;
  /** Largest representable value. */
  export const MAX_VALUE: f64;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f64;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f64;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f64;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f64;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f64;
  /** Not a number value. */
  export const NaN: f64;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f64;
  /** Converts a string to an f64 of this type. */
  export function parse(value: string, radix?: i32): f64;
  /** Loads a 64-bit float from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;
  /** Stores a 64-bit float to memory. */
  export function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;
  /** Computes the sum of two 64-bit floats. */
  export function add(left: f64, right: f64): f64;
  /** Computes the difference of two 64-bit floats. */
  export function sub(left: f64, right: f64): f64;
  /** Computes the product of two 64-bit floats. */
  export function mul(left: f64, right: f64): f64;
  /** Computes the quotient of two 64-bit floats. */
  export function div(left: f64, right: f64): f64;
  /** Return 1 two 64-bit floats are equal to each other, 0 otherwise. */
  export function eq(left: f64, right: f64): i32;
  /** Return 0 two 32-bit floats are equal to each other, 1 otherwise. */
  export function ne(left: f64, right: f64): i32;
  /** Computes the absolute value of a 64-bit float. */
  export function abs(value: f64): f64;
  /** Determines the maximum of two 64-bit floats. If either operand is \`NaN\`, returns \`NaN\`. */
  export function max(left: f64, right: f64): f64;
  /** Determines the minimum of two 64-bit floats. If either operand is \`NaN\`, returns \`NaN\`. */
  export function min(left: f64, right: f64): f64;
  /** Performs the ceiling operation on a 64-bit float. */
  export function ceil(value: f64): f64;
  /** Composes a 64-bit float from the magnitude of \`x\` and the sign of \`y\`. */
  export function copysign(x: f64, y: f64): f64;
  /** Performs the floor operation on a 64-bit float. */
  export function floor(value: f64): f64;
  /** Rounds to the nearest integer tied to even of a 64-bit float. */
  export function nearest(value: f64): f64;
  /** Reinterprets the bits of the specified 64-bit integer as a 64-bit float. */
  export function reinterpret_i64(value: i64): f64;
  /** Calculates the square root of a 64-bit float. */
  export function sqrt(value: f64): f64;
  /** Rounds to the nearest integer towards zero of a 64-bit float. */
  export function trunc(value: f64): f64;
}
/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */
declare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;
declare namespace v128 {
  /** Creates a vector with identical lanes. */
  export function splat<T>(x: T): v128;
  /** Extracts one lane as a scalar. */
  export function extract_lane<T>(x: v128, idx: u8): T;
  /** Replaces one lane. */
  export function replace_lane<T>(x: v128, idx: u8, value: T): v128;
  /** Selects lanes from either vector according to the specified lane indexes. */
  export function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
  /** Loads a vector from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading the lanes of the specified type and extending each to the next larger type. */
  export function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading a value of the specified type into the lowest bits and initializing all other bits of the vector to zero. */
  export function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the single lane at the specified index of the given vector to memory. */
  export function store_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector with eight 16-bit integer lanes by loading and sign extending eight 8-bit integers. */
  export function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with eight 16-bit integer lanes by loading and zero extending eight 8-bit integers. */
  export function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with four 32-bit integer lanes by loading and sign extending four 16-bit integers. */
  export function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with four 32-bit integer lanes by loading and zero extending four 16-bit integers. */
  export function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with two 64-bit integer lanes by loading and sign extending two 32-bit integers. */
  export function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with two 64-bit integer lanes by loading and zero extending two 32-bit integers. */
  export function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with identical lanes by loading the splatted value. */
  export function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads an 8-bit integer and splats it sixteen times forming a new vector. */
  export function load8_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a 16-bit integer and splats it eight times forming a new vector. */
  export function load16_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a 32-bit integer and splats it four times forming a new vector. */
  export function load32_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a 64-bit integer and splats it two times forming a new vector. */
  export function load64_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading a 32-bit value into the lowest bits and initializing all other bits of the vector to zero. */
  export function load32_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading a 64-bit value into the lowest bits and initializing all other bits of the vector to zero. */
  export function load64_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 8-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 16-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 32-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 64-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 8-bit lane at the specified lane of the given vector to memory. */
  export function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 16-bit lane at the specified lane of the given vector to memory. */
  export function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 32-bit lane at the specified lane of the given vector to memory. */
  export function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 64-bit lane at the specified lane of the given vector to memory. */
  export function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores a vector to memory. */
  export function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;
  /** Adds each lane. */
  export function add<T>(a: v128, b: v128): v128;
  /** Subtracts each lane. */
  export function sub<T>(a: v128, b: v128): v128;
  /** Multiplies each lane. */
  export function mul<T>(a: v128, b: v128): v128; // except i64
  /** Divides each lane. */
  export function div<T extends f32 | f64>(a: v128, b: v128): v128;
  /** Negates each lane of a vector. */
  export function neg<T>(a: v128): v128;
  /** Adds each lane using saturation. */
  export function add_sat<T>(a: v128, b: v128): v128;
  /** Subtracts each lane using saturation. */
  export function sub_sat<T>(a: v128, b: v128): v128;
  /** Performs a bitwise left shift on each lane of a vector by a scalar. */
  export function shl<T>(a: v128, b: i32): v128;
  /** Performs a bitwise right shift on each lane of a vector by a scalar. */
  export function shr<T>(a: v128, b: i32): v128;
  /** Performs the bitwise AND operation on two vectors. */
  export function and(a: v128, b: v128): v128;
  /** Performs the bitwise OR operation on two vectors. */
  export function or(a: v128, b: v128): v128;
  /** Performs the bitwise XOR operation on two vectors. */
  export function xor(a: v128, b: v128): v128;
  /** Performs the bitwise ANDNOT operation on two vectors. */
  export function andnot(a: v128, b: v128): v128;
  /** Performs the bitwise NOT operation on a vector. */
  export function not(a: v128): v128;
  /** Selects bits of either vector according to the specified mask. */
  export function bitselect(v1: v128, v2: v128, mask: v128): v128;
  /** Reduces a vector to a scalar indicating whether any lane is considered \`true\`. */
  export function any_true(a: v128): bool;
  /** Reduces a vector to a scalar indicating whether all lanes are considered \`true\`. */
  export function all_true<T>(a: v128): bool;
  /** Extracts the high bit of each lane and produces a scalar mask with all bits concatenated. */
  export function bitmask<T>(a: v128): i32;
  /** Counts the number of bits set to one within each lane. */
  export function popcnt<T>(a: v128): v128;
  /** Computes the minimum of each lane. */
  export function min<T>(a: v128, b: v128): v128;
  /** Computes the maximum of each lane. */
  export function max<T>(a: v128, b: v128): v128;
  /** Computes the pseudo-minimum of each lane. */
  export function pmin<T extends f32 | f64>(a: v128, b: v128): v128;
  /** Computes the pseudo-maximum of each lane. */
  export function pmax<T extends f32 | f64>(a: v128, b: v128): v128;
  /** Computes the dot product of two lanes each, yielding lanes one size wider than the input. */
  export function dot<T extends i16>(a: v128, b: v128): v128;
  /** Computes the average of each lane. */
  export function avgr<T extends u8 | u16>(a: v128, b: v128): v128;
  /** Computes the absolute value of each lane. */
  export function abs<T extends f32 | f64>(a: v128): v128;
  /** Computes the square root of each lane. */
  export function sqrt<T extends f32 | f64>(a: v128): v128;
  /** Performs the ceiling operation on each lane. */
  export function ceil<T extends f32 | f64>(a: v128): v128;
  /** Performs the floor operation on each lane. */
  export function floor<T extends f32 | f64>(a: v128): v128;
  /** Rounds to the nearest integer towards zero of each lane. */
  export function trunc<T extends f32 | f64>(a: v128): v128;
  /** Rounds to the nearest integer tied to even of each lane. */
  export function nearest<T extends f32 | f64>(a: v128): v128;
  /** Computes which lanes are equal. */
  export function eq<T>(a: v128, b: v128): v128;
  /** Computes which lanes are not equal. */
  export function ne<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are less than those of the second. */
  export function lt<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are less than or equal those of the second. */
  export function le<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are greater than those of the second. */
  export function gt<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are greater than or equal those of the second. */
  export function ge<T>(a: v128, b: v128): v128;
  /** Converts each lane of a vector from integer to single-precision floating point. */
  export function convert<TFrom extends i32 | u32>(a: v128): v128;
  /** Converts the low lanes of a vector from integer to double-precision floating point. */
  export function convert_low<TFrom extends i32 | u32>(a: v128): v128;
  /** Truncates each lane of a vector from single-precision floating point to integer with saturation. Takes the target type. */
  export function trunc_sat<TTo extends i32 | u32>(a: v128): v128;
  /** Truncates each lane of a vector from double-precision floating point to integer with saturation. Takes the target type. */
  export function trunc_sat_zero<TTo extends i32 | u32>(a: v128): v128;
  /** Narrows each lane to their respective narrower lanes. */
  export function narrow<TFrom extends i16 | i32>(a: v128, b: v128): v128;
  /** Extends the low lanes of a vector to their respective wider lanes. */
  export function extend_low<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;
  /** Extends the high lanes of a vector to their respective wider lanes. */
  export function extend_high<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;
  /** Adds lanes pairwise producing twice wider extended results. */
  export function extadd_pairwise<TFrom extends i8 | u8 | i16 | u16>(a: v128): v128;
  /** Demotes each float lane to lower precision. The higher lanes of the result are initialized to zero. */
  export function demote_zero<T extends f64 = f64>(a: v128): v128;
  /** Promotes the lower float lanes to higher precision. */
  export function promote_low<T extends f32 = f32>(a: v128): v128;
  /** Performs the line-wise saturating rounding multiplication in Q15 format. */
  export function q15mulr_sat<T extends i16>(a: v128, b: v128): v128;
  /** Performs the lane-wise integer extended multiplication of the lower lanes producing a twice wider result than the inputs. */
  export function extmul_low<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;
  /** Performs the lane-wise integer extended multiplication of the higher lanes producing a twice wider result than the inputs. */
  export function extmul_high<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;
}
/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */
declare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;
declare namespace i8x16 {
  /** Creates a vector with sixteen identical 8-bit integer lanes. */
  export function splat(x: i8): v128;
  /** Extracts one 8-bit integer lane as a signed scalar. */
  export function extract_lane_s(x: v128, idx: u8): i8;
  /** Extracts one 8-bit integer lane as an unsigned scalar. */
  export function extract_lane_u(x: v128, idx: u8): u8;
  /** Replaces one 8-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i8): v128;
  /** Adds each 8-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 8-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Computes the signed minimum of each 8-bit integer lane. */
  export function min_s(a: v128, b: v128): v128;
  /** Computes the unsigned minimum of each 8-bit integer lane. */
  export function min_u(a: v128, b: v128): v128;
  /** Computes the signed maximum of each 8-bit integer lane. */
  export function max_s(a: v128, b: v128): v128;
  /** Computes the unsigned maximum of each 8-bit integer lane. */
  export function max_u(a: v128, b: v128): v128;
  /** Computes the unsigned average of each 8-bit integer lane. */
  export function avgr_u(a: v128, b: v128): v128;
  /** Computes the absolute value of each 8-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 8-bit integer lane. */
  export function neg(a: v128): v128;
  /** Adds each 8-bit integer lane using signed saturation. */
  export function add_sat_s(a: v128, b: v128): v128;
  /** Adds each 8-bit integer lane using unsigned saturation. */
  export function add_sat_u(a: v128, b: v128): v128;
  /** Subtracts each 8-bit integer lane using signed saturation. */
  export function sub_sat_s(a: v128, b: v128): v128;
  /** Subtracts each 8-bit integer lane using unsigned saturation. */
  export function sub_sat_u(a: v128, b: v128): v128;
  /** Performs a bitwise left shift on each 8-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift on each 8-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 8-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 8-bit integer lanes are considered \`true\`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 8-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Counts the number of bits set to one within each 8-bit integer lane. */
  export function popcnt(a: v128): v128;
  /** Computes which 8-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 8-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are less than those of the second. */
  export function lt_u(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are less than or equal those of the second. */
  export function le_u(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than those of the second. */
  export function gt_u(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_u(a: v128, b: v128): v128;
  /** Narrows each 16-bit signed integer lane to 8-bit signed integer lanes. */
  export function narrow_i16x8_s(a: v128, b: v128): v128;
  /** Narrows each 16-bit signed integer lane to 8-bit unsigned integer lanes. */
  export function narrow_i16x8_u(a: v128, b: v128): v128;
  /** Selects 8-bit lanes from either vector according to the specified [0-15] respectively [16-31] lane indexes. */
  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
}
/** Initializes a 128-bit vector from eight 16-bit integer values. Arguments must be compile-time constants. */
declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;
declare namespace i16x8 {
  /** Creates a vector with eight identical 16-bit integer lanes. */
  export function splat(x: i16): v128;
  /** Extracts one 16-bit integer lane as a signed scalar. */
  export function extract_lane_s(x: v128, idx: u8): i16;
  /** Extracts one 16-bit integer lane as an unsigned scalar. */
  export function extract_lane_u(x: v128, idx: u8): u16;
  /** Replaces one 16-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i16): v128;
  /** Adds each 16-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 16-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 16-bit integer lane. */
  export function mul(a: v128, b: v128): v128;
  /** Computes the signed minimum of each 16-bit integer lane. */
  export function min_s(a: v128, b: v128): v128;
  /** Computes the unsigned minimum of each 16-bit integer lane. */
  export function min_u(a: v128, b: v128): v128;
  /** Computes the signed maximum of each 16-bit integer lane. */
  export function max_s(a: v128, b: v128): v128;
  /** Computes the unsigned maximum of each 16-bit integer lane. */
  export function max_u(a: v128, b: v128): v128;
  /** Computes the unsigned average of each 16-bit integer lane. */
  export function avgr_u(a: v128, b: v128): v128;
  /** Computes the absolute value of each 16-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 16-bit integer lane. */
  export function neg(a: v128): v128;
  /** Adds each 16-bit integer lane using signed saturation. */
  export function add_sat_s(a: v128, b: v128): v128;
  /** Adds each 16-bit integer lane using unsigned saturation. */
  export function add_sat_u(a: v128, b: v128): v128;
  /** Subtracts each 16-bit integer lane using signed saturation. */
  export function sub_sat_s(a: v128, b: v128): v128;
  /** Subtracts each 16-bit integer lane using unsigned saturation. */
  export function sub_sat_u(a: v128, b: v128): v128;
  /** Performs a bitwise left shift on each 16-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift each 16-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 16-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 16-bit integer lanes are considered \`true\`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 16-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Computes which 16-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 16-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are less than those of the second. */
  export function lt_u(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are less than or equal those of the second. */
  export function le_u(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than those of the second. */
  export function gt_u(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_u(a: v128, b: v128): v128;
  /** Narrows each 32-bit signed integer lane to 16-bit signed integer lanes. */
  export function narrow_i32x4_s(a: v128, b: v128): v128;
  /** Narrows each 32-bit signed integer lane to 16-bit unsigned integer lanes. */
  export function narrow_i32x4_u(a: v128, b: v128): v128;
  /** Extends the low 8-bit signed integer lanes to 16-bit signed integer lanes. */
  export function extend_low_i8x16_s(a: v128): v128;
  /** Extends the low 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */
  export function extend_low_i8x16_u(a: v128): v128;
  /** Extends the high 8-bit signed integer lanes to 16-bit signed integer lanes. */
  export function extend_high_i8x16_s(a: v128): v128;
  /** Extends the high 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */
  export function extend_high_i8x16_u(a: v128): v128;
  /** Adds the sixteen 8-bit signed integer lanes pairwise producing eight 16-bit signed integer results. */
  export function extadd_pairwise_i8x16_s(a: v128): v128;
  /** Adds the sixteen 8-bit unsigned integer lanes pairwise producing eight 16-bit unsigned integer results. */
  export function extadd_pairwise_i8x16_u(a: v128): v128;
  /** Performs the line-wise 16-bit signed integer saturating rounding multiplication in Q15 format. */
  export function q15mulr_sat_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */
  export function extmul_low_i8x16_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */
  export function extmul_low_i8x16_u(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */
  export function extmul_high_i8x16_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */
  export function extmul_high_i8x16_u(a: v128, b: v128): v128;
  /** Selects 16-bit lanes from either vector according to the specified [0-7] respectively [8-15] lane indexes. */
  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
}
/** Initializes a 128-bit vector from four 32-bit integer values. Arguments must be compile-time constants. */
declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;
declare namespace i32x4 {
  /** Creates a vector with four identical 32-bit integer lanes. */
  export function splat(x: i32): v128;
  /** Extracts one 32-bit integer lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): i32;
  /** Replaces one 32-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i32): v128;
  /** Adds each 32-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 32-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 32-bit integer lane. */
  export function mul(a: v128, b: v128): v128;
  /** Computes the signed minimum of each 32-bit integer lane. */
  export function min_s(a: v128, b: v128): v128;
  /** Computes the unsigned minimum of each 32-bit integer lane. */
  export function min_u(a: v128, b: v128): v128;
  /** Computes the signed maximum of each 32-bit integer lane. */
  export function max_s(a: v128, b: v128): v128;
  /** Computes the unsigned maximum of each 32-bit integer lane. */
  export function max_u(a: v128, b: v128): v128;
  /** Computes the dot product of two 16-bit integer lanes each, yielding 32-bit integer lanes. */
  export function dot_i16x8_s(a: v128, b: v128): v128;
  /** Computes the absolute value of each 32-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 32-bit integer lane. */
  export function neg(a: v128): v128;
  /** Performs a bitwise left shift on each 32-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift on each 32-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 32-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 32-bit integer lanes are considered \`true\`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 32-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Computes which 32-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 32-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are less than those of the second. */
  export function lt_u(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are less than or equal those of the second. */
  export function le_u(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than those of the second. */
  export function gt_u(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_u(a: v128, b: v128): v128;
  /** Truncates each 32-bit float lane to a signed integer with saturation. */
  export function trunc_sat_f32x4_s(a: v128): v128;
  /** Truncates each 32-bit float lane to an unsigned integer with saturation. */
  export function trunc_sat_f32x4_u(a: v128): v128;
  /** Truncates the two 64-bit float lanes to the two lower signed integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */
  export function trunc_sat_f64x2_s_zero(a: v128): v128;
  /** Truncates the two 64-bit float lanes to the two lower unsigned integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */
  export function trunc_sat_f64x2_u_zero(a: v128): v128;
  /** Extends the low 16-bit signed integer lanes to 32-bit signed integer lanes. */
  export function extend_low_i16x8_s(a: v128): v128;
  /** Extends the low 16-bit unsigned integer lane to 32-bit unsigned integer lanes. */
  export function extend_low_i16x8_u(a: v128): v128;
  /** Extends the high 16-bit signed integer lanes to 32-bit signed integer lanes. */
  export function extend_high_i16x8_s(a: v128): v128;
  /** Extends the high 16-bit unsigned integer lanes to 32-bit unsigned integer lanes. */
  export function extend_high_i16x8_u(a: v128): v128;
  /** Adds the eight 16-bit signed integer lanes pairwise producing four 32-bit signed integer results. */
  export function extadd_pairwise_i16x8_s(a: v128): v128;
  /** Adds the eight 16-bit unsigned integer lanes pairwise producing four 32-bit unsigned integer results. */
  export function extadd_pairwise_i16x8_u(a: v128): v128;
  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */
  export function extmul_low_i16x8_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */
  export function extmul_low_i16x8_u(a: v128, b: v128): v128;
  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */
  export function extmul_high_i16x8_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */
  export function extmul_high_i16x8_u(a: v128, b: v128): v128;
  /** Selects 32-bit lanes from either vector according to the specified [0-3] respectively [4-7] lane indexes. */
  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
}
/** Initializes a 128-bit vector from two 64-bit integer values. Arguments must be compile-time constants. */
declare function i64x2(a: i64, b: i64): v128;
declare namespace i64x2 {
  /** Creates a vector with two identical 64-bit integer lanes. */
  export function splat(x: i64): v128;
  /** Extracts one 64-bit integer lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): i64;
  /** Replaces one 64-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i64): v128;
  /** Adds each 64-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 64-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 64-bit integer lane. */
  export function mul(a: v128, b: v128): v128;
  /** Computes the absolute value of each 64-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 64-bit integer lane. */
  export function neg(a: v128): v128;
  /** Performs a bitwise left shift on each 64-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift on each 64-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 64-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 64-bit integer lanes are considered \`true\`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 64-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Computes which 64-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 64-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Extends the low 32-bit signed integer lanes to 64-bit signed integer lanes. */
  export function extend_low_i32x4_s(a: v128): v128;
  /** Extends the low 32-bit unsigned integer lane to 64-bit unsigned integer lanes. */
  export function extend_low_i32x4_u(a: v128): v128;
  /** Extends the high 32-bit signed integer lanes to 64-bit signed integer lanes. */
  export function extend_high_i32x4_s(a: v128): v128;
  /** Extends the high 32-bit unsigned integer lanes to 64-bit unsigned integer lanes. */
  export function extend_high_i32x4_u(a: v128): v128;
  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */
  export function extmul_low_i32x4_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */
  export function extmul_low_i32x4_u(a: v128, b: v128): v128;
  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */
  export function extmul_high_i32x4_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */
  export function extmul_high_i32x4_u(a: v128, b: v128): v128;
  /** Selects 64-bit lanes from either vector according to the specified [0-1] respectively [2-3] lane indexes. */
  export function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
}
/** Initializes a 128-bit vector from four 32-bit float values. Arguments must be compile-time constants. */
declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;
declare namespace f32x4 {
  /** Creates a vector with four identical 32-bit float lanes. */
  export function splat(x: f32): v128;
  /** Extracts one 32-bit float lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): f32;
  /** Replaces one 32-bit float lane. */
  export function replace_lane(x: v128, idx: u8, value: f32): v128;
  /** Adds each 32-bit float lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 32-bit float lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 32-bit float lane. */
  export function mul(a: v128, b: v128): v128;
  /** Divides each 32-bit float lane. */
  export function div(a: v128, b: v128): v128;
  /** Negates each 32-bit float lane. */
  export function neg(a: v128): v128;
  /** Computes the minimum of each 32-bit float lane. */
  export function min(a: v128, b: v128): v128;
  /** Computes the maximum of each 32-bit float lane. */
  export function max(a: v128, b: v128): v128;
  /** Computes the pseudo-minimum of each 32-bit float lane. */
  export function pmin(a: v128, b: v128): v128;
  /** Computes the pseudo-maximum of each 32-bit float lane. */
  export function pmax(a: v128, b: v128): v128;
  /** Computes the absolute value of each 32-bit float lane. */
  export function abs(a: v128): v128;
  /** Computes the square root of each 32-bit float lane. */
  export function sqrt(a: v128): v128;
  /** Performs the ceiling operation on each 32-bit float lane. */
  export function ceil(a: v128): v128;
  /** Performs the floor operation on each each 32-bit float lane. */
  export function floor(a: v128): v128;
  /** Rounds to the nearest integer towards zero of each 32-bit float lane. */
  export function trunc(a: v128): v128;
  /** Rounds to the nearest integer tied to even of each 32-bit float lane. */
  export function nearest(a: v128): v128;
  /** Computes which 32-bit float lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are less than those of the second. */
  export function lt(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are less than or equal those of the second. */
  export function le(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are greater than those of the second. */
  export function gt(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are greater than or equal those of the second. */
  export function ge(a: v128, b: v128): v128;
  /** Converts each 32-bit signed integer lane of a vector to single-precision floating point. */
  export function convert_i32x4_s(a: v128): v128;
  /** Converts each 32-bit unsigned integer lane of a vector to single-precision floating point. */
  export function convert_i32x4_u(a: v128): v128;
  /** Demotes each 64-bit float lane of a vector to single-precision. The higher lanes of the result are initialized to zero. */
  export function demote_f64x2_zero(a: v128): v128;
  /** Selects 32-bit lanes from either vector according to the specified [0-3] respectively [4-7] lane indexes. */
  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
}
/** Initializes a 128-bit vector from two 64-bit float values. Arguments must be compile-time constants. */
declare function f64x2(a: f64, b: f64): v128;
declare namespace f64x2 {
  /** Creates a vector with two identical 64-bit float lanes. */
  export function splat(x: f64): v128;
  /** Extracts one 64-bit float lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): f64;
  /** Replaces one 64-bit float lane. */
  export function replace_lane(x: v128, idx: u8, value: f64): v128;
  /** Adds each 64-bit float lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 64-bit float lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 64-bit float lane. */
  export function mul(a: v128, b: v128): v128;
  /** Divides each 64-bit float lane. */
  export function div(a: v128, b: v128): v128;
  /** Negates each 64-bit float lane. */
  export function neg(a: v128): v128;
  /** Computes the minimum of each 64-bit float lane. */
  export function min(a: v128, b: v128): v128;
  /** Computes the maximum of each 64-bit float lane. */
  export function max(a: v128, b: v128): v128;
  /** Computes the pseudo-minimum of each 64-bit float lane. */
  export function pmin(a: v128, b: v128): v128;
  /** Computes the pseudo-maximum of each 64-bit float lane. */
  export function pmax(a: v128, b: v128): v128;
  /** Computes the absolute value of each 64-bit float lane. */
  export function abs(a: v128): v128;
  /** Computes the square root of each 64-bit float lane. */
  export function sqrt(a: v128): v128;
  /** Performs the ceiling operation on each 64-bit float lane. */
  export function ceil(a: v128): v128;
  /** Performs the floor operation on each each 64-bit float lane. */
  export function floor(a: v128): v128;
  /** Rounds to the nearest integer towards zero of each 64-bit float lane. */
  export function trunc(a: v128): v128;
  /** Rounds to the nearest integer tied to even of each 64-bit float lane. */
  export function nearest(a: v128): v128;
  /** Computes which 64-bit float lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are less than those of the second. */
  export function lt(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are less than or equal those of the second. */
  export function le(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are greater than those of the second. */
  export function gt(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are greater than or equal those of the second. */
  export function ge(a: v128, b: v128): v128;
  /** Converts the low 32-bit signed integer lanes of a vector to double-precision floating point. */
  export function convert_low_i32x4_s(a: v128): v128;
  /** Converts the low 32-bit unsigned integer lanes of a vector to double-precision floating point. */
  export function convert_low_i32x4_u(a: v128): v128;
  /** Promotes the low 32-bit float lanes of a vector to double-precision. */
  export function promote_low_f32x4(a: v128): v128;
  /** Selects 64-bit lanes from either vector according to the specified [0-1] respectively [2-3] lane indexes. */
  export function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
}

declare abstract class i31 {
  /** Creates a new i31ref from the specified integer value. */
  static new(value: i32): i31ref;
  /** Gets the integer value of an i31ref. */
  static get(i31expr: i31ref): i32;
}

/** Macro type evaluating to the underlying native WebAssembly type. */
declare type native<T> = T;
/** Special type evaluating the indexed access index type. */
declare type indexof<T extends ArrayLike<unknown>> = keyof T;
/** Special type evaluating the indexed access value type. */
declare type valueof<T extends ArrayLike<unknown>> = T[0];
/** A special type evaluated to the return type of T if T is a callable function. */
declare type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;
/** A special type evaluated to the return type of T if T is a callable function. */
declare type returnof<T extends (...args: any) => any> = ReturnType<T>;
/** A special type that excludes null and undefined from T. */
declare type NonNullable<T> = T extends null | undefined ? never : T;
/** A special type that excludes null and undefined from T. */
declare type nonnull<T> = NonNullable<T>;

/** Pseudo-class representing the backing class of integer types. */
/** @internal */
declare class _Integer {
  /** Smallest representable value. */
  static readonly MIN_VALUE: number;
  /** Largest representable value. */
  static readonly MAX_VALUE: number;
  /** @deprecated Converts a string to an integer of this type. Please use "i32.parse" method. */
  static parseInt(value: string, radix?: number): number;
  /** Converts this integer to a string. */
  toString(radix?: number): string;
}

/** Pseudo-class representing the backing class of floating-point types. */
/** @internal */
declare class _Float {
  /** Difference between 1 and the smallest representable value greater than 1. */
  static readonly EPSILON: f32 | f64;
  /** Smallest representable value. */
  static readonly MIN_VALUE: f32 | f64;
  /** Largest representable value. */
  static readonly MAX_VALUE: f32 | f64;
  /** Smallest safely representable integer value. */
  static readonly MIN_SAFE_INTEGER: f32 | f64;
  /** Largest safely representable integer value. */
  static readonly MAX_SAFE_INTEGER: f32 | f64;
  /** Value representing positive infinity. */
  static readonly POSITIVE_INFINITY: f32 | f64;
  /** Value representing negative infinity. */
  static readonly NEGATIVE_INFINITY: f32 | f64;
  /** Value representing 'not a number'. */
  static readonly NaN: f32 | f64;
  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */
  static isNaN(value: f32 | f64): bool;
  /** Returns true if passed value is finite. */
  static isFinite(value: f32 | f64): bool;
  /** Returns true if the value passed is a safe integer. */
  static isSafeInteger(value: f32 | f64): bool;
  /** Returns true if the value passed is an integer, false otherwise. */
  static isInteger(value: f32 | f64): bool;
  /** @deprecated Converts a string to an integer. Please use "i32.parse" / "i64.parse" methods. */
  static parseInt(value: string, radix?: i32): f32 | f64;
  /** @deprecated Converts a string to a floating-point number. Please use "f32.parse" / "f64.parse" methods. */
  static parseFloat(value: string): f32 | f64;
  /** Converts this floating-point number to a string. */
  toString(radix?: number): string;
}

declare class Boolean {
  toString(radix?: number): string;
}

/** Backing class of signed 8-bit integers. */
declare const I8: typeof _Integer;
/** Backing class of signed 16-bit integers. */
declare const I16: typeof _Integer;
/** Backing class of signed 32-bit integers. */
declare const I32: typeof _Integer;
/** Backing class of signed 64-bit integers. */
declare const I64: typeof _Integer;
/** Backing class of signed size integers. */
declare const Isize: typeof _Integer;
/** Backing class of unsigned 8-bit integers. */
declare const U8: typeof _Integer;
/** Backing class of unsigned 16-bit integers. */
declare const U16: typeof _Integer;
/** Backing class of unsigned 32-bit integers. */
declare const U32: typeof _Integer;
/** Backing class of unsigned 64-bit integers. */
declare const U64: typeof _Integer;
/** Backing class of unsigned size integers. */
declare const Usize: typeof _Integer;
/** Backing class of 32-bit floating-point values. */
declare const F32: typeof _Float;
/** Backing class of 64-bit floating-point values. */
declare const F64: typeof _Float;
/** Alias of F64. */
declare const Number: typeof F64;
declare type Number = _Float;

// User-defined diagnostic macros

/** Emits a user-defined diagnostic error when encountered. */
declare function ERROR(message?: any): never;
/** Emits a user-defined diagnostic warning when encountered. */
declare function WARNING(message?: any): void;
/** Emits a user-defined diagnostic info when encountered. */
declare function INFO(message?: any): void;

// Standard library

/** Memory operations. */
declare namespace memory {
  /** Whether the memory managed interface is implemented. */
  export const implemented: bool;
  /** Returns the current memory size in units of pages. One page is 64kb. */
  export function size(): i32;
  /** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or \`-1\` on failure. */
  export function grow(value: i32): i32;
  /** Sets n bytes beginning at the specified destination in memory to the specified byte value. */
  export function fill(dst: usize, value: u8, count: usize): void;
  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */
  export function copy(dst: usize, src: usize, n: usize): void;
  /** Repeats \`src\` of length \`srcLength\` \`count\` times at \`dst\`. */
  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void;
  /** Copies elements from a passive element segment to a table. */
  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void;
  /** Prevents further use of a passive element segment. */
  export function drop(segmentIndex: u32): void;
  /** Compares two chunks of memory. Returns \`0\` if equal, otherwise the difference of the first differing bytes. */
  export function compare(vl: usize, vr: usize, n: usize): i32;
  /** Gets a pointer to a zeroed static chunk of memory of the given size. Alignment defaults to \`16\`. Arguments must be compile-time constants. */
  export function data(size: i32, align?: i32): usize;
  /** Gets a pointer to a pre-initialized static chunk of memory. Alignment defaults to the size of \`T\`. Arguments must be compile-time constants. */
  export function data<T>(values: T[], align?: i32): usize;
}

/** Heap memory interface. */
declare namespace heap {
  /** Allocates a chunk of memory of at least the specified size. */
  export function alloc(size: usize): usize;
  /** Reallocates a chunk of memory to have at least the specified size. */
  export function realloc(ptr: usize, size: usize): usize;
  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub/none runtime. */
  export function free(ptr: usize): void;
}

/** Table operations. */
declare namespace table {
  /** Copies elements from a passive element segment to a table. */
  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void;
  /** Prevents further use of a passive element segment. */
  export function drop(elementIndex: u32): void;
  /** Copies elements from one region of a table to another region. */
  export function copy(dest: u32, src: u32, n: u32): void;
}

declare namespace Atomics {
  export function load<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32): T;
  export function store<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): void;
  export function add<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function sub<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function and<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function or<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function xor<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function exchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function compareExchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, expectedValue: T, replacementValue: T): T;
  export function wait<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, value: T, timeout?: i64): AtomicWaitResult;
  export function notify<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, count?: i32): i32;
  /** The static Atomics.isLockFree() method is used to determine whether to use locks or atomic operations. It returns true, if the given size is one of the BYTES_PER_ELEMENT */
  export function isLockFree(size: usize): bool;
}

/** Class representing a generic, fixed-length raw binary data buffer. */
declare class ArrayBuffer {
  /** The size, in bytes, of the array. */
  readonly byteLength: i32;
  /** Returns true if value is one of the ArrayBuffer views, such as typed array or a DataView **/
  static isView<T>(value: T): bool;
  /** Constructs a new array buffer of the given length in bytes. */
  constructor(length: i32);
  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */
  slice(begin?: i32, end?: i32): ArrayBuffer;
  /** Returns a string representation of ArrayBuffer. */
  toString(): string;
}

/** The \`DataView\` view provides a low-level interface for reading and writing multiple number types in a binary \`ArrayBuffer\`, without having to care about the platform's endianness. */
declare class DataView {
  /** The \`buffer\` accessor property represents the \`ArrayBuffer\` or \`SharedArrayBuffer\` referenced by the \`DataView\` at construction time. */
  readonly buffer: ArrayBuffer;
  /** Returns raw pointer to data storage including offset (unsafe). */
  readonly dataStart: usize;
  /** The \`byteLength\` accessor property represents the length (in bytes) of this view from the start of its \`ArrayBuffer\` or \`SharedArrayBuffer\`. */
  readonly byteLength: i32;
  /** The \`byteOffset\` accessor property represents the offset (in bytes) of this view from the start of its \`ArrayBuffer\` or \`SharedArrayBuffer\`. */
  readonly byteOffset: i32;
  /** Constructs a new \`DataView\` with the given properties */
  constructor(buffer: ArrayBuffer, byteOffset?: i32, byteLength?: i32);
  /** The \`getFloat32()\` method gets a signed 32-bit float (float) at the specified byte offset from the start of the \`DataView\`. */
  getFloat32(byteOffset: i32, littleEndian?: bool): f32;
  /** The \`getFloat64()\` method gets a signed 64-bit float (double) at the specified byte offset from the start of the \`DataView\`. */
  getFloat64(byteOffset: i32, littleEndian?: bool): f64;
  /** The \`getInt8()\` method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the \`DataView\`. */
  getInt8(byteOffset: i32): i8;
  /** The \`getInt16()\` method gets a signed 16-bit integer (short) at the specified byte offset from the start of the \`DataView\`. */
  getInt16(byteOffset: i32, littleEndian?: bool): i16;
  /** The \`getInt32()\` method gets a signed 32-bit integer (long) at the specified byte offset from the start of the \`DataView\`. */
  getInt32(byteOffset: i32, littleEndian?: bool): i32;
  /** The \`getInt64()\` method gets a signed 64-bit integer (long long) at the specified byte offset from the start of the \`DataView\`. */
  getInt64(byteOffset: i32, littleEndian?: bool): i64;
  /** The \`getUint8()\` method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the \`DataView\`. */
  getUint8(byteOffset: i32): u8;
  /** The \`getUint16()\` method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the \`DataView\`. */
  getUint16(byteOffset: i32, littleEndian?: bool): u16;
  /** The \`getUint32()\` method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the \`DataView\`. */
  getUint32(byteOffset: i32, littleEndian?: bool): u32;
  /** The \`getUint64()\` method gets an unsigned 64-bit integer (unsigned long long) at the specified byte offset from the start of the \`DataView\`. */
  getUint64(byteOffset: i32, littleEndian?: bool): u64;
  /** The \`setFloat32()\` method stores a signed 32-bit float (float) value at the specified byte offset from the start of the \`DataView\`. */
  setFloat32(byteOffset: i32, value: f32, littleEndian?: bool): void;
  /** The \`setFloat64()\` method stores a signed 64-bit float (double) value at the specified byte offset from the start of the \`DataView\`. */
  setFloat64(byteOffset: i32, value: f64, littleEndian?: bool): void;
  /** The \`setInt8()\` method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the \`DataView\`. */
  setInt8(byteOffset: i32, value: i8): void;
  /** The \`setInt16()\` method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the \`DataView\`. */
  setInt16(byteOffset: i32, value: i16, littleEndian?: bool): void;
  /** The \`setInt32()\` method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the \`DataView\`. */
  setInt32(byteOffset: i32, value: i32, littleEndian?: bool): void;
  /** The \`setInt64()\` method stores a signed 64-bit integer (long long) value at the specified byte offset from the start of the \`DataView\`. */
  setInt64(byteOffset: i32, value: i64, littleEndian?: bool): void;
  /** The \`setUint8()\` method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the \`DataView\`. */
  setUint8(byteOffset: i32, value: u8): void;
  /** The \`setUint16()\` method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the \`DataView\`. */
  setUint16(byteOffset: i32, value: u16, littleEndian?: bool): void;
  /** The \`setUint32()\` method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the \`DataView\`. */
  setUint32(byteOffset: i32, value: u32, littleEndian?: bool): void;
  /** The \`setUint64()\` method stores an unsigned 64-bit integer (unsigned long long) value at the specified byte offset from the start of the \`DataView\`. */
  setUint64(byteOffset: i32, value: u64, littleEndian?: bool): void;
  /** Returns a string representation of DataView. */
  toString(): string;
}

interface ArrayLike<T> {
  [key: number]: T;
  length: i32;
}

/** Interface for a typed view on an array buffer. */
interface ArrayBufferView {
  /** The {@link ArrayBuffer} referenced by this view. */
  readonly buffer: ArrayBuffer;
  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteOffset: i32;
  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteLength: i32;
  /** Returns raw pointer to data storage including offset (unsafe). */
  readonly dataStart: usize;
}

/** @internal */
declare abstract class TypedArray<T> implements ArrayBufferView {
  [key: number]: T;
  /** Number of bytes per element. */
  static readonly BYTES_PER_ELEMENT: usize;
  /** Constructs a new typed array. */
  constructor(length: i32);
  /** The {@link ArrayBuffer} referenced by this view. */
  readonly buffer: ArrayBuffer;
  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteOffset: i32;
  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteLength: i32;
  /** Returns raw pointer to data storage including offset (unsafe). */
  readonly dataStart: usize;
  /** The length (in elements). */
  readonly length: i32;
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): T;
  /** The includes() method determines whether a typed array includes a certain element, returning true or false as appropriate. */
  includes(searchElement: T, fromIndex?: i32): bool;
  /** The indexOf() method returns the first index at which a given element can be found in the typed array, or -1 if it is not present. */
  indexOf(searchElement: T, fromIndex?: i32): i32;
  /** The lastIndexOf() method returns the last index at which a given element can be found in the typed array, or -1 if it is not present. The typed array is searched backwards, starting at fromIndex. */
  lastIndexOf(searchElement: T, fromIndex?: i32): i32;
  /** Returns copied section of an TypedArray from begin inclusive to end exclusive */
  slice(begin?: i32, end?: i32): TypedArray<T>;
  /** Returns a new TypedArray of this type on the same ArrayBuffer from begin inclusive to end exclusive. */
  subarray(begin?: i32, end?: i32): TypedArray<T>;
  /** The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end. The end argument is optional and defaults to the length of the array. */
  copyWithin(target: i32, start: i32, end?: i32): this;
  /**  The reduce() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value. This method has the same algorithm as Array.prototype.reduce(). */
  reduce<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;
  /**  The reduceRight() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value, starting from the end of the array. This method has the same algorithm as Array.prototype.reduceRight(). */
  reduceRight<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;
  /** The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some().*/
  some(callbackfn: (value: T, index: i32, self: this) => bool): bool;
  /** The map() method creates a new typed array with the results of calling a provided function on every element in this typed array. This method has the same algorithm as Array.prototype.map().*/
  map(callbackfn: (value: T, index: i32, self: this) => T): TypedArray<T>;
  /** The filter() method creates a new typed array with all elements that pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.filter(). */
  filter(callbackfn: (value: T, index: i32, self: this) => bool): TypedArray<T>;
  /** The sort() method sorts the elements of a typed array numerically in place and returns the typed array. This method has the same algorithm as Array.prototype.sort(), except that sorts the values numerically instead of as strings. TypedArray is one of the typed array types here. */
  sort(callback?: (a: T, b: T) => i32): this;
  /** The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). */
  fill(value: T, start?: i32, end?: i32): this;
  /** The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */
  findIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;
  /** The findLastIndex() method returns an index start searching from the end in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */
  findLastIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;
  /** The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). */
  every(callbackfn: (value: T, index: i32, self: this) => bool): bool;
  /** The forEach() method executes a provided function once per array element. This method has the same algorithm as Array.prototype.forEach().*/
  forEach(callbackfn: (value: T, index: i32, self: this) => void): void;
  /** The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). */
  reverse(): this;
  /** The join() method joins all elements of an array into a string. This method has the same algorithm as Array.prototype.join(). */
  join(separator?: string): string;
  /** The set() method stores multiple values in the typed array, reading input values from a specified array. */
  set<U extends ArrayLike<number>>(source: U, offset?: i32): void
  /** The toString() method returns a string representing the specified array and its elements. This method has the same algorithm as Array.prototype.toString() */
  toString(): string;
}

/** An array of twos-complement 8-bit signed integers. */
declare class Int8Array extends TypedArray<i8> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;
}
/** An array of 8-bit unsigned integers. */
declare class Uint8Array extends TypedArray<u8> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;
}
/** A clamped array of 8-bit unsigned integers. */
declare class Uint8ClampedArray extends TypedArray<u8> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;
}
/** An array of twos-complement 16-bit signed integers. */
declare class Int16Array extends TypedArray<i16> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;
}
/** An array of 16-bit unsigned integers. */
declare class Uint16Array extends TypedArray<u16> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;
}
/** An array of twos-complement 32-bit signed integers. */
declare class Int32Array extends TypedArray<i32> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;
}
/** An array of 32-bit unsigned integers. */
declare class Uint32Array extends TypedArray<u32> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;
}
/** An array of twos-complement 64-bit signed integers. */
declare class Int64Array extends TypedArray<i64> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int64Array;
}
/** An array of 64-bit unsigned integers. */
declare class Uint64Array extends TypedArray<u64> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint64Array;
}
/** An array of 32-bit floating point numbers. */
declare class Float32Array extends TypedArray<f32> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;
}
/** An array of 64-bit floating point numbers. */
declare class Float64Array extends TypedArray<f64> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;
}

/** Class representing a sequence of values of type \`T\`. */
declare class Array<T> {

  /** Tests if a value is an array. */
  static isArray<U>(value: any): value is Array<any>;

  [key: number]: T;
  /** Current length of the array. */
  length: i32;
  /** Returns raw pointer to data storage (unsafe). */
  readonly dataStart: usize;
  /** Constructs a new array. */
  constructor(length?: i32);
  at(index: i32): T;
  fill(value: T, start?: i32, end?: i32): this;
  findIndex(callbackfn: (value: T, index: i32, array: Array<T>) => bool): i32;
  findLastIndex(callbackfn: (value: T, index: i32, array: Array<T>) => bool): i32;
  includes(searchElement: T, fromIndex?: i32): bool;
  indexOf(searchElement: T, fromIndex?: i32): i32;
  lastIndexOf(searchElement: T, fromIndex?: i32): i32;
  push(element: T): i32;
  concat(items: T[]): T[];
  copyWithin(target: i32, start: i32, end?: i32): this;
  pop(): T;
  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;
  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;
  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;
  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;
  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;
  every(callbackfn: (value: T, index: i32, array: Array<T>) => bool): bool;
  some(callbackfn: (value: T, index: i32, array: Array<T>) => bool): bool;
  shift(): T;
  unshift(element: T): i32;
  slice(from?: i32, to?: i32): Array<T>;
  splice(start: i32, deleteCount?: i32): Array<T>;
  sort(comparator?: (a: T, b: T) => i32): this;
  join(separator?: string): string;
  reverse(): this;
  /** Flattens an array of arrays. If any null entries exist in the array, they are ignored, unlike JavaScript's version of Array#flat(). */
  flat(): T extends unknown[] ? T : never;
  toString(): string;
}

/** Class representing a static (not resizable) sequence of values of type \`T\`. This class is @final. */
declare class StaticArray<T> {
  [key: number]: T;
  static fromArray<T>(source: Array<T>): StaticArray<T>;
  /** @deprecated */
  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T>;
  /** @deprecated */
  static slice<T>(source: StaticArray<T>, start?: i32, end?: i32): StaticArray<T>;
  readonly length: i32;
  constructor(length?: i32);
  at(index: i32): T;
  fill(value: T, start?: i32, end?: i32): this;
  findIndex(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): i32;
  findLastIndex(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): i32;
  copyWithin(target: i32, start: i32, end?: i32): this;
  includes(searchElement: T, fromIndex?: i32): bool;
  indexOf(searchElement: T, fromIndex?: i32): i32;
  lastIndexOf(searchElement: T, fromIndex?: i32): i32;
  forEach(callbackfn: (value: T, index: i32, array: StaticArray<T>) => void): void;
  map<U>(callbackfn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U>;
  filter(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T>;
  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U, initialValue: U): U;
  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U, initialValue: U): U;
  every(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): bool;
  some(callbackfn: (value: T, index: i32, array: StaticArray<T>) => bool): bool;
  concat(items: Array<T>): Array<T>;
  concat<U extends ArrayLike<T>>(other: U): U;
  slice(from?: i32, to?: i32): Array<T>;
  slice<U extends ArrayLike<T>>(from?: i32, to?: i32): U;
  sort(comparator?: (a: T, b: T) => i32): this;
  join(separator?: string): string;
  reverse(): this;
  toString(): string;
}

/** Class representing a sequence of characters. */
declare class String {
  static fromCharCode(ls: i32, hs?: i32): string;
  static fromCharCodes(arr: i32[]): string;
  static fromCodePoint(code: i32): string;
  static fromCodePoints(arr: i32[]): string;
  static raw(parts: TemplateStringsArray, ...args: any[]): string;
  readonly length: i32;
  at(index: i32): string;
  charAt(index: i32): string;
  charCodeAt(index: i32): i32;
  codePointAt(index: i32): i32;
  concat(other: string): string;
  endsWith(other: string): bool;
  indexOf(other: string, fromIndex?: i32): i32;
  lastIndexOf(other: string, fromIndex?: i32): i32;
  localeCompare(other: string): i32;
  includes(other: string): bool;
  startsWith(other: string): bool;
  substr(start: i32, length?: i32): string;
  substring(start: i32, end?: i32): string;
  trim(): string;
  trimLeft(): string;
  trimRight(): string;
  trimStart(): string;
  trimEnd(): string;
  padStart(targetLength: i32, padString?: string): string;
  padEnd(targetLength: i32, padString?: string): string;
  repeat(count?: i32): string;
  replace(search: string, replacement: string): string;
  replaceAll(search: string, replacement: string): string;
  slice(beginIndex: i32, endIndex?: i32): string;
  split(separator?: string, limit?: i32): string[];
  toLowerCase(): string;
  toUpperCase(): string;
  toString(): string;
}

declare namespace String {
  /** Encoding helpers for UTF-8. */
  export namespace UTF8 {
    /** UTF-8 encoding error modes. */
    export const enum ErrorMode {
      /** Keeps unpaired surrogates as of WTF-8. This is the default. */
      WTF8,
      /** Replaces unpaired surrogates with the replacement character (U+FFFD). */
      REPLACE,
      /** Throws an error on unpaired surrogates. */
      ERROR
    }
    /** Calculates the byte length of the specified string when encoded as UTF-8, optionally null terminated. */
    export function byteLength(str: string, nullTerminated?: bool): i32;
    /** Encodes the specified string to UTF-8 bytes, optionally null terminated. ErrorMode defaults to WTF-8. */
    export function encode(str: string, nullTerminated?: bool, errorMode?: ErrorMode): ArrayBuffer;
    /** Encodes the specified raw string to UTF-8 bytes, opionally null terminated. ErrorMode defaults to WTF-8. Returns the number of bytes written. */
    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated?: bool, errorMode?: ErrorMode): usize;
    /** Decodes the specified buffer from UTF-8 bytes to a string, optionally null terminated. */
    export function decode(buf: ArrayBuffer, nullTerminated?: bool): string;
    /** Decodes raw UTF-8 bytes to a string, optionally null terminated. */
    export function decodeUnsafe(buf: usize, len: usize, nullTerminated?: bool): string;
  }
  /** Encoding helpers for UTF-16. */
  export namespace UTF16 {
    /** Calculates the byte length of the specified string when encoded as UTF-16. */
    export function byteLength(str: string): i32;
    /** Encodes the specified string to UTF-16 bytes. */
    export function encode(str: string): ArrayBuffer;
    /** Encodes the specified raw string to UTF-16 bytes. Returns the number of bytes written. */
    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize;
    /** Decodes the specified buffer from UTF-16 bytes to a string. */
    export function decode(buf: ArrayBuffer): string;
    /** Decodes raw UTF-16 bytes to a string. */
    export function decodeUnsafe(buf: usize, len: usize): string;
  }
}

declare class TemplateStringsArray extends Array<string> {
  readonly raw: string[];
}

declare class Object {
  /** The Object.is() method determines whether two values are the same value. */
  static is<T>(value1: T, value2: T): bool;
}

declare namespace performance {
  /** Gets a high resolution timestamp measured in milliseconds. */
  export function now(): f64;
}

declare class Date {
  /** Returns the UTC timestamp in milliseconds of the specified date. */
  static UTC(
    year: i32,
    month: i32,
    day: i32,
    hour: i32,
    minute: i32,
    second: i32,
    millisecond: i32
  ): i64;
  /** Returns the current UTC timestamp in milliseconds. */
  static now(): i64;
  /** Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC. */
  static parse(dateString: string): Date;
  static fromString(dateString: string): Date;
  /** Constructs a new date object from an UTC timestamp in milliseconds. */
  constructor(value: i64);
  /** Returns the UTC timestamp of this date in milliseconds. */
  getTime(): i64;
  /** Sets the UTC timestamp of this date in milliseconds. */
  setTime(value: i64): i64;

  getUTCFullYear(): i32;
  getUTCMonth(): i32;
  getUTCDate(): i32;
  getUTCDay(): i32;
  getUTCHours(): i32;
  getUTCMinutes(): i32;
  getUTCSeconds(): i32;
  getUTCMilliseconds(): i32;

  setUTCFullYear(value: i32): void;
  setUTCMonth(value: i32, day?: i32): void;
  setUTCDate(value: i32): void;
  setUTCHours(value: i32): void;
  setUTCMinutes(value: i32): void;
  setUTCSeconds(value: i32): void;
  setUTCMilliseconds(value: i32): void;

  toString(): string;
  toISOString(): string;
  toUTCString(): string;
  toDateString(): string;
  toTimeString(): string;
}

/** Class for representing a runtime error. Base class of all errors. */
declare class Error {

  /** Error name. */
  name: string;

  /** Message provided on construction. */
  message: string;

  /** Stack trace. */
  stack?: string;

  /** Constructs a new error, optionally with a message. */
  constructor(message?: string);

  /** Method returns a string representing the specified Error class. */
  toString(): string;
}

/** Class for indicating an error when a value is not in the set or range of allowed values. */
declare class RangeError extends Error { }

/** Class for indicating an error when a value is not of the expected type. */
declare class TypeError extends Error { }

/** Class for indicating an error when trying to interpret syntactically invalid code. */
declare class SyntaxError extends Error { }

/** Class for indicating an error when a global URI handling function was used in a wrong way. */
declare class URIError extends Error { }

interface Function {
  /** Function table index. */
  readonly index: u32;
  /** Function name. Always an empty string. */
  readonly name: string;
  /** Number of expected parameters. */
  readonly length: u32;
  /** Calls this function indirectly with the specified arguments. */
  call(thisArg: unknown, ...args: unknown[]): any;
  /** Returns a string representation of this function. */
  toString(): string;
}
interface IArguments {}
interface RegExp {}

declare class Map<K,V> {
  readonly size: i32;
  has(key: K): bool;
  set(key: K, value: V): this;
  get(key: K): V;
  delete(key: K): bool;
  clear(): void;
  keys(): K[]; // preliminary
  values(): V[]; // preliminary
  toString(): string;
}

declare class Set<K> {
  readonly size: i32;
  has(value: K): bool;
  add(value: K): this;
  delete(value: K): bool;
  clear(): void;
  values(): K[]; // preliminary
  toString(): string;
}

interface SymbolConstructor {
  readonly hasInstance: symbol;
  readonly isConcatSpreadable: symbol;
  readonly isRegExp: symbol;
  readonly iterator: symbol;
  readonly match: symbol;
  readonly replace: symbol;
  readonly search: symbol;
  readonly species: symbol;
  readonly split: symbol;
  readonly toPrimitive: symbol;
  readonly toStringTag: symbol;
  readonly unscopables: symbol;
  (description?: string | null): symbol;
  for(key: string): symbol;
  keyFor(sym: symbol): string | null;
}

declare const Symbol: SymbolConstructor;

/** @internal */
interface IMath<T> {
  /** The base of natural logarithms, e, approximately 2.718. */
  readonly E: T;
  /** The natural logarithm of 2, approximately 0.693. */
  readonly LN2: T;
  /** The natural logarithm of 10, approximately 2.302. */
  readonly LN10: T;
  /** The base 2 logarithm of e, approximately 1.442. */
  readonly LOG2E: T;
  /** The base 10 logarithm of e, approximately 0.434. */
  readonly LOG10E: T;
  /** The ratio of the circumference of a circle to its diameter, approximately 3.14159. */
  readonly PI: T;
  /** The square root of 1/2, approximately 0.707. */
  readonly SQRT1_2: T;
  /** The square root of 2, approximately 1.414. */
  readonly SQRT2: T;
  /** Returns the absolute value of \`x\`. */
  abs(x: T): T;
  /** Returns the arccosine (in radians) of \`x\`. */
  acos(x: T): T;
  /** Returns the hyperbolic arc-cosine of \`x\`. */
  acosh(x: T): T;
  /** Returns the arcsine (in radians) of \`x\`. */
  asin(x: T): T;
  /** Returns the hyperbolic arcsine of \`x\`. */
  asinh(x: T): T;
  /** Returns the arctangent (in radians) of \`x\`. */
  atan(x: T): T;
  /** Returns the arctangent of the quotient of its arguments. */
  atan2(y: T, x: T): T;
  /** Returns the hyperbolic arctangent of \`x\`. */
  atanh(x: T): T;
  /** Returns the cube root of \`x\`. */
  cbrt(x: T): T;
  /** Returns the smallest integer greater than or equal to \`x\`. */
  ceil(x: T): T;
  /** Returns the number of leading zero bits in the 32-bit binary representation of \`x\`. */
  clz32(x: T): T;
  /** Returns the cosine (in radians) of \`x\`. */
  cos(x: T): T;
  /** Returns the hyperbolic cosine of \`x\`. */
  cosh(x: T): T;
  /** Returns e to the power of \`x\`. */
  exp(x: T): T;
  /** Returns e to the power of \`x\`, minus 1. */
  expm1(x: T): T;
  /** Returns the largest integer less than or equal to \`x\`. */
  floor(x: T): T;
  /** Returns the nearest 32-bit single precision float representation of \`x\`. */
  fround(x: T): T;
  /** Returns the square root of the sum of squares of its arguments. */
  hypot(value1: T, value2: T): T; // TODO: rest
  /** Returns the result of the C-like 32-bit multiplication of \`a\` and \`b\`. */
  imul(a: T, b: T): T;
  /** Returns the natural logarithm (base e) of \`x\`. */
  log(x: T): T;
  /** Returns the base 10 logarithm of \`x\`. */
  log10(x: T): T;
  /** Returns the natural logarithm (base e) of 1 + \`x\`. */
  log1p(x: T): T;
  /** Returns the base 2 logarithm of \`x\`. */
  log2(x: T): T;
  /** Returns the largest-valued number of its arguments. */
  max(value1: T, value2: T): T; // TODO: rest
  /** Returns the lowest-valued number of its arguments. */
  min(value1: T, value2: T): T; // TODO: rest
  /** Returns \`base\` to the power of \`exponent\`. */
  pow(base: T, exponent: T): T;
  /** Returns a pseudo-random number in the range from 0.0 inclusive up to but not including 1.0. */
  random(): T;
  /** Returns the value of \`x\` rounded to the nearest integer. */
  round(x: T): T;
  /** Returns the sign of \`x\`, indicating whether the number is positive, negative or zero. */
  sign(x: T): T;
  /** Returns whether the sign bit of \`x\` is set. */
  signbit(x: T): bool;
  /** Returns the sine of \`x\`. */
  sin(x: T): T;
  /** Returns the hyperbolic sine of \`x\`. */
  sinh(x: T): T;
  /** Returns the square root of \`x\`. */
  sqrt(x: T): T;
  /** Returns the tangent of \`x\`. */
  tan(x: T): T;
  /** Returns the hyperbolic tangent of \`x\`. */
  tanh(x: T): T;
  /** Returns the integer part of \`x\` by removing any fractional digits. */
  trunc(x: T): T;
}

/** @internal */
interface INativeMath<T> extends IMath<T> {
  /** Contains sin value produced after Math/Mathf.sincos */
  sincos_sin: T;
  /** Contains cos value produced after Math/Mathf.sincos */
  sincos_cos: T;
  /** Seeds the random number generator. */
  seedRandom(value: i64): void;
  /** Multiplies a floating point \`x\` by 2 raised to power exp \`n\`. */
  scalbn(x: T, n: i32): T;
  /** Returns the floating-point remainder of \`x / y\` (rounded towards zero). */
  mod(x: T, y: T): T;
  /** Returns the floating-point remainder of \`x / y\` (rounded to nearest). */
  rem(x: T, y: T): T;
  /** Returns sin and cos simultaneously for same angle. Results stored to \`sincos_s32/64\` and \`sincos_c32/64\` globals */
  sincos(x: T): void;
  /** Returns 2 raised to the given power x. Equivalent to 2 ** x. */
  exp2(x: T): T;
}

/** Double precision math imported from JavaScript. */
declare const JSMath: IMath<f64>;
/** Double precision math implemented natively. */
declare const NativeMath: INativeMath<f64>;
/** Single precision math implemented natively. */
declare const NativeMathf: INativeMath<f32>;
/** Alias of {@link NativeMath} or {@link JSMath} respectively. Defaults to \`NativeMath\`. */
declare const Math: IMath<f64>;
/** Alias of {@link NativeMathf} or {@link JSMath} respectively. Defaults to \`NativeMathf\`. */
declare const Mathf: IMath<f32>;

/** Environmental abort function. */
declare function abort(msg?: string | null, fileName?: string | null, lineNumber?: i32, columnNumber?: i32): never;
/** Environmental tracing function. */
declare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;
/** Environmental seeding function. */
declare function seed(): f64;

/** Node-like process. */
declare namespace process {
  /** String representing the CPU architecture for which the binary was compiled. Either \`wasm32\` or \`wasm64\`. */
  export const arch: string;
  /** String representing the operating system platform for which the binary was compiled. Always \`wasm\`. */
  export const platform: string;
  /** Array of command line arguments passed to the binary upon instantiation. */
  export const argv: string[];
  /** Map of variables in the binary's user environment. */
  export const env: Map<string,string>;
  /** Terminates the process with either the given exit code, or \`process.exitCode\` if omitted. */
  export function exit(code?: i32): void;
  /** \`exit()\`\u2019s default value. Defaults to \`0\`. */
  export let exitCode: i32;
  /** Stream connected to \`stdin\` (fd \`0\`). */
  export const stdin: ReadableStream;
  /** Stream connected to \`stdout\` (fd \`1\`). */
  export const stdout: WritableStream;
  /** Stream connected to \`stderr\` (fd \`2\`). */
  export const stderr: WritableStream;
  /** Obtains the system's current time of day, in milliseconds since Unix epoch. */
  export function time(): i64;
  /** Obtains the system's monotonic high resolution time, in nanoseconds since an arbitrary time in the past. */
  export function hrtime(): u64;

  interface Stream {
    /** Closes the stream. Throws if already closed or if the stream cannot be closed. */
    close(): void;
  }
  interface ReadableStream extends Stream {
    /** Reads available data from the stream, into \`buffer\` at offset \`offset\`, returning the number of bytes read. */
    read(buffer: ArrayBuffer, offset?: isize): i32;
  }
  interface WritableStream extends Stream {
    /** Writes string or buffer to the stream. */
    write<T extends string | ArrayBuffer>(data: T): void;
  }
}

/** Browser-like console. */
declare namespace console {
  /** Logs \`message\` to console if \`assertion\` is false-ish. */
  export function assert<T>(assertion: T, message?: string): void;
  /** Outputs \`message\` to the console. */
  export function log(message?: string): void;
  /** Outputs \`message\` to the console, prefixed with "Debug:". */
  export function debug(message?: string): void;
  /** Outputs \`message\` to the console, prefixed with "Info:". */
  export function info(message?: string): void;
  /** Outputs \`message\` to the console, prefixed with "Warning:". */
  export function warn(message?: string): void;
  /** Outputs \`message\` to the console, prefixed with "Error:". */
  export function error(message?: string): void;
  /** Starts a new timer using the specified \`label\`. */
  export function time(label?: string): void;
  /** Logs the current value of a timer previously started with \`console.time\`. */
  export function timeLog(label?: string): void;
  /** Logs the current value of a timer previously started with \`console.time\` and discards the timer. */
  export function timeEnd(label?: string): void;
}

/** Browser-like crypto utilities. */
declare namespace crypto {
  /** Fills \`array\` with cryptographically strong random values. */
  export function getRandomValues(array: Uint8Array): void;
}

// Decorators

interface TypedPropertyDescriptor<T> {
  configurable?: boolean;
  enumerable?: boolean;
  writable?: boolean;
  value?: T;
  get?(): T;
  set?(value: T): void;
}

/** Annotates a method as a binary operator overload for the specified \`token\`. */
declare function operator(token:
  "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |
  ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"
): (
  target: any,
  propertyKey: string,
  descriptor: TypedPropertyDescriptor<any>
) => TypedPropertyDescriptor<any> | void;

declare namespace operator {
  /** Annotates a method as a binary operator overload for the specified \`token\`. */
  export function binary(token:
    "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |
    ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"
  ): (
    target: any,
    propertyKey: string,
    descriptor: TypedPropertyDescriptor<any>
  ) => TypedPropertyDescriptor<any> | void;
  /** Annotates a method as an unary prefix operator overload for the specified \`token\`. */
  export function prefix(token: "!" | "~" | "+" | "-" | "++" | "--"): (
    target: any,
    propertyKey: string,
    descriptor: TypedPropertyDescriptor<any>
  ) => TypedPropertyDescriptor<any> | void;
  /** Annotates a method as an unary postfix operator overload for the specified \`token\`. */
  export function postfix(token: "++" | "--"): (
    target: any,
    propertyKey: string,
    descriptor: TypedPropertyDescriptor<any>
  ) => TypedPropertyDescriptor<any> | void;
}

/** Annotates an element as a program global. */
declare function global(...args: any[]): any;

/** Annotates a class as being unmanaged with limited capabilities. */
declare function unmanaged(constructor: Function): void;

/** Annotates a class as being final / non-derivable. */
declare function final(constructor: Function): void;

/** Annotates a method, function or constant global as always inlined. */
declare function inline(...args: any[]): any;

/** Annotates a method, function or constant global as unsafe. */
declare function unsafe(...args: any[]): any;

/** Annotates an explicit external name of a function or global. */
declare function external(name: string): any;
declare function external(moduleName: string, name: string): any;
declare namespace external {
  function js(code: string): any;
}

/** Annotates a global for lazy compilation. */
declare function lazy(...args: any[]): any;
`,portable:`/**
 * Environment definitions for compiling AssemblyScript to JavaScript using tsc.
 *
 * Note that semantic differences require additional explicit conversions for full compatibility.
 * For example, when casting an i32 to an u8, doing \`<u8>(someI32 & 0xff)\` will yield the same
 * result when compiling to WebAssembly or JS while \`<u8>someI32\` alone does nothing in JS.
 *
 * Note that i64's are not portable (JS numbers are IEEE754 doubles with a maximum safe integer
 * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example
 * {@link glue/js/i64} respectively {@link glue/wasm/i64}.
 *
 * @module std/portable
 *//***/

// Types

declare type bool = boolean;
declare type i8 = number;
declare type i16 = number;
declare type i32 = number;
declare type isize = number;
declare type u8 = number;
declare type u16 = number;
declare type u32 = number;
declare type usize = number;
declare type f32 = number;
declare type f64 = number;

/** Special type evaluating the indexed access index type. */
declare type indexof<T extends unknown[]> = keyof T;
/** Special type evaluating the indexed access value type. */
declare type valueof<T extends unknown[]> = T[0];

// Compiler hints

/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */
declare const ASC_TARGET: i32;
/** Runtime type. 0 = Stub, 1 = Minimal, 2 = Incremental. */
declare const ASC_RUNTIME: i32;
/** Provided noAssert option. */
declare const ASC_NO_ASSERT: bool;
/** Provided memoryBase option. */
declare const ASC_MEMORY_BASE: i32;
/** Provided optimizeLevel option. */
declare const ASC_OPTIMIZE_LEVEL: i32;
/** Provided shrinkLevel option. */
declare const ASC_SHRINK_LEVEL: i32;
/** Whether the mutable global feature is enabled. */
declare const ASC_FEATURE_MUTABLE_GLOBAL: bool;
/** Whether the sign extension feature is enabled. */
declare const ASC_FEATURE_SIGN_EXTENSION: bool;

// Builtins

/** Performs the sign-agnostic reverse bytes **/
declare function bswap<T = i32 | u32 | isize | usize>(value: T): T;
/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */
declare function clz<T = i32>(value: T): T;
/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */
declare function ctz<T = i32>(value: T): T;
/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */
declare function popcnt<T = i32>(value: T): T;
/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */
declare function rotl<T = i32>(value: T, shift: T): T;
/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */
declare function rotr<T = i32>(value: T, shift: T): T;
/** Computes the absolute value of an integer or float. */
declare function abs<T = i32 | f32 | f64>(value: T): T;
/** Determines the maximum of two integers or floats. If either operand is \`NaN\`, returns \`NaN\`. */
declare function max<T = i32 | f32 | f64>(left: T, right: T): T;
/** Determines the minimum of two integers or floats. If either operand is \`NaN\`, returns \`NaN\`. */
declare function min<T = i32 | f32 | f64>(left: T, right: T): T;
/** Composes a 32-bit or 64-bit float from the magnitude of \`x\` and the sign of \`y\`. */
declare function copysign<T = f32 | f64>(x: T, y: T): T;
/** Performs the ceiling operation on a 32-bit or 64-bit float. */
declare function ceil<T = f32 | f64>(value: T): T;
/** Performs the floor operation on a 32-bit or 64-bit float. */
declare function floor<T = f32 | f64>(value: T): T;
/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */
declare function nearest<T = f32 | f64>(value: T): T;
/** Selects one of two pre-evaluated values depending on the condition. */
declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;
/** Calculates the square root of a 32-bit or 64-bit float. */
declare function sqrt<T = f32 | f64>(value: T): T;
/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */
declare function trunc<T = f32 | f64>(value: T): T;
/** Emits an unreachable operation that results in a runtime error when executed. */
declare function unreachable(): any; // sic

/** Changes the type of any value of \`usize\` kind to another one of \`usize\` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/
declare function changetype<T>(value: any): T;
/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */
declare function unchecked<T>(value: T): T;
/** Tests if the specified value is a valid integer. Can't distinguish an integer from an integral float. */
declare function isInteger(value: any): value is number;
/** Tests if the specified value is a valid float. Can't distinguish a float from an integer. */
declare function isFloat(value: any): value is number;
/** Tests if the specified value is of a nullable reference type. */
declare function isNullable(value: any): bool;
/** Tests if the specified value is of a reference type. */
declare function isReference(value: any): value is object | string;
/** Tests if the specified value is of a function type */
declare function isFunction(value: any): value is Function;
/** Tests if the specified value can be used as a string. */
declare function isString(value: any): value is string | String;
/** Tests if the specified value can be used as an array. */
declare function isArray(value: any): value is Array<any>;
/** Tests if the specified type *or* expression can be used as an array like object. */
declare function isArrayLike(value: any): value is ArrayLike<any>;
/** Tests if the specified expression resolves to a defined element. */
declare function isDefined(expression: any): bool;
/** Tests if the specified expression evaluates to a constant value. */
declare function isConstant(expression: any): bool;
/** Traps if the specified value is not true-ish, otherwise returns the value. */
declare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model \`: T != null\`?
/** Parses an integer string to a 64-bit float. */
declare function parseInt(str: string, radix?: i32): f64;
/** Parses a floating point string to a 64-bit float. */
declare function parseFloat(str: string): f64;
/** Returns the 64-bit floating-point remainder of \`x/y\`. */
declare function fmod(x: f64, y: f64): f64;
/** Returns the 32-bit floating-point remainder of \`x/y\`. */
declare function fmodf(x: f32, y: f32): f32;

/** Converts any other numeric value to an 8-bit signed integer. */
declare function i8(value: any): i8;
declare namespace i8 {
  /** Smallest representable value. */
  export const MIN_VALUE: i8;
  /** Largest representable value. */
  export const MAX_VALUE: i8;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): i8;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): i8;
}
/** Converts any other numeric value to a 16-bit signed integer. */
declare function i16(value: any): i16;
declare namespace i16 {
  /** Smallest representable value. */
  export const MIN_VALUE: i16;
  /** Largest representable value. */
  export const MAX_VALUE: i16;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): i16;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): i16;
}
/** Converts any other numeric value to a 32-bit signed integer. */
declare function i32(value: any): i32;
declare namespace i32 {
  /** Smallest representable value. */
  export const MIN_VALUE: i32;
  /** Largest representable value. */
  export const MAX_VALUE: i32;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): i32;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): i32;
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */
declare function isize(value: any): isize;
declare namespace isize {
  /** Smallest representable value. */
  export const MIN_VALUE: isize;
  /** Largest representable value. */
  export const MAX_VALUE: isize;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): isize;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): isize;
}
/** Converts any other numeric value to an 8-bit unsigned integer. */
declare function u8(value: any): u8;
declare namespace u8 {
  /** Smallest representable value. */
  export const MIN_VALUE: u8;
  /** Largest representable value. */
  export const MAX_VALUE: u8;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): u8;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): u8;
}
/** Converts any other numeric value to a 16-bit unsigned integer. */
declare function u16(value: any): u16;
declare namespace u16 {
  /** Smallest representable value. */
  export const MIN_VALUE: u16;
  /** Largest representable value. */
  export const MAX_VALUE: u16;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): u16;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): u16;
}
/** Converts any other numeric value to a 32-bit unsigned integer. */
declare function u32(value: any): u32;
declare namespace u32 {
  /** Smallest representable value. */
  export const MIN_VALUE: u32;
  /** Largest representable value. */
  export const MAX_VALUE: u32;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): u32;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): u32;
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */
declare function usize(value: any): isize;
declare namespace usize {
  /** Smallest representable value. */
  export const MIN_VALUE: usize;
  /** Largest representable value. */
  export const MAX_VALUE: usize;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): usize;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): usize;
}
/** Converts any other numeric value to a 1-bit unsigned integer. */
declare function bool(value: any): bool;
declare namespace bool {
  /** Smallest representable value. */
  export const MIN_VALUE: bool;
  /** Largest representable value. */
  export const MAX_VALUE: bool;
}
/** Converts any other numeric value to a 32-bit float. */
declare function f32(value: any): f32;
declare namespace f32 {
  /** Smallest representable value. */
  export const MIN_VALUE: f32;
  /** Largest representable value. */
  export const MAX_VALUE: f32;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f32;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f32;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f32;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f32;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f32;
  /** Not a number value. */
  /* eslint no-shadow-restricted-names: "off" */
  export const NaN: f32;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f32;
  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */
  export function isNaN(value: f32): bool;
  /** Returns true if passed value is finite. */
  export function isFinite(value: f32): bool;
  /** Returns true if the value passed is a safe integer. */
  export function isSafeInteger(value: f32): bool;
  /** Returns true if the value passed is an integer, false otherwise. */
  export function isInteger(value: f32): bool;
  /** Converts a string to a floating-point number. */
  export function parseFloat(string: string): f32;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): f32;
}
/** Converts any other numeric value to a 64-bit float. */
declare function f64(value: any): f64;
declare namespace f64 {
  /** Smallest representable value. */
  export const MIN_VALUE: f64;
  /** Largest representable value. */
  export const MAX_VALUE: f64;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f64;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f64;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f64;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f64;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f64;
  /** Not a number value. */
  /* eslint no-shadow-restricted-names: "off" */
  export const NaN: f64;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f64;
  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */
  export function isNaN(value: f32): bool;
  /** Returns true if passed value is finite. */
  export function isFinite(value: f32): bool;
  /** Returns true if the value passed is a safe integer. */
  export function isSafeInteger(value: f64): bool;
  /** Returns true if the value passed is an integer, false otherwise. */
  export function isInteger(value: f64): bool;
  /** Converts a string to a floating-point number. */
  export function parseFloat(string: string): f64;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): f64;
}

// Standard library

declare const Mathf: typeof Math;
declare const JSMath: typeof Math;

declare interface StringConstructor {
  /** Equivalent to calling \`String.fromCharCode\` with multiple arguments. */
  fromCharCodes(arr: i32[]): string;
  /** Equivalent to calling \`String.fromCodePoint\` with multiple arguments. */
  fromCodePoints(arr: i32[]): string;
}

declare interface String {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): string;
}

/** Annotates a class as being unmanaged with limited capabilities. */
declare function unmanaged(constructor: Function): void;

/** Environmental tracing function. */
declare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;

declare interface Array<T> {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): T;
  /** Returns an index start searching from the end in the array */
  findLastIndex(callbackfn: (value: T, index: i32, self: Array<T>) => bool): i32;
}

declare interface Int8ArrayConstructor {
  /** Equivalent to calling \`new Int8Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;
}

declare interface Int8Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): i8;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): i32;
}

declare interface Uint8ArrayConstructor {
  /** Equivalent to calling \`new Uint8Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;
}

declare interface Uint8Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u8;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): i32;
}

declare interface Uint8ClampedArrayConstructor {
  /** Equivalent to calling \`new Uint8ClampedArray\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;
}

declare interface Uint8ClampedArray {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u8;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32;
}

declare interface Int16ArrayConstructor {
  /** Equivalent to calling \`new Int16Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;
}

declare interface Int16Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): i16;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): i32;
}

declare interface Uint16ArrayConstructor {
  /** Equivalent to calling \`new Uint16Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;
}

declare interface Uint16Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u16;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): i32;
}

declare interface Int32ArrayConstructor {
  /** Equivalent to calling \`new Int32Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;
}

declare interface Int32Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): i32;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): i32;
}

declare interface Uint32ArrayConstructor {
  /** Equivalent to calling \`new Uint32Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;
}

declare interface Uint32Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u32;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): i32;
}

declare interface Float32ArrayConstructor {
  /** Equivalent to calling \`new Float32Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;
}

declare interface Float32Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): f32;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): i32;
}

declare interface Float64ArrayConstructor {
  /** Equivalent to calling \`new Float64Array\` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;
}

declare interface Float64Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): f64;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): i32;
}

// FIXME: remove
declare function offsetof<T>(fieldName?: string): usize;
declare function idof<T>(): u32;
`};var pr={};Mn(pr,{default:()=>Bs});bs(pr,hA);import*as hA from"binaryen";import{default as Bs}from"binaryen";var ju={};Mn(ju,{ASTBuilder:()=>qu,ArrayLiteralExpression:()=>Wa,ArrowKind:()=>Uo,AssertionExpression:()=>Xa,AssertionKind:()=>Ha,AtomicRMWOp:()=>dl,BinaryExpression:()=>Ka,BinaryModule:()=>Pl,BinaryOp:()=>hl,BlockStatement:()=>Ao,BrOnOp:()=>Fl,BreakStatement:()=>To,CallExpression:()=>$a,Class:()=>ps,ClassDeclaration:()=>Qi,ClassExpression:()=>Ya,ClassPrototype:()=>fs,CommaExpression:()=>Za,CommentKind:()=>qa,CommentNode:()=>ja,CommonFlags:()=>va,CommonNames:()=>v,CompiledExpression:()=>vo,Compiler:()=>gs,ConditionKind:()=>jl,ConstantValueKind:()=>Zl,Constraints:()=>Vu,ConstructorExpression:()=>Ja,ContinueStatement:()=>So,DEFAULT_STACK_SIZE:()=>N2,DeclarationStatement:()=>rn,DeclaredElement:()=>Kn,DecoratorFlags:()=>q,DecoratorKind:()=>tr,DecoratorNode:()=>Ga,DiagnosticCategory:()=>La,DiagnosticCode:()=>Aa,DiagnosticEmitter:()=>mt,DiagnosticMessage:()=>$i,DoStatement:()=>Co,Element:()=>us,ElementAccessExpression:()=>Qa,ElementKind:()=>X,EmptyStatement:()=>wo,Enum:()=>Yl,EnumDeclaration:()=>Io,EnumValue:()=>Jl,EnumValueDeclaration:()=>ko,ExportDefaultStatement:()=>Lo,ExportImportStatement:()=>Bo,ExportMember:()=>zo,ExportNames:()=>Yt,ExportStatement:()=>No,Expression:()=>ye,ExpressionId:()=>cl,ExpressionRunnerFlags:()=>kl,ExpressionStatement:()=>Do,ExternalKind:()=>fl,FEATURE_BULK_MEMORY:()=>U2,FEATURE_EXCEPTION_HANDLING:()=>G2,FEATURE_EXTENDED_CONST:()=>$2,FEATURE_GC:()=>H2,FEATURE_MEMORY64:()=>X2,FEATURE_MULTI_VALUE:()=>W2,FEATURE_MUTABLE_GLOBALS:()=>R2,FEATURE_NONTRAPPING_F2I:()=>M2,FEATURE_REFERENCE_TYPES:()=>j2,FEATURE_RELAXED_SIMD:()=>K2,FEATURE_SIGN_EXTENSION:()=>O2,FEATURE_SIMD:()=>P2,FEATURE_STRINGREF:()=>Y2,FEATURE_TAIL_CALLS:()=>q2,FEATURE_THREADS:()=>V2,FalseExpression:()=>yo,Feature:()=>ya,FeatureFlags:()=>ul,Field:()=>eu,FieldDeclaration:()=>Oo,FieldFlags:()=>ql,FieldPrototype:()=>Ql,File:()=>Si,FloatLiteralExpression:()=>eo,Flow:()=>Wn,FlowFlags:()=>Vl,ForOfStatement:()=>Mo,ForStatement:()=>Ro,Function:()=>Hn,FunctionDeclaration:()=>Or,FunctionExpression:()=>no,FunctionPrototype:()=>pn,FunctionTypeNode:()=>Ma,GETTER_PREFIX:()=>Mi,Global:()=>jt,HeapTypeRef:()=>oe,INDEX_SUFFIX:()=>We,INNER_DELIMITER:()=>Ea,INSTANCE_DELIMITER:()=>Sr,IdentifierExpression:()=>hn,IdentifierHandling:()=>rl,IfStatement:()=>Po,ImportDeclaration:()=>Vo,ImportNames:()=>ct,ImportStatement:()=>bi,IndexSignature:()=>tu,IndexSignatureNode:()=>Fo,InstanceOfExpression:()=>to,IntegerLiteralExpression:()=>ro,Interface:()=>iu,InterfaceDeclaration:()=>Go,InterfacePrototype:()=>ru,JSBuilder:()=>xs,LIBRARY_PREFIX:()=>Cn,LIBRARY_SUBST:()=>Vi,LiteralExpression:()=>kn,LiteralKind:()=>Gn,Local:()=>nn,LocalFlags:()=>Gl,MemorySegment:()=>vi,MethodDeclaration:()=>qo,Module:()=>xt,ModuleDeclaration:()=>Yo,NamedTypeNode:()=>_i,Namespace:()=>cs,NamespaceDeclaration:()=>jo,NewExpression:()=>io,Node:()=>F,NodeKind:()=>Oa,NullExpression:()=>so,ObjectLiteralExpression:()=>ao,OmittedExpression:()=>oo,OperatorKind:()=>Ye,Options:()=>Pu,PARENT_SUBST:()=>xp,PATH_DELIMITER:()=>Xn,PackedType:()=>Ht,Parameter:()=>r2,ParameterKind:()=>Pa,ParameterNode:()=>Va,ParenthesizedExpression:()=>lo,Parser:()=>Xl,Precedence:()=>ge,Program:()=>Kl,Property:()=>nu,PropertyAccessExpression:()=>uo,PropertyPrototype:()=>kr,Range:()=>fe,RefAsOp:()=>El,RefIsOp:()=>vl,RegexpLiteralExpression:()=>co,Relooper:()=>ss,ReportMode:()=>Wl,Resolver:()=>Hl,ReturnStatement:()=>Wo,Runtime:()=>ba,RuntimeFeatures:()=>Gu,SETTER_PREFIX:()=>Ui,SIMDExtractOp:()=>xl,SIMDLoadOp:()=>yl,SIMDLoadStoreLaneOp:()=>_l,SIMDReplaceOp:()=>gl,SIMDShiftOp:()=>ml,SIMDTernaryOp:()=>bl,STATIC_DELIMITER:()=>Pi,STUB_DELIMITER:()=>Fa,SideEffects:()=>Ir,Signature:()=>tn,Source:()=>Ji,SourceKind:()=>Eo,State:()=>ll,Statement:()=>ue,StringAsOp:()=>Cl,StringEncodeOp:()=>Sl,StringIterMoveOp:()=>wl,StringLiteralExpression:()=>po,StringMeasureOp:()=>Tl,StringNewOp:()=>Al,StringSliceWTFOp:()=>Il,SuperExpression:()=>ho,SwitchBuilder:()=>Ul,SwitchCase:()=>Ho,SwitchStatement:()=>Xo,TSDBuilder:()=>ms,Target:()=>_a,TemplateLiteralExpression:()=>xo,TernaryExpression:()=>fo,ThisExpression:()=>go,ThrowStatement:()=>Ko,Token:()=>tl,Tokenizer:()=>ol,TrueExpression:()=>mo,TryStatement:()=>$o,Type:()=>l,TypeBuilderErrorReason:()=>es,TypeDeclaration:()=>Zo,TypeDefinition:()=>Tn,TypeFlags:()=>lu,TypeKind:()=>ou,TypeName:()=>Ra,TypeNode:()=>Yi,TypeParameterNode:()=>Ua,TypeRef:()=>A,TypeSystem:()=>Mr,TypedElement:()=>$n,Typeinfo:()=>gi,TypeinfoFlags:()=>Ri,UnaryExpression:()=>Zi,UnaryOp:()=>pl,UnaryPostfixExpression:()=>_o,UnaryPrefixExpression:()=>bo,VariableDeclaration:()=>Jo,VariableLikeDeclarationStatement:()=>Dr,VariableLikeElement:()=>yt,VariableStatement:()=>Qo,VoidStatement:()=>el,WhileStatement:()=>nl,addGlobalAlias:()=>C2,allocPtrArray:()=>pe,buildJS:()=>T1,buildTSD:()=>A1,compile:()=>F1,createType:()=>dn,default:()=>$F,diagnosticCategoryToColor:()=>Da,diagnosticCategoryToString:()=>Ki,diagnosticCodeToString:()=>Ta,disableFeature:()=>J2,enableFeature:()=>Z2,ensureType:()=>ls,expandType:()=>Bl,featureToString:()=>Oi,findDecorator:()=>qn,formatDiagnostic:()=>Ws,formatDiagnosticMessage:()=>Ws,getBinaryLeft:()=>He,getBinaryOp:()=>Xt,getBinaryRight:()=>Ie,getBinaryenModuleRef:()=>S1,getBlockChildAt:()=>is,getBlockChildCount:()=>rs,getBlockName:()=>ts,getBreakCondition:()=>Mp,getBreakName:()=>Rp,getCallOperandAt:()=>Re,getCallOperandCount:()=>un,getCallTarget:()=>Ar,getConstValueF32:()=>Fe,getConstValueF64:()=>Ae,getConstValueI32:()=>Y,getConstValueI64High:()=>Pe,getConstValueI64Low:()=>Be,getConstValueV128:()=>zl,getDefaultParameterName:()=>au,getDependee:()=>v1,getDiagnosticCategory:()=>l1,getDiagnosticCode:()=>o1,getDiagnosticMessage:()=>u1,getDiagnosticRange:()=>c1,getDiagnosticRelatedRange:()=>f1,getDropValue:()=>Pp,getExpressionId:()=>H,getExpressionType:()=>se,getFunctionBody:()=>qp,getFunctionName:()=>Rl,getFunctionParams:()=>jp,getFunctionResults:()=>Wp,getFunctionVars:()=>Hp,getGlobalGetName:()=>ns,getGlobalInit:()=>$p,getGlobalName:()=>Xp,getGlobalType:()=>Kp,getIfCondition:()=>Ti,getIfFalse:()=>qt,getIfTrue:()=>Fr,getLoadBytes:()=>Nl,getLoadOffset:()=>Ip,getLoadPtr:()=>kp,getLocalGetIndex:()=>Sn,getLocalSetIndex:()=>Fi,getLocalSetValue:()=>Jt,getLoopBody:()=>Op,getLoopName:()=>Dp,getMemoryGrowDelta:()=>Gp,getRangeEnd:()=>h1,getRangeSource:()=>d1,getRangeStart:()=>p1,getReturnValue:()=>Vp,getSelectCondition:()=>Up,getSelectElse:()=>Ol,getSelectThen:()=>Dl,getSideEffects:()=>Qt,getSource:()=>a1,getSourceNormalizedPath:()=>x1,getStoreBytes:()=>Bp,getStoreOffset:()=>zp,getStorePtr:()=>Np,getStoreValue:()=>Lp,getTagName:()=>Yp,getTagParams:()=>Zp,getTagResults:()=>Jp,getUnaryOp:()=>Er,getUnaryValue:()=>Ai,initializeProgram:()=>E1,isConstExpressionNaN:()=>Gt,isConstNaN:()=>wp,isConstNegZero:()=>Vt,isConstNonZero:()=>en,isConstZero:()=>Me,isDeclaredElement:()=>er,isError:()=>y1,isGlobalMutable:()=>Ml,isIllegalVariableIdentifier:()=>al,isInfo:()=>g1,isLoadSigned:()=>Ll,isLocalTee:()=>vr,isNullableType:()=>Ei,isTypeOmitted:()=>Ve,isTypedElement:()=>$l,isWarning:()=>m1,mangleInternalName:()=>Ne,mangleInternalPath:()=>Rr,mustPreserveSideEffects:()=>as,needsExplicitUnreachable:()=>os,newOptions:()=>h2,newProgram:()=>i1,nextDiagnostic:()=>s1,nextFile:()=>b1,operatorTokenToString:()=>Ue,optimize:()=>w1,parse:()=>_1,readString:()=>ze,removeGlobalAlias:()=>w2,setBasenameHint:()=>e1,setBindingsHint:()=>n1,setBundleVersion:()=>D2,setDebugInfo:()=>r1,setExportMemory:()=>m2,setExportRuntime:()=>z2,setExportStart:()=>I2,setExportTable:()=>F2,setImportMemory:()=>y2,setImportTable:()=>E2,setInitialMemory:()=>_2,setLowMemoryLimit:()=>B2,setMaximumMemory:()=>b2,setMemoryBase:()=>T2,setNoAssert:()=>g2,setNoUnsafe:()=>k2,setOptimizeLevelHints:()=>Q2,setPedantic:()=>t1,setRuntime:()=>x2,setSharedMemory:()=>v2,setSourceMap:()=>A2,setStackSize:()=>L2,setTableBase:()=>S2,setTarget:()=>d2,tokenFromKeyword:()=>il,tokenIsAlsoIdentifier:()=>sl,typesToRefs:()=>Kt,typesToString:()=>Ci,util:()=>Sa,validate:()=>C1});import*as Mh from"binaryen";import{default as Jc}from"binaryen";import _e from"long";var $s=Object.defineProperty,$c=Object.getOwnPropertyDescriptor,Bh=Object.getOwnPropertyNames,zh=Object.prototype.hasOwnProperty,Ys=(e,n)=>{for(var t in n)$s(e,t,{get:n[t],enumerable:!0})},Bc=(e,n,t,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of Bh(n))!zh.call(e,i)&&i!==t&&$s(e,i,{get:()=>n[i],enumerable:!(r=$c(n,i))||r.enumerable});return e},Nh=(e,n,t)=>(Bc(e,n,"default"),t&&Bc(t,n,"default")),Lh=(e,n,t,r)=>{for(var i=r>1?void 0:r?$c(n,t):n,s=e.length-1,a;s>=0;s--)(a=e[s])&&(i=(r?a(n,t,i):a(i))||i);return r&&i&&$s(n,t,i),i},Yc={};Ys(Yc,{ASTBuilder:()=>qu,ArrayLiteralExpression:()=>Wa,ArrowKind:()=>Uo,AssertionExpression:()=>Xa,AssertionKind:()=>Ha,AtomicRMWOp:()=>dl,BinaryExpression:()=>Ka,BinaryModule:()=>Pl,BinaryOp:()=>hl,BlockStatement:()=>Ao,BrOnOp:()=>Fl,BreakStatement:()=>To,CallExpression:()=>$a,Class:()=>ps,ClassDeclaration:()=>Qi,ClassExpression:()=>Ya,ClassPrototype:()=>fs,CommaExpression:()=>Za,CommentKind:()=>qa,CommentNode:()=>ja,CommonFlags:()=>va,CommonNames:()=>v,CompiledExpression:()=>vo,Compiler:()=>gs,ConditionKind:()=>jl,ConstantValueKind:()=>Zl,Constraints:()=>Vu,ConstructorExpression:()=>Ja,ContinueStatement:()=>So,DEFAULT_STACK_SIZE:()=>N2,DeclarationStatement:()=>rn,DeclaredElement:()=>Kn,DecoratorFlags:()=>q,DecoratorKind:()=>tr,DecoratorNode:()=>Ga,DiagnosticCategory:()=>La,DiagnosticCode:()=>Aa,DiagnosticEmitter:()=>mt,DiagnosticMessage:()=>$i,DoStatement:()=>Co,Element:()=>us,ElementAccessExpression:()=>Qa,ElementKind:()=>X,EmptyStatement:()=>wo,Enum:()=>Yl,EnumDeclaration:()=>Io,EnumValue:()=>Jl,EnumValueDeclaration:()=>ko,ExportDefaultStatement:()=>Lo,ExportImportStatement:()=>Bo,ExportMember:()=>zo,ExportNames:()=>Yt,ExportStatement:()=>No,Expression:()=>ye,ExpressionId:()=>cl,ExpressionRunnerFlags:()=>kl,ExpressionStatement:()=>Do,ExternalKind:()=>fl,FEATURE_BULK_MEMORY:()=>U2,FEATURE_EXCEPTION_HANDLING:()=>G2,FEATURE_EXTENDED_CONST:()=>$2,FEATURE_GC:()=>H2,FEATURE_MEMORY64:()=>X2,FEATURE_MULTI_VALUE:()=>W2,FEATURE_MUTABLE_GLOBALS:()=>R2,FEATURE_NONTRAPPING_F2I:()=>M2,FEATURE_REFERENCE_TYPES:()=>j2,FEATURE_RELAXED_SIMD:()=>K2,FEATURE_SIGN_EXTENSION:()=>O2,FEATURE_SIMD:()=>P2,FEATURE_STRINGREF:()=>Y2,FEATURE_TAIL_CALLS:()=>q2,FEATURE_THREADS:()=>V2,FalseExpression:()=>yo,Feature:()=>ya,FeatureFlags:()=>ul,Field:()=>eu,FieldDeclaration:()=>Oo,FieldFlags:()=>ql,FieldPrototype:()=>Ql,File:()=>Si,FloatLiteralExpression:()=>eo,Flow:()=>Wn,FlowFlags:()=>Vl,ForOfStatement:()=>Mo,ForStatement:()=>Ro,Function:()=>Hn,FunctionDeclaration:()=>Or,FunctionExpression:()=>no,FunctionPrototype:()=>pn,FunctionTypeNode:()=>Ma,GETTER_PREFIX:()=>Mi,Global:()=>jt,HeapTypeRef:()=>oe,INDEX_SUFFIX:()=>We,INNER_DELIMITER:()=>Ea,INSTANCE_DELIMITER:()=>Sr,IdentifierExpression:()=>hn,IdentifierHandling:()=>rl,IfStatement:()=>Po,ImportDeclaration:()=>Vo,ImportNames:()=>ct,ImportStatement:()=>bi,IndexSignature:()=>tu,IndexSignatureNode:()=>Fo,InstanceOfExpression:()=>to,IntegerLiteralExpression:()=>ro,Interface:()=>iu,InterfaceDeclaration:()=>Go,InterfacePrototype:()=>ru,JSBuilder:()=>xs,LIBRARY_PREFIX:()=>Cn,LIBRARY_SUBST:()=>Vi,LiteralExpression:()=>kn,LiteralKind:()=>Gn,Local:()=>nn,LocalFlags:()=>Gl,MemorySegment:()=>vi,MethodDeclaration:()=>qo,Module:()=>xt,ModuleDeclaration:()=>Yo,NamedTypeNode:()=>_i,Namespace:()=>cs,NamespaceDeclaration:()=>jo,NewExpression:()=>io,Node:()=>F,NodeKind:()=>Oa,NullExpression:()=>so,ObjectLiteralExpression:()=>ao,OmittedExpression:()=>oo,OperatorKind:()=>Ye,Options:()=>Pu,PARENT_SUBST:()=>xp,PATH_DELIMITER:()=>Xn,PackedType:()=>Ht,Parameter:()=>r2,ParameterKind:()=>Pa,ParameterNode:()=>Va,ParenthesizedExpression:()=>lo,Parser:()=>Xl,Precedence:()=>ge,Program:()=>Kl,Property:()=>nu,PropertyAccessExpression:()=>uo,PropertyPrototype:()=>kr,Range:()=>fe,RefAsOp:()=>El,RefIsOp:()=>vl,RegexpLiteralExpression:()=>co,Relooper:()=>ss,ReportMode:()=>Wl,Resolver:()=>Hl,ReturnStatement:()=>Wo,Runtime:()=>ba,RuntimeFeatures:()=>Gu,SETTER_PREFIX:()=>Ui,SIMDExtractOp:()=>xl,SIMDLoadOp:()=>yl,SIMDLoadStoreLaneOp:()=>_l,SIMDReplaceOp:()=>gl,SIMDShiftOp:()=>ml,SIMDTernaryOp:()=>bl,STATIC_DELIMITER:()=>Pi,STUB_DELIMITER:()=>Fa,SideEffects:()=>Ir,Signature:()=>tn,Source:()=>Ji,SourceKind:()=>Eo,State:()=>ll,Statement:()=>ue,StringAsOp:()=>Cl,StringEncodeOp:()=>Sl,StringIterMoveOp:()=>wl,StringLiteralExpression:()=>po,StringMeasureOp:()=>Tl,StringNewOp:()=>Al,StringSliceWTFOp:()=>Il,SuperExpression:()=>ho,SwitchBuilder:()=>Ul,SwitchCase:()=>Ho,SwitchStatement:()=>Xo,TSDBuilder:()=>ms,Target:()=>_a,TemplateLiteralExpression:()=>xo,TernaryExpression:()=>fo,ThisExpression:()=>go,ThrowStatement:()=>Ko,Token:()=>tl,Tokenizer:()=>ol,TrueExpression:()=>mo,TryStatement:()=>$o,Type:()=>l,TypeBuilderErrorReason:()=>es,TypeDeclaration:()=>Zo,TypeDefinition:()=>Tn,TypeFlags:()=>lu,TypeKind:()=>ou,TypeName:()=>Ra,TypeNode:()=>Yi,TypeParameterNode:()=>Ua,TypeRef:()=>A,TypeSystem:()=>Mr,TypedElement:()=>$n,Typeinfo:()=>gi,TypeinfoFlags:()=>Ri,UnaryExpression:()=>Zi,UnaryOp:()=>pl,UnaryPostfixExpression:()=>_o,UnaryPrefixExpression:()=>bo,VariableDeclaration:()=>Jo,VariableLikeDeclarationStatement:()=>Dr,VariableLikeElement:()=>yt,VariableStatement:()=>Qo,VoidStatement:()=>el,WhileStatement:()=>nl,addGlobalAlias:()=>C2,allocPtrArray:()=>pe,buildJS:()=>T1,buildTSD:()=>A1,compile:()=>F1,createType:()=>dn,diagnosticCategoryToColor:()=>Da,diagnosticCategoryToString:()=>Ki,diagnosticCodeToString:()=>Ta,disableFeature:()=>J2,enableFeature:()=>Z2,ensureType:()=>ls,expandType:()=>Bl,featureToString:()=>Oi,findDecorator:()=>qn,formatDiagnostic:()=>Ws,formatDiagnosticMessage:()=>Ws,getBinaryLeft:()=>He,getBinaryOp:()=>Xt,getBinaryRight:()=>Ie,getBinaryenModuleRef:()=>S1,getBlockChildAt:()=>is,getBlockChildCount:()=>rs,getBlockName:()=>ts,getBreakCondition:()=>Mp,getBreakName:()=>Rp,getCallOperandAt:()=>Re,getCallOperandCount:()=>un,getCallTarget:()=>Ar,getConstValueF32:()=>Fe,getConstValueF64:()=>Ae,getConstValueI32:()=>Y,getConstValueI64High:()=>Pe,getConstValueI64Low:()=>Be,getConstValueV128:()=>zl,getDefaultParameterName:()=>au,getDependee:()=>v1,getDiagnosticCategory:()=>l1,getDiagnosticCode:()=>o1,getDiagnosticMessage:()=>u1,getDiagnosticRange:()=>c1,getDiagnosticRelatedRange:()=>f1,getDropValue:()=>Pp,getExpressionId:()=>H,getExpressionType:()=>se,getFunctionBody:()=>qp,getFunctionName:()=>Rl,getFunctionParams:()=>jp,getFunctionResults:()=>Wp,getFunctionVars:()=>Hp,getGlobalGetName:()=>ns,getGlobalInit:()=>$p,getGlobalName:()=>Xp,getGlobalType:()=>Kp,getIfCondition:()=>Ti,getIfFalse:()=>qt,getIfTrue:()=>Fr,getLoadBytes:()=>Nl,getLoadOffset:()=>Ip,getLoadPtr:()=>kp,getLocalGetIndex:()=>Sn,getLocalSetIndex:()=>Fi,getLocalSetValue:()=>Jt,getLoopBody:()=>Op,getLoopName:()=>Dp,getMemoryGrowDelta:()=>Gp,getRangeEnd:()=>h1,getRangeSource:()=>d1,getRangeStart:()=>p1,getReturnValue:()=>Vp,getSelectCondition:()=>Up,getSelectElse:()=>Ol,getSelectThen:()=>Dl,getSideEffects:()=>Qt,getSource:()=>a1,getSourceNormalizedPath:()=>x1,getStoreBytes:()=>Bp,getStoreOffset:()=>zp,getStorePtr:()=>Np,getStoreValue:()=>Lp,getTagName:()=>Yp,getTagParams:()=>Zp,getTagResults:()=>Jp,getUnaryOp:()=>Er,getUnaryValue:()=>Ai,initializeProgram:()=>E1,isConstExpressionNaN:()=>Gt,isConstNaN:()=>wp,isConstNegZero:()=>Vt,isConstNonZero:()=>en,isConstZero:()=>Me,isDeclaredElement:()=>er,isError:()=>y1,isGlobalMutable:()=>Ml,isIllegalVariableIdentifier:()=>al,isInfo:()=>g1,isLoadSigned:()=>Ll,isLocalTee:()=>vr,isNullableType:()=>Ei,isTypeOmitted:()=>Ve,isTypedElement:()=>$l,isWarning:()=>m1,mangleInternalName:()=>Ne,mangleInternalPath:()=>Rr,mustPreserveSideEffects:()=>as,needsExplicitUnreachable:()=>os,newOptions:()=>h2,newProgram:()=>i1,nextDiagnostic:()=>s1,nextFile:()=>b1,operatorTokenToString:()=>Ue,optimize:()=>w1,parse:()=>_1,readString:()=>ze,removeGlobalAlias:()=>w2,setBasenameHint:()=>e1,setBindingsHint:()=>n1,setBundleVersion:()=>D2,setDebugInfo:()=>r1,setExportMemory:()=>m2,setExportRuntime:()=>z2,setExportStart:()=>I2,setExportTable:()=>F2,setImportMemory:()=>y2,setImportTable:()=>E2,setInitialMemory:()=>_2,setLowMemoryLimit:()=>B2,setMaximumMemory:()=>b2,setMemoryBase:()=>T2,setNoAssert:()=>g2,setNoUnsafe:()=>k2,setOptimizeLevelHints:()=>Q2,setPedantic:()=>t1,setRuntime:()=>x2,setSharedMemory:()=>v2,setSourceMap:()=>A2,setStackSize:()=>L2,setTableBase:()=>S2,setTarget:()=>d2,tokenFromKeyword:()=>il,tokenIsAlsoIdentifier:()=>sl,typesToRefs:()=>Kt,typesToString:()=>Ci,util:()=>Sa,validate:()=>C1});var V=typeof window<"u"&&window||typeof global<"u"&&global||self;if(typeof V.ASC_TARGET>"u"){let e=function(){Error.captureStackTrace?Error.captureStackTrace(this,e):this.stack=this.name+": "+this.message+`
`+new Error().stack},n=function(a){this.message=a||"assertion failed",Error.captureStackTrace?Error.captureStackTrace(this,n):this.stack=this.name+": "+this.message+`
`+new Error().stack},t=function(a,o){if(a==o){if(a!=0)return 0;a=1/a,o=1/o}else{let u=a!=a,c=o!=o;if(u|c)return u-c;a==null&&(a=String(a)),o==null&&(o=String(o))}return a>o?1:-1};Dh=e,Oh=n,Rh=t,V.ASC_TARGET=0,V.ASC_RUNTIME=0,V.ASC_NO_ASSERT=!1,V.ASC_MEMORY_BASE=0,V.ASC_OPTIMIZE_LEVEL=3,V.ASC_SHRINK_LEVEL=0,V.ASC_FEATURE_MUTABLE_GLOBAL=!1,V.ASC_FEATURE_SIGN_EXTENSION=!1,V.ASC_FEATURE_BULK_MEMORY=!1,V.ASC_FEATURE_SIMD=!1,V.ASC_FEATURE_THREADS=!1;let r=new Float64Array(1),i=new Uint32Array(r.buffer);Object.defineProperties(V.i8=function(a){return a<<24>>24},{MIN_VALUE:{value:-128},MAX_VALUE:{value:127}}),Object.defineProperties(V.i16=function(a){return a<<16>>16},{MIN_VALUE:{value:-32768},MAX_VALUE:{value:32767}}),Object.defineProperties(V.i32=V.isize=function(a){return a|0},{MIN_VALUE:{value:-2147483648},MAX_VALUE:{value:2147483647}}),Object.defineProperties(V.u8=function(a){return a&255},{MIN_VALUE:{value:0},MAX_VALUE:{value:255}}),Object.defineProperties(V.u16=function(a){return a&65535},{MIN_VALUE:{value:0},MAX_VALUE:{value:65535}}),Object.defineProperties(V.u32=V.usize=function(a){return a>>>0},{MIN_VALUE:{value:0},MAX_VALUE:{value:4294967295}}),Object.defineProperties(V.bool=function(a){return!!a},{MIN_VALUE:{value:!1},MAX_VALUE:{value:!0}}),Object.defineProperties(V.f32=function(a){return Math.fround(a)},{EPSILON:{value:11920928955078125e-23},MIN_VALUE:{value:1401298464324817e-60},MAX_VALUE:{value:34028234663852886e22},MIN_NORMAL_VALUE:{value:11754943508222875e-54},MIN_SAFE_INTEGER:{value:-16777215},MAX_SAFE_INTEGER:{value:16777215},POSITIVE_INFINITY:{value:1/0},NEGATIVE_INFINITY:{value:-1/0},NaN:{value:NaN}}),Object.defineProperties(V.f64=function(a){return+a},{EPSILON:{value:2220446049250313e-31},MIN_VALUE:{value:5e-324},MAX_VALUE:{value:17976931348623157e292},MIN_NORMAL_VALUE:{value:22250738585072014e-324},MIN_SAFE_INTEGER:{value:-9007199254740991},MAX_SAFE_INTEGER:{value:9007199254740991},POSITIVE_INFINITY:{value:1/0},NEGATIVE_INFINITY:{value:-1/0},NaN:{value:NaN}}),V.clz=Math.clz32,V.ctz=function(a){return 32-Math.clz32(~a&a-1)},V.popcnt=function(a){return a-=a>>>1&1431655765,a=(a&858993459)+(a>>>2&858993459),(a+(a>>>4)&252645135)*16843009>>>24},V.rotl=function(a,o){return o&=31,a<<o|a>>>32-o},V.rotr=function(a,o){return o&=31,a>>>o|a<<32-o},V.abs=Math.abs,V.max=Math.max,V.min=Math.min,V.ceil=Math.ceil,V.floor=Math.floor,V.nearest=function(a){let o=Math.abs(a);return o<4503599627370496?(o+4503599627370496-4503599627370496)*Math.sign(a):a},V.select=function(a,o,u){return u?a:o},V.sqrt=Math.sqrt,V.trunc=Math.trunc,V.copysign=function(a,o){return o?Math.abs(a)*Math.sign(o):(r[0]=o,i[1]>>>31?-1:1)},V.bswap=function(a){let o=a>>8&16711935,u=(a&16711935)<<8;return a=o|u,o=a>>16&65535,u=(a&65535)<<16,o|u},e.prototype=Object.create(Error.prototype),e.prototype.name="UnreachableError",e.prototype.message="unreachable",V.unreachable=function(){throw new e},n.prototype=Object.create(Error.prototype),n.prototype.name="AssertionError",V.assert=function(a,o){if(a)return a;throw new n(o)},V.changetype=function(a){return a},String.fromCharCodes=function(a){let o=a.length;if(o<=8192)return String.fromCharCode.apply(String,a);let u=0,c="";for(;u<o;)c+=String.fromCharCode.apply(String,a.slice(u,Math.min(u+8192,o))),u+=8192;return c},String.fromCodePoints=function(a){let o=a.length;if(o<=8192)return String.fromCodePoint.apply(String,a);let u=0,c="";for(;u<o;)c+=String.fromCodePoint.apply(String,a.slice(u,Math.min(u+8192,o))),u+=8192;return c},String.prototype.at||Object.defineProperty(String.prototype,"at",{value:function(a){return this.charAt(a>=0?a:a+this.length)},configurable:!0}),String.prototype.replaceAll||Object.defineProperty(String.prototype,"replaceAll",{value:function(a,o){let u=this.split(a).join(o);return a.length||(u=o+u+o),u},configurable:!0});let s=Array.prototype.sort;Array.prototype.sort=function(a){return s.call(this,a||t)},[Array,Uint8ClampedArray,Uint8Array,Int8Array,Uint16Array,Int16Array,Uint32Array,Int32Array,Float32Array,Float64Array].forEach(a=>{a.prototype.at||Object.defineProperty(a.prototype,"at",{value:function(o){return this[o>=0?o:o+this.length]},configurable:!0}),a.prototype.findLastIndex||Object.defineProperty(a.prototype,"findLastIndex",{value:function(o){for(let u=this.length-1;u>=0;--u)if(o(this[u],u,this))return u;return-1},configurable:!0}),a!=Array&&Object.defineProperty(a,"wrap",{value:function(o,u,c){return new a(o,u,c)},configurable:!0})}),V.isInteger=Number.isInteger,V.isFloat=function(a){return typeof a=="number"},V.isNullable=function(a){return!0},V.isReference=function(a){return typeof a=="object"||typeof a=="string"},V.isFunction=function(a){return typeof a=="function"},V.isString=function(a){return typeof a=="string"||a instanceof String},V.isArray=Array.isArray,V.isArrayLike=function(a){return a&&typeof a=="object"&&typeof a.length=="number"&&a.length>=0&&Math.trunc(a.length)===a.length},V.isDefined=function(a){return typeof a<"u"},V.isConstant=function(a){return!1},V.unchecked=function(a){return a},V.fmod=function(a,o){return a%o},V.fmodf=function(a,o){return Math.fround(a%o)},V.JSMath=Math,Object.defineProperties(V.JSMath,{sincos_sin:{value:0,writable:!0},sincos_cos:{value:0,writable:!0},signbit:{value:function(a){return r[0]=a,Boolean(i[1]>>>31)}},sincos:{value:function(a){this.sincos_sin=Math.sin(a),this.sincos_cos=Math.cos(a)}},exp2:{value:function(a){return Math.pow(2,a)}}}),V.unmanaged=function(){},V.trace=function(a,o){o&&(a+=Array.prototype.slice.call(arguments,2,2+o)),console.error("trace: "+a)}}else console.warn("compiler mismatch: std/portable included twice");var Dh,Oh,Rh,Zc={};Ys(Zc,{default:()=>Jc});Nh(Zc,Mh);var{_BinaryenTypeCreate:Uh,_BinaryenTypeArity:Ph,_BinaryenTypeExpand:Vh,_BinaryenTypeGetHeapType:Ut,_BinaryenTypeFromHeapType:ae,_BinaryenTypeIsNullable:Gh,_BinaryenTypeFuncref:qh,_BinaryenTypeExternref:jh,_BinaryenTypeAnyref:Wh,_BinaryenTypeEqref:Hh,_BinaryenTypeI31ref:Xh,_BinaryenTypeDataref:Kh,_BinaryenTypeArrayref:$h,_BinaryenTypeStringref:Yh,_BinaryenTypeStringviewWTF8:Zh,_BinaryenTypeStringviewWTF16:Jh,_BinaryenTypeStringviewIter:Qh,_BinaryenTypeNullref:ed,_BinaryenTypeNullExternref:nd,_BinaryenTypeNullFuncref:td,_BinaryenHeapTypeFunc:gA,_BinaryenHeapTypeExt:mA,_BinaryenHeapTypeAny:yA,_BinaryenHeapTypeEq:_A,_BinaryenHeapTypeI31:bA,_BinaryenHeapTypeData:vA,_BinaryenHeapTypeArray:EA,_BinaryenHeapTypeString:FA,_BinaryenHeapTypeStringviewWTF8:AA,_BinaryenHeapTypeStringviewWTF16:TA,_BinaryenHeapTypeStringviewIter:SA,_BinaryenHeapTypeNone:CA,_BinaryenHeapTypeNoext:wA,_BinaryenHeapTypeNofunc:IA,_BinaryenHeapTypeIsBottom:rd,_BinaryenHeapTypeGetBottom:id,_BinaryenModuleCreate:sd,_BinaryenModuleDispose:ad,_BinaryenSizeofLiteral:zc,_BinaryenLiteralInt32:od,_BinaryenLiteralInt64:ld,_BinaryenLiteralFloat32:ud,_BinaryenLiteralFloat64:cd,_BinaryenLiteralVec128:fd,_BinaryenLiteralFloat32Bits:kA,_BinaryenLiteralFloat64Bits:BA,_BinaryenExpressionGetId:gt,_BinaryenExpressionGetType:pt,_BinaryenExpressionSetType:zA,_BinaryenExpressionPrint:NA,_BinaryenExpressionCopy:pd,_BinaryenExpressionFinalize:hd,_BinaryenBlock:dd,_BinaryenBlockGetName:Zs,_BinaryenBlockSetName:LA,_BinaryenBlockGetNumChildren:Ii,_BinaryenBlockGetChildAt:ki,_BinaryenBlockSetChildAt:xd,_BinaryenBlockAppendChild:DA,_BinaryenBlockInsertChildAt:OA,_BinaryenBlockRemoveChildAt:RA,_BinaryenIf:gd,_BinaryenIfGetCondition:Js,_BinaryenIfSetCondition:md,_BinaryenIfGetIfTrue:Qs,_BinaryenIfSetIfTrue:yd,_BinaryenIfGetIfFalse:ea,_BinaryenIfSetIfFalse:_d,_BinaryenLoop:bd,_BinaryenLoopGetName:Qc,_BinaryenLoopSetName:MA,_BinaryenLoopGetBody:na,_BinaryenLoopSetBody:vd,_BinaryenBreak:Ed,_BinaryenBreakGetName:e0,_BinaryenBreakSetName:UA,_BinaryenBreakGetCondition:Bi,_BinaryenBreakSetCondition:Fd,_BinaryenBreakGetValue:n0,_BinaryenBreakSetValue:Ad,_BinaryenSwitch:Td,_BinaryenSwitchGetNumNames:Sd,_BinaryenSwitchGetNameAt:Cd,_BinaryenSwitchSetNameAt:PA,_BinaryenSwitchAppendName:VA,_BinaryenSwitchInsertNameAt:GA,_BinaryenSwitchRemoveNameAt:qA,_BinaryenSwitchGetDefaultName:wd,_BinaryenSwitchSetDefaultName:jA,_BinaryenSwitchGetCondition:t0,_BinaryenSwitchSetCondition:Id,_BinaryenSwitchGetValue:r0,_BinaryenSwitchSetValue:kd,_BinaryenCall:Bd,_BinaryenCallGetTarget:ta,_BinaryenCallSetTarget:WA,_BinaryenCallGetNumOperands:Br,_BinaryenCallGetOperandAt:zr,_BinaryenCallSetOperandAt:i0,_BinaryenCallAppendOperand:HA,_BinaryenCallInsertOperandAt:XA,_BinaryenCallRemoveOperandAt:KA,_BinaryenCallIsReturn:$A,_BinaryenCallSetReturn:YA,_BinaryenReturnCall:zd,_BinaryenCallIndirect:Nd,_BinaryenCallIndirectGetTable:ZA,_BinaryenCallIndirectSetTable:JA,_BinaryenCallIndirectGetTarget:s0,_BinaryenCallIndirectSetTarget:Ld,_BinaryenCallIndirectGetNumOperands:ra,_BinaryenCallIndirectGetOperandAt:ia,_BinaryenCallIndirectSetOperandAt:a0,_BinaryenCallIndirectAppendOperand:QA,_BinaryenCallIndirectInsertOperandAt:eT,_BinaryenCallIndirectRemoveOperandAt:nT,_BinaryenCallIndirectIsReturn:tT,_BinaryenCallIndirectSetReturn:rT,_BinaryenReturnCallIndirect:Dd,_BinaryenLocalGet:Od,_BinaryenLocalGetGetIndex:o0,_BinaryenLocalGetSetIndex:iT,_BinaryenLocalSet:Rd,_BinaryenLocalSetIsTee:l0,_BinaryenLocalSetGetIndex:sa,_BinaryenLocalSetSetIndex:sT,_BinaryenLocalSetGetValue:zi,_BinaryenLocalSetSetValue:u0,_BinaryenLocalTee:Md,_BinaryenGlobalGet:Ud,_BinaryenGlobalGetGetName:c0,_BinaryenGlobalGetSetName:aT,_BinaryenGlobalSet:Pd,_BinaryenGlobalSetGetName:Vd,_BinaryenGlobalSetSetName:oT,_BinaryenGlobalSetGetValue:f0,_BinaryenGlobalSetSetValue:Gd,_BinaryenMemorySize:qd,_BinaryenMemoryGrow:jd,_BinaryenMemoryGrowGetDelta:aa,_BinaryenMemoryGrowSetDelta:Wd,_BinaryenLoad:Hd,_BinaryenLoadIsAtomic:lT,_BinaryenLoadSetAtomic:uT,_BinaryenLoadIsSigned:Xd,_BinaryenLoadSetSigned:cT,_BinaryenLoadGetOffset:Kd,_BinaryenLoadSetOffset:fT,_BinaryenLoadGetBytes:$d,_BinaryenLoadSetBytes:pT,_BinaryenLoadGetAlign:hT,_BinaryenLoadSetAlign:dT,_BinaryenLoadGetPtr:oa,_BinaryenLoadSetPtr:Yd,_BinaryenAtomicLoad:Zd,_BinaryenStore:Jd,_BinaryenStoreIsAtomic:xT,_BinaryenStoreSetAtomic:gT,_BinaryenStoreGetBytes:p0,_BinaryenStoreSetBytes:mT,_BinaryenStoreGetOffset:h0,_BinaryenStoreSetOffset:yT,_BinaryenStoreGetAlign:_T,_BinaryenStoreSetAlign:bT,_BinaryenStoreGetPtr:Ni,_BinaryenStoreSetPtr:d0,_BinaryenStoreGetValue:la,_BinaryenStoreSetValue:Qd,_BinaryenStoreGetValueType:vT,_BinaryenStoreSetValueType:ET,_BinaryenAtomicStore:ex,_BinaryenConst:hr,_BinaryenConstGetValueI32:nx,_BinaryenConstSetValueI32:FT,_BinaryenConstGetValueI64Low:tx,_BinaryenConstSetValueI64Low:AT,_BinaryenConstGetValueI64High:rx,_BinaryenConstSetValueI64High:TT,_BinaryenConstGetValueF32:ix,_BinaryenConstSetValueF32:ST,_BinaryenConstGetValueF64:sx,_BinaryenConstSetValueF64:CT,_BinaryenConstGetValueV128:ax,_BinaryenConstSetValueV128:wT,_BinaryenUnary:ox,_BinaryenUnaryGetOp:lx,_BinaryenUnarySetOp:IT,_BinaryenUnaryGetValue:ua,_BinaryenUnarySetValue:ux,_BinaryenBinary:cx,_BinaryenBinaryGetOp:fx,_BinaryenBinarySetOp:kT,_BinaryenBinaryGetLeft:ca,_BinaryenBinarySetLeft:px,_BinaryenBinaryGetRight:fa,_BinaryenBinarySetRight:hx,_BinaryenSelect:dx,_BinaryenSelectGetIfTrue:pa,_BinaryenSelectSetIfTrue:xx,_BinaryenSelectGetIfFalse:ha,_BinaryenSelectSetIfFalse:gx,_BinaryenSelectGetCondition:da,_BinaryenSelectSetCondition:mx,_BinaryenDrop:Nc,_BinaryenDropGetValue:xa,_BinaryenDropSetValue:yx,_BinaryenReturn:_x,_BinaryenReturnGetValue:Li,_BinaryenReturnSetValue:x0,_BinaryenNop:bx,_BinaryenUnreachable:vx,_BinaryenAtomicRMW:Ex,_BinaryenAtomicRMWGetOp:BT,_BinaryenAtomicRMWSetOp:zT,_BinaryenAtomicRMWGetBytes:NT,_BinaryenAtomicRMWSetBytes:LT,_BinaryenAtomicRMWGetOffset:DT,_BinaryenAtomicRMWSetOffset:OT,_BinaryenAtomicRMWGetPtr:g0,_BinaryenAtomicRMWSetPtr:Fx,_BinaryenAtomicRMWGetValue:m0,_BinaryenAtomicRMWSetValue:Ax,_BinaryenAtomicCmpxchg:Tx,_BinaryenAtomicCmpxchgGetBytes:RT,_BinaryenAtomicCmpxchgSetBytes:MT,_BinaryenAtomicCmpxchgGetOffset:UT,_BinaryenAtomicCmpxchgSetOffset:PT,_BinaryenAtomicCmpxchgGetPtr:y0,_BinaryenAtomicCmpxchgSetPtr:Sx,_BinaryenAtomicCmpxchgGetExpected:_0,_BinaryenAtomicCmpxchgSetExpected:Cx,_BinaryenAtomicCmpxchgGetReplacement:b0,_BinaryenAtomicCmpxchgSetReplacement:wx,_BinaryenAtomicWait:Ix,_BinaryenAtomicWaitGetPtr:v0,_BinaryenAtomicWaitSetPtr:kx,_BinaryenAtomicWaitGetExpected:E0,_BinaryenAtomicWaitSetExpected:Bx,_BinaryenAtomicWaitGetTimeout:F0,_BinaryenAtomicWaitSetTimeout:zx,_BinaryenAtomicWaitGetExpectedType:VT,_BinaryenAtomicWaitSetExpectedType:GT,_BinaryenAtomicNotify:Nx,_BinaryenAtomicNotifyGetPtr:A0,_BinaryenAtomicNotifySetPtr:Lx,_BinaryenAtomicNotifyGetNotifyCount:T0,_BinaryenAtomicNotifySetNotifyCount:Dx,_BinaryenAtomicFence:Ox,_BinaryenAtomicFenceGetOrder:qT,_BinaryenAtomicFenceSetOrder:jT,_BinaryenSIMDExtract:Rx,_BinaryenSIMDExtractGetOp:WT,_BinaryenSIMDExtractSetOp:HT,_BinaryenSIMDExtractGetVec:S0,_BinaryenSIMDExtractSetVec:Mx,_BinaryenSIMDExtractGetIndex:XT,_BinaryenSIMDExtractSetIndex:KT,_BinaryenSIMDReplace:Ux,_BinaryenSIMDReplaceGetOp:$T,_BinaryenSIMDReplaceSetOp:YT,_BinaryenSIMDReplaceGetVec:C0,_BinaryenSIMDReplaceSetVec:Px,_BinaryenSIMDReplaceGetIndex:ZT,_BinaryenSIMDReplaceSetIndex:JT,_BinaryenSIMDReplaceGetValue:w0,_BinaryenSIMDReplaceSetValue:Vx,_BinaryenSIMDShuffle:Gx,_BinaryenSIMDShuffleGetLeft:I0,_BinaryenSIMDShuffleSetLeft:qx,_BinaryenSIMDShuffleGetRight:k0,_BinaryenSIMDShuffleSetRight:jx,_BinaryenSIMDShuffleGetMask:QT,_BinaryenSIMDShuffleSetMask:e7,_BinaryenSIMDTernary:Wx,_BinaryenSIMDTernaryGetOp:n7,_BinaryenSIMDTernarySetOp:t7,_BinaryenSIMDTernaryGetA:B0,_BinaryenSIMDTernarySetA:Hx,_BinaryenSIMDTernaryGetB:z0,_BinaryenSIMDTernarySetB:Xx,_BinaryenSIMDTernaryGetC:N0,_BinaryenSIMDTernarySetC:Kx,_BinaryenSIMDShift:$x,_BinaryenSIMDShiftGetOp:r7,_BinaryenSIMDShiftSetOp:i7,_BinaryenSIMDShiftGetVec:L0,_BinaryenSIMDShiftSetVec:Yx,_BinaryenSIMDShiftGetShift:D0,_BinaryenSIMDShiftSetShift:Zx,_BinaryenSIMDLoad:Jx,_BinaryenSIMDLoadGetOp:s7,_BinaryenSIMDLoadSetOp:a7,_BinaryenSIMDLoadGetOffset:o7,_BinaryenSIMDLoadSetOffset:l7,_BinaryenSIMDLoadGetAlign:u7,_BinaryenSIMDLoadSetAlign:c7,_BinaryenSIMDLoadGetPtr:O0,_BinaryenSIMDLoadSetPtr:Qx,_BinaryenSIMDLoadStoreLane:eg,_BinaryenSIMDLoadStoreLaneGetOp:f7,_BinaryenSIMDLoadStoreLaneSetOp:p7,_BinaryenSIMDLoadStoreLaneGetOffset:h7,_BinaryenSIMDLoadStoreLaneSetOffset:d7,_BinaryenSIMDLoadStoreLaneGetAlign:x7,_BinaryenSIMDLoadStoreLaneSetAlign:g7,_BinaryenSIMDLoadStoreLaneGetIndex:m7,_BinaryenSIMDLoadStoreLaneSetIndex:y7,_BinaryenSIMDLoadStoreLaneGetPtr:R0,_BinaryenSIMDLoadStoreLaneSetPtr:ng,_BinaryenSIMDLoadStoreLaneGetVec:M0,_BinaryenSIMDLoadStoreLaneSetVec:tg,_BinaryenSIMDLoadStoreLaneIsStore:_7,_BinaryenMemoryInit:b7,_BinaryenMemoryInitGetSegment:v7,_BinaryenMemoryInitSetSegment:E7,_BinaryenMemoryInitGetDest:U0,_BinaryenMemoryInitSetDest:rg,_BinaryenMemoryInitGetOffset:P0,_BinaryenMemoryInitSetOffset:ig,_BinaryenMemoryInitGetSize:V0,_BinaryenMemoryInitSetSize:sg,_BinaryenDataDrop:F7,_BinaryenDataDropGetSegment:A7,_BinaryenDataDropSetSegment:T7,_BinaryenMemoryCopy:ag,_BinaryenMemoryCopyGetDest:G0,_BinaryenMemoryCopySetDest:og,_BinaryenMemoryCopyGetSource:q0,_BinaryenMemoryCopySetSource:lg,_BinaryenMemoryCopyGetSize:j0,_BinaryenMemoryCopySetSize:ug,_BinaryenMemoryFill:cg,_BinaryenMemoryFillGetDest:W0,_BinaryenMemoryFillSetDest:fg,_BinaryenMemoryFillGetValue:H0,_BinaryenMemoryFillSetValue:pg,_BinaryenMemoryFillGetSize:X0,_BinaryenMemoryFillSetSize:hg,_BinaryenRefNull:dg,_BinaryenRefIs:Lc,_BinaryenRefIsGetOp:S7,_BinaryenRefIsSetOp:C7,_BinaryenRefIsGetValue:K0,_BinaryenRefIsSetValue:xg,_BinaryenRefAs:Dc,_BinaryenRefAsGetOp:w7,_BinaryenRefAsSetOp:I7,_BinaryenRefAsGetValue:$0,_BinaryenRefAsSetValue:gg,_BinaryenRefFunc:mg,_BinaryenRefFuncGetFunc:yg,_BinaryenRefFuncSetFunc:k7,_BinaryenRefEq:_g,_BinaryenRefEqGetLeft:Y0,_BinaryenRefEqSetLeft:bg,_BinaryenRefEqGetRight:Z0,_BinaryenRefEqSetRight:vg,_BinaryenTableGet:Eg,_BinaryenTableGetGetTable:B7,_BinaryenTableGetSetTable:z7,_BinaryenTableGetGetIndex:N7,_BinaryenTableGetSetIndex:L7,_BinaryenTableSet:Fg,_BinaryenTableSetGetTable:D7,_BinaryenTableSetSetTable:O7,_BinaryenTableSetGetIndex:R7,_BinaryenTableSetSetIndex:M7,_BinaryenTableSetGetValue:U7,_BinaryenTableSetSetValue:P7,_BinaryenTableSize:Ag,_BinaryenTableSizeGetTable:V7,_BinaryenTableSizeSetTable:G7,_BinaryenTableGrow:Tg,_BinaryenTableGrowGetTable:q7,_BinaryenTableGrowSetTable:j7,_BinaryenTableGrowGetValue:W7,_BinaryenTableGrowSetValue:H7,_BinaryenTableGrowGetDelta:X7,_BinaryenTableGrowSetDelta:K7,_BinaryenTry:Sg,_BinaryenTryGetName:$7,_BinaryenTrySetName:Y7,_BinaryenTryGetBody:J0,_BinaryenTrySetBody:Cg,_BinaryenTryGetNumCatchTags:Z7,_BinaryenTryGetNumCatchBodies:Q0,_BinaryenTryGetCatchTagAt:J7,_BinaryenTrySetCatchTagAt:Q7,_BinaryenTryAppendCatchTag:eS,_BinaryenTryInsertCatchTagAt:nS,_BinaryenTryRemoveCatchTagAt:tS,_BinaryenTryGetCatchBodyAt:ef,_BinaryenTrySetCatchBodyAt:wg,_BinaryenTryAppendCatchBody:rS,_BinaryenTryInsertCatchBodyAt:iS,_BinaryenTryRemoveCatchBodyAt:sS,_BinaryenTryHasCatchAll:aS,_BinaryenTryGetDelegateTarget:oS,_BinaryenTrySetDelegateTarget:lS,_BinaryenTryIsDelegate:uS,_BinaryenThrow:Ig,_BinaryenThrowGetTag:kg,_BinaryenThrowSetTag:cS,_BinaryenThrowGetNumOperands:nf,_BinaryenThrowGetOperandAt:tf,_BinaryenThrowSetOperandAt:Bg,_BinaryenThrowAppendOperand:fS,_BinaryenThrowInsertOperandAt:pS,_BinaryenThrowRemoveOperandAt:hS,_BinaryenRethrow:zg,_BinaryenRethrowGetTarget:dS,_BinaryenRethrowSetDepth:xS,_BinaryenTupleMake:Ng,_BinaryenTupleMakeGetNumOperands:rf,_BinaryenTupleMakeGetOperandAt:sf,_BinaryenTupleMakeSetOperandAt:Lg,_BinaryenTupleMakeAppendOperand:gS,_BinaryenTupleMakeInsertOperandAt:mS,_BinaryenTupleMakeRemoveOperandAt:yS,_BinaryenTupleExtract:Dg,_BinaryenTupleExtractGetTuple:af,_BinaryenTupleExtractSetTuple:Og,_BinaryenTupleExtractGetIndex:_S,_BinaryenTupleExtractSetIndex:bS,_BinaryenPop:Rg,_BinaryenI31New:Mg,_BinaryenI31NewGetValue:of,_BinaryenI31NewSetValue:Ug,_BinaryenI31Get:Pg,_BinaryenI31GetGetI31:lf,_BinaryenI31GetSetI31:Vg,_BinaryenI31GetIsSigned:vS,_BinaryenI31GetSetSigned:ES,_BinaryenCallRef:FS,_BinaryenCallRefGetNumOperands:uf,_BinaryenCallRefGetOperandAt:cf,_BinaryenCallRefSetOperandAt:Gg,_BinaryenCallRefAppendOperand:AS,_BinaryenCallRefInsertOperandAt:TS,_BinaryenCallRefRemoveOperandAt:SS,_BinaryenCallRefGetTarget:ff,_BinaryenCallRefSetTarget:qg,_BinaryenCallRefIsReturn:CS,_BinaryenCallRefSetReturn:wS,_BinaryenRefTest:IS,_BinaryenRefTestGetRef:pf,_BinaryenRefTestSetRef:jg,_BinaryenRefTestGetIntendedType:kS,_BinaryenRefTestSetIntendedType:BS,_BinaryenRefCast:zS,_BinaryenRefCastGetRef:hf,_BinaryenRefCastSetRef:Wg,_BinaryenRefCastGetIntendedType:NS,_BinaryenRefCastSetIntendedType:LS,_BinaryenBrOn:DS,_BinaryenBrOnGetOp:OS,_BinaryenBrOnSetOp:RS,_BinaryenBrOnGetName:Hg,_BinaryenBrOnSetName:MS,_BinaryenBrOnGetRef:df,_BinaryenBrOnSetRef:Xg,_BinaryenBrOnGetIntendedType:US,_BinaryenBrOnSetIntendedType:PS,_BinaryenStructNew:VS,_BinaryenStructNewGetNumOperands:xf,_BinaryenStructNewGetOperandAt:gf,_BinaryenStructNewSetOperandAt:Kg,_BinaryenStructNewAppendOperand:GS,_BinaryenStructNewInsertOperandAt:qS,_BinaryenStructNewRemoveOperandAt:jS,_BinaryenStructGet:WS,_BinaryenStructGetGetIndex:$g,_BinaryenStructGetSetIndex:HS,_BinaryenStructGetGetRef:mf,_BinaryenStructGetSetRef:Yg,_BinaryenStructGetIsSigned:XS,_BinaryenStructGetSetSigned:KS,_BinaryenStructSet:$S,_BinaryenStructSetGetIndex:Zg,_BinaryenStructSetSetIndex:YS,_BinaryenStructSetGetRef:yf,_BinaryenStructSetSetRef:Jg,_BinaryenStructSetGetValue:_f,_BinaryenStructSetSetValue:Qg,_BinaryenArrayNew:ZS,_BinaryenArrayNewGetInit:bf,_BinaryenArrayNewSetInit:e6,_BinaryenArrayNewGetSize:vf,_BinaryenArrayNewSetSize:n6,_BinaryenArrayInit:JS,_BinaryenArrayInitGetNumValues:Ef,_BinaryenArrayInitGetValueAt:Ff,_BinaryenArrayInitSetValueAt:t6,_BinaryenArrayInitAppendValue:QS,_BinaryenArrayInitInsertValueAt:e9,_BinaryenArrayInitRemoveValueAt:n9,_BinaryenArrayGet:t9,_BinaryenArrayGetGetRef:Af,_BinaryenArrayGetSetRef:r6,_BinaryenArrayGetGetIndex:Tf,_BinaryenArrayGetSetIndex:i6,_BinaryenArrayGetIsSigned:r9,_BinaryenArrayGetSetSigned:i9,_BinaryenArraySet:s9,_BinaryenArraySetGetRef:Sf,_BinaryenArraySetSetRef:s6,_BinaryenArraySetGetIndex:Cf,_BinaryenArraySetSetIndex:a6,_BinaryenArraySetGetValue:wf,_BinaryenArraySetSetValue:o6,_BinaryenArrayLen:a9,_BinaryenArrayLenGetRef:If,_BinaryenArrayLenSetRef:l6,_BinaryenArrayCopy:o9,_BinaryenArrayCopyGetDestRef:kf,_BinaryenArrayCopySetDestRef:u6,_BinaryenArrayCopyGetDestIndex:Bf,_BinaryenArrayCopySetDestIndex:c6,_BinaryenArrayCopyGetSrcRef:zf,_BinaryenArrayCopySetSrcRef:f6,_BinaryenArrayCopyGetSrcIndex:Nf,_BinaryenArrayCopySetSrcIndex:p6,_BinaryenArrayCopyGetLength:Lf,_BinaryenArrayCopySetLength:h6,_BinaryenStringNew:l9,_BinaryenStringNewGetOp:u9,_BinaryenStringNewSetOp:c9,_BinaryenStringNewGetPtr:Df,_BinaryenStringNewSetPtr:d6,_BinaryenStringNewGetLength:Of,_BinaryenStringNewSetLength:x6,_BinaryenStringNewGetStart:Rf,_BinaryenStringNewSetStart:g6,_BinaryenStringNewGetEnd:Mf,_BinaryenStringNewSetEnd:m6,_BinaryenStringConst:f9,_BinaryenStringConstGetString:p9,_BinaryenStringConstSetString:h9,_BinaryenStringMeasure:d9,_BinaryenStringMeasureGetOp:x9,_BinaryenStringMeasureSetOp:g9,_BinaryenStringMeasureGetRef:Uf,_BinaryenStringMeasureSetRef:y6,_BinaryenStringEncode:m9,_BinaryenStringEncodeGetOp:y9,_BinaryenStringEncodeSetOp:_9,_BinaryenStringEncodeGetRef:Pf,_BinaryenStringEncodeSetRef:_6,_BinaryenStringEncodeGetPtr:Vf,_BinaryenStringEncodeSetPtr:b6,_BinaryenStringEncodeGetStart:Gf,_BinaryenStringEncodeSetStart:v6,_BinaryenStringConcat:b9,_BinaryenStringConcatGetLeft:qf,_BinaryenStringConcatSetLeft:E6,_BinaryenStringConcatGetRight:jf,_BinaryenStringConcatSetRight:F6,_BinaryenStringEq:A6,_BinaryenStringEqGetLeft:Wf,_BinaryenStringEqSetLeft:T6,_BinaryenStringEqGetRight:Hf,_BinaryenStringEqSetRight:S6,_BinaryenStringAs:v9,_BinaryenStringAsGetOp:E9,_BinaryenStringAsSetOp:F9,_BinaryenStringAsGetRef:Xf,_BinaryenStringAsSetRef:C6,_BinaryenStringWTF8Advance:A9,_BinaryenStringWTF8AdvanceGetRef:Kf,_BinaryenStringWTF8AdvanceSetRef:w6,_BinaryenStringWTF8AdvanceGetPos:$f,_BinaryenStringWTF8AdvanceSetPos:I6,_BinaryenStringWTF8AdvanceGetBytes:Yf,_BinaryenStringWTF8AdvanceSetBytes:k6,_BinaryenStringWTF16Get:T9,_BinaryenStringWTF16GetGetRef:Zf,_BinaryenStringWTF16GetSetRef:B6,_BinaryenStringWTF16GetGetPos:Jf,_BinaryenStringWTF16GetSetPos:z6,_BinaryenStringIterNext:S9,_BinaryenStringIterNextGetRef:Qf,_BinaryenStringIterNextSetRef:N6,_BinaryenStringIterMove:C9,_BinaryenStringIterMoveGetOp:w9,_BinaryenStringIterMoveSetOp:I9,_BinaryenStringIterMoveGetRef:ep,_BinaryenStringIterMoveSetRef:L6,_BinaryenStringIterMoveGetNum:np,_BinaryenStringIterMoveSetNum:D6,_BinaryenStringSliceWTF:k9,_BinaryenStringSliceWTFGetOp:B9,_BinaryenStringSliceWTFSetOp:z9,_BinaryenStringSliceWTFGetRef:tp,_BinaryenStringSliceWTFSetRef:O6,_BinaryenStringSliceWTFGetStart:rp,_BinaryenStringSliceWTFSetStart:R6,_BinaryenStringSliceWTFGetEnd:ip,_BinaryenStringSliceWTFSetEnd:M6,_BinaryenStringSliceIter:N9,_BinaryenStringSliceIterGetRef:sp,_BinaryenStringSliceIterSetRef:U6,_BinaryenStringSliceIterGetNum:ap,_BinaryenStringSliceIterSetNum:P6,_BinaryenAddFunction:di,_BinaryenGetFunction:xi,_BinaryenRemoveFunction:Rs,_BinaryenGetNumFunctions:V6,_BinaryenGetFunctionByIndex:G6,_BinaryenFunctionGetName:ga,_BinaryenFunctionGetParams:Ms,_BinaryenFunctionGetResults:Us,_BinaryenFunctionGetNumVars:op,_BinaryenFunctionGetVar:lp,_BinaryenFunctionGetNumLocals:Oc,_BinaryenFunctionHasLocalName:L9,_BinaryenFunctionGetLocalName:D9,_BinaryenFunctionSetLocalName:q6,_BinaryenFunctionGetBody:Tr,_BinaryenFunctionSetBody:up,_BinaryenFunctionOptimize:O9,_BinaryenFunctionRunPasses:j6,_BinaryenFunctionSetDebugLocation:W6,_BinaryenAddFunctionImport:H6,_BinaryenAddTableImport:X6,_BinaryenAddMemoryImport:K6,_BinaryenAddGlobalImport:$6,_BinaryenAddTagImport:Y6,_BinaryenAddFunctionExport:cp,_BinaryenAddTableExport:Z6,_BinaryenAddMemoryExport:J6,_BinaryenAddGlobalExport:Q6,_BinaryenAddTagExport:e3,_BinaryenGetExport:fp,_BinaryenRemoveExport:pp,_BinaryenGetNumExports:R9,_BinaryenGetExportByIndex:M9,_BinaryenExportGetKind:n3,_BinaryenExportGetName:t3,_BinaryenExportGetValue:r3,_BinaryenAddGlobal:i3,_BinaryenGetGlobal:s3,_BinaryenRemoveGlobal:a3,_BinaryenGetNumGlobals:o3,_BinaryenGetGlobalByIndex:l3,_BinaryenGlobalGetName:u3,_BinaryenGlobalGetType:c3,_BinaryenGlobalIsMutable:f3,_BinaryenGlobalGetInitExpr:hp,_BinaryenAddTag:p3,_BinaryenGetTag:h3,_BinaryenRemoveTag:d3,_BinaryenTagGetName:x3,_BinaryenTagGetParams:g3,_BinaryenTagGetResults:m3,_BinaryenAddTable:y3,_BinaryenRemoveTable:U9,_BinaryenGetNumTables:P9,_BinaryenGetTable:_3,_BinaryenGetTableByIndex:V9,_BinaryenTableGetName:G9,_BinaryenTableSetName:q9,_BinaryenTableGetInitial:j9,_BinaryenTableSetInitial:b3,_BinaryenTableHasMax:W9,_BinaryenTableGetMax:H9,_BinaryenTableSetMax:v3,_BinaryenAddActiveElementSegment:E3,_BinaryenAddPassiveElementSegment:X9,_BinaryenRemoveElementSegment:K9,_BinaryenGetNumElementSegments:$9,_BinaryenGetElementSegment:Y9,_BinaryenGetElementSegmentByIndex:Z9,_BinaryenSetMemory:F3,_BinaryenGetNumMemorySegments:J9,_BinaryenGetMemorySegmentByteOffset:Q9,_BinaryenGetMemorySegmentByteLength:eC,_BinaryenCopyMemorySegmentData:nC,_BinaryenSetStart:A3,_BinaryenModuleParse:tC,_BinaryenModulePrint:rC,_BinaryenModulePrintAsmjs:iC,_BinaryenModuleValidate:T3,_BinaryenModuleOptimize:sC,_BinaryenModuleRunPasses:S3,_BinaryenModuleAutoDrop:aC,_BinaryenSizeofAllocateAndWriteResult:C3,_BinaryenModuleAllocateAndWrite:w3,_BinaryenModuleAllocateAndWriteText:I3,_BinaryenModuleAllocateAndWriteStackIR:k3,_BinaryenModuleRead:B3,_BinaryenModuleInterpret:z3,_BinaryenModuleAddDebugInfoFileName:N3,_BinaryenModuleGetDebugInfoFileName:L3,_BinaryenModuleGetFeatures:D3,_BinaryenModuleSetFeatures:O3,_BinaryenAddCustomSection:R3,_BinaryenExpressionGetSideEffects:M3,_RelooperCreate:U3,_RelooperAddBlock:P3,_RelooperAddBranch:V3,_RelooperAddBlockWithSwitch:G3,_RelooperAddBranchForSwitch:q3,_RelooperRenderAndDispose:j3,_ExpressionRunnerCreate:W3,_ExpressionRunnerSetLocalValue:oC,_ExpressionRunnerSetGlobalValue:lC,_ExpressionRunnerRunAndDispose:H3,_TypeBuilderCreate:X3,_TypeBuilderGrow:Rc,_TypeBuilderGetSize:Ps,_TypeBuilderSetBasicHeapType:uC,_TypeBuilderSetSignatureType:K3,_TypeBuilderSetStructType:$3,_TypeBuilderSetArrayType:cC,_TypeBuilderIsBasic:fC,_TypeBuilderGetBasic:pC,_TypeBuilderGetTempHeapType:Mc,_TypeBuilderGetTempTupleType:Uc,_TypeBuilderGetTempRefType:dr,_TypeBuilderSetSubType:Y3,_TypeBuilderCreateRecGroup:hC,_TypeBuilderBuildAndDispose:Z3,_BinaryenModuleSetTypeName:dC,_BinaryenModuleSetFieldName:xC,_BinaryenGetOptimizeLevel:J3,_BinaryenSetOptimizeLevel:Q3,_BinaryenGetShrinkLevel:em,_BinaryenSetShrinkLevel:nm,_BinaryenGetDebugInfo:tm,_BinaryenSetDebugInfo:rm,_BinaryenGetLowMemoryUnused:im,_BinaryenSetLowMemoryUnused:sm,_BinaryenGetZeroFilledMemory:am,_BinaryenSetZeroFilledMemory:om,_BinaryenGetFastMath:lm,_BinaryenSetFastMath:um,_BinaryenGetPassArgument:cm,_BinaryenSetPassArgument:fm,_BinaryenClearPassArguments:pm,_BinaryenGetAlwaysInlineMaxSize:hm,_BinaryenSetAlwaysInlineMaxSize:dm,_BinaryenGetFlexibleInlineMaxSize:xm,_BinaryenSetFlexibleInlineMaxSize:gm,_BinaryenGetOneCallerInlineMaxSize:mm,_BinaryenSetOneCallerInlineMaxSize:ym,_BinaryenGetAllowInliningFunctionsWithLoops:_m,_BinaryenSetAllowInliningFunctionsWithLoops:bm,_BinaryenGetTypeSystem:vm,_BinaryenSetTypeSystem:Em,_malloc:In,_free:K,__i32_store8:Oe,__i32_store16:gC,__i32_store:ma,__f32_store:mC,__f64_store:yC,__i32_load8_s:_C,__i32_load8_u:Pt,__i32_load16_s:bC,__i32_load16_u:vC,__i32_load:ht,__f32_load:EC,__f64_load:FC}=Jc,Di=new Float64Array(1),dp=new Float32Array(Di.buffer),Zt=new Int32Array(Di.buffer);globalThis.f32_as_i32=function(e){return dp[0]=e,Zt[0]};globalThis.i32_as_f32=function(e){return Zt[0]=e,dp[0]};globalThis.f64_as_i64=function(e){return Di[0]=e,i64_new(Zt[0],Zt[1])};globalThis.i64_as_f64=function(e){return Zt[0]=i64_low(e),Zt[1]=i64_high(e),Di[0]};globalThis.i64_zero=_e.ZERO;globalThis.i64_one=_e.ONE;globalThis.i64_neg_one=_e.fromInt(-1);globalThis.i64_minimum=_e.MIN_VALUE;globalThis.i64_maximum=_e.MAX_VALUE;globalThis.i64_is=function(e){return _e.isLong(e)};globalThis.i64_new=function(e,n){return _e.fromBits(e,n)};globalThis.i64_low=function(e){return e.low};globalThis.i64_high=function(e){return e.high};globalThis.i64_not=function(e){return e.not()};globalThis.i64_neg=function(e){return e.neg()};globalThis.i64_clz=function(e){return e.clz()};globalThis.i64_ctz=function(e){return e.ctz()};globalThis.i64_add=function(e,n){return e.add(n)};globalThis.i64_sub=function(e,n){return e.sub(n)};globalThis.i64_mul=function(e,n){return e.mul(n)};globalThis.i64_pow=function(e,n){let t=n.low,r=n.high;if(r<=0){if(r<0)return e.eq(globalThis.i64_neg_one)?t&1?e:_e.ONE:e.eq(_e.ONE)?e:_e.ZERO;if(t==0)return _e.ONE;if(t==1)return e;if(t==2)return e.mul(e)}let i=_e.ONE;for(;t|r;)t&1&&(i=i.mul(e)),n=n.shru(1),e=e.mul(e),t=n.low,r=n.high;return i};globalThis.i64_div=function(e,n){return e.div(n)};globalThis.i64_div_u=function(e,n){return e.toUnsigned().div(n.toUnsigned()).toSigned()};globalThis.i64_rem=function(e,n){return e.mod(n)};globalThis.i64_rem_u=function(e,n){return e.toUnsigned().mod(n.toUnsigned()).toSigned()};globalThis.i64_and=function(e,n){return e.and(n)};globalThis.i64_or=function(e,n){return e.or(n)};globalThis.i64_xor=function(e,n){return e.xor(n)};globalThis.i64_shl=function(e,n){return e.shl(n)};globalThis.i64_shr=function(e,n){return e.shr(n)};globalThis.i64_shr_u=function(e,n){return e.shru(n)};globalThis.i64_eq=function(e,n){return e.eq(n)};globalThis.i64_ne=function(e,n){return e.ne(n)};globalThis.i64_ge=function(e,n){return e.ge(n)};globalThis.i64_ge_u=function(e,n){return e.toUnsigned().ge(n.toUnsigned())};globalThis.i64_gt=function(e,n){return e.gt(n)};globalThis.i64_gt_u=function(e,n){return e.toUnsigned().gt(n.toUnsigned())};globalThis.i64_le=function(e,n){return e.le(n)};globalThis.i64_le_u=function(e,n){return e.toUnsigned().le(n.toUnsigned())};globalThis.i64_lt=function(e,n){return e.lt(n)};globalThis.i64_lt_u=function(e,n){return e.toUnsigned().lt(n.toUnsigned())};globalThis.i64_align=function(e,n){assert(n&&(n&n-1)==0);let t=_e.fromInt(n-1);return e.add(t).and(t.not())};globalThis.i64_signbit=function(e){return Boolean(e.high>>>31)};globalThis.i64_is_i8=function(e){return e.high===0&&e.low>=0&&e.low<=i8.MAX_VALUE||e.high===-1&&e.low>=i8.MIN_VALUE&&e.low<0};globalThis.i64_is_i16=function(e){return e.high===0&&e.low>=0&&e.low<=i16.MAX_VALUE||e.high===-1&&e.low>=i16.MIN_VALUE&&e.low<0};globalThis.i64_is_i32=function(e){return e.high===0&&e.low>=0||e.high===-1&&e.low<0};globalThis.i64_is_u8=function(e){return e.high===0&&e.low>>>0<=u8.MAX_VALUE};globalThis.i64_is_u16=function(e){return e.high===0&&e.low>>>0<=u16.MAX_VALUE};globalThis.i64_is_u32=function(e){return e.high===0};globalThis.i64_is_bool=function(e){return(e.high|e.low&-2)===0};var Fm=_e.fromNumber(f32.MIN_SAFE_INTEGER),Am=_e.fromNumber(f32.MAX_SAFE_INTEGER);globalThis.i64_is_f32=function(e){return e.gte(Fm)&&e.lte(Am)};var Tm=_e.fromNumber(f64.MIN_SAFE_INTEGER),Sm=_e.fromNumber(f64.MAX_SAFE_INTEGER);globalThis.i64_is_f64=function(e){return e.gte(Tm)&&e.lte(Sm)};globalThis.i64_to_f32=function(e){return globalThis.Math.fround(e.toNumber())};globalThis.i64_to_f64=function(e){return e.toNumber()};globalThis.i64_to_string=function(e,n){return n?e.toUnsigned().toString():e.toString()};globalThis.i64_clone=function(e){return _e.fromBits(e.low,e.high,e.unsigned)};globalThis.Map_keys=function(e){return Array.from(e.keys())};globalThis.Map_values=function(e){return Array.from(e.values())};globalThis.Set_values=function(e){return Array.from(e.values())};var ya=(e=>(e[e.None=0]="None",e[e.SignExtension=1]="SignExtension",e[e.MutableGlobals=2]="MutableGlobals",e[e.NontrappingF2I=4]="NontrappingF2I",e[e.BulkMemory=8]="BulkMemory",e[e.Simd=16]="Simd",e[e.Threads=32]="Threads",e[e.ExceptionHandling=64]="ExceptionHandling",e[e.TailCalls=128]="TailCalls",e[e.ReferenceTypes=256]="ReferenceTypes",e[e.MultiValue=512]="MultiValue",e[e.GC=1024]="GC",e[e.Memory64=2048]="Memory64",e[e.RelaxedSimd=4096]="RelaxedSimd",e[e.ExtendedConst=8192]="ExtendedConst",e[e.Stringref=16384]="Stringref",e))(ya||{});function Oi(e){switch(e){case 1:return"sign-extension";case 2:return"mutable-globals";case 4:return"nontrapping-f2i";case 8:return"bulk-memory";case 16:return"simd";case 32:return"threads";case 64:return"exception-handling";case 128:return"tail-calls";case 256:return"reference-types";case 512:return"multi-value";case 1024:return"gc";case 2048:return"memory64";case 4096:return"relaxed-simd";case 8192:return"extended-const";case 16384:return"stringref"}return assert(!1),""}var _a=(e=>(e[e.Js=0]="Js",e[e.Wasm32=1]="Wasm32",e[e.Wasm64=2]="Wasm64",e))(_a||{}),ba=(e=>(e[e.Stub=0]="Stub",e[e.Minimal=1]="Minimal",e[e.Incremental=2]="Incremental",e))(ba||{}),gi=class{constructor(){this.flags=Ri.NONE,this.base=0}};gi=Lh([unmanaged],gi);var Ri=(e=>(e[e.NONE=0]="NONE",e[e.ARRAYBUFFERVIEW=1]="ARRAYBUFFERVIEW",e[e.ARRAY=2]="ARRAY",e[e.STATICARRAY=4]="STATICARRAY",e[e.SET=8]="SET",e[e.MAP=16]="MAP",e[e.POINTERFREE=32]="POINTERFREE",e[e.VALUE_ALIGN_0=64]="VALUE_ALIGN_0",e[e.VALUE_ALIGN_1=128]="VALUE_ALIGN_1",e[e.VALUE_ALIGN_2=256]="VALUE_ALIGN_2",e[e.VALUE_ALIGN_3=512]="VALUE_ALIGN_3",e[e.VALUE_ALIGN_4=1024]="VALUE_ALIGN_4",e[e.VALUE_SIGNED=2048]="VALUE_SIGNED",e[e.VALUE_FLOAT=4096]="VALUE_FLOAT",e[e.VALUE_NULLABLE=8192]="VALUE_NULLABLE",e[e.VALUE_MANAGED=16384]="VALUE_MANAGED",e[e.KEY_ALIGN_0=32768]="KEY_ALIGN_0",e[e.KEY_ALIGN_1=65536]="KEY_ALIGN_1",e[e.KEY_ALIGN_2=131072]="KEY_ALIGN_2",e[e.KEY_ALIGN_3=262144]="KEY_ALIGN_3",e[e.KEY_ALIGN_4=524288]="KEY_ALIGN_4",e[e.KEY_SIGNED=1048576]="KEY_SIGNED",e[e.KEY_FLOAT=2097152]="KEY_FLOAT",e[e.KEY_NULLABLE=4194304]="KEY_NULLABLE",e[e.KEY_MANAGED=8388608]="KEY_MANAGED",e))(Ri||{}),va=(e=>(e[e.None=0]="None",e[e.Import=1]="Import",e[e.Export=2]="Export",e[e.Declare=4]="Declare",e[e.Const=8]="Const",e[e.Let=16]="Let",e[e.Static=32]="Static",e[e.Readonly=64]="Readonly",e[e.Abstract=128]="Abstract",e[e.Public=256]="Public",e[e.Private=512]="Private",e[e.Protected=1024]="Protected",e[e.Get=2048]="Get",e[e.Set=4096]="Set",e[e.Override=8192]="Override",e[e.DefinitelyAssigned=16384]="DefinitelyAssigned",e[e.Ambient=32768]="Ambient",e[e.Generic=65536]="Generic",e[e.GenericContext=131072]="GenericContext",e[e.Instance=262144]="Instance",e[e.Constructor=524288]="Constructor",e[e.ModuleExport=1048576]="ModuleExport",e[e.ModuleImport=2097152]="ModuleImport",e[e.Resolved=4194304]="Resolved",e[e.Compiled=8388608]="Compiled",e[e.Errored=16777216]="Errored",e[e.Inlined=33554432]="Inlined",e[e.Scoped=67108864]="Scoped",e[e.Stub=134217728]="Stub",e[e.Virtual=268435456]="Virtual",e[e.Closure=536870912]="Closure",e[e.Quoted=1073741824]="Quoted",e))(va||{}),Xn="/",xp="..",Mi="get:",Ui="set:",Sr="#",Pi=".",Ea="~",Vi="~lib",Cn=Vi+Xn,We=Xn+"index",Fa="@",v;(e=>(e.Empty="",e.i8="i8",e.i16="i16",e.i32="i32",e.i64="i64",e.isize="isize",e.u8="u8",e.u16="u16",e.u32="u32",e.u64="u64",e.usize="usize",e.bool="bool",e.f32="f32",e.f64="f64",e.v128="v128",e.funcref="funcref",e.externref="externref",e.anyref="anyref",e.eqref="eqref",e.i31ref="i31ref",e.dataref="dataref",e.arrayref="arrayref",e.stringref="stringref",e.stringview_wtf8="stringview_wtf8",e.stringview_wtf16="stringview_wtf16",e.stringview_iter="stringview_iter",e.i8x16="i8x16",e.u8x16="u8x16",e.i16x8="i16x8",e.u16x8="u16x8",e.i32x4="i32x4",e.u32x4="u32x4",e.i64x2="i64x2",e.u64x2="u64x2",e.f32x4="f32x4",e.f64x2="f64x2",e.void_="void",e.number="number",e.boolean="boolean",e.string="string",e.native="native",e.indexof="indexof",e.valueof="valueof",e.returnof="returnof",e.nonnull="nonnull",e.null_="null",e.true_="true",e.false_="false",e.this_="this",e.super_="super",e.constructor="constructor",e.ASC_TARGET="ASC_TARGET",e.ASC_RUNTIME="ASC_RUNTIME",e.ASC_NO_ASSERT="ASC_NO_ASSERT",e.ASC_MEMORY_BASE="ASC_MEMORY_BASE",e.ASC_TABLE_BASE="ASC_TABLE_BASE",e.ASC_OPTIMIZE_LEVEL="ASC_OPTIMIZE_LEVEL",e.ASC_SHRINK_LEVEL="ASC_SHRINK_LEVEL",e.ASC_LOW_MEMORY_LIMIT="ASC_LOW_MEMORY_LIMIT",e.ASC_EXPORT_RUNTIME="ASC_EXPORT_RUNTIME",e.ASC_FEATURE_SIGN_EXTENSION="ASC_FEATURE_SIGN_EXTENSION",e.ASC_FEATURE_MUTABLE_GLOBALS="ASC_FEATURE_MUTABLE_GLOBALS",e.ASC_FEATURE_NONTRAPPING_F2I="ASC_FEATURE_NONTRAPPING_F2I",e.ASC_FEATURE_BULK_MEMORY="ASC_FEATURE_BULK_MEMORY",e.ASC_FEATURE_SIMD="ASC_FEATURE_SIMD",e.ASC_FEATURE_THREADS="ASC_FEATURE_THREADS",e.ASC_FEATURE_EXCEPTION_HANDLING="ASC_FEATURE_EXCEPTION_HANDLING",e.ASC_FEATURE_TAIL_CALLS="ASC_FEATURE_TAIL_CALLS",e.ASC_FEATURE_REFERENCE_TYPES="ASC_FEATURE_REFERENCE_TYPES",e.ASC_FEATURE_MULTI_VALUE="ASC_FEATURE_MULTI_VALUE",e.ASC_FEATURE_GC="ASC_FEATURE_GC",e.ASC_FEATURE_MEMORY64="ASC_FEATURE_MEMORY64",e.ASC_FEATURE_RELAXED_SIMD="ASC_FEATURE_RELAXED_SIMD",e.ASC_FEATURE_EXTENDED_CONST="ASC_FEATURE_EXTENDED_CONST",e.ASC_FEATURE_STRINGREF="ASC_FEATURE_STRINGREF",e.ASC_VERSION_MAJOR="ASC_VERSION_MAJOR",e.ASC_VERSION_MINOR="ASC_VERSION_MINOR",e.ASC_VERSION_PATCH="ASC_VERSION_PATCH",e.I8="I8",e.I16="I16",e.I32="I32",e.I64="I64",e.Isize="Isize",e.U8="U8",e.U16="U16",e.U32="U32",e.U64="U64",e.Usize="Usize",e.Bool="Bool",e.F32="F32",e.F64="F64",e.V128="V128",e.Funcref="Funcref",e.Externref="Externref",e.Anyref="Anyref",e.Eqref="Eqref",e.I31ref="I31ref",e.Dataref="Dataref",e.Arrayref="Arrayref",e.String="String",e.RegExp="RegExp",e.Object="Object",e.Array="Array",e.StaticArray="StaticArray",e.Set="Set",e.Map="Map",e.Function="Function",e.ArrayBufferView="ArrayBufferView",e.ArrayBuffer="ArrayBuffer",e.Math="Math",e.Mathf="Mathf",e.NativeMath="NativeMath",e.NativeMathf="NativeMathf",e.Int8Array="Int8Array",e.Int16Array="Int16Array",e.Int32Array="Int32Array",e.Int64Array="Int64Array",e.Uint8Array="Uint8Array",e.Uint8ClampedArray="Uint8ClampedArray",e.Uint16Array="Uint16Array",e.Uint32Array="Uint32Array",e.Uint64Array="Uint64Array",e.Float32Array="Float32Array",e.Float64Array="Float64Array",e.TemplateStringsArray="TemplateStringsArray",e.Error="Error",e.abort="abort",e._g="_g",e.max_iterations="max_iterations",e.accept="$accept",e.emit="$emit",e.etxn_details="$etxn_details",e.etxn_fee_base="$etxn_fee_base",e.etxn_reserve="$etxn_reserve",e.float_compare="$float_compare",e.float_divide="$float_divide",e.float_int="$float_int",e.float_mulratio="$float_mulratio",e.float_multiply="$float_multiply",e.float_negate="$float_negate",e.float_set="$float_set",e.float_sto="$float_sto",e.float_sto_set="$float_sto_set",e.float_sum="$float_sum",e.hook_account="$hook_account",e.hook_param="$hook_param",e.ledger_seq="ledger_seq",e.otxn_field="otxn_field",e.otxn_slot="$otxn_slot",e.rollback="$rollback",e.slot="$slot",e.slot_count="$slot_count",e.slot_float="$slot_float",e.slot_set="$slot_set",e.slot_subarray="$slot_subarray",e.slot_subfield="$slot_subfield",e.slot_type="$slot_type",e.state="$state",e.state_foreign="$state_foreign",e.state_set="$state_set",e.sto_emplace="$sto_emplace",e.sto_erase="$sto_erase",e.sto_subarray="$sto_subarray",e.sto_subfield="$sto_subfield",e.trace="trace",e.trace_float="$trace_float",e.trace_num="$trace_num",e.util_accid="$util_accid",e.util_keylet="$util_keylet",e.util_sha512h="$util_sha512h",e.util_verify="$util_verify",e.seed="seed",e.pow="pow",e.ipow32="ipow32",e.ipow64="ipow64",e.mod="mod",e.alloc="__alloc",e.realloc="__realloc",e.free="__free",e.new_="__new",e.renew="__renew",e.link="__link",e.collect="__collect",e.typeinfo="__typeinfo",e.instanceof_="__instanceof",e.visit="__visit",e.newBuffer="__newBuffer",e.newArray="__newArray",e.BLOCK="~lib/rt/common/BLOCK",e.OBJECT="~lib/rt/common/OBJECT",e.DefaultMemory="0",e.DefaultTable="0"))(v||={});var Aa=(e=>(e[e.Not_implemented_0=100]="Not_implemented_0",e[e.Operation_is_unsafe=101]="Operation_is_unsafe",e[e.User_defined_0=102]="User_defined_0",e[e.Feature_0_is_not_enabled=103]="Feature_0_is_not_enabled",e[e.Low_memory_limit_exceeded_by_static_data_0_1=104]="Low_memory_limit_exceeded_by_static_data_0_1",e[e.Module_requires_at_least_0_pages_of_initial_memory=105]="Module_requires_at_least_0_pages_of_initial_memory",e[e.Module_requires_at_least_0_pages_of_maximum_memory=106]="Module_requires_at_least_0_pages_of_maximum_memory",e[e.Shared_memory_requires_maximum_memory_to_be_defined=107]="Shared_memory_requires_maximum_memory_to_be_defined",e[e.Shared_memory_requires_feature_threads_to_be_enabled=108]="Shared_memory_requires_feature_threads_to_be_enabled",e[e.Transform_0_1=109]="Transform_0_1",e[e.Start_function_name_0_is_invalid_or_conflicts_with_another_export=110]="Start_function_name_0_is_invalid_or_conflicts_with_another_export",e[e.Element_0_not_found=111]="Element_0_not_found",e[e.Exchange_of_0_values_is_not_supported_by_all_embeddings=112]="Exchange_of_0_values_is_not_supported_by_all_embeddings",e[e.Conversion_from_type_0_to_1_requires_an_explicit_cast=200]="Conversion_from_type_0_to_1_requires_an_explicit_cast",e[e.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit=201]="Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit",e[e.Type_0_cannot_be_changed_to_type_1=202]="Type_0_cannot_be_changed_to_type_1",e[e.Operation_0_cannot_be_applied_to_type_1=203]="Operation_0_cannot_be_applied_to_type_1",e[e.Type_0_cannot_be_nullable=204]="Type_0_cannot_be_nullable",e[e.Mutable_value_cannot_be_inlined=206]="Mutable_value_cannot_be_inlined",e[e.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa=207]="Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa",e[e.Unmanaged_classes_cannot_implement_interfaces=208]="Unmanaged_classes_cannot_implement_interfaces",e[e.Invalid_regular_expression_flags=209]="Invalid_regular_expression_flags",e[e.Expression_is_never_null=210]="Expression_is_never_null",e[e.Class_0_is_final_and_cannot_be_extended=211]="Class_0_is_final_and_cannot_be_extended",e[e.Decorator_0_is_not_valid_here=212]="Decorator_0_is_not_valid_here",e[e.Duplicate_decorator=213]="Duplicate_decorator",e[e.Type_0_is_illegal_in_this_context=214]="Type_0_is_illegal_in_this_context",e[e.Optional_parameter_must_have_an_initializer=215]="Optional_parameter_must_have_an_initializer",e[e.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal=216]="Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal",e[e.Function_0_cannot_be_inlined_into_itself=217]="Function_0_cannot_be_inlined_into_itself",e[e.Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set=218]="Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set",e[e.Optional_properties_are_not_supported=219]="Optional_properties_are_not_supported",e[e.Expression_must_be_a_compile_time_constant=220]="Expression_must_be_a_compile_time_constant",e[e.Type_0_is_not_a_function_index_or_function_reference=221]="Type_0_is_not_a_function_index_or_function_reference",e[e._0_must_be_a_value_between_1_and_2_inclusive=222]="_0_must_be_a_value_between_1_and_2_inclusive",e[e._0_must_be_a_power_of_two=223]="_0_must_be_a_power_of_two",e[e._0_is_not_a_valid_operator=224]="_0_is_not_a_valid_operator",e[e.Expression_cannot_be_represented_by_a_type=225]="Expression_cannot_be_represented_by_a_type",e[e.Expression_resolves_to_unusual_type_0=226]="Expression_resolves_to_unusual_type_0",e[e.Array_literal_expected=227]="Array_literal_expected",e[e.Function_0_is_virtual_and_will_not_be_inlined=228]="Function_0_is_virtual_and_will_not_be_inlined",e[e.Property_0_only_has_a_setter_and_is_missing_a_getter=229]="Property_0_only_has_a_setter_and_is_missing_a_getter",e[e._0_keyword_cannot_be_used_here=230]="_0_keyword_cannot_be_used_here",e[e.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final=231]="A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final",e[e.Property_0_is_always_assigned_before_being_used=233]="Property_0_is_always_assigned_before_being_used",e[e.Expression_does_not_compile_to_a_value_at_runtime=234]="Expression_does_not_compile_to_a_value_at_runtime",e[e.Only_variables_functions_and_enums_become_WebAssembly_module_exports=235]="Only_variables_functions_and_enums_become_WebAssembly_module_exports",e[e.Literal_0_does_not_fit_into_i64_or_u64_types=236]="Literal_0_does_not_fit_into_i64_or_u64_types",e[e.Index_signature_accessors_in_type_0_differ_in_types=237]="Index_signature_accessors_in_type_0_differ_in_types",e[e.Importing_the_table_disables_some_indirect_call_optimizations=901]="Importing_the_table_disables_some_indirect_call_optimizations",e[e.Exporting_the_table_disables_some_indirect_call_optimizations=902]="Exporting_the_table_disables_some_indirect_call_optimizations",e[e.Expression_compiles_to_a_dynamic_check_at_runtime=903]="Expression_compiles_to_a_dynamic_check_at_runtime",e[e.Indexed_access_may_involve_bounds_checking=904]="Indexed_access_may_involve_bounds_checking",e[e.Explicitly_returning_constructor_drops_this_allocation=905]="Explicitly_returning_constructor_drops_this_allocation",e[e.Unnecessary_definite_assignment=906]="Unnecessary_definite_assignment",e[e._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead=907]="_NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead",e[e.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters=908]="Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters",e[e.Unterminated_string_literal=1002]="Unterminated_string_literal",e[e.Identifier_expected=1003]="Identifier_expected",e[e._0_expected=1005]="_0_expected",e[e.A_file_cannot_have_a_reference_to_itself=1006]="A_file_cannot_have_a_reference_to_itself",e[e.Trailing_comma_not_allowed=1009]="Trailing_comma_not_allowed",e[e.Unexpected_token=1012]="Unexpected_token",e[e.A_rest_parameter_must_be_last_in_a_parameter_list=1014]="A_rest_parameter_must_be_last_in_a_parameter_list",e[e.Parameter_cannot_have_question_mark_and_initializer=1015]="Parameter_cannot_have_question_mark_and_initializer",e[e.A_required_parameter_cannot_follow_an_optional_parameter=1016]="A_required_parameter_cannot_follow_an_optional_parameter",e[e._0_modifier_cannot_appear_on_class_elements_of_this_kind=1031]="_0_modifier_cannot_appear_on_class_elements_of_this_kind",e[e.Statements_are_not_allowed_in_ambient_contexts=1036]="Statements_are_not_allowed_in_ambient_contexts",e[e.Initializers_are_not_allowed_in_ambient_contexts=1039]="Initializers_are_not_allowed_in_ambient_contexts",e[e._0_modifier_cannot_be_used_here=1042]="_0_modifier_cannot_be_used_here",e[e.A_rest_parameter_cannot_be_optional=1047]="A_rest_parameter_cannot_be_optional",e[e.A_rest_parameter_cannot_have_an_initializer=1048]="A_rest_parameter_cannot_have_an_initializer",e[e.A_set_accessor_must_have_exactly_one_parameter=1049]="A_set_accessor_must_have_exactly_one_parameter",e[e.A_set_accessor_parameter_cannot_have_an_initializer=1052]="A_set_accessor_parameter_cannot_have_an_initializer",e[e.A_get_accessor_cannot_have_parameters=1054]="A_get_accessor_cannot_have_parameters",e[e.Enum_member_must_have_initializer=1061]="Enum_member_must_have_initializer",e[e.Type_parameters_cannot_appear_on_a_constructor_declaration=1092]="Type_parameters_cannot_appear_on_a_constructor_declaration",e[e.Type_annotation_cannot_appear_on_a_constructor_declaration=1093]="Type_annotation_cannot_appear_on_a_constructor_declaration",e[e.An_accessor_cannot_have_type_parameters=1094]="An_accessor_cannot_have_type_parameters",e[e.A_set_accessor_cannot_have_a_return_type_annotation=1095]="A_set_accessor_cannot_have_a_return_type_annotation",e[e.Type_parameter_list_cannot_be_empty=1098]="Type_parameter_list_cannot_be_empty",e[e.Type_argument_list_cannot_be_empty=1099]="Type_argument_list_cannot_be_empty",e[e.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement=1104]="A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement",e[e.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement=1105]="A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement",e[e.A_return_statement_can_only_be_used_within_a_function_body=1108]="A_return_statement_can_only_be_used_within_a_function_body",e[e.Expression_expected=1109]="Expression_expected",e[e.Type_expected=1110]="Type_expected",e[e.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement=1113]="A_default_clause_cannot_appear_more_than_once_in_a_switch_statement",e[e.Duplicate_label_0=1114]="Duplicate_label_0",e[e.An_export_assignment_cannot_have_modifiers=1120]="An_export_assignment_cannot_have_modifiers",e[e.Octal_literals_are_not_allowed_in_strict_mode=1121]="Octal_literals_are_not_allowed_in_strict_mode",e[e.Digit_expected=1124]="Digit_expected",e[e.Hexadecimal_digit_expected=1125]="Hexadecimal_digit_expected",e[e.Unexpected_end_of_text=1126]="Unexpected_end_of_text",e[e.Invalid_character=1127]="Invalid_character",e[e._case_or_default_expected=1130]="_case_or_default_expected",e[e._super_must_be_followed_by_an_argument_list_or_member_access=1034]="_super_must_be_followed_by_an_argument_list_or_member_access",e[e.A_declare_modifier_cannot_be_used_in_an_already_ambient_context=1038]="A_declare_modifier_cannot_be_used_in_an_already_ambient_context",e[e.Type_argument_expected=1140]="Type_argument_expected",e[e.String_literal_expected=1141]="String_literal_expected",e[e.Line_break_not_permitted_here=1142]="Line_break_not_permitted_here",e[e.Declaration_expected=1146]="Declaration_expected",e[e._const_declarations_must_be_initialized=1155]="_const_declarations_must_be_initialized",e[e.Unterminated_regular_expression_literal=1161]="Unterminated_regular_expression_literal",e[e.Interface_declaration_cannot_have_implements_clause=1176]="Interface_declaration_cannot_have_implements_clause",e[e.Binary_digit_expected=1177]="Binary_digit_expected",e[e.Octal_digit_expected=1178]="Octal_digit_expected",e[e.An_implementation_cannot_be_declared_in_ambient_contexts=1183]="An_implementation_cannot_be_declared_in_ambient_contexts",e[e.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer=1190]="The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer",e[e.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive=1198]="An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive",e[e.Unterminated_Unicode_escape_sequence=1199]="Unterminated_Unicode_escape_sequence",e[e.Decorators_are_not_valid_here=1206]="Decorators_are_not_valid_here",e[e._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration=1242]="_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration",e[e.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract=1245]="Method_0_cannot_have_an_implementation_because_it_is_marked_abstract",e[e.A_definite_assignment_assertion_is_not_permitted_in_this_context=1255]="A_definite_assignment_assertion_is_not_permitted_in_this_context",e[e.A_class_may_only_extend_another_class=1311]="A_class_may_only_extend_another_class",e[e.A_parameter_property_cannot_be_declared_using_a_rest_parameter=1317]="A_parameter_property_cannot_be_declared_using_a_rest_parameter",e[e.A_default_export_can_only_be_used_in_a_module=1319]="A_default_export_can_only_be_used_in_a_module",e[e.An_expression_of_type_0_cannot_be_tested_for_truthiness=1345]="An_expression_of_type_0_cannot_be_tested_for_truthiness",e[e.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal=1351]="An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal",e[e.Duplicate_identifier_0=2300]="Duplicate_identifier_0",e[e.Cannot_find_name_0=2304]="Cannot_find_name_0",e[e.Module_0_has_no_exported_member_1=2305]="Module_0_has_no_exported_member_1",e[e.An_interface_can_only_extend_an_interface=2312]="An_interface_can_only_extend_an_interface",e[e.Generic_type_0_requires_1_type_argument_s=2314]="Generic_type_0_requires_1_type_argument_s",e[e.Type_0_is_not_generic=2315]="Type_0_is_not_generic",e[e.Type_0_is_not_assignable_to_type_1=2322]="Type_0_is_not_assignable_to_type_1",e[e.Property_0_is_private_in_type_1_but_not_in_type_2=2325]="Property_0_is_private_in_type_1_but_not_in_type_2",e[e.Index_signature_is_missing_in_type_0=2329]="Index_signature_is_missing_in_type_0",e[e._this_cannot_be_referenced_in_current_location=2332]="_this_cannot_be_referenced_in_current_location",e[e._this_cannot_be_referenced_in_constructor_arguments=2333]="_this_cannot_be_referenced_in_constructor_arguments",e[e._super_can_only_be_referenced_in_a_derived_class=2335]="_super_can_only_be_referenced_in_a_derived_class",e[e._super_cannot_be_referenced_in_constructor_arguments=2336]="_super_cannot_be_referenced_in_constructor_arguments",e[e.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors=2337]="Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors",e[e.Property_0_does_not_exist_on_type_1=2339]="Property_0_does_not_exist_on_type_1",e[e.Property_0_is_private_and_only_accessible_within_class_1=2341]="Property_0_is_private_and_only_accessible_within_class_1",e[e.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures=2349]="Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures",e[e.This_expression_is_not_constructable=2351]="This_expression_is_not_constructable",e[e.A_function_whose_declared_type_is_not_void_must_return_a_value=2355]="A_function_whose_declared_type_is_not_void_must_return_a_value",e[e.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access=2357]="The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access",e[e.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access=2364]="The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access",e[e.Operator_0_cannot_be_applied_to_types_1_and_2=2365]="Operator_0_cannot_be_applied_to_types_1_and_2",e[e.A_super_call_must_be_the_first_statement_in_the_constructor=2376]="A_super_call_must_be_the_first_statement_in_the_constructor",e[e.Constructors_for_derived_classes_must_contain_a_super_call=2377]="Constructors_for_derived_classes_must_contain_a_super_call",e[e.Getter_and_setter_accessors_do_not_agree_in_visibility=2379]="Getter_and_setter_accessors_do_not_agree_in_visibility",e[e._get_and_set_accessor_must_have_the_same_type=2380]="_get_and_set_accessor_must_have_the_same_type",e[e.Overload_signatures_must_all_be_public_private_or_protected=2385]="Overload_signatures_must_all_be_public_private_or_protected",e[e.Constructor_implementation_is_missing=2390]="Constructor_implementation_is_missing",e[e.Function_implementation_is_missing_or_not_immediately_following_the_declaration=2391]="Function_implementation_is_missing_or_not_immediately_following_the_declaration",e[e.Multiple_constructor_implementations_are_not_allowed=2392]="Multiple_constructor_implementations_are_not_allowed",e[e.Duplicate_function_implementation=2393]="Duplicate_function_implementation",e[e.This_overload_signature_is_not_compatible_with_its_implementation_signature=2394]="This_overload_signature_is_not_compatible_with_its_implementation_signature",e[e.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local=2395]="Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local",e[e.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2=2416]="Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2",e[e.A_class_can_only_implement_an_interface=2422]="A_class_can_only_implement_an_interface",e[e.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged=2434]="A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged",e[e.Types_have_separate_declarations_of_a_private_property_0=2442]="Types_have_separate_declarations_of_a_private_property_0",e[e.Property_0_is_protected_in_type_1_but_public_in_type_2=2444]="Property_0_is_protected_in_type_1_but_public_in_type_2",e[e.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses=2445]="Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses",e[e.Variable_0_used_before_its_declaration=2448]="Variable_0_used_before_its_declaration",e[e.Cannot_redeclare_block_scoped_variable_0=2451]="Cannot_redeclare_block_scoped_variable_0",e[e.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly=2453]="The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly",e[e.Type_alias_0_circularly_references_itself=2456]="Type_alias_0_circularly_references_itself",e[e.Type_0_has_no_property_1=2460]="Type_0_has_no_property_1",e[e.The_0_operator_cannot_be_applied_to_type_1=2469]="The_0_operator_cannot_be_applied_to_type_1",e[e.In_const_enum_declarations_member_initializer_must_be_constant_expression=2474]="In_const_enum_declarations_member_initializer_must_be_constant_expression",e[e.Export_declaration_conflicts_with_exported_declaration_of_0=2484]="Export_declaration_conflicts_with_exported_declaration_of_0",e[e._0_is_referenced_directly_or_indirectly_in_its_own_base_expression=2506]="_0_is_referenced_directly_or_indirectly_in_its_own_base_expression",e[e.Cannot_create_an_instance_of_an_abstract_class=2511]="Cannot_create_an_instance_of_an_abstract_class",e[e.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2=2515]="Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2",e[e.Object_is_possibly_null=2531]="Object_is_possibly_null",e[e.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property=2540]="Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property",e[e.The_target_of_an_assignment_must_be_a_variable_or_a_property_access=2541]="The_target_of_an_assignment_must_be_a_variable_or_a_property_access",e[e.Index_signature_in_type_0_only_permits_reading=2542]="Index_signature_in_type_0_only_permits_reading",e[e.Expected_0_arguments_but_got_1=2554]="Expected_0_arguments_but_got_1",e[e.Expected_at_least_0_arguments_but_got_1=2555]="Expected_at_least_0_arguments_but_got_1",e[e.Expected_0_type_arguments_but_got_1=2558]="Expected_0_type_arguments_but_got_1",e[e.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned=2564]="Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned",e[e.Property_0_is_used_before_being_assigned=2565]="Property_0_is_used_before_being_assigned",e[e.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums=2651]="A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums",e[e.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration=2673]="Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration",e[e.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration=2674]="Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration",e[e.The_this_types_of_each_signature_are_incompatible=2685]="The_this_types_of_each_signature_are_incompatible",e[e.Namespace_0_has_no_exported_member_1=2694]="Namespace_0_has_no_exported_member_1",e[e.Required_type_parameters_may_not_follow_optional_type_parameters=2706]="Required_type_parameters_may_not_follow_optional_type_parameters",e[e.Duplicate_property_0=2718]="Duplicate_property_0",e[e.Property_0_is_missing_in_type_1_but_required_in_type_2=2741]="Property_0_is_missing_in_type_1_but_required_in_type_2",e[e.Type_0_has_no_call_signatures=2757]="Type_0_has_no_call_signatures",e[e.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0=4117]="This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0",e[e.File_0_not_found=6054]="File_0_not_found",e[e.Numeric_separators_are_not_allowed_here=6188]="Numeric_separators_are_not_allowed_here",e[e.Multiple_consecutive_numeric_separators_are_not_permitted=6189]="Multiple_consecutive_numeric_separators_are_not_permitted",e[e._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class=17009]="_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class",e[e._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class=17011]="_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class",e))(Aa||{});function Ta(e){switch(e){case 100:return"Not implemented: {0}";case 101:return"Operation is unsafe.";case 102:return"User-defined: {0}";case 103:return"Feature '{0}' is not enabled.";case 104:return"Low memory limit exceeded by static data: {0} > {1}";case 105:return"Module requires at least '{0}' pages of initial memory.";case 106:return"Module requires at least '{0}' pages of maximum memory.";case 107:return"Shared memory requires maximum memory to be defined.";case 108:return"Shared memory requires feature 'threads' to be enabled.";case 109:return"Transform '{0}': {1}";case 110:return"Start function name '{0}' is invalid or conflicts with another export.";case 111:return"Element '{0}' not found.";case 112:return"Exchange of '{0}' values is not supported by all embeddings";case 200:return"Conversion from type '{0}' to '{1}' requires an explicit cast.";case 201:return"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.";case 202:return"Type '{0}' cannot be changed to type '{1}'.";case 203:return"Operation '{0}' cannot be applied to type '{1}'.";case 204:return"Type '{0}' cannot be nullable.";case 206:return"Mutable value cannot be inlined.";case 207:return"Unmanaged classes cannot extend managed classes and vice-versa.";case 208:return"Unmanaged classes cannot implement interfaces.";case 209:return"Invalid regular expression flags.";case 210:return"Expression is never 'null'.";case 211:return"Class '{0}' is final and cannot be extended.";case 212:return"Decorator '{0}' is not valid here.";case 213:return"Duplicate decorator.";case 214:return"Type '{0}' is illegal in this context.";case 215:return"Optional parameter must have an initializer.";case 216:return"Class '{0}' cannot declare a constructor when instantiated from an object literal.";case 217:return"Function '{0}' cannot be inlined into itself.";case 218:return"Cannot access method '{0}' without calling it as it requires 'this' to be set.";case 219:return"Optional properties are not supported.";case 220:return"Expression must be a compile-time constant.";case 221:return"Type '{0}' is not a function index or function reference.";case 222:return"'{0}' must be a value between '{1}' and '{2}' inclusive.";case 223:return"'{0}' must be a power of two.";case 224:return"'{0}' is not a valid operator.";case 225:return"Expression cannot be represented by a type.";case 226:return"Expression resolves to unusual type '{0}'.";case 227:return"Array literal expected.";case 228:return"Function '{0}' is virtual and will not be inlined.";case 229:return"Property '{0}' only has a setter and is missing a getter.";case 230:return"'{0}' keyword cannot be used here.";case 231:return"A class with a constructor explicitly returning something else than 'this' must be '@final'.";case 233:return"Property '{0}' is always assigned before being used.";case 234:return"Expression does not compile to a value at runtime.";case 235:return"Only variables, functions and enums become WebAssembly module exports.";case 236:return"Literal '{0}' does not fit into 'i64' or 'u64' types.";case 237:return"Index signature accessors in type '{0}' differ in types.";case 901:return"Importing the table disables some indirect call optimizations.";case 902:return"Exporting the table disables some indirect call optimizations.";case 903:return"Expression compiles to a dynamic check at runtime.";case 904:return"Indexed access may involve bounds checking.";case 905:return"Explicitly returning constructor drops 'this' allocation.";case 906:return"Unnecessary definite assignment.";case 907:return"'NaN' does not compare equal to any other value including itself. Use isNaN(x) instead.";case 908:return"Comparison with -0.0 is sign insensitive. Use Object.is(x, -0.0) if the sign matters.";case 1002:return"Unterminated string literal.";case 1003:return"Identifier expected.";case 1005:return"'{0}' expected.";case 1006:return"A file cannot have a reference to itself.";case 1009:return"Trailing comma not allowed.";case 1012:return"Unexpected token.";case 1014:return"A rest parameter must be last in a parameter list.";case 1015:return"Parameter cannot have question mark and initializer.";case 1016:return"A required parameter cannot follow an optional parameter.";case 1031:return"'{0}' modifier cannot appear on class elements of this kind.";case 1036:return"Statements are not allowed in ambient contexts.";case 1039:return"Initializers are not allowed in ambient contexts.";case 1042:return"'{0}' modifier cannot be used here.";case 1047:return"A rest parameter cannot be optional.";case 1048:return"A rest parameter cannot have an initializer.";case 1049:return"A 'set' accessor must have exactly one parameter.";case 1052:return"A 'set' accessor parameter cannot have an initializer.";case 1054:return"A 'get' accessor cannot have parameters.";case 1061:return"Enum member must have initializer.";case 1092:return"Type parameters cannot appear on a constructor declaration.";case 1093:return"Type annotation cannot appear on a constructor declaration.";case 1094:return"An accessor cannot have type parameters.";case 1095:return"A 'set' accessor cannot have a return type annotation.";case 1098:return"Type parameter list cannot be empty.";case 1099:return"Type argument list cannot be empty.";case 1104:return"A 'continue' statement can only be used within an enclosing iteration statement.";case 1105:return"A 'break' statement can only be used within an enclosing iteration or switch statement.";case 1108:return"A 'return' statement can only be used within a function body.";case 1109:return"Expression expected.";case 1110:return"Type expected.";case 1113:return"A 'default' clause cannot appear more than once in a 'switch' statement.";case 1114:return"Duplicate label '{0}'.";case 1120:return"An export assignment cannot have modifiers.";case 1121:return"Octal literals are not allowed in strict mode.";case 1124:return"Digit expected.";case 1125:return"Hexadecimal digit expected.";case 1126:return"Unexpected end of text.";case 1127:return"Invalid character.";case 1130:return"'case' or 'default' expected.";case 1034:return"'super' must be followed by an argument list or member access.";case 1038:return"A 'declare' modifier cannot be used in an already ambient context.";case 1140:return"Type argument expected.";case 1141:return"String literal expected.";case 1142:return"Line break not permitted here.";case 1146:return"Declaration expected.";case 1155:return"'const' declarations must be initialized.";case 1161:return"Unterminated regular expression literal.";case 1176:return"Interface declaration cannot have 'implements' clause.";case 1177:return"Binary digit expected.";case 1178:return"Octal digit expected.";case 1183:return"An implementation cannot be declared in ambient contexts.";case 1190:return"The variable declaration of a 'for...of' statement cannot have an initializer.";case 1198:return"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.";case 1199:return"Unterminated Unicode escape sequence.";case 1206:return"Decorators are not valid here.";case 1242:return"'abstract' modifier can only appear on a class, method, or property declaration.";case 1245:return"Method '{0}' cannot have an implementation because it is marked abstract.";case 1255:return"A definite assignment assertion '!' is not permitted in this context.";case 1311:return"A class may only extend another class.";case 1317:return"A parameter property cannot be declared using a rest parameter.";case 1319:return"A default export can only be used in a module.";case 1345:return"An expression of type '{0}' cannot be tested for truthiness.";case 1351:return"An identifier or keyword cannot immediately follow a numeric literal.";case 2300:return"Duplicate identifier '{0}'.";case 2304:return"Cannot find name '{0}'.";case 2305:return"Module '{0}' has no exported member '{1}'.";case 2312:return"An interface can only extend an interface.";case 2314:return"Generic type '{0}' requires {1} type argument(s).";case 2315:return"Type '{0}' is not generic.";case 2322:return"Type '{0}' is not assignable to type '{1}'.";case 2325:return"Property '{0}' is private in type '{1}' but not in type '{2}'.";case 2329:return"Index signature is missing in type '{0}'.";case 2332:return"'this' cannot be referenced in current location.";case 2333:return"'this' cannot be referenced in constructor arguments.";case 2335:return"'super' can only be referenced in a derived class.";case 2336:return"'super' cannot be referenced in constructor arguments.";case 2337:return"Super calls are not permitted outside constructors or in nested functions inside constructors.";case 2339:return"Property '{0}' does not exist on type '{1}'.";case 2341:return"Property '{0}' is private and only accessible within class '{1}'.";case 2349:return"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.";case 2351:return"This expression is not constructable.";case 2355:return"A function whose declared type is not 'void' must return a value.";case 2357:return"The operand of an increment or decrement operator must be a variable or a property access.";case 2364:return"The left-hand side of an assignment expression must be a variable or a property access.";case 2365:return"Operator '{0}' cannot be applied to types '{1}' and '{2}'.";case 2376:return"A 'super' call must be the first statement in the constructor.";case 2377:return"Constructors for derived classes must contain a 'super' call.";case 2379:return"Getter and setter accessors do not agree in visibility.";case 2380:return"'get' and 'set' accessor must have the same type.";case 2385:return"Overload signatures must all be public, private or protected.";case 2390:return"Constructor implementation is missing.";case 2391:return"Function implementation is missing or not immediately following the declaration.";case 2392:return"Multiple constructor implementations are not allowed.";case 2393:return"Duplicate function implementation.";case 2394:return"This overload signature is not compatible with its implementation signature.";case 2395:return"Individual declarations in merged declaration '{0}' must be all exported or all local.";case 2416:return"Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.";case 2422:return"A class can only implement an interface.";case 2434:return"A namespace declaration cannot be located prior to a class or function with which it is merged.";case 2442:return"Types have separate declarations of a private property '{0}'.";case 2444:return"Property '{0}' is protected in type '{1}' but public in type '{2}'.";case 2445:return"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.";case 2448:return"Variable '{0}' used before its declaration.";case 2451:return"Cannot redeclare block-scoped variable '{0}'";case 2453:return"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.";case 2456:return"Type alias '{0}' circularly references itself.";case 2460:return"Type '{0}' has no property '{1}'.";case 2469:return"The '{0}' operator cannot be applied to type '{1}'.";case 2474:return"In 'const' enum declarations member initializer must be constant expression.";case 2484:return"Export declaration conflicts with exported declaration of '{0}'.";case 2506:return"'{0}' is referenced directly or indirectly in its own base expression.";case 2511:return"Cannot create an instance of an abstract class.";case 2515:return"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.";case 2531:return"Object is possibly 'null'.";case 2540:return"Cannot assign to '{0}' because it is a constant or a read-only property.";case 2541:return"The target of an assignment must be a variable or a property access.";case 2542:return"Index signature in type '{0}' only permits reading.";case 2554:return"Expected {0} arguments, but got {1}.";case 2555:return"Expected at least {0} arguments, but got {1}.";case 2558:return"Expected {0} type arguments, but got {1}.";case 2564:return"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.";case 2565:return"Property '{0}' is used before being assigned.";case 2651:return"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.";case 2673:return"Constructor of class '{0}' is private and only accessible within the class declaration.";case 2674:return"Constructor of class '{0}' is protected and only accessible within the class declaration.";case 2685:return"The 'this' types of each signature are incompatible.";case 2694:return"Namespace '{0}' has no exported member '{1}'.";case 2706:return"Required type parameters may not follow optional type parameters.";case 2718:return"Duplicate property '{0}'.";case 2741:return"Property '{0}' is missing in type '{1}' but required in type '{2}'.";case 2757:return"Type '{0}' has no call signatures.";case 4117:return"This member cannot have an 'override' modifier because it is not declared in the base class '{0}'.";case 6054:return"File '{0}' not found.";case 6188:return"Numeric separators are not allowed here.";case 6189:return"Multiple consecutive numeric separators are not permitted.";case 17009:return"'super' must be called before accessing 'this' in the constructor of a derived class.";case 17011:return"'super' must be called before accessing a property of 'super' in the constructor of a derived class.";default:return""}}var Sa={};Ys(Sa,{BitSet:()=>Nm,COLOR_BLUE:()=>$m,COLOR_CYAN:()=>Tp,COLOR_GRAY:()=>Xm,COLOR_GREEN:()=>Km,COLOR_MAGENTA:()=>Ap,COLOR_RED:()=>za,COLOR_RESET:()=>Xi,COLOR_WHITE:()=>Ym,COLOR_YELLOW:()=>Fp,CharCode:()=>_p,SURROGATE_HIGH:()=>Wi,SURROGATE_LOW:()=>Nr,accuratePow64:()=>Gs,cloneMap:()=>de,colorize:()=>Zm,combineSurrogates:()=>Ia,dirname:()=>Ep,escapeString:()=>ke,indent:()=>k,isAlpha:()=>ka,isAlphaOrDecimal:()=>bp,isColorsEnabled:()=>wr,isDecimal:()=>cn,isHexBase:()=>yi,isHexOrDecimal:()=>Rm,isHighSurrogate:()=>Hi,isIdentifier:()=>fn,isIdentifierPart:()=>br,isIdentifierStart:()=>_r,isLineBreak:()=>dt,isLowSurrogate:()=>wa,isOctal:()=>qs,isPowerOf2:()=>nr,isSurrogate:()=>Lm,isSurrogateHigh:()=>Dm,isSurrogateLow:()=>Om,isWhiteSpace:()=>Ca,mergeMaps:()=>zm,normalizePath:()=>Lr,numCodeUnits:()=>Wt,readF32:()=>Im,readF64:()=>km,readI16:()=>wm,readI32:()=>Cr,readI64:()=>gp,readI8:()=>Cm,readV128:()=>Bm,resolvePath:()=>Ba,setColorsEnabled:()=>js,v128_ones:()=>Cp,v128_zero:()=>Sp,writeF32:()=>qi,writeF64:()=>ji,writeI16:()=>Gi,writeI32:()=>be,writeI32AsI64:()=>Vs,writeI64:()=>mi,writeI64AsI32:()=>mp,writeI8:()=>me,writeV128:()=>yp});function Cm(e,n){return e[n]}function me(e,n,t){n[t]=e}function wm(e,n){return i32(e[n])|i32(e[n+1])<<8}function Gi(e,n,t){n[t]=e,n[t+1]=e>>>8}function Cr(e,n){return i32(e[n])|i32(e[n+1])<<8|i32(e[n+2])<<16|i32(e[n+3])<<24}function be(e,n,t){n[t]=e,n[t+1]=e>>>8,n[t+2]=e>>>16,n[t+3]=e>>>24}function Vs(e,n,t,r=!1){be(e,n,t),be(r||e>=0?0:-1,n,t+4)}function gp(e,n){let t=Cr(e,n),r=Cr(e,n+4);return i64_new(t,r)}function mi(e,n,t){be(i64_low(e),n,t),be(i64_high(e),n,t+4)}function mp(e,n,t,r=!1){assert(r?i64_is_u32(e):i64_is_i32(e)),be(i64_low(e),n,t)}function Im(e,n){return i32_as_f32(Cr(e,n))}function qi(e,n,t){be(f32_as_i32(e),n,t)}function km(e,n){return i64_as_f64(gp(e,n))}function ji(e,n,t){let r=f64_as_i64(e);be(i64_low(r),n,t),be(i64_high(r),n,t+4)}function Bm(e,n){return e.slice(n,n+16)}function yp(e,n,t){assert(e.length==16),n.set(e,t)}function de(e){if(ASC_TARGET){let n=new Map;if(e)for(let t=Map_keys(e),r=0,i=t.length;r<i;++r){let s=unchecked(t[r]),a=assert(e.get(s));n.set(s,a)}return n}else return new Map(e)}function zm(e,n){if(ASC_TARGET){let t=new Map;for(let r=Map_keys(e),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]),o=assert(e.get(a));t.set(a,o)}for(let r=Map_keys(n),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]),o=assert(n.get(a));t.set(a,o)}return t}else{let t=new Map(e);return n.forEach((r,i)=>t.set(i,r)),t}}var Nm=class{constructor(){this.clear()}get size(){let e=0,n=this.words;for(let t=0,r=n.length;t<r;t++){let i=unchecked(n[t]);i&&(e+=popcnt(i))}return e}add(e){let n=e>>>5,t=this.words;return n>=t.length&&(this.words=new Uint32Array(n+16),this.words.set(t),t=this.words),unchecked(t[n]|=1<<e),this}delete(e){let n=e>>>5,t=this.words;n>=t.length||unchecked(t[n]&=~(1<<e))}has(e){let n=e>>>5,t=this.words;return n>=t.length?!1:(unchecked(t[e>>>5])&1<<e)!==0}clear(){this.words=new Uint32Array(16)}toArray(){let e=new Array(this.size);for(let n=0,t=0,r=this.words.length;n<r;++n){let i=unchecked(this.words[n]);for(;i;){let s=i&-i;unchecked(e[t++]=(n<<5)+popcnt(s-1)),i^=s}}return e}toString(){return`BitSet { ${this.toArray()} }`}};function nr(e){return e!=0&&(e&e-1)==0}function Gs(e,n){return!ASC_TARGET&&isFinite(n)&&Math.abs(n)>=2&&Math.trunc(n)==n?n<0?Math.pow(e,n+.5)/Math.pow(e,.5):Math.pow(e,n-.5)*Math.pow(e,.5):Math.pow(e,n)}var _p=(e=>(e[e.Null=0]="Null",e[e.LineFeed=10]="LineFeed",e[e.CarriageReturn=13]="CarriageReturn",e[e.LineSeparator=8232]="LineSeparator",e[e.ParagraphSeparator=8233]="ParagraphSeparator",e[e.NextLine=133]="NextLine",e[e.Space=32]="Space",e[e.NonBreakingSpace=160]="NonBreakingSpace",e[e.EnQuad=8192]="EnQuad",e[e.EmQuad=8193]="EmQuad",e[e.EnSpace=8194]="EnSpace",e[e.EmSpace=8195]="EmSpace",e[e.ThreePerEmSpace=8196]="ThreePerEmSpace",e[e.FourPerEmSpace=8197]="FourPerEmSpace",e[e.SixPerEmSpace=8198]="SixPerEmSpace",e[e.FigureSpace=8199]="FigureSpace",e[e.PunctuationSpace=8200]="PunctuationSpace",e[e.ThinSpace=8201]="ThinSpace",e[e.HairSpace=8202]="HairSpace",e[e.ZeroWidthSpace=8203]="ZeroWidthSpace",e[e.NarrowNoBreakSpace=8239]="NarrowNoBreakSpace",e[e.IdeographicSpace=12288]="IdeographicSpace",e[e.MathematicalSpace=8287]="MathematicalSpace",e[e.Ogham=5760]="Ogham",e[e._=95]="_",e[e._0=48]="_0",e[e._1=49]="_1",e[e._2=50]="_2",e[e._3=51]="_3",e[e._4=52]="_4",e[e._5=53]="_5",e[e._6=54]="_6",e[e._7=55]="_7",e[e._8=56]="_8",e[e._9=57]="_9",e[e.a=97]="a",e[e.b=98]="b",e[e.c=99]="c",e[e.d=100]="d",e[e.e=101]="e",e[e.f=102]="f",e[e.g=103]="g",e[e.h=104]="h",e[e.i=105]="i",e[e.j=106]="j",e[e.k=107]="k",e[e.l=108]="l",e[e.m=109]="m",e[e.n=110]="n",e[e.o=111]="o",e[e.p=112]="p",e[e.q=113]="q",e[e.r=114]="r",e[e.s=115]="s",e[e.t=116]="t",e[e.u=117]="u",e[e.v=118]="v",e[e.w=119]="w",e[e.x=120]="x",e[e.y=121]="y",e[e.z=122]="z",e[e.A=65]="A",e[e.B=66]="B",e[e.C=67]="C",e[e.D=68]="D",e[e.E=69]="E",e[e.F=70]="F",e[e.G=71]="G",e[e.H=72]="H",e[e.I=73]="I",e[e.J=74]="J",e[e.K=75]="K",e[e.L=76]="L",e[e.M=77]="M",e[e.N=78]="N",e[e.O=79]="O",e[e.P=80]="P",e[e.Q=81]="Q",e[e.R=82]="R",e[e.S=83]="S",e[e.T=84]="T",e[e.U=85]="U",e[e.V=86]="V",e[e.W=87]="W",e[e.X=88]="X",e[e.Y=89]="Y",e[e.Z=90]="Z",e[e.Ampersand=38]="Ampersand",e[e.Asterisk=42]="Asterisk",e[e.At=64]="At",e[e.Backslash=92]="Backslash",e[e.Backtick=96]="Backtick",e[e.Bar=124]="Bar",e[e.Caret=94]="Caret",e[e.CloseBrace=125]="CloseBrace",e[e.CloseBracket=93]="CloseBracket",e[e.CloseParen=41]="CloseParen",e[e.Colon=58]="Colon",e[e.Comma=44]="Comma",e[e.Dollar=36]="Dollar",e[e.Dot=46]="Dot",e[e.DoubleQuote=34]="DoubleQuote",e[e.Equals=61]="Equals",e[e.Exclamation=33]="Exclamation",e[e.GreaterThan=62]="GreaterThan",e[e.Hash=35]="Hash",e[e.LessThan=60]="LessThan",e[e.Minus=45]="Minus",e[e.OpenBrace=123]="OpenBrace",e[e.OpenBracket=91]="OpenBracket",e[e.OpenParen=40]="OpenParen",e[e.Percent=37]="Percent",e[e.Plus=43]="Plus",e[e.Question=63]="Question",e[e.Semicolon=59]="Semicolon",e[e.SingleQuote=39]="SingleQuote",e[e.Slash=47]="Slash",e[e.Tilde=126]="Tilde",e[e.Backspace=8]="Backspace",e[e.FormFeed=12]="FormFeed",e[e.ByteOrderMark=65279]="ByteOrderMark",e[e.Tab=9]="Tab",e[e.VerticalTab=11]="VerticalTab",e))(_p||{});function dt(e){switch(e){case 10:case 13:case 8232:case 8233:return!0;default:return!1}}function Ca(e){switch(e){case 32:case 9:case 11:case 12:case 160:case 133:case 5760:case 8239:case 8287:case 12288:case 65279:return!0;default:return e>=8192&&e<=8203}}var Wi=55296,Nr=56320;function Lm(e){return(e&63488)==Wi}function Dm(e){return e<Nr}function Om(e){return e>=Nr}function Hi(e){return(e&64512)==Wi}function wa(e){return(e&64512)==Nr}function Ia(e,n){return 65536+((e&1023)<<10)|n&1023}function Wt(e){return 1+i32(e>65535)}function ka(e){let n=e|32;return n>=97&&n<=122}function cn(e){return e>=48&&e<=57}function qs(e){return e>=48&&e<=55}function yi(e){let n=e|32;return n>=97&&n<=102}function Rm(e){return cn(e)||yi(e)}function bp(e){return ka(e)||cn(e)}function _r(e){return ka(e)||e==95||e==36||e>=Um&&e<=Pm&&vp(e,Mm)}function br(e){return bp(e)||e==95||e==36||e>=Gm&&e<=qm&&vp(e,Vm)}function fn(e){let n=e.length;if(!n)return!1;let t=e.codePointAt(0);if(!_r(t))return!1;let r=Wt(t);for(;r<n;){if(t=e.codePointAt(r),!br(t))return!1;r+=Wt(t)}return!0}var Mm=[170,170,181,181,186,186,192,214,216,246,248,705,710,721,736,740,748,748,750,750,880,884,886,887,890,893,895,895,902,902,904,906,908,908,910,929,931,1013,1015,1153,1162,1327,1329,1366,1369,1369,1376,1416,1488,1514,1519,1522,1568,1610,1646,1647,1649,1747,1749,1749,1765,1766,1774,1775,1786,1788,1791,1791,1808,1808,1810,1839,1869,1957,1969,1969,1994,2026,2036,2037,2042,2042,2048,2069,2074,2074,2084,2084,2088,2088,2112,2136,2144,2154,2160,2183,2185,2190,2208,2249,2308,2361,2365,2365,2384,2384,2392,2401,2417,2432,2437,2444,2447,2448,2451,2472,2474,2480,2482,2482,2486,2489,2493,2493,2510,2510,2524,2525,2527,2529,2544,2545,2556,2556,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2649,2652,2654,2654,2674,2676,2693,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2749,2749,2768,2768,2784,2785,2809,2809,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2869,2873,2877,2877,2908,2909,2911,2913,2929,2929,2947,2947,2949,2954,2958,2960,2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,3001,3024,3024,3077,3084,3086,3088,3090,3112,3114,3129,3133,3133,3160,3162,3165,3165,3168,3169,3200,3200,3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3261,3261,3293,3294,3296,3297,3313,3314,3332,3340,3342,3344,3346,3386,3389,3389,3406,3406,3412,3414,3423,3425,3450,3455,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3585,3632,3634,3635,3648,3654,3713,3714,3716,3716,3718,3722,3724,3747,3749,3749,3751,3760,3762,3763,3773,3773,3776,3780,3782,3782,3804,3807,3840,3840,3904,3911,3913,3948,3976,3980,4096,4138,4159,4159,4176,4181,4186,4189,4193,4193,4197,4198,4206,4208,4213,4225,4238,4238,4256,4293,4295,4295,4301,4301,4304,4346,4348,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4744,4746,4749,4752,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4822,4824,4880,4882,4885,4888,4954,4992,5007,5024,5109,5112,5117,5121,5740,5743,5759,5761,5786,5792,5866,5870,5880,5888,5905,5919,5937,5952,5969,5984,5996,5998,6e3,6016,6067,6103,6103,6108,6108,6176,6264,6272,6312,6314,6314,6320,6389,6400,6430,6480,6509,6512,6516,6528,6571,6576,6601,6656,6678,6688,6740,6823,6823,6917,6963,6981,6988,7043,7072,7086,7087,7098,7141,7168,7203,7245,7247,7258,7293,7296,7304,7312,7354,7357,7359,7401,7404,7406,7411,7413,7414,7418,7418,7424,7615,7680,7957,7960,7965,7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,8155,8160,8172,8178,8180,8182,8188,8305,8305,8319,8319,8336,8348,8450,8450,8455,8455,8458,8467,8469,8469,8472,8477,8484,8484,8486,8486,8488,8488,8490,8505,8508,8511,8517,8521,8526,8526,8544,8584,11264,11492,11499,11502,11506,11507,11520,11557,11559,11559,11565,11565,11568,11623,11631,11631,11648,11670,11680,11686,11688,11694,11696,11702,11704,11710,11712,11718,11720,11726,11728,11734,11736,11742,12293,12295,12321,12329,12337,12341,12344,12348,12353,12438,12443,12447,12449,12538,12540,12543,12549,12591,12593,12686,12704,12735,12784,12799,13312,19903,19968,42124,42192,42237,42240,42508,42512,42527,42538,42539,42560,42606,42623,42653,42656,42735,42775,42783,42786,42888,42891,42954,42960,42961,42963,42963,42965,42969,42994,43009,43011,43013,43015,43018,43020,43042,43072,43123,43138,43187,43250,43255,43259,43259,43261,43262,43274,43301,43312,43334,43360,43388,43396,43442,43471,43471,43488,43492,43494,43503,43514,43518,43520,43560,43584,43586,43588,43595,43616,43638,43642,43642,43646,43695,43697,43697,43701,43702,43705,43709,43712,43712,43714,43714,43739,43741,43744,43754,43762,43764,43777,43782,43785,43790,43793,43798,43808,43814,43816,43822,43824,43866,43868,43881,43888,44002,44032,55203,55216,55238,55243,55291,63744,64109,64112,64217,64256,64262,64275,64279,64285,64285,64287,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,64433,64467,64829,64848,64911,64914,64967,65008,65019,65136,65140,65142,65276,65313,65338,65345,65370,65382,65470,65474,65479,65482,65487,65490,65495,65498,65500,65536,65547,65549,65574,65576,65594,65596,65597,65599,65613,65616,65629,65664,65786,65856,65908,66176,66204,66208,66256,66304,66335,66349,66378,66384,66421,66432,66461,66464,66499,66504,66511,66513,66517,66560,66717,66736,66771,66776,66811,66816,66855,66864,66915,66928,66938,66940,66954,66956,66962,66964,66965,66967,66977,66979,66993,66995,67001,67003,67004,67072,67382,67392,67413,67424,67431,67456,67461,67463,67504,67506,67514,67584,67589,67592,67592,67594,67637,67639,67640,67644,67644,67647,67669,67680,67702,67712,67742,67808,67826,67828,67829,67840,67861,67872,67897,67968,68023,68030,68031,68096,68096,68112,68115,68117,68119,68121,68149,68192,68220,68224,68252,68288,68295,68297,68324,68352,68405,68416,68437,68448,68466,68480,68497,68608,68680,68736,68786,68800,68850,68864,68899,69248,69289,69296,69297,69376,69404,69415,69415,69424,69445,69488,69505,69552,69572,69600,69622,69635,69687,69745,69746,69749,69749,69763,69807,69840,69864,69891,69926,69956,69956,69959,69959,69968,70002,70006,70006,70019,70066,70081,70084,70106,70106,70108,70108,70144,70161,70163,70187,70272,70278,70280,70280,70282,70285,70287,70301,70303,70312,70320,70366,70405,70412,70415,70416,70419,70440,70442,70448,70450,70451,70453,70457,70461,70461,70480,70480,70493,70497,70656,70708,70727,70730,70751,70753,70784,70831,70852,70853,70855,70855,71040,71086,71128,71131,71168,71215,71236,71236,71296,71338,71352,71352,71424,71450,71488,71494,71680,71723,71840,71903,71935,71942,71945,71945,71948,71955,71957,71958,71960,71983,71999,71999,72001,72001,72096,72103,72106,72144,72161,72161,72163,72163,72192,72192,72203,72242,72250,72250,72272,72272,72284,72329,72349,72349,72368,72440,72704,72712,72714,72750,72768,72768,72818,72847,72960,72966,72968,72969,72971,73008,73030,73030,73056,73061,73063,73064,73066,73097,73112,73112,73440,73458,73648,73648,73728,74649,74752,74862,74880,75075,77712,77808,77824,78894,82944,83526,92160,92728,92736,92766,92784,92862,92880,92909,92928,92975,92992,92995,93027,93047,93053,93071,93760,93823,93952,94026,94032,94032,94099,94111,94176,94177,94179,94179,94208,100343,100352,101589,101632,101640,110576,110579,110581,110587,110589,110590,110592,110882,110928,110930,110948,110951,110960,111355,113664,113770,113776,113788,113792,113800,113808,113817,119808,119892,119894,119964,119966,119967,119970,119970,119973,119974,119977,119980,119982,119993,119995,119995,119997,120003,120005,120069,120071,120074,120077,120084,120086,120092,120094,120121,120123,120126,120128,120132,120134,120134,120138,120144,120146,120485,120488,120512,120514,120538,120540,120570,120572,120596,120598,120628,120630,120654,120656,120686,120688,120712,120714,120744,120746,120770,120772,120779,122624,122654,123136,123180,123191,123197,123214,123214,123536,123565,123584,123627,124896,124902,124904,124907,124909,124910,124912,124926,124928,125124,125184,125251,125259,125259,126464,126467,126469,126495,126497,126498,126500,126500,126503,126503,126505,126514,126516,126519,126521,126521,126523,126523,126530,126530,126535,126535,126537,126537,126539,126539,126541,126543,126545,126546,126548,126548,126551,126551,126553,126553,126555,126555,126557,126557,126559,126559,126561,126562,126564,126564,126567,126570,126572,126578,126580,126583,126585,126588,126590,126590,126592,126601,126603,126619,126625,126627,126629,126633,126635,126651,131072,173791,173824,177976,177984,178205,178208,183969,183984,191456,194560,195101,196608,201546],Um=170,Pm=201546,Vm=[170,170,181,181,183,183,186,186,192,214,216,246,248,705,710,721,736,740,748,748,750,750,768,884,886,887,890,893,895,895,902,906,908,908,910,929,931,1013,1015,1153,1155,1159,1162,1327,1329,1366,1369,1369,1376,1416,1425,1469,1471,1471,1473,1474,1476,1477,1479,1479,1488,1514,1519,1522,1552,1562,1568,1641,1646,1747,1749,1756,1759,1768,1770,1788,1791,1791,1808,1866,1869,1969,1984,2037,2042,2042,2045,2045,2048,2093,2112,2139,2144,2154,2160,2183,2185,2190,2200,2273,2275,2403,2406,2415,2417,2435,2437,2444,2447,2448,2451,2472,2474,2480,2482,2482,2486,2489,2492,2500,2503,2504,2507,2510,2519,2519,2524,2525,2527,2531,2534,2545,2556,2556,2558,2558,2561,2563,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2620,2620,2622,2626,2631,2632,2635,2637,2641,2641,2649,2652,2654,2654,2662,2677,2689,2691,2693,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2748,2757,2759,2761,2763,2765,2768,2768,2784,2787,2790,2799,2809,2815,2817,2819,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2869,2873,2876,2884,2887,2888,2891,2893,2901,2903,2908,2909,2911,2915,2918,2927,2929,2929,2946,2947,2949,2954,2958,2960,2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,3001,3006,3010,3014,3016,3018,3021,3024,3024,3031,3031,3046,3055,3072,3084,3086,3088,3090,3112,3114,3129,3132,3140,3142,3144,3146,3149,3157,3158,3160,3162,3165,3165,3168,3171,3174,3183,3200,3203,3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3260,3268,3270,3272,3274,3277,3285,3286,3293,3294,3296,3299,3302,3311,3313,3314,3328,3340,3342,3344,3346,3396,3398,3400,3402,3406,3412,3415,3423,3427,3430,3439,3450,3455,3457,3459,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3530,3530,3535,3540,3542,3542,3544,3551,3558,3567,3570,3571,3585,3642,3648,3662,3664,3673,3713,3714,3716,3716,3718,3722,3724,3747,3749,3749,3751,3773,3776,3780,3782,3782,3784,3789,3792,3801,3804,3807,3840,3840,3864,3865,3872,3881,3893,3893,3895,3895,3897,3897,3902,3911,3913,3948,3953,3972,3974,3991,3993,4028,4038,4038,4096,4169,4176,4253,4256,4293,4295,4295,4301,4301,4304,4346,4348,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4744,4746,4749,4752,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4822,4824,4880,4882,4885,4888,4954,4957,4959,4969,4977,4992,5007,5024,5109,5112,5117,5121,5740,5743,5759,5761,5786,5792,5866,5870,5880,5888,5909,5919,5940,5952,5971,5984,5996,5998,6e3,6002,6003,6016,6099,6103,6103,6108,6109,6112,6121,6155,6157,6159,6169,6176,6264,6272,6314,6320,6389,6400,6430,6432,6443,6448,6459,6470,6509,6512,6516,6528,6571,6576,6601,6608,6618,6656,6683,6688,6750,6752,6780,6783,6793,6800,6809,6823,6823,6832,6845,6847,6862,6912,6988,6992,7001,7019,7027,7040,7155,7168,7223,7232,7241,7245,7293,7296,7304,7312,7354,7357,7359,7376,7378,7380,7418,7424,7957,7960,7965,7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,8155,8160,8172,8178,8180,8182,8188,8255,8256,8276,8276,8305,8305,8319,8319,8336,8348,8400,8412,8417,8417,8421,8432,8450,8450,8455,8455,8458,8467,8469,8469,8472,8477,8484,8484,8486,8486,8488,8488,8490,8505,8508,8511,8517,8521,8526,8526,8544,8584,11264,11492,11499,11507,11520,11557,11559,11559,11565,11565,11568,11623,11631,11631,11647,11670,11680,11686,11688,11694,11696,11702,11704,11710,11712,11718,11720,11726,11728,11734,11736,11742,11744,11775,12293,12295,12321,12335,12337,12341,12344,12348,12353,12438,12441,12447,12449,12538,12540,12543,12549,12591,12593,12686,12704,12735,12784,12799,13312,19903,19968,42124,42192,42237,42240,42508,42512,42539,42560,42607,42612,42621,42623,42737,42775,42783,42786,42888,42891,42954,42960,42961,42963,42963,42965,42969,42994,43047,43052,43052,43072,43123,43136,43205,43216,43225,43232,43255,43259,43259,43261,43309,43312,43347,43360,43388,43392,43456,43471,43481,43488,43518,43520,43574,43584,43597,43600,43609,43616,43638,43642,43714,43739,43741,43744,43759,43762,43766,43777,43782,43785,43790,43793,43798,43808,43814,43816,43822,43824,43866,43868,43881,43888,44010,44012,44013,44016,44025,44032,55203,55216,55238,55243,55291,63744,64109,64112,64217,64256,64262,64275,64279,64285,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,64433,64467,64829,64848,64911,64914,64967,65008,65019,65024,65039,65056,65071,65075,65076,65101,65103,65136,65140,65142,65276,65296,65305,65313,65338,65343,65343,65345,65370,65382,65470,65474,65479,65482,65487,65490,65495,65498,65500,65536,65547,65549,65574,65576,65594,65596,65597,65599,65613,65616,65629,65664,65786,65856,65908,66045,66045,66176,66204,66208,66256,66272,66272,66304,66335,66349,66378,66384,66426,66432,66461,66464,66499,66504,66511,66513,66517,66560,66717,66720,66729,66736,66771,66776,66811,66816,66855,66864,66915,66928,66938,66940,66954,66956,66962,66964,66965,66967,66977,66979,66993,66995,67001,67003,67004,67072,67382,67392,67413,67424,67431,67456,67461,67463,67504,67506,67514,67584,67589,67592,67592,67594,67637,67639,67640,67644,67644,67647,67669,67680,67702,67712,67742,67808,67826,67828,67829,67840,67861,67872,67897,67968,68023,68030,68031,68096,68099,68101,68102,68108,68115,68117,68119,68121,68149,68152,68154,68159,68159,68192,68220,68224,68252,68288,68295,68297,68326,68352,68405,68416,68437,68448,68466,68480,68497,68608,68680,68736,68786,68800,68850,68864,68903,68912,68921,69248,69289,69291,69292,69296,69297,69376,69404,69415,69415,69424,69456,69488,69509,69552,69572,69600,69622,69632,69702,69734,69749,69759,69818,69826,69826,69840,69864,69872,69881,69888,69940,69942,69951,69956,69959,69968,70003,70006,70006,70016,70084,70089,70092,70094,70106,70108,70108,70144,70161,70163,70199,70206,70206,70272,70278,70280,70280,70282,70285,70287,70301,70303,70312,70320,70378,70384,70393,70400,70403,70405,70412,70415,70416,70419,70440,70442,70448,70450,70451,70453,70457,70459,70468,70471,70472,70475,70477,70480,70480,70487,70487,70493,70499,70502,70508,70512,70516,70656,70730,70736,70745,70750,70753,70784,70853,70855,70855,70864,70873,71040,71093,71096,71104,71128,71133,71168,71232,71236,71236,71248,71257,71296,71352,71360,71369,71424,71450,71453,71467,71472,71481,71488,71494,71680,71738,71840,71913,71935,71942,71945,71945,71948,71955,71957,71958,71960,71989,71991,71992,71995,72003,72016,72025,72096,72103,72106,72151,72154,72161,72163,72164,72192,72254,72263,72263,72272,72345,72349,72349,72368,72440,72704,72712,72714,72758,72760,72768,72784,72793,72818,72847,72850,72871,72873,72886,72960,72966,72968,72969,72971,73014,73018,73018,73020,73021,73023,73031,73040,73049,73056,73061,73063,73064,73066,73102,73104,73105,73107,73112,73120,73129,73440,73462,73648,73648,73728,74649,74752,74862,74880,75075,77712,77808,77824,78894,82944,83526,92160,92728,92736,92766,92768,92777,92784,92862,92864,92873,92880,92909,92912,92916,92928,92982,92992,92995,93008,93017,93027,93047,93053,93071,93760,93823,93952,94026,94031,94087,94095,94111,94176,94177,94179,94180,94192,94193,94208,100343,100352,101589,101632,101640,110576,110579,110581,110587,110589,110590,110592,110882,110928,110930,110948,110951,110960,111355,113664,113770,113776,113788,113792,113800,113808,113817,113821,113822,118528,118573,118576,118598,119141,119145,119149,119154,119163,119170,119173,119179,119210,119213,119362,119364,119808,119892,119894,119964,119966,119967,119970,119970,119973,119974,119977,119980,119982,119993,119995,119995,119997,120003,120005,120069,120071,120074,120077,120084,120086,120092,120094,120121,120123,120126,120128,120132,120134,120134,120138,120144,120146,120485,120488,120512,120514,120538,120540,120570,120572,120596,120598,120628,120630,120654,120656,120686,120688,120712,120714,120744,120746,120770,120772,120779,120782,120831,121344,121398,121403,121452,121461,121461,121476,121476,121499,121503,121505,121519,122624,122654,122880,122886,122888,122904,122907,122913,122915,122916,122918,122922,123136,123180,123184,123197,123200,123209,123214,123214,123536,123566,123584,123641,124896,124902,124904,124907,124909,124910,124912,124926,124928,125124,125136,125142,125184,125259,125264,125273,126464,126467,126469,126495,126497,126498,126500,126500,126503,126503,126505,126514,126516,126519,126521,126521,126523,126523,126530,126530,126535,126535,126537,126537,126539,126539,126541,126543,126545,126546,126548,126548,126551,126551,126553,126553,126555,126555,126557,126557,126559,126559,126561,126562,126564,126564,126567,126570,126572,126578,126580,126583,126585,126588,126590,126590,126592,126601,126603,126619,126625,126627,126629,126633,126635,126651,130032,130041,131072,173791,173824,177976,177984,178205,178208,183969,183984,191456,194560,195101,196608,201546,917760,917999],Gm=170,qm=917999;function vp(e,n){let t=0,r=n.length;for(;t+1<r;){let i=t+(r-t>>>1);i-=i&1;let s=n[i];if(s<=e&&e<=n[i+1])return!0;e<s?r=i:t=i+2}return!1}var zs="  ",jm="    ",Wm="      ",Hm="        ",fi=new Map;function k(e,n){if(n<=4)switch(n){case 1:e.push(zs);break;case 2:e.push(jm);break;case 3:e.push(Wm);break;case 4:e.push(Hm);break}else{let t;fi.size<=1024?fi.has(n)?t=assert(fi.get(n)):fi.set(n,t=zs.repeat(n)):t=zs.repeat(n),e.push(t)}}function ke(e,n){let t=new Array,r=0,i=0;for(let s=e.length;i<s;)switch(e.charCodeAt(i)){case 0:{i>r&&t.push(e.substring(r,r=i+1)),t.push("\\0"),r=++i;break}case 8:{i>r&&t.push(e.substring(r,i)),r=++i,t.push("\\b");break}case 9:{i>r&&t.push(e.substring(r,i)),r=++i,t.push("\\t");break}case 10:{i>r&&t.push(e.substring(r,i)),r=++i,t.push("\\n");break}case 11:{i>r&&t.push(e.substring(r,i)),r=++i,t.push("\\v");break}case 12:{i>r&&t.push(e.substring(r,i)),r=++i,t.push("\\f");break}case 13:{i>r&&t.push(e.substring(r,i)),t.push("\\r"),r=++i;break}case 34:{n==34?(i>r&&t.push(e.substring(r,i)),t.push('\\"'),r=++i):++i;break}case 39:{n==39?(i>r&&t.push(e.substring(r,i)),t.push("\\'"),r=++i):++i;break}case 92:{i>r&&t.push(e.substring(r,i)),t.push("\\\\"),r=++i;break}case 96:{n==96?(i>r&&t.push(e.substring(r,i)),t.push("\\`"),r=++i):++i;break}default:{++i;break}}return i>r&&t.push(e.substring(r,i)),t.join("")}var lt=47;function Lr(e){let n=0,t=e.length;for(;n+1<t&&e.charCodeAt(n)==46&&e.charCodeAt(n+1)==lt;)n+=2;(n>0||t<e.length)&&(e=e.substring(n,t),t-=n,n=0);let r;for(;n+1<t;){if(r=!1,e.charCodeAt(n)==lt&&e.charCodeAt(n+1)==46){if(r=n+2==t,r||n+2<t&&e.charCodeAt(n+2)==lt){e=r?e.substring(0,n):e.substring(0,n)+e.substring(n+2),t-=2;continue}if(r=n+3==t,r&&e.charCodeAt(n+2)==46||n+3<t&&e.charCodeAt(n+2)==46&&e.charCodeAt(n+3)==lt){let i=n;for(;--i>=0;)if(e.charCodeAt(i)==lt){(n-i!=3||e.charCodeAt(i+1)!=46||e.charCodeAt(i+2)!=46)&&(e=r?e.substring(0,i):e.substring(0,i)+e.substring(n+3),t-=n+3-i,n=i-1);break}if(i<0&&n>0&&(n!=2||e.charCodeAt(0)!=46||e.charCodeAt(1)!=46)){e=e.substring(n+4),t=e.length;continue}}}n++}return t>0?e:"."}function Ba(e,n){return e.startsWith("std/")?e:Lr(Ep(n)+Xn+e)}function Ep(e){let n=e.length;if(n<=1){if(n==0)return".";if(e.charCodeAt(0)==lt)return e}for(;--n>0;)if(e.charCodeAt(n)==lt)return e.substring(0,n);return"."}var Xm="\x1B[90m",za="\x1B[91m",Km="\x1B[92m",Fp="\x1B[93m",$m="\x1B[94m",Ap="\x1B[95m",Tp="\x1B[96m",Ym="\x1B[97m",Xi="\x1B[0m",Na=!0;function wr(){return Na}function js(e){let n=e;return Na=e,n}function Zm(e,n){return Na?n+e+Xi:e}var Sp=new Uint8Array(16),Cp=new Uint8Array(16).fill(255),La=(e=>(e[e.Pedantic=0]="Pedantic",e[e.Info=1]="Info",e[e.Warning=2]="Warning",e[e.Error=3]="Error",e))(La||{}),fe=class{constructor(e,n){this.start=e,this.end=n,this.debugInfoRef=0}static join(e,n){if(e.source!=n.source)throw new Error("source mismatch");let t=new fe(e.start<n.start?e.start:n.start,e.end>n.end?e.end:n.end);return t.source=e.source,t}equals(e){return this.source==e.source&&this.start==e.start&&this.end==e.end}get atStart(){let e=new fe(this.start,this.start);return e.source=this.source,e}get atEnd(){let e=new fe(this.end,this.end);return e.source=this.source,e}toString(){return this.source.text.substring(this.start,this.end)}};function Ki(e){switch(e){case 0:return"PEDANTIC";case 1:return"INFO";case 2:return"WARNING";case 3:return"ERROR";default:return assert(!1),""}}function Da(e){switch(e){case 0:return Ap;case 1:return Tp;case 2:return Fp;case 3:return za;default:return assert(!1),""}}var $i=class{constructor(e,n,t){this.range=null,this.relatedRange=null,this.code=e,this.category=n,this.message=t}static create(e,n,t=null,r=null,i=null){let s=Ta(e);return t!=null&&(s=s.replace("{0}",t)),r!=null&&(s=s.replace("{1}",r)),i!=null&&(s=s.replace("{2}",i)),new $i(e,n,s)}equals(e){if(this.code!=e.code)return!1;let n=this.range,t=e.range;if(n){if(!t||!n.equals(t))return!1}else if(t)return!1;let r=this.relatedRange,i=e.relatedRange;if(r){if(!i||!r.equals(i))return!1}else if(i)return!1;return this.message==e.message}withRange(e){return this.range=e,this}withRelatedRange(e){return this.relatedRange=e,this}toString(){let e=Ki(this.category),n=this.range,t=this.code,r=this.message;if(n){let i=n.source,s=i.normalizedPath,a=i.lineAt(n.start),o=i.columnAt(),u=n.end-n.start;return`${e} ${t}: "${r}" in ${s}(${a},${o}+${u})`}return`${e} ${t}: ${r}`}};function Ws(e,n=!1,t=!1){let r=js(n),i=[];wr()&&i.push(Da(e.category)),i.push(Ki(e.category)),wr()&&i.push(Xi),i.push(e.code<1e3?" AS":" TS"),i.push(e.code.toString()),i.push(": "),i.push(e.message);let s=e.range;if(s){let a=s.source;t?(i.push(`
`),i.push(Pc(s))):(i.push(`
 in `),i.push(a.normalizedPath)),i.push("("),i.push(a.lineAt(s.start).toString()),i.push(","),i.push(a.columnAt().toString()),i.push(")");let o=e.relatedRange;if(o){let u=o.source;t?(i.push(`
`),i.push(Pc(o))):(i.push(`
 in `),i.push(u.normalizedPath)),i.push("("),i.push(u.lineAt(o.start).toString()),i.push(","),i.push(u.columnAt().toString()),i.push(")")}}return js(r),i.join("")}function Pc(e){let n=e.source,t=n.text,r=t.length,i=e.start,s=i,a=n.lineAt(i).toString(),o=" ".repeat(a.length);for(;i>0&&!dt(t.charCodeAt(i-1));)i--;for(;i<r&&Ca(t.charCodeAt(i));)i++;for(;s<r&&!dt(t.charCodeAt(s));)s++;let u=[o,`  :
 `,a," \u2502 ",t.substring(i,s).replaceAll("	","  "),`
 `,o," \u2502 "];for(;i<e.start;)t.charCodeAt(i)==9?(u.push("  "),i+=2):(u.push(" "),i++);if(wr()&&u.push(za),e.start==e.end)u.push("^");else for(;i++<e.end;){let c=t.charCodeAt(i);if(c==9)u.push("~~");else if(dt(c)){u.push(i==e.start+1?"^":"~");break}else u.push("~")}return wr()&&u.push(Xi),u.push(`
 `),u.push(o),u.push(" \u2514\u2500 in "),u.push(n.normalizedPath),u.join("")}var mt=class{constructor(e=null){this.seen=new Map,e||(e=[]),this.diagnostics=e}emitDiagnostic(e,n,t,r,i=null,s=null,a=null){let o=$i.create(e,n,i,s,a);if(t&&(o=o.withRange(t)),r&&(o.relatedRange=r),t){let u=this.seen;if(u.has(t.source)){let c=assert(u.get(t.source));if(c.has(t.start)){let f=assert(c.get(t.start));for(let p=0,d=f.length;p<d;++p)if(f[p].equals(o))return;f.push(o)}else c.set(t.start,[o])}else{let c=new Map;c.set(t.start,[o]),u.set(t.source,c)}}this.diagnostics.push(o)}pedantic(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,0,n,null,t,r,i)}pedanticRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,0,n,t,r,i,s)}info(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,1,n,null,t,r,i)}infoRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,1,n,t,r,i,s)}warning(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,2,n,null,t,r,i)}warningRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,2,n,t,r,i,s)}error(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,3,n,null,t,r,i)}errorRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,3,n,t,r,i,s)}},Oa=(e=>(e[e.Source=0]="Source",e[e.NamedType=1]="NamedType",e[e.FunctionType=2]="FunctionType",e[e.TypeName=3]="TypeName",e[e.TypeParameter=4]="TypeParameter",e[e.Parameter=5]="Parameter",e[e.Identifier=6]="Identifier",e[e.Assertion=7]="Assertion",e[e.Binary=8]="Binary",e[e.Call=9]="Call",e[e.Class=10]="Class",e[e.Comma=11]="Comma",e[e.ElementAccess=12]="ElementAccess",e[e.False=13]="False",e[e.Function=14]="Function",e[e.InstanceOf=15]="InstanceOf",e[e.Literal=16]="Literal",e[e.New=17]="New",e[e.Null=18]="Null",e[e.Omitted=19]="Omitted",e[e.Parenthesized=20]="Parenthesized",e[e.PropertyAccess=21]="PropertyAccess",e[e.Ternary=22]="Ternary",e[e.Super=23]="Super",e[e.This=24]="This",e[e.True=25]="True",e[e.Constructor=26]="Constructor",e[e.UnaryPostfix=27]="UnaryPostfix",e[e.UnaryPrefix=28]="UnaryPrefix",e[e.Compiled=29]="Compiled",e[e.Block=30]="Block",e[e.Break=31]="Break",e[e.Continue=32]="Continue",e[e.Do=33]="Do",e[e.Empty=34]="Empty",e[e.Export=35]="Export",e[e.ExportDefault=36]="ExportDefault",e[e.ExportImport=37]="ExportImport",e[e.Expression=38]="Expression",e[e.For=39]="For",e[e.ForOf=40]="ForOf",e[e.If=41]="If",e[e.Import=42]="Import",e[e.Return=43]="Return",e[e.Switch=44]="Switch",e[e.Throw=45]="Throw",e[e.Try=46]="Try",e[e.Variable=47]="Variable",e[e.Void=48]="Void",e[e.While=49]="While",e[e.Module=50]="Module",e[e.ClassDeclaration=51]="ClassDeclaration",e[e.EnumDeclaration=52]="EnumDeclaration",e[e.EnumValueDeclaration=53]="EnumValueDeclaration",e[e.FieldDeclaration=54]="FieldDeclaration",e[e.FunctionDeclaration=55]="FunctionDeclaration",e[e.ImportDeclaration=56]="ImportDeclaration",e[e.InterfaceDeclaration=57]="InterfaceDeclaration",e[e.MethodDeclaration=58]="MethodDeclaration",e[e.NamespaceDeclaration=59]="NamespaceDeclaration",e[e.TypeDeclaration=60]="TypeDeclaration",e[e.VariableDeclaration=61]="VariableDeclaration",e[e.Decorator=62]="Decorator",e[e.ExportMember=63]="ExportMember",e[e.SwitchCase=64]="SwitchCase",e[e.IndexSignature=65]="IndexSignature",e[e.Comment=66]="Comment",e))(Oa||{}),F=class{constructor(e,n){this.kind=e,this.range=n}static createSimpleTypeName(e,n){return new Ra(F.createIdentifierExpression(e,n),null,n)}static createNamedType(e,n,t,r){return new _i(e,n,t,r)}static createFunctionType(e,n,t,r,i){return new Ma(e,n,t,r,i)}static createOmittedType(e){return new _i(F.createSimpleTypeName("",e),null,!1,e)}static createTypeParameter(e,n,t,r){return new Ua(e,n,t,r)}static createParameter(e,n,t,r,i){return new Va(e,n,t,r,i)}static createDecorator(e,n,t){return new Ga(tr.fromNode(e),e,n,t)}static createComment(e,n,t){return new ja(e,n,t)}static createIdentifierExpression(e,n,t=!1){return new hn(e,t,n)}static createEmptyIdentifierExpression(e){return new hn("",!1,e)}static createArrayLiteralExpression(e,n){return new Wa(e,n)}static createAssertionExpression(e,n,t,r){return new Xa(e,n,t,r)}static createBinaryExpression(e,n,t,r){return new Ka(e,n,t,r)}static createCallExpression(e,n,t,r){return new $a(e,n,t,r)}static createClassExpression(e){return new Ya(e)}static createCommaExpression(e,n){return new Za(e,n)}static createConstructorExpression(e){return new Ja(e)}static createElementAccessExpression(e,n,t){return new Qa(e,n,t)}static createFalseExpression(e){return new yo(e)}static createFloatLiteralExpression(e,n){return new eo(e,n)}static createFunctionExpression(e){return new no(e)}static createInstanceOfExpression(e,n,t){return new to(e,n,t)}static createIntegerLiteralExpression(e,n){return new ro(e,n)}static createNewExpression(e,n,t,r){return new io(e,n,t,r)}static createNullExpression(e){return new so(e)}static createObjectLiteralExpression(e,n,t){return new ao(e,n,t)}static createOmittedExpression(e){return new oo(e)}static createParenthesizedExpression(e,n){return new lo(e,n)}static createPropertyAccessExpression(e,n,t){return new uo(e,n,t)}static createRegexpLiteralExpression(e,n,t){return new co(e,n,t)}static createTernaryExpression(e,n,t,r){return new fo(e,n,t,r)}static createStringLiteralExpression(e,n){return new po(e,n)}static createSuperExpression(e){return new ho(e)}static createTemplateLiteralExpression(e,n,t,r,i,s){return new xo(e,n,t,r,i,s)}static createThisExpression(e){return new go(e)}static createTrueExpression(e){return new mo(e)}static createUnaryPostfixExpression(e,n,t){return new _o(e,n,t)}static createUnaryPrefixExpression(e,n,t){return new bo(e,n,t)}static createCompiledExpression(e,n,t){return new vo(e,n,t)}static createBlockStatement(e,n){return new Ao(e,n)}static createBreakStatement(e,n){return new To(e,n)}static createClassDeclaration(e,n,t,r,i,s,a,o){return new Qi(e,n,t,r,i,s,a,o)}static createContinueStatement(e,n){return new So(e,n)}static createDoStatement(e,n,t){return new Co(e,n,t)}static createEmptyStatement(e){return new wo(e)}static createEnumDeclaration(e,n,t,r,i){return new Io(e,n,t,r,i)}static createEnumValueDeclaration(e,n,t,r){return new ko(e,n,t,r)}static createExportStatement(e,n,t,r){return new No(e,n,t,r)}static createExportDefaultStatement(e,n){return new Lo(e,n)}static createExportImportStatement(e,n,t){return new Bo(e,n,t)}static createExportMember(e,n,t){return n||(n=e),new zo(e,n,t)}static createExpressionStatement(e){return new Do(e)}static createIfStatement(e,n,t,r){return new Po(e,n,t,r)}static createImportStatement(e,n,t){return new bi(e,null,n,t)}static createWildcardImportStatement(e,n,t){return new bi(null,e,n,t)}static createImportDeclaration(e,n,t){return n||(n=e),new Vo(n,e,t)}static createInterfaceDeclaration(e,n,t,r,i,s,a,o){return new Go(e,n,t,r,i,s,a,o)}static createFieldDeclaration(e,n,t,r,i,s){return new Oo(e,n,t,r,i,-1,s)}static createForStatement(e,n,t,r,i){return new Ro(e,n,t,r,i)}static createForOfStatement(e,n,t,r){return new Mo(e,n,t,r)}static createFunctionDeclaration(e,n,t,r,i,s,a,o){return new Or(e,n,t,r,i,s,a,o)}static createIndexSignature(e,n,t,r){return new Fo(e,n,t,r)}static createMethodDeclaration(e,n,t,r,i,s,a){return new qo(e,n,t,r,i,s,a)}static createNamespaceDeclaration(e,n,t,r,i){return new jo(e,n,t,r,i)}static createReturnStatement(e,n){return new Wo(e,n)}static createSwitchStatement(e,n,t){return new Xo(e,n,t)}static createSwitchCase(e,n,t){return new Ho(e,n,t)}static createThrowStatement(e,n){return new Ko(e,n)}static createTryStatement(e,n,t,r,i){return new $o(e,n,t,r,i)}static createTypeDeclaration(e,n,t,r,i,s){return new Zo(e,n,t,r,i,s)}static createModuleDeclaration(e,n,t){return new Yo(e,n,t)}static createVariableStatement(e,n,t){return new Qo(e,n,t)}static createVariableDeclaration(e,n,t,r,i,s){return new Jo(e,n,t,r,i,s)}static createVoidStatement(e,n){return new el(e,n)}static createWhileStatement(e,n,t){return new nl(e,n,t)}isLiteralKind(e){return this.kind==16&&changetype(this).literalKind==e}get isNumericLiteral(){if(this.kind==16)switch(changetype(this).literalKind){case Gn.Float:case Gn.Integer:return!0}return!1}get compilesToConst(){switch(this.kind){case 16:{switch(changetype(this).literalKind){case Gn.Float:case Gn.Integer:case Gn.String:return!0}break}case 18:case 25:case 13:return!0}return!1}isAccessOn(e){let n=changetype(this);return n.kind==9&&(n=n.expression),n.kind==21&&n.expression.kind==e}get isAccessOnThis(){return this.isAccessOn(24)}get isAccessOnSuper(){return this.isAccessOn(23)}get isEmpty(){return this.kind==34}},Yi=class extends F{constructor(e,n,t){super(e,t),this.isNullable=n}hasGenericComponent(e){if(this.kind==1){let n=changetype(this);if(!n.name.next){let t=n.typeArguments;if(t&&t.length>0){for(let r=0,i=t.length;r<i;++r)if(t[r].hasGenericComponent(e))return!0}else{let r=n.name.identifier.text;for(let i=0,s=e.length;i<s;++i)if(e[i].name.text==r)return!0}}}else if(this.kind==2){let n=changetype(this),t=n.parameters;for(let i=0,s=t.length;i<s;++i)if(t[i].type.hasGenericComponent(e))return!0;if(n.returnType.hasGenericComponent(e))return!0;let r=n.explicitThisType;if(r&&r.hasGenericComponent(e))return!0}else assert(!1);return!1}},Ra=class extends F{constructor(e,n,t){super(3,t),this.identifier=e,this.next=n}},_i=class extends Yi{constructor(e,n,t,r){super(1,t,r),this.name=e,this.typeArguments=n}get hasTypeArguments(){let e=this.typeArguments;return e!=null&&e.length>0}},Ma=class extends Yi{constructor(e,n,t,r,i){super(2,r,i),this.parameters=e,this.returnType=n,this.explicitThisType=t}},Ua=class extends F{constructor(e,n,t,r){super(4,r),this.name=e,this.extendsType=n,this.defaultType=t}},Pa=(e=>(e[e.Default=0]="Default",e[e.Optional=1]="Optional",e[e.Rest=2]="Rest",e))(Pa||{}),Va=class extends F{constructor(e,n,t,r,i){super(5,i),this.parameterKind=e,this.name=n,this.type=t,this.initializer=r,this.implicitFieldDeclaration=null,this.flags=0}is(e){return(this.flags&e)==e}isAny(e){return(this.flags&e)!=0}set(e){this.flags|=e}},tr=(e=>(e[e.Custom=0]="Custom",e[e.Global=1]="Global",e[e.Operator=2]="Operator",e[e.OperatorBinary=3]="OperatorBinary",e[e.OperatorPrefix=4]="OperatorPrefix",e[e.OperatorPostfix=5]="OperatorPostfix",e[e.Unmanaged=6]="Unmanaged",e[e.Final=7]="Final",e[e.Inline=8]="Inline",e[e.External=9]="External",e[e.ExternalJs=10]="ExternalJs",e[e.Builtin=11]="Builtin",e[e.Lazy=12]="Lazy",e[e.Unsafe=13]="Unsafe",e))(tr||{});(e=>{function n(t){if(t.kind==6){let r=t.text;switch(assert(r.length),r.charCodeAt(0)){case 98:{if(r=="builtin")return 11;break}case 101:{if(r=="external")return 9;break}case 102:{if(r=="final")return 7;break}case 103:{if(r=="global")return 1;break}case 105:{if(r=="inline")return 8;break}case 108:{if(r=="lazy")return 12;break}case 111:{if(r=="operator")return 2;break}case 117:{if(r=="unmanaged")return 6;if(r=="unsafe")return 13;break}}}else if(t.kind==21){let r=t,i=r.expression;if(i.kind==6){let s=i.text;assert(s.length);let a=r.property.text;if(assert(a.length),s=="operator")switch(a.charCodeAt(0)){case 98:{if(a=="binary")return 3;break}case 112:{if(a=="prefix")return 4;if(a=="postfix")return 5;break}}else if(s=="external")switch(a.charCodeAt(0)){case 106:{if(a=="js")return 10;break}}}}return 0}e.fromNode=n})(tr||={});var Ga=class extends F{constructor(e,n,t,r){super(62,r),this.decoratorKind=e,this.name=n,this.args=t}},qa=(e=>(e[e.Line=0]="Line",e[e.Triple=1]="Triple",e[e.Block=2]="Block",e))(qa||{}),ja=class extends F{constructor(e,n,t){super(66,t),this.commentKind=e,this.text=n}},ye=class extends F{},hn=class extends ye{constructor(e,n,t){super(6,t),this.text=e,this.isQuoted=n}},Gn=(e=>(e[e.Float=0]="Float",e[e.Integer=1]="Integer",e[e.String=2]="String",e[e.Template=3]="Template",e[e.RegExp=4]="RegExp",e[e.Array=5]="Array",e[e.Object=6]="Object",e))(Gn||{}),kn=class extends ye{constructor(e,n){super(16,n),this.literalKind=e}},Wa=class extends kn{constructor(e,n){super(5,n),this.elementExpressions=e}},Ha=(e=>(e[e.Prefix=0]="Prefix",e[e.As=1]="As",e[e.NonNull=2]="NonNull",e[e.Const=3]="Const",e))(Ha||{}),Xa=class extends ye{constructor(e,n,t,r){super(7,r),this.assertionKind=e,this.expression=n,this.toType=t}},Ka=class extends ye{constructor(e,n,t,r){super(8,r),this.operator=e,this.left=n,this.right=t}},$a=class extends ye{constructor(e,n,t,r){super(9,r),this.expression=e,this.typeArguments=n,this.args=t}get typeArgumentsRange(){let e=this.typeArguments,n;return e&&(n=e.length)?fe.join(e[0].range,e[n-1].range):this.expression.range}get argumentsRange(){let e=this.args,n=e.length;return n?fe.join(e[0].range,e[n-1].range):this.expression.range}},Ya=class extends ye{constructor(e){super(10,e.range),this.declaration=e}},Za=class extends ye{constructor(e,n){super(11,n),this.expressions=e}},Ja=class extends hn{constructor(e){super("constructor",!1,e),this.kind=26}},Qa=class extends ye{constructor(e,n,t){super(12,t),this.expression=e,this.elementExpression=n}},eo=class extends kn{constructor(e,n){super(0,n),this.value=e}},no=class extends ye{constructor(e){super(14,e.range),this.declaration=e}},to=class extends ye{constructor(e,n,t){super(15,t),this.expression=e,this.isType=n}},ro=class extends kn{constructor(e,n){super(1,n),this.value=e}},io=class extends ye{constructor(e,n,t,r){super(17,r),this.typeName=e,this.typeArguments=n,this.args=t}get typeArgumentsRange(){let e=this.typeArguments,n;return e&&(n=e.length)>0?fe.join(e[0].range,e[n-1].range):this.typeName.range}get argumentsRange(){let e=this.args,n=e.length;return n?fe.join(e[0].range,e[n-1].range):this.typeName.range}},so=class extends hn{constructor(e){super("null",!1,e),this.kind=18}},ao=class extends kn{constructor(e,n,t){super(6,t),this.names=e,this.values=n}},oo=class extends ye{constructor(e){super(19,e)}},lo=class extends ye{constructor(e,n){super(20,n),this.expression=e}},uo=class extends ye{constructor(e,n,t){super(21,t),this.expression=e,this.property=n}},co=class extends kn{constructor(e,n,t){super(4,t),this.pattern=e,this.patternFlags=n}},fo=class extends ye{constructor(e,n,t,r){super(22,r),this.condition=e,this.ifThen=n,this.ifElse=t}},po=class extends kn{constructor(e,n){super(2,n),this.value=e}},ho=class extends hn{constructor(e){super("super",!1,e),this.kind=23}},xo=class extends kn{constructor(e,n,t,r,i,s){super(3,s),this.tag=e,this.parts=n,this.rawParts=t,this.expressions=r,this.exprLengths=i}},go=class extends hn{constructor(e){super("this",!1,e),this.kind=24}},mo=class extends hn{constructor(e){super("true",!1,e),this.kind=25}},yo=class extends hn{constructor(e){super("false",!1,e),this.kind=13}},Zi=class extends ye{constructor(e,n,t,r){super(e,r),this.operator=n,this.operand=t}},_o=class extends Zi{constructor(e,n,t){super(27,e,n,t)}},bo=class extends Zi{constructor(e,n,t){super(28,e,n,t)}},vo=class extends ye{constructor(e,n,t){super(29,t),this.expr=e,this.type=n}},ue=class extends F{},Eo=(e=>(e[e.User=0]="User",e[e.UserEntry=1]="UserEntry",e[e.Library=2]="Library",e[e.LibraryEntry=3]="LibraryEntry",e))(Eo||{}),Ji=class extends F{constructor(e,n,t){super(0,new fe(0,t.length)),this.sourceKind=e,this.normalizedPath=n,this.text=t,this.statements=new Array,this.debugInfoIndex=-1,this.exportPaths=null,this.lineCache=null,this.lineColumn=1;let r=Rr(n);this.internalPath=r;let i=r.lastIndexOf(Xn);this.simplePath=i>=0?r.substring(i+1):r,this.range.source=this}get isNative(){return this.internalPath==Vi}get isLibrary(){let e=this.sourceKind;return e==2||e==3}lineAt(e){assert(e>=0&&e<2147483647);let n=this.lineCache;if(!n){this.lineCache=n=[0];let i=this.text,s=0,a=i.length;for(;s<a;)i.charCodeAt(s++)==10&&n.push(s);n.push(2147483647)}let t=0,r=n.length-1;for(;t<r;){let i=t+(r-t>>1),s=unchecked(n[i]);if(e<s)r=i;else{if(e<unchecked(n[i+1]))return this.lineColumn=e-s+1,i+1;t=i+1}}return assert(0)}columnAt(){return this.lineColumn}},rn=class extends ue{constructor(e,n,t,r,i){super(e,i),this.name=n,this.decorators=t,this.flags=r,this.overriddenModuleName=null}is(e){return(this.flags&e)==e}isAny(e){return(this.flags&e)!=0}set(e){this.flags|=e}},Fo=class extends F{constructor(e,n,t,r){super(65,r),this.keyType=e,this.valueType=n,this.flags=t}},Dr=class extends rn{constructor(e,n,t,r,i,s,a){super(e,n,t,r,a),this.type=i,this.initializer=s}},Ao=class extends ue{constructor(e,n){super(30,n),this.statements=e}},To=class extends ue{constructor(e,n){super(31,n),this.label=e}},Qi=class extends rn{constructor(e,n,t,r,i,s,a,o){super(51,e,n,t,o),this.typeParameters=r,this.extendsType=i,this.implementsTypes=s,this.members=a,this.indexSignature=null}get isGeneric(){let e=this.typeParameters;return e!=null&&e.length>0}},So=class extends ue{constructor(e,n){super(32,n),this.label=e}},Co=class extends ue{constructor(e,n,t){super(33,t),this.body=e,this.condition=n}},wo=class extends ue{constructor(e){super(34,e)}},Io=class extends rn{constructor(e,n,t,r,i){super(52,e,n,t,i),this.values=r}},ko=class extends Dr{constructor(e,n,t,r){super(53,e,null,n,null,t,r)}},Bo=class extends ue{constructor(e,n,t){super(37,t),this.name=e,this.externalName=n}},zo=class extends F{constructor(e,n,t){super(63,t),this.localName=e,this.exportedName=n}},No=class extends ue{constructor(e,n,t,r){if(super(35,r),this.members=e,this.path=n,this.isDeclare=t,n){let i=Lr(n.value);n.value.startsWith(".")?i=Ba(i,r.source.internalPath):i.startsWith(Cn)||(i=Cn+i),this.internalPath=i}else this.internalPath=null}},Lo=class extends ue{constructor(e,n){super(36,n),this.declaration=e}},Do=class extends ue{constructor(e){super(38,e.range),this.expression=e}},Oo=class extends Dr{constructor(e,n,t,r,i,s,a){super(54,e,n,t,r,i,a),this.parameterIndex=s}},Ro=class extends ue{constructor(e,n,t,r,i){super(39,i),this.initializer=e,this.condition=n,this.incrementor=t,this.body=r}},Mo=class extends ue{constructor(e,n,t,r){super(40,r),this.variable=e,this.iterable=n,this.body=t}},Uo=(e=>(e[e.None=0]="None",e[e.Parenthesized=1]="Parenthesized",e[e.Single=2]="Single",e))(Uo||{}),Or=class extends rn{constructor(e,n,t,r,i,s,a,o){super(55,e,n,t,o),this.typeParameters=r,this.signature=i,this.body=s,this.arrowKind=a}get isGeneric(){let e=this.typeParameters;return e!=null&&e.length>0}clone(){return new Or(this.name,this.decorators,this.flags,this.typeParameters,this.signature,this.body,this.arrowKind,this.range)}},Po=class extends ue{constructor(e,n,t,r){super(41,r),this.condition=e,this.ifTrue=n,this.ifFalse=t}},Vo=class extends rn{constructor(e,n,t){super(56,e,null,0,t),this.foreignName=n}},bi=class extends ue{constructor(e,n,t,r){super(42,r),this.declarations=e,this.namespaceName=n,this.path=t;let i=Lr(t.value);t.value.startsWith(".")?i=Ba(i,r.source.internalPath):i.startsWith(Cn)||(i=Cn+i),this.internalPath=Rr(i)}},Go=class extends Qi{constructor(e,n,t,r,i,s,a,o){super(e,n,t,r,i,s,a,o),this.kind=57}},qo=class extends Or{constructor(e,n,t,r,i,s,a){super(e,n,t,r,i,s,0,a),this.kind=58}},jo=class extends rn{constructor(e,n,t,r,i){super(59,e,n,t,i),this.members=r}},Wo=class extends ue{constructor(e,n){super(43,n),this.value=e}},Ho=class extends F{constructor(e,n,t){super(64,t),this.label=e,this.statements=n}get isDefault(){return this.label==null}},Xo=class extends ue{constructor(e,n,t){super(44,t),this.condition=e,this.cases=n}},Ko=class extends ue{constructor(e,n){super(45,n),this.value=e}},$o=class extends ue{constructor(e,n,t,r,i){super(46,i),this.bodyStatements=e,this.catchVariable=n,this.catchStatements=t,this.finallyStatements=r}},Yo=class extends ue{constructor(e,n,t){super(50,t),this.moduleName=e,this.flags=n}},Zo=class extends rn{constructor(e,n,t,r,i,s){super(60,e,n,t,s),this.typeParameters=r,this.type=i}},Jo=class extends Dr{constructor(e,n,t,r,i,s){super(61,e,n,t,r,i,s)}},Qo=class extends ue{constructor(e,n,t){super(47,t),this.decorators=e,this.declarations=n}},el=class extends ue{constructor(e,n){super(48,n),this.expression=e}},nl=class extends ue{constructor(e,n,t){super(49,t),this.condition=e,this.body=n}};function qn(e,n){if(n)for(let t=0,r=n.length;t<r;++t){let i=n[t];if(i.decoratorKind==e)return i}return null}function Rr(e){return e.endsWith("/")?e+="index":e.endsWith(".ts")&&(e=e.substring(0,e.length-3)),e}function Ve(e){if(e.kind==1){let n=e.name;return!(n.next||n.identifier.text.length>0)}return!1}var tl=(e=>(e[e.Abstract=0]="Abstract",e[e.As=1]="As",e[e.Async=2]="Async",e[e.Await=3]="Await",e[e.Break=4]="Break",e[e.Case=5]="Case",e[e.Catch=6]="Catch",e[e.Class=7]="Class",e[e.Const=8]="Const",e[e.Continue=9]="Continue",e[e.Constructor=10]="Constructor",e[e.Debugger=11]="Debugger",e[e.Declare=12]="Declare",e[e.Default=13]="Default",e[e.Delete=14]="Delete",e[e.Do=15]="Do",e[e.Else=16]="Else",e[e.Enum=17]="Enum",e[e.Export=18]="Export",e[e.Extends=19]="Extends",e[e.False=20]="False",e[e.Finally=21]="Finally",e[e.For=22]="For",e[e.From=23]="From",e[e.Function=24]="Function",e[e.Get=25]="Get",e[e.If=26]="If",e[e.Implements=27]="Implements",e[e.Import=28]="Import",e[e.In=29]="In",e[e.InstanceOf=30]="InstanceOf",e[e.Interface=31]="Interface",e[e.Is=32]="Is",e[e.KeyOf=33]="KeyOf",e[e.Let=34]="Let",e[e.Module=35]="Module",e[e.Namespace=36]="Namespace",e[e.New=37]="New",e[e.Null=38]="Null",e[e.Of=39]="Of",e[e.Override=40]="Override",e[e.Package=41]="Package",e[e.Private=42]="Private",e[e.Protected=43]="Protected",e[e.Public=44]="Public",e[e.Readonly=45]="Readonly",e[e.Return=46]="Return",e[e.Set=47]="Set",e[e.Static=48]="Static",e[e.Super=49]="Super",e[e.Switch=50]="Switch",e[e.This=51]="This",e[e.Throw=52]="Throw",e[e.True=53]="True",e[e.Try=54]="Try",e[e.Type=55]="Type",e[e.TypeOf=56]="TypeOf",e[e.Var=57]="Var",e[e.Void=58]="Void",e[e.While=59]="While",e[e.With=60]="With",e[e.Yield=61]="Yield",e[e.OpenBrace=62]="OpenBrace",e[e.CloseBrace=63]="CloseBrace",e[e.OpenParen=64]="OpenParen",e[e.CloseParen=65]="CloseParen",e[e.OpenBracket=66]="OpenBracket",e[e.CloseBracket=67]="CloseBracket",e[e.Dot=68]="Dot",e[e.Dot_Dot_Dot=69]="Dot_Dot_Dot",e[e.Semicolon=70]="Semicolon",e[e.Comma=71]="Comma",e[e.LessThan=72]="LessThan",e[e.GreaterThan=73]="GreaterThan",e[e.LessThan_Equals=74]="LessThan_Equals",e[e.GreaterThan_Equals=75]="GreaterThan_Equals",e[e.Equals_Equals=76]="Equals_Equals",e[e.Exclamation_Equals=77]="Exclamation_Equals",e[e.Equals_Equals_Equals=78]="Equals_Equals_Equals",e[e.Exclamation_Equals_Equals=79]="Exclamation_Equals_Equals",e[e.Equals_GreaterThan=80]="Equals_GreaterThan",e[e.Plus=81]="Plus",e[e.Minus=82]="Minus",e[e.Asterisk_Asterisk=83]="Asterisk_Asterisk",e[e.Asterisk=84]="Asterisk",e[e.Slash=85]="Slash",e[e.Percent=86]="Percent",e[e.Plus_Plus=87]="Plus_Plus",e[e.Minus_Minus=88]="Minus_Minus",e[e.LessThan_LessThan=89]="LessThan_LessThan",e[e.GreaterThan_GreaterThan=90]="GreaterThan_GreaterThan",e[e.GreaterThan_GreaterThan_GreaterThan=91]="GreaterThan_GreaterThan_GreaterThan",e[e.Ampersand=92]="Ampersand",e[e.Bar=93]="Bar",e[e.Caret=94]="Caret",e[e.Exclamation=95]="Exclamation",e[e.Tilde=96]="Tilde",e[e.Ampersand_Ampersand=97]="Ampersand_Ampersand",e[e.Bar_Bar=98]="Bar_Bar",e[e.Question=99]="Question",e[e.Colon=100]="Colon",e[e.Equals=101]="Equals",e[e.Plus_Equals=102]="Plus_Equals",e[e.Minus_Equals=103]="Minus_Equals",e[e.Asterisk_Equals=104]="Asterisk_Equals",e[e.Asterisk_Asterisk_Equals=105]="Asterisk_Asterisk_Equals",e[e.Slash_Equals=106]="Slash_Equals",e[e.Percent_Equals=107]="Percent_Equals",e[e.LessThan_LessThan_Equals=108]="LessThan_LessThan_Equals",e[e.GreaterThan_GreaterThan_Equals=109]="GreaterThan_GreaterThan_Equals",e[e.GreaterThan_GreaterThan_GreaterThan_Equals=110]="GreaterThan_GreaterThan_GreaterThan_Equals",e[e.Ampersand_Equals=111]="Ampersand_Equals",e[e.Bar_Equals=112]="Bar_Equals",e[e.Caret_Equals=113]="Caret_Equals",e[e.At=114]="At",e[e.Identifier=115]="Identifier",e[e.StringLiteral=116]="StringLiteral",e[e.IntegerLiteral=117]="IntegerLiteral",e[e.FloatLiteral=118]="FloatLiteral",e[e.TemplateLiteral=119]="TemplateLiteral",e[e.Invalid=120]="Invalid",e[e.EndOfFile=121]="EndOfFile",e))(tl||{}),rl=(e=>(e[e.Default=0]="Default",e[e.Prefer=1]="Prefer",e[e.Always=2]="Always",e))(rl||{});function il(e){let n=e.length;switch(assert(n),e.charCodeAt(0)){case 97:{if(n==5){if(e=="async")return 2;if(e=="await")return 3;break}if(e=="as")return 1;if(e=="abstract")return 0;break}case 98:{if(e=="break")return 4;break}case 99:{if(n==5){if(e=="const")return 8;if(e=="class")return 7;if(e=="catch")return 6;break}if(e=="case")return 5;if(e=="continue")return 9;if(e=="constructor")return 10;break}case 100:{if(n==7){if(e=="default")return 13;if(e=="declare")return 12;break}if(e=="do")return 15;if(e=="delete")return 14;if(e=="debugger")return 11;break}case 101:{if(n==4){if(e=="else")return 16;if(e=="enum")return 17;break}if(e=="export")return 18;if(e=="extends")return 19;break}case 102:{if(n<=5){if(e=="false")return 20;if(e=="for")return 22;if(e=="from")return 23;break}if(e=="function")return 24;if(e=="finally")return 21;break}case 103:{if(e=="get")return 25;break}case 105:{if(n==2){if(e=="if")return 26;if(e=="in")return 29;if(e=="is")return 32;break}switch(e.charCodeAt(3)){case 108:{if(e=="implements")return 27;break}case 111:{if(e=="import")return 28;break}case 116:{if(e=="instanceof")return 30;break}case 101:{if(e=="interface")return 31;break}}break}case 107:{if(e=="keyof")return 33;break}case 108:{if(e=="let")return 34;break}case 109:{if(e=="module")return 35;break}case 110:{if(e=="new")return 37;if(e=="null")return 38;if(e=="namespace")return 36;break}case 111:{if(e=="of")return 39;if(e=="override")return 40;break}case 112:{if(n==7){if(e=="private")return 42;if(e=="package")return 41;break}if(e=="public")return 44;if(e=="protected")return 43;break}case 114:{if(e=="return")return 46;if(e=="readonly")return 45;break}case 115:{if(n==6){if(e=="switch")return 50;if(e=="static")return 48;break}if(e=="set")return 47;if(e=="super")return 49;break}case 116:{if(n==4){if(e=="true")return 53;if(e=="this")return 51;if(e=="type")return 55;break}if(e=="try")return 54;if(e=="throw")return 52;if(e=="typeof")return 56;break}case 118:{if(e=="var")return 57;if(e=="void")return 58;break}case 119:{if(e=="while")return 59;if(e=="with")return 60;break}case 121:{if(e=="yield")return 61;break}}return 120}function sl(e){switch(e){case 0:case 1:case 10:case 12:case 14:case 23:case 22:case 25:case 30:case 32:case 33:case 35:case 36:case 38:case 45:case 47:case 55:case 58:return!0;default:return!1}}function al(e){switch(assert(e.length),e.charCodeAt(0)){case 100:return e=="delete";case 102:return e=="for";case 105:return e=="instanceof";case 110:return e=="null";case 118:return e=="void"}return!1}function Ue(e){switch(e){case 14:return"delete";case 29:return"in";case 30:return"instanceof";case 37:return"new";case 56:return"typeof";case 58:return"void";case 61:return"yield";case 69:return"...";case 71:return",";case 72:return"<";case 73:return">";case 74:return"<=";case 75:return">=";case 76:return"==";case 77:return"!=";case 78:return"===";case 79:return"!==";case 81:return"+";case 82:return"-";case 83:return"**";case 84:return"*";case 85:return"/";case 86:return"%";case 87:return"++";case 88:return"--";case 89:return"<<";case 90:return">>";case 91:return">>>";case 92:return"&";case 93:return"|";case 94:return"^";case 95:return"!";case 96:return"~";case 97:return"&&";case 98:return"||";case 101:return"=";case 102:return"+=";case 103:return"-=";case 104:return"*=";case 105:return"**=";case 106:return"/=";case 107:return"%=";case 108:return"<<=";case 109:return">>=";case 110:return">>>=";case 111:return"&=";case 112:return"|=";case 113:return"^=";default:return assert(!1),""}}var ol=class extends mt{constructor(e,n=null){super(n),this.end=0,this.pos=0,this.token=-1,this.tokenPos=0,this.nextToken=-1,this.nextTokenPos=0,this.nextTokenOnNewLine=!1,this.onComment=null,this.readingTemplateString=!1,this.readStringStart=0,this.readStringEnd=0,n||(n=[]),this.diagnostics=n,this.source=e;let t=e.text,r=t.length,i=0;if(i<r&&t.charCodeAt(i)==65279&&++i,i+1<r&&t.charCodeAt(i)==35&&t.charCodeAt(i+1)==33)for(i+=2;i<r&&t.charCodeAt(i)!=10;)++i;this.pos=i,this.end=r}next(e=0){this.nextToken=-1;let n;do n=this.unsafeNext(e);while(n==120);return this.token=n,n}unsafeNext(e=0,n=i32.MAX_VALUE){let t=this.source.text,r=this.end,i=this.pos;for(;i<r;){this.tokenPos=i;let s=t.charCodeAt(i);switch(s){case 13:if(!(++i<r&&t.charCodeAt(i)==10))break;case 10:case 9:case 11:case 12:case 32:{++i;break}case 33:return++i,n>1&&i<r&&t.charCodeAt(i)==61?(++i,n>2&&i<r&&t.charCodeAt(i)==61?(this.pos=i+1,79):(this.pos=i,77)):(this.pos=i,95);case 34:case 39:return this.pos=i,116;case 96:return this.pos=i,119;case 37:return++i,n>1&&i<r&&t.charCodeAt(i)==61?(this.pos=i+1,107):(this.pos=i,86);case 38:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==38)return this.pos=i+1,97;if(a==61)return this.pos=i+1,111}return this.pos=i,92}case 40:return this.pos=i+1,64;case 41:return this.pos=i+1,65;case 42:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==61)return this.pos=i+1,104;if(a==42)return++i,n>2&&i<r&&t.charCodeAt(i)==61?(this.pos=i+1,105):(this.pos=i,83)}return this.pos=i,84}case 43:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==43)return this.pos=i+1,87;if(a==61)return this.pos=i+1,102}return this.pos=i,81}case 44:return this.pos=i+1,71;case 45:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==45)return this.pos=i+1,88;if(a==61)return this.pos=i+1,103}return this.pos=i,82}case 46:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(cn(a))return this.pos=i-1,118;if(n>2&&i+1<r&&a==46&&t.charCodeAt(i+1)==46)return this.pos=i+2,69}return this.pos=i,68}case 47:{let a=i;if(++i,n>1&&i<r){let o=t.charCodeAt(i);if(o==47){let u=0;for(i+1<r&&t.charCodeAt(i+1)==47&&(++i,u=1);++i<r;)if(t.charCodeAt(i)==10){++i;break}this.onComment&&this.onComment(u,t.substring(a,i),this.range(a,i));break}if(o==42){let u=!1;for(;++i<r;)if(s=t.charCodeAt(i),s==42&&i+1<r&&t.charCodeAt(i+1)==47){i+=2,u=!0;break}u?this.onComment&&this.onComment(2,t.substring(a,i),this.range(a,i)):this.error(1005,this.range(i),"*/");break}if(o==61)return this.pos=i+1,106}return this.pos=i,85}case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.pos=i,this.testInteger()?117:118;case 58:return this.pos=i+1,100;case 59:return this.pos=i+1,70;case 60:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==60)return++i,n>2&&i<r&&t.charCodeAt(i)==61?(this.pos=i+1,108):(this.pos=i,89);if(a==61)return this.pos=i+1,74}return this.pos=i,72}case 61:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==61)return++i,n>2&&i<r&&t.charCodeAt(i)==61?(this.pos=i+1,78):(this.pos=i,76);if(a==62)return this.pos=i+1,80}return this.pos=i,101}case 62:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==62){if(++i,n>2&&i<r){if(a=t.charCodeAt(i),a==62)return++i,n>3&&i<r&&t.charCodeAt(i)==61?(this.pos=i+1,110):(this.pos=i,91);if(a==61)return this.pos=i+1,109}return this.pos=i,90}if(a==61)return this.pos=i+1,75}return this.pos=i,73}case 63:return this.pos=i+1,99;case 91:return this.pos=i+1,66;case 93:return this.pos=i+1,67;case 94:return++i,n>1&&i<r&&t.charCodeAt(i)==61?(this.pos=i+1,113):(this.pos=i,94);case 123:return this.pos=i+1,62;case 124:{if(++i,n>1&&i<r){let a=t.charCodeAt(i);if(a==124)return this.pos=i+1,98;if(a==61)return this.pos=i+1,112}return this.pos=i,93}case 125:return this.pos=i+1,63;case 126:return this.pos=i+1,96;case 64:return this.pos=i+1,114;default:{if(Hi(s)&&i+1<r&&(s=Ia(s,t.charCodeAt(i+1))),_r(s)){let o=i;for(;(i+=Wt(s))<r&&br(s=t.codePointAt(i)););if(e!=2){let u=il(t.substring(o,i));if(u!=120&&!(e==1&&sl(u)))return this.pos=i,u}return this.pos=o,115}else if(Ca(s)){++i;break}let a=i;return i+=Wt(s),this.error(1127,this.range(a,i)),this.pos=i,120}}}return this.pos=i,121}peek(e=!1,n=0,t=i32.MAX_VALUE){let r=this.source.text;if(this.nextToken<0){let i=this.pos,s=this.token,a=this.tokenPos,o;do o=this.unsafeNext(n,t);while(o==120);if(this.nextToken=o,this.nextTokenPos=this.tokenPos,e){this.nextTokenOnNewLine=!1;for(let u=i,c=this.nextTokenPos;u<c;++u)if(dt(r.charCodeAt(u))){this.nextTokenOnNewLine=!0;break}}this.pos=i,this.token=s,this.tokenPos=a}return this.nextToken}skipIdentifier(e=1){return this.skip(115,e)}skip(e,n=0){let t=this.pos,r=this.token,i=this.tokenPos,s=i32.MAX_VALUE;e==73&&(s=1);let a;do a=this.unsafeNext(n,s);while(a==120);return a==e?(this.token=e,this.nextToken=-1,!0):(this.pos=t,this.token=r,this.tokenPos=i,!1)}mark(){let e=Ns;return e?(Ns=null,e.pos=this.pos,e.token=this.token,e.tokenPos=this.tokenPos):e=new ll(this.pos,this.token,this.tokenPos),e}discard(e){Ns=e}reset(e){this.pos=e.pos,this.token=e.token,this.tokenPos=e.tokenPos,this.nextToken=-1}range(e=-1,n=-1){e<0?(e=this.tokenPos,n=this.pos):n<0&&(n=e);let t=new fe(e,n);return t.source=this.source,t}readIdentifier(){let e=this.source.text,n=this.end,t=this.pos,r=t,i=e.codePointAt(t);for(assert(_r(i));(t+=Wt(i))<n&&br(i=e.codePointAt(t)););return this.pos=t,e.substring(r,t)}readString(e=0,n=!1){let t=this.source.text,r=this.end,i=this.pos;e||(e=t.charCodeAt(i++));let s=i;this.readStringStart=s;let a="";for(;;){if(i>=r){a+=t.substring(s,i),this.error(1002,this.range(s-1,r)),this.readStringEnd=r;break}let o=t.charCodeAt(i);if(o==e){this.readStringEnd=i,a+=t.substring(s,i++);break}if(o==92){a+=t.substring(s,i),this.pos=i,a+=this.readEscapeSequence(n),i=this.pos,s=i;continue}if(e==96){if(o==36&&i+1<r&&t.charCodeAt(i+1)==123)return a+=t.substring(s,i),this.readStringEnd=i,this.pos=i+2,this.readingTemplateString=!0,a}else if(dt(o)){a+=t.substring(s,i),this.error(1002,this.range(s-1,i)),this.readStringEnd=i;break}++i}return this.pos=i,this.readingTemplateString=!1,a}readEscapeSequence(e=!1){let n=this.pos,t=this.end;if(++this.pos>=t)return this.error(1126,this.range(t)),"";let r=this.source.text,i=r.charCodeAt(this.pos++);switch(i){case 48:return e&&this.pos<t&&cn(r.charCodeAt(this.pos))?(++this.pos,r.substring(n,this.pos)):"\0";case 98:return"\b";case 116:return"	";case 110:return`
`;case 118:return"\v";case 102:return"\f";case 114:return"\r";case 39:return"'";case 34:return'"';case 117:return this.pos<t&&r.charCodeAt(this.pos)==123?(++this.pos,this.readExtendedUnicodeEscape(e?n:-1)):this.readUnicodeEscape(e?n:-1);case 120:return this.readHexadecimalEscape(2,e?n:-1);case 13:this.pos<t&&r.charCodeAt(this.pos)==10&&++this.pos;case 10:case 8232:case 8233:return"";default:return String.fromCodePoint(i)}}readRegexpPattern(){let e=this.source.text,n=this.pos,t=this.end,r=!1;for(;;){if(this.pos>=t){this.error(1161,this.range(n,t));break}if(e.charCodeAt(this.pos)==92){++this.pos,r=!0;continue}let i=e.charCodeAt(this.pos);if(!r&&i==47)break;if(dt(i)){this.error(1161,this.range(n,this.pos));break}++this.pos,r=!1}return e.substring(n,this.pos)}readRegexpFlags(){let e=this.source.text,n=this.pos,t=this.end,r=0;for(;this.pos<t;){let i=e.charCodeAt(this.pos);if(!br(i))break;switch(++this.pos,i){case 103:{r|=r&1?-1:1;break}case 105:{r|=r&2?-1:2;break}case 109:{r|=r&4?-1:4;break}default:{r=-1;break}}}return r==-1&&this.error(209,this.range(n,this.pos)),e.substring(n,this.pos)}testInteger(){let e=this.source.text,n=this.pos,t=this.end;if(n+1<t&&e.charCodeAt(n)==48)switch(e.charCodeAt(n+2)|32){case 120:case 98:case 111:return!0}for(;n<t;){let r=e.charCodeAt(n);if(r==46||(r|32)==101)return!1;if(r!=95&&(r<48||r>57))break;n++}return!0}readInteger(){let e=this.source.text,n=this.pos;if(n+2<this.end&&e.charCodeAt(n)==48){switch(e.charCodeAt(n+1)|32){case 120:return this.pos=n+2,this.readHexInteger();case 98:return this.pos=n+2,this.readBinaryInteger();case 111:return this.pos=n+2,this.readOctalInteger()}if(qs(e.charCodeAt(n+1))){let t=n;this.pos=n+1;let r=this.readOctalInteger();return this.error(1121,this.range(t,this.pos)),r}}return this.readDecimalInteger()}readHexInteger(){let e=this.source.text,n=this.pos,t=this.end,r=n,i=r,s=i64_zero,a=i64_new(4),o=s,u=!1;for(;n<t;){let c=e.charCodeAt(n);if(cn(c))o=i64_add(i64_shl(s,a),i64_new(c-48));else if(yi(c))o=i64_add(i64_shl(s,a),i64_new((c|32)+(10-97)));else if(c==95)i==n&&this.error(i==r?6188:6189,this.range(n)),i=n+1;else break;i64_gt_u(s,o)&&(u=!0),s=o,++n}return n==r?this.error(1125,this.range(r)):i==n&&this.error(6188,this.range(i-1)),u&&this.error(236,this.range(r-2,n),this.source.text.substring(r-2,n)),this.pos=n,s}readDecimalInteger(){let e=this.source.text,n=this.pos,t=this.end,r=n,i=r,s=i64_zero,a=i64_new(10),o=s,u=!1;for(;n<t;){let c=e.charCodeAt(n);if(cn(c))o=i64_add(i64_mul(s,a),i64_new(c-48));else if(c==95)i==n?this.error(i==r?6188:6189,this.range(n)):n-1==r&&e.charCodeAt(n-1)==48&&this.error(6188,this.range(n)),i=n+1;else break;i64_gt_u(s,o)&&(u=!0),s=o,++n}return n==r?this.error(1124,this.range(r)):i==n?this.error(6188,this.range(i-1)):u&&this.error(236,this.range(r,n),this.source.text.substring(r,n)),this.pos=n,s}readOctalInteger(){let e=this.source.text,n=this.pos,t=this.end,r=n,i=r,s=i64_zero,a=i64_new(3),o=s,u=!1;for(;n<t;){let c=e.charCodeAt(n);if(qs(c))o=i64_add(i64_shl(s,a),i64_new(c-48));else if(c==95)i==n&&this.error(i==r?6188:6189,this.range(n)),i=n+1;else break;i64_gt_u(s,o)&&(u=!0),s=o,++n}return n==r?this.error(1178,this.range(r)):i==n?this.error(6188,this.range(i-1)):u&&this.error(236,this.range(r-2,n),this.source.text.substring(r-2,n)),this.pos=n,s}readBinaryInteger(){let e=this.source.text,n=this.pos,t=this.end,r=n,i=r,s=i64_zero,a=s,o=!1;for(;n<t;){let u=e.charCodeAt(n);if(u==48)a=i64_shl(s,i64_one);else if(u==49)a=i64_or(i64_shl(s,i64_one),i64_one);else if(u==95)i==n&&this.error(i==r?6188:6189,this.range(n)),i=n+1;else break;i64_gt(s,a)&&(o=!0),s=a,++n}return n==r?this.error(1177,this.range(r)):i==n?this.error(6188,this.range(i-1)):o&&this.error(236,this.range(r-2,n),this.source.text.substring(r-2,n)),this.pos=n,s}readFloat(){return this.readDecimalFloat()}readDecimalFloat(){let e=this.source.text,n=this.end,t=this.pos,r=this.readDecimalFloatPartial(!1);if(this.pos<n&&e.charCodeAt(this.pos)==46&&(++this.pos,r+=this.readDecimalFloatPartial()),this.pos<n){let s=e.charCodeAt(this.pos);(s|32)==101&&((++this.pos<n&&(s=e.charCodeAt(this.pos))==45||s==43&&cn(e.charCodeAt(this.pos+1)))&&++this.pos,r+=this.readDecimalFloatPartial())}let i=e.substring(t,this.pos);return r&&(i=i.replaceAll("_","")),parseFloat(i)}readDecimalFloatPartial(e=!0){let n=this.source.text,t=this.pos,r=t,i=this.end,s=r,a=0;for(;t<i;){let o=n.charCodeAt(t);if(o==95)s==t?this.error(s==r?6188:6189,this.range(t)):!e&&t-1==r&&n.charCodeAt(t-1)==48&&this.error(6188,this.range(t)),s=t+1,++a;else if(!cn(o))break;++t}return t!=r&&s==t&&this.error(6188,this.range(s-1)),this.pos=t,a}readHexFloat(){throw new Error("not implemented")}readHexadecimalEscape(e=2,n=-1){let t=0,r=this.source.text,i=this.pos,s=this.end;for(;i<s;){let a=r.charCodeAt(i++);if(cn(a))t=(t<<4)+a-48;else if(yi(a))t=(t<<4)+(a|32)+(10-97);else return~n?(this.pos=--i,r.substring(n,i)):(this.pos=i,this.error(1125,this.range(i-1,i)),"");if(--e==0)break}return e?(this.pos=i,~n?r.substring(n,i):(this.error(1126,this.range(i)),"")):(this.pos=i,String.fromCodePoint(t))}checkForIdentifierStartAfterNumericLiteral(){let e=this.pos;e<this.end&&_r(this.source.text.charCodeAt(e))&&this.error(1351,this.range(e))}readUnicodeEscape(e=-1){return this.readHexadecimalEscape(4,e)}readExtendedUnicodeEscape(e=-1){let n=this.pos,t=this.readHexInteger(),r=i64_low(t),i=!1;assert(!i64_high(t)),r>1114111&&(e==-1&&this.error(1198,this.range(n,this.pos)),i=!0);let s=this.end,a=this.source.text;return this.pos>=s?(e==-1&&this.error(1126,this.range(n,s)),i=!0):a.charCodeAt(this.pos)==125?++this.pos:(e==-1&&this.error(1199,this.range(n,this.pos)),i=!0),i?~e?a.substring(e,this.pos):"":String.fromCodePoint(r)}},ll=class{constructor(e,n,t){this.pos=e,this.token=n,this.tokenPos=t}},Ns=null,A;(e=>(e.None=0,e.Unreachable=1,e.I32=2,e.I64=3,e.F32=4,e.F64=5,e.V128=6,e.Funcref=qh(),e.Externref=jh(),e.Anyref=Wh(),e.Eqref=Hh(),e.I31ref=Xh(),e.Dataref=Kh(),e.Arrayref=$h(),e.Stringref=Yh(),e.StringviewWTF8=Zh(),e.StringviewWTF16=Jh(),e.StringviewIter=Qh(),e.Noneref=ed(),e.Nofuncref=td(),e.Noexternref=nd()))(A||={});var oe;(e=>{e.Extern=0,e.Func=1,e.Any=2,e.Eq=3,e.I31=4,e.Data=5,e.Array=6,e.String=7,e.StringviewWTF8=8,e.StringviewWTF16=9,e.StringviewIter=10,e.None=11,e.Noextern=12,e.Nofunc=13;function n(r){return rd(r)}e.isBottom=n;function t(r){return id(r)}e.getBottom=t})(oe||={});var Ht;(e=>(e.NotPacked=0,e.I8=1,e.I16=2))(Ht||={});var es;(e=>{e.SelfSupertype=0,e.InvalidSupertype=1,e.ForwardSupertypeReference=2,e.ForwardChildReference=3;function n(t){switch(t){case 0:return"SelfSupertype";case 1:return"InvalidSupertype";case 2:return"ForwardSupertypeReference";case 3:return"ForwardChildReference"}return assert(!1),""}e.toString=n})(es||={});var Mr;(e=>(e.Equirecursive=0,e.Nominal=1,e.Isorecursive=2))(Mr||={});var ul=(e=>(e[e.MVP=0]="MVP",e[e.Atomics=1]="Atomics",e[e.MutableGlobals=2]="MutableGlobals",e[e.TruncSat=4]="TruncSat",e[e.SIMD=8]="SIMD",e[e.BulkMemory=16]="BulkMemory",e[e.SignExt=32]="SignExt",e[e.ExceptionHandling=64]="ExceptionHandling",e[e.TailCall=128]="TailCall",e[e.ReferenceTypes=256]="ReferenceTypes",e[e.MultiValue=512]="MultiValue",e[e.GC=1024]="GC",e[e.Memory64=2048]="Memory64",e[e.RelaxedSIMD=8192]="RelaxedSIMD",e[e.ExtendedConst=16384]="ExtendedConst",e[e.Stringref=32768]="Stringref",e[e.MultiMemory=65536]="MultiMemory",e[e.All=126975]="All",e))(ul||{}),cl=(e=>(e[e.Invalid=0]="Invalid",e[e.Block=1]="Block",e[e.If=2]="If",e[e.Loop=3]="Loop",e[e.Break=4]="Break",e[e.Switch=5]="Switch",e[e.Call=6]="Call",e[e.CallIndirect=7]="CallIndirect",e[e.LocalGet=8]="LocalGet",e[e.LocalSet=9]="LocalSet",e[e.GlobalGet=10]="GlobalGet",e[e.GlobalSet=11]="GlobalSet",e[e.Load=12]="Load",e[e.Store=13]="Store",e[e.Const=14]="Const",e[e.Unary=15]="Unary",e[e.Binary=16]="Binary",e[e.Select=17]="Select",e[e.Drop=18]="Drop",e[e.Return=19]="Return",e[e.MemorySize=20]="MemorySize",e[e.MemoryGrow=21]="MemoryGrow",e[e.Nop=22]="Nop",e[e.Unreachable=23]="Unreachable",e[e.AtomicRMW=24]="AtomicRMW",e[e.AtomicCmpxchg=25]="AtomicCmpxchg",e[e.AtomicWait=26]="AtomicWait",e[e.AtomicNotify=27]="AtomicNotify",e[e.AtomicFence=28]="AtomicFence",e[e.SIMDExtract=29]="SIMDExtract",e[e.SIMDReplace=30]="SIMDReplace",e[e.SIMDShuffle=31]="SIMDShuffle",e[e.SIMDTernary=32]="SIMDTernary",e[e.SIMDShift=33]="SIMDShift",e[e.SIMDLoad=34]="SIMDLoad",e[e.SIMDLoadStoreLane=35]="SIMDLoadStoreLane",e[e.MemoryInit=36]="MemoryInit",e[e.DataDrop=37]="DataDrop",e[e.MemoryCopy=38]="MemoryCopy",e[e.MemoryFill=39]="MemoryFill",e[e.Pop=40]="Pop",e[e.RefNull=41]="RefNull",e[e.RefIs=42]="RefIs",e[e.RefFunc=43]="RefFunc",e[e.RefEq=44]="RefEq",e[e.TableGet=45]="TableGet",e[e.TableSet=46]="TableSet",e[e.TableSize=47]="TableSize",e[e.TableGrow=48]="TableGrow",e[e.Try=49]="Try",e[e.Throw=50]="Throw",e[e.Rethrow=51]="Rethrow",e[e.TupleMake=52]="TupleMake",e[e.TupleExtract=53]="TupleExtract",e[e.I31New=54]="I31New",e[e.I31Get=55]="I31Get",e[e.CallRef=56]="CallRef",e[e.RefTest=57]="RefTest",e[e.RefCast=58]="RefCast",e[e.BrOn=59]="BrOn",e[e.StructNew=60]="StructNew",e[e.StructGet=61]="StructGet",e[e.StructSet=62]="StructSet",e[e.ArrayNew=63]="ArrayNew",e[e.ArrayInit=64]="ArrayInit",e[e.ArrayGet=65]="ArrayGet",e[e.ArraySet=66]="ArraySet",e[e.ArrayLen=67]="ArrayLen",e[e.ArrayCopy=68]="ArrayCopy",e[e.RefAs=69]="RefAs",e[e.StringNew=70]="StringNew",e[e.StringConst=71]="StringConst",e[e.StringMeasure=72]="StringMeasure",e[e.StringEncode=73]="StringEncode",e[e.StringConcat=74]="StringConcat",e[e.StringEq=75]="StringEq",e[e.StringAs=76]="StringAs",e[e.StringWTF8Advance=77]="StringWTF8Advance",e[e.StringWTF16Get=78]="StringWTF16Get",e[e.StringIterNext=79]="StringIterNext",e[e.StringIterMove=80]="StringIterMove",e[e.StringSliceWTF=81]="StringSliceWTF",e[e.StringSliceIter=82]="StringSliceIter",e))(cl||{}),fl=(e=>(e[e.Function=0]="Function",e[e.Table=1]="Table",e[e.Memory=2]="Memory",e[e.Global=3]="Global",e[e.Tag=4]="Tag",e))(fl||{}),pl=(e=>(e[e.ClzI32=0]="ClzI32",e[e.ClzI64=1]="ClzI64",e[e.CtzI32=2]="CtzI32",e[e.CtzI64=3]="CtzI64",e[e.PopcntI32=4]="PopcntI32",e[e.PopcntI64=5]="PopcntI64",e[e.NegF32=6]="NegF32",e[e.NegF64=7]="NegF64",e[e.AbsF32=8]="AbsF32",e[e.AbsF64=9]="AbsF64",e[e.CeilF32=10]="CeilF32",e[e.CeilF64=11]="CeilF64",e[e.FloorF32=12]="FloorF32",e[e.FloorF64=13]="FloorF64",e[e.TruncF32=14]="TruncF32",e[e.TruncF64=15]="TruncF64",e[e.NearestF32=16]="NearestF32",e[e.NearestF64=17]="NearestF64",e[e.SqrtF32=18]="SqrtF32",e[e.SqrtF64=19]="SqrtF64",e[e.EqzI32=20]="EqzI32",e[e.EqzI64=21]="EqzI64",e[e.ExtendI32ToI64=22]="ExtendI32ToI64",e[e.ExtendU32ToU64=23]="ExtendU32ToU64",e[e.WrapI64ToI32=24]="WrapI64ToI32",e[e.TruncF32ToI32=25]="TruncF32ToI32",e[e.TruncF32ToI64=26]="TruncF32ToI64",e[e.TruncF32ToU32=27]="TruncF32ToU32",e[e.TruncF32ToU64=28]="TruncF32ToU64",e[e.TruncF64ToI32=29]="TruncF64ToI32",e[e.TruncF64ToI64=30]="TruncF64ToI64",e[e.TruncF64ToU32=31]="TruncF64ToU32",e[e.TruncF64ToU64=32]="TruncF64ToU64",e[e.ReinterpretF32ToI32=33]="ReinterpretF32ToI32",e[e.ReinterpretF64ToI64=34]="ReinterpretF64ToI64",e[e.ConvertI32ToF32=35]="ConvertI32ToF32",e[e.ConvertI32ToF64=36]="ConvertI32ToF64",e[e.ConvertU32ToF32=37]="ConvertU32ToF32",e[e.ConvertU32ToF64=38]="ConvertU32ToF64",e[e.ConvertI64ToF32=39]="ConvertI64ToF32",e[e.ConvertI64ToF64=40]="ConvertI64ToF64",e[e.ConvertU64ToF32=41]="ConvertU64ToF32",e[e.ConvertU64ToF64=42]="ConvertU64ToF64",e[e.PromoteF32ToF64=43]="PromoteF32ToF64",e[e.DemoteF64ToF32=44]="DemoteF64ToF32",e[e.ReinterpretI32ToF32=45]="ReinterpretI32ToF32",e[e.ReinterpretI64ToF64=46]="ReinterpretI64ToF64",e[e.Extend8I32=47]="Extend8I32",e[e.Extend16I32=48]="Extend16I32",e[e.Extend8I64=49]="Extend8I64",e[e.Extend16I64=50]="Extend16I64",e[e.Extend32I64=51]="Extend32I64",e[e.TruncSatF32ToI32=52]="TruncSatF32ToI32",e[e.TruncSatF32ToU32=53]="TruncSatF32ToU32",e[e.TruncSatF64ToI32=54]="TruncSatF64ToI32",e[e.TruncSatF64ToU32=55]="TruncSatF64ToU32",e[e.TruncSatF32ToI64=56]="TruncSatF32ToI64",e[e.TruncSatF32ToU64=57]="TruncSatF32ToU64",e[e.TruncSatF64ToI64=58]="TruncSatF64ToI64",e[e.TruncSatF64ToU64=59]="TruncSatF64ToU64",e[e.SplatI8x16=60]="SplatI8x16",e[e.SplatI16x8=61]="SplatI16x8",e[e.SplatI32x4=62]="SplatI32x4",e[e.SplatI64x2=63]="SplatI64x2",e[e.SplatF32x4=64]="SplatF32x4",e[e.SplatF64x2=65]="SplatF64x2",e[e.NotV128=66]="NotV128",e[e.AnyTrueV128=67]="AnyTrueV128",e[e.AbsI8x16=68]="AbsI8x16",e[e.NegI8x16=69]="NegI8x16",e[e.AllTrueI8x16=70]="AllTrueI8x16",e[e.BitmaskI8x16=71]="BitmaskI8x16",e[e.PopcntI8x16=72]="PopcntI8x16",e[e.AbsI16x8=73]="AbsI16x8",e[e.NegI16x8=74]="NegI16x8",e[e.AllTrueI16x8=75]="AllTrueI16x8",e[e.BitmaskI16x8=76]="BitmaskI16x8",e[e.AbsI32x4=77]="AbsI32x4",e[e.NegI32x4=78]="NegI32x4",e[e.AllTrueI32x4=79]="AllTrueI32x4",e[e.BitmaskI32x4=80]="BitmaskI32x4",e[e.AbsI64x2=81]="AbsI64x2",e[e.NegI64x2=82]="NegI64x2",e[e.AllTrueI64x2=83]="AllTrueI64x2",e[e.BitmaskI64x2=84]="BitmaskI64x2",e[e.AbsF32x4=85]="AbsF32x4",e[e.NegF32x4=86]="NegF32x4",e[e.SqrtF32x4=87]="SqrtF32x4",e[e.CeilF32x4=88]="CeilF32x4",e[e.FloorF32x4=89]="FloorF32x4",e[e.TruncF32x4=90]="TruncF32x4",e[e.NearestF32x4=91]="NearestF32x4",e[e.AbsF64x2=92]="AbsF64x2",e[e.NegF64x2=93]="NegF64x2",e[e.SqrtF64x2=94]="SqrtF64x2",e[e.CeilF64x2=95]="CeilF64x2",e[e.FloorF64x2=96]="FloorF64x2",e[e.TruncF64x2=97]="TruncF64x2",e[e.NearestF64x2=98]="NearestF64x2",e[e.ExtaddPairwiseI8x16ToI16x8=99]="ExtaddPairwiseI8x16ToI16x8",e[e.ExtaddPairwiseU8x16ToU16x8=100]="ExtaddPairwiseU8x16ToU16x8",e[e.ExtaddPairwiseI16x8ToI32x4=101]="ExtaddPairwiseI16x8ToI32x4",e[e.ExtaddPairwiseU16x8ToU32x4=102]="ExtaddPairwiseU16x8ToU32x4",e[e.TruncSatF32x4ToI32x4=103]="TruncSatF32x4ToI32x4",e[e.TruncSatF32x4ToU32x4=104]="TruncSatF32x4ToU32x4",e[e.ConvertI32x4ToF32x4=105]="ConvertI32x4ToF32x4",e[e.ConvertU32x4ToF32x4=106]="ConvertU32x4ToF32x4",e[e.ExtendLowI8x16ToI16x8=107]="ExtendLowI8x16ToI16x8",e[e.ExtendHighI8x16ToI16x8=108]="ExtendHighI8x16ToI16x8",e[e.ExtendLowU8x16ToU16x8=109]="ExtendLowU8x16ToU16x8",e[e.ExtendHighU8x16ToU16x8=110]="ExtendHighU8x16ToU16x8",e[e.ExtendLowI16x8ToI32x4=111]="ExtendLowI16x8ToI32x4",e[e.ExtendHighI16x8ToI32x4=112]="ExtendHighI16x8ToI32x4",e[e.ExtendLowU16x8ToU32x4=113]="ExtendLowU16x8ToU32x4",e[e.ExtendHighU16x8ToU32x4=114]="ExtendHighU16x8ToU32x4",e[e.ExtendLowI32x4ToI64x2=115]="ExtendLowI32x4ToI64x2",e[e.ExtendHighI32x4ToI64x2=116]="ExtendHighI32x4ToI64x2",e[e.ExtendLowU32x4ToU64x2=117]="ExtendLowU32x4ToU64x2",e[e.ExtendHighU32x4ToU64x2=118]="ExtendHighU32x4ToU64x2",e[e.ConvertLowI32x4ToF64x2=119]="ConvertLowI32x4ToF64x2",e[e.ConvertLowU32x4ToF64x2=120]="ConvertLowU32x4ToF64x2",e[e.TruncSatF64x2ToI32x4Zero=121]="TruncSatF64x2ToI32x4Zero",e[e.TruncSatF64x2ToU32x4Zero=122]="TruncSatF64x2ToU32x4Zero",e[e.DemoteZeroF64x2ToF32x4=123]="DemoteZeroF64x2ToF32x4",e[e.PromoteLowF32x4ToF64x2=124]="PromoteLowF32x4ToF64x2",e[e._last=124]="_last",e[e.ClzSize=125]="ClzSize",e[e.CtzSize=126]="CtzSize",e[e.PopcntSize=127]="PopcntSize",e[e.EqzSize=128]="EqzSize",e))(pl||{}),hl=(e=>(e[e.AddI32=0]="AddI32",e[e.SubI32=1]="SubI32",e[e.MulI32=2]="MulI32",e[e.DivI32=3]="DivI32",e[e.DivU32=4]="DivU32",e[e.RemI32=5]="RemI32",e[e.RemU32=6]="RemU32",e[e.AndI32=7]="AndI32",e[e.OrI32=8]="OrI32",e[e.XorI32=9]="XorI32",e[e.ShlI32=10]="ShlI32",e[e.ShrI32=11]="ShrI32",e[e.ShrU32=12]="ShrU32",e[e.RotlI32=13]="RotlI32",e[e.RotrI32=14]="RotrI32",e[e.EqI32=15]="EqI32",e[e.NeI32=16]="NeI32",e[e.LtI32=17]="LtI32",e[e.LtU32=18]="LtU32",e[e.LeI32=19]="LeI32",e[e.LeU32=20]="LeU32",e[e.GtI32=21]="GtI32",e[e.GtU32=22]="GtU32",e[e.GeI32=23]="GeI32",e[e.GeU32=24]="GeU32",e[e.AddI64=25]="AddI64",e[e.SubI64=26]="SubI64",e[e.MulI64=27]="MulI64",e[e.DivI64=28]="DivI64",e[e.DivU64=29]="DivU64",e[e.RemI64=30]="RemI64",e[e.RemU64=31]="RemU64",e[e.AndI64=32]="AndI64",e[e.OrI64=33]="OrI64",e[e.XorI64=34]="XorI64",e[e.ShlI64=35]="ShlI64",e[e.ShrI64=36]="ShrI64",e[e.ShrU64=37]="ShrU64",e[e.RotlI64=38]="RotlI64",e[e.RotrI64=39]="RotrI64",e[e.EqI64=40]="EqI64",e[e.NeI64=41]="NeI64",e[e.LtI64=42]="LtI64",e[e.LtU64=43]="LtU64",e[e.LeI64=44]="LeI64",e[e.LeU64=45]="LeU64",e[e.GtI64=46]="GtI64",e[e.GtU64=47]="GtU64",e[e.GeI64=48]="GeI64",e[e.GeU64=49]="GeU64",e[e.AddF32=50]="AddF32",e[e.SubF32=51]="SubF32",e[e.MulF32=52]="MulF32",e[e.DivF32=53]="DivF32",e[e.CopysignF32=54]="CopysignF32",e[e.MinF32=55]="MinF32",e[e.MaxF32=56]="MaxF32",e[e.EqF32=57]="EqF32",e[e.NeF32=58]="NeF32",e[e.LtF32=59]="LtF32",e[e.LeF32=60]="LeF32",e[e.GtF32=61]="GtF32",e[e.GeF32=62]="GeF32",e[e.AddF64=63]="AddF64",e[e.SubF64=64]="SubF64",e[e.MulF64=65]="MulF64",e[e.DivF64=66]="DivF64",e[e.CopysignF64=67]="CopysignF64",e[e.MinF64=68]="MinF64",e[e.MaxF64=69]="MaxF64",e[e.EqF64=70]="EqF64",e[e.NeF64=71]="NeF64",e[e.LtF64=72]="LtF64",e[e.LeF64=73]="LeF64",e[e.GtF64=74]="GtF64",e[e.GeF64=75]="GeF64",e[e.EqI8x16=76]="EqI8x16",e[e.NeI8x16=77]="NeI8x16",e[e.LtI8x16=78]="LtI8x16",e[e.LtU8x16=79]="LtU8x16",e[e.GtI8x16=80]="GtI8x16",e[e.GtU8x16=81]="GtU8x16",e[e.LeI8x16=82]="LeI8x16",e[e.LeU8x16=83]="LeU8x16",e[e.GeI8x16=84]="GeI8x16",e[e.GeU8x16=85]="GeU8x16",e[e.EqI16x8=86]="EqI16x8",e[e.NeI16x8=87]="NeI16x8",e[e.LtI16x8=88]="LtI16x8",e[e.LtU16x8=89]="LtU16x8",e[e.GtI16x8=90]="GtI16x8",e[e.GtU16x8=91]="GtU16x8",e[e.LeI16x8=92]="LeI16x8",e[e.LeU16x8=93]="LeU16x8",e[e.GeI16x8=94]="GeI16x8",e[e.GeU16x8=95]="GeU16x8",e[e.EqI32x4=96]="EqI32x4",e[e.NeI32x4=97]="NeI32x4",e[e.LtI32x4=98]="LtI32x4",e[e.LtU32x4=99]="LtU32x4",e[e.GtI32x4=100]="GtI32x4",e[e.GtU32x4=101]="GtU32x4",e[e.LeI32x4=102]="LeI32x4",e[e.LeU32x4=103]="LeU32x4",e[e.GeI32x4=104]="GeI32x4",e[e.GeU32x4=105]="GeU32x4",e[e.EqI64x2=106]="EqI64x2",e[e.NeI64x2=107]="NeI64x2",e[e.LtI64x2=108]="LtI64x2",e[e.GtI64x2=109]="GtI64x2",e[e.LeI64x2=110]="LeI64x2",e[e.GeI64x2=111]="GeI64x2",e[e.EqF32x4=112]="EqF32x4",e[e.NeF32x4=113]="NeF32x4",e[e.LtF32x4=114]="LtF32x4",e[e.GtF32x4=115]="GtF32x4",e[e.LeF32x4=116]="LeF32x4",e[e.GeF32x4=117]="GeF32x4",e[e.EqF64x2=118]="EqF64x2",e[e.NeF64x2=119]="NeF64x2",e[e.LtF64x2=120]="LtF64x2",e[e.GtF64x2=121]="GtF64x2",e[e.LeF64x2=122]="LeF64x2",e[e.GeF64x2=123]="GeF64x2",e[e.AndV128=124]="AndV128",e[e.OrV128=125]="OrV128",e[e.XorV128=126]="XorV128",e[e.AndnotV128=127]="AndnotV128",e[e.AddI8x16=128]="AddI8x16",e[e.AddSatI8x16=129]="AddSatI8x16",e[e.AddSatU8x16=130]="AddSatU8x16",e[e.SubI8x16=131]="SubI8x16",e[e.SubSatI8x16=132]="SubSatI8x16",e[e.SubSatU8x16=133]="SubSatU8x16",e[e.MinI8x16=134]="MinI8x16",e[e.MinU8x16=135]="MinU8x16",e[e.MaxI8x16=136]="MaxI8x16",e[e.MaxU8x16=137]="MaxU8x16",e[e.AvgrU8x16=138]="AvgrU8x16",e[e.AddI16x8=139]="AddI16x8",e[e.AddSatI16x8=140]="AddSatI16x8",e[e.AddSatU16x8=141]="AddSatU16x8",e[e.SubI16x8=142]="SubI16x8",e[e.SubSatI16x8=143]="SubSatI16x8",e[e.SubSatU16x8=144]="SubSatU16x8",e[e.MulI16x8=145]="MulI16x8",e[e.MinI16x8=146]="MinI16x8",e[e.MinU16x8=147]="MinU16x8",e[e.MaxI16x8=148]="MaxI16x8",e[e.MaxU16x8=149]="MaxU16x8",e[e.AvgrU16x8=150]="AvgrU16x8",e[e.Q15mulrSatI16x8=151]="Q15mulrSatI16x8",e[e.ExtmulLowI16x8=152]="ExtmulLowI16x8",e[e.ExtmulHighI16x8=153]="ExtmulHighI16x8",e[e.ExtmulLowU16x8=154]="ExtmulLowU16x8",e[e.ExtmulHighU16x8=155]="ExtmulHighU16x8",e[e.AddI32x4=156]="AddI32x4",e[e.SubI32x4=157]="SubI32x4",e[e.MulI32x4=158]="MulI32x4",e[e.MinI32x4=159]="MinI32x4",e[e.MinU32x4=160]="MinU32x4",e[e.MaxI32x4=161]="MaxI32x4",e[e.MaxU32x4=162]="MaxU32x4",e[e.DotI16x8=163]="DotI16x8",e[e.ExtmulLowI32x4=164]="ExtmulLowI32x4",e[e.ExtmulHighI32x4=165]="ExtmulHighI32x4",e[e.ExtmulLowU32x4=166]="ExtmulLowU32x4",e[e.ExtmulHighU32x4=167]="ExtmulHighU32x4",e[e.AddI64x2=168]="AddI64x2",e[e.SubI64x2=169]="SubI64x2",e[e.MulI64x2=170]="MulI64x2",e[e.ExtmulLowI64x2=171]="ExtmulLowI64x2",e[e.ExtmulHighI64x2=172]="ExtmulHighI64x2",e[e.ExtmulLowU64x2=173]="ExtmulLowU64x2",e[e.ExtmulHighU64x2=174]="ExtmulHighU64x2",e[e.AddF32x4=175]="AddF32x4",e[e.SubF32x4=176]="SubF32x4",e[e.MulF32x4=177]="MulF32x4",e[e.DivF32x4=178]="DivF32x4",e[e.MinF32x4=179]="MinF32x4",e[e.MaxF32x4=180]="MaxF32x4",e[e.PminF32x4=181]="PminF32x4",e[e.PmaxF32x4=182]="PmaxF32x4",e[e.AddF64x2=183]="AddF64x2",e[e.SubF64x2=184]="SubF64x2",e[e.MulF64x2=185]="MulF64x2",e[e.DivF64x2=186]="DivF64x2",e[e.MinF64x2=187]="MinF64x2",e[e.MaxF64x2=188]="MaxF64x2",e[e.PminF64x2=189]="PminF64x2",e[e.PmaxF64x2=190]="PmaxF64x2",e[e.NarrowI16x8ToI8x16=191]="NarrowI16x8ToI8x16",e[e.NarrowU16x8ToU8x16=192]="NarrowU16x8ToU8x16",e[e.NarrowI32x4ToI16x8=193]="NarrowI32x4ToI16x8",e[e.NarrowU32x4ToU16x8=194]="NarrowU32x4ToU16x8",e[e.SwizzleI8x16=195]="SwizzleI8x16",e[e._last=195]="_last",e[e.AddSize=196]="AddSize",e[e.SubSize=197]="SubSize",e[e.MulSize=198]="MulSize",e[e.DivISize=199]="DivISize",e[e.DivUSize=200]="DivUSize",e[e.RemISize=201]="RemISize",e[e.RemUSize=202]="RemUSize",e[e.AndSize=203]="AndSize",e[e.OrSize=204]="OrSize",e[e.XorSize=205]="XorSize",e[e.ShlSize=206]="ShlSize",e[e.ShrISize=207]="ShrISize",e[e.ShrUSize=208]="ShrUSize",e[e.RotlSize=209]="RotlSize",e[e.RotrSize=210]="RotrSize",e[e.EqSize=211]="EqSize",e[e.NeSize=212]="NeSize",e[e.LtISize=213]="LtISize",e[e.LtUSize=214]="LtUSize",e[e.LeISize=215]="LeISize",e[e.LeUSize=216]="LeUSize",e[e.GtISize=217]="GtISize",e[e.GtUSize=218]="GtUSize",e[e.GeISize=219]="GeISize",e[e.GeUSize=220]="GeUSize",e))(hl||{}),dl=(e=>(e[e.Add=0]="Add",e[e.Sub=1]="Sub",e[e.And=2]="And",e[e.Or=3]="Or",e[e.Xor=4]="Xor",e[e.Xchg=5]="Xchg",e))(dl||{}),xl=(e=>(e[e.ExtractLaneI8x16=0]="ExtractLaneI8x16",e[e.ExtractLaneU8x16=1]="ExtractLaneU8x16",e[e.ExtractLaneI16x8=2]="ExtractLaneI16x8",e[e.ExtractLaneU16x8=3]="ExtractLaneU16x8",e[e.ExtractLaneI32x4=4]="ExtractLaneI32x4",e[e.ExtractLaneI64x2=5]="ExtractLaneI64x2",e[e.ExtractLaneF32x4=6]="ExtractLaneF32x4",e[e.ExtractLaneF64x2=7]="ExtractLaneF64x2",e))(xl||{}),gl=(e=>(e[e.ReplaceLaneI8x16=0]="ReplaceLaneI8x16",e[e.ReplaceLaneI16x8=1]="ReplaceLaneI16x8",e[e.ReplaceLaneI32x4=2]="ReplaceLaneI32x4",e[e.ReplaceLaneI64x2=3]="ReplaceLaneI64x2",e[e.ReplaceLaneF32x4=4]="ReplaceLaneF32x4",e[e.ReplaceLaneF64x2=5]="ReplaceLaneF64x2",e))(gl||{}),ml=(e=>(e[e.ShlI8x16=0]="ShlI8x16",e[e.ShrI8x16=1]="ShrI8x16",e[e.ShrU8x16=2]="ShrU8x16",e[e.ShlI16x8=3]="ShlI16x8",e[e.ShrI16x8=4]="ShrI16x8",e[e.ShrU16x8=5]="ShrU16x8",e[e.ShlI32x4=6]="ShlI32x4",e[e.ShrI32x4=7]="ShrI32x4",e[e.ShrU32x4=8]="ShrU32x4",e[e.ShlI64x2=9]="ShlI64x2",e[e.ShrI64x2=10]="ShrI64x2",e[e.ShrU64x2=11]="ShrU64x2",e))(ml||{}),yl=(e=>(e[e.Load8Splat=0]="Load8Splat",e[e.Load16Splat=1]="Load16Splat",e[e.Load32Splat=2]="Load32Splat",e[e.Load64Splat=3]="Load64Splat",e[e.Load8x8S=4]="Load8x8S",e[e.Load8x8U=5]="Load8x8U",e[e.Load16x4S=6]="Load16x4S",e[e.Load16x4U=7]="Load16x4U",e[e.Load32x2S=8]="Load32x2S",e[e.Load32x2U=9]="Load32x2U",e[e.Load32Zero=10]="Load32Zero",e[e.Load64Zero=11]="Load64Zero",e))(yl||{}),_l=(e=>(e[e.Load8Lane=0]="Load8Lane",e[e.Load16Lane=1]="Load16Lane",e[e.Load32Lane=2]="Load32Lane",e[e.Load64Lane=3]="Load64Lane",e[e.Store8Lane=4]="Store8Lane",e[e.Store16Lane=5]="Store16Lane",e[e.Store32Lane=6]="Store32Lane",e[e.Store64Lane=7]="Store64Lane",e))(_l||{}),bl=(e=>(e[e.Bitselect=0]="Bitselect",e))(bl||{}),vl=(e=>(e[e.Null=0]="Null",e[e.Func=1]="Func",e[e.Data=2]="Data",e[e.I31=3]="I31",e))(vl||{}),El=(e=>(e[e.NonNull=0]="NonNull",e[e.Func=1]="Func",e[e.Data=2]="Data",e[e.I31=3]="I31",e[e.ExternInternalize=4]="ExternInternalize",e[e.ExternExternalize=5]="ExternExternalize",e))(El||{}),Fl=(e=>(e[e.Null=0]="Null",e[e.NonNull=1]="NonNull",e[e.Cast=2]="Cast",e[e.CastFail=3]="CastFail",e[e.Func=4]="Func",e[e.NonFunc=5]="NonFunc",e[e.Data=6]="Data",e[e.NonData=7]="NonData",e[e.I31=8]="I31",e[e.NonI31=9]="NonI31",e))(Fl||{}),Al=(e=>(e[e.UTF8=0]="UTF8",e[e.WTF8=1]="WTF8",e[e.Replace=2]="Replace",e[e.WTF16=3]="WTF16",e[e.UTF8Array=4]="UTF8Array",e[e.WTF8Array=5]="WTF8Array",e[e.ReplaceArray=6]="ReplaceArray",e[e.WTF16Array=7]="WTF16Array",e))(Al||{}),Tl=(e=>(e[e.UTF8=0]="UTF8",e[e.WTF8=1]="WTF8",e[e.WTF16=2]="WTF16",e[e.IsUSV=3]="IsUSV",e[e.WTF16View=4]="WTF16View",e))(Tl||{}),Sl=(e=>(e[e.UTF8=0]="UTF8",e[e.WTF8=1]="WTF8",e[e.WTF16=2]="WTF16",e[e.UTF8Array=3]="UTF8Array",e[e.WTF8Array=4]="WTF8Array",e[e.WTF16Array=5]="WTF16Array",e))(Sl||{}),Cl=(e=>(e[e.WTF8=0]="WTF8",e[e.WTF16=1]="WTF16",e[e.Iter=2]="Iter",e))(Cl||{}),wl=(e=>(e[e.Advance=0]="Advance",e[e.Rewind=1]="Rewind",e))(wl||{}),Il=(e=>(e[e.WTF8=0]="WTF8",e[e.WTF16=1]="WTF16",e))(Il||{}),kl=(e=>(e[e.Default=0]="Default",e[e.PreserveSideeffects=1]="PreserveSideeffects",e[e.TraverseCalls=2]="TraverseCalls",e))(kl||{}),vi=class{constructor(e,n){this.buffer=e,this.offset=n}},Hs=class{constructor(e,n,t){this.ref=e,this.useShadowStack=n,this.sizeType=t,this.hasTemporaryFunction=!1,this.cachedStringsToPointers=new Map,this.cachedPointersToStrings=new Map,assert(t==A.I32||t==A.I64),this.lit=In(zc()),Em(Mr.Nominal)}static create(e,n){return new Hs(sd(),e,n)}static createFrom(e,n,t){let r=xr(e),i=new Hs(B3(r,e.length),n,t);return K(changetype(r)),i}i32(e){let n=this.lit;return od(n,e),hr(this.ref,n)}i64(e,n=0){let t=this.lit;return ld(t,e,n),hr(this.ref,t)}usize(e){return i64_is(e)?this.sizeType==A.I64?this.i64(i64_low(e),i64_high(e)):(assert(i64_is_u32(e)),this.i32(i64_low(e))):this.sizeType==A.I64?this.i64(i32(e)):this.i32(i32(e))}f32(e){let n=this.lit;return ud(n,e),hr(this.ref,n)}f64(e){let n=this.lit;return cd(n,e),hr(this.ref,n)}v128(e){assert(e.length==16);let n=this.lit;for(let t=0;t<16;++t)Oe(n+t,unchecked(e[t]));return fd(n,n),hr(this.ref,n)}ref_null(e){return dg(this.ref,e)}ref_eq(e,n){return _g(this.ref,e,n)}string_eq(e,n){return A6(this.ref,e,n)}unary(e,n){if(e>124){let t=this.sizeType==A.I64;switch(e){case 125:e=t?1:0;break;case 126:e=t?3:2;break;case 127:e=t?5:4;break;case 128:e=t?21:20;break;default:assert(!1)}}return ox(this.ref,e,n)}binary(e,n,t){if(e>195){let r=this.sizeType==A.I64;switch(e){case 196:e=r?25:0;break;case 197:e=r?26:1;break;case 198:e=r?27:2;break;case 199:e=r?28:3;break;case 200:e=r?29:4;break;case 201:e=r?30:5;break;case 202:e=r?31:6;break;case 203:e=r?32:7;break;case 204:e=r?33:8;break;case 205:e=r?34:9;break;case 206:e=r?35:10;break;case 207:e=r?36:11;break;case 208:e=r?37:12;break;case 209:e=r?38:13;break;case 210:e=r?39:14;break;case 211:e=r?40:15;break;case 212:e=r?41:16;break;case 213:e=r?42:17;break;case 214:e=r?43:18;break;case 215:e=r?44:19;break;case 216:e=r?45:20;break;case 217:e=r?46:21;break;case 218:e=r?47:22;break;case 219:e=r?48:23;break;case 220:e=r?49:24;break;default:assert(!1)}}return cx(this.ref,e,n,t)}memory_size(e=v.DefaultMemory,n=!1){let t=this.allocStringCached(e);return qd(this.ref,t,n)}memory_grow(e,n=v.DefaultMemory,t=!1){let r=this.allocStringCached(n);return jd(this.ref,e,r,t)}table_size(e){let n=this.allocStringCached(e);return Ag(this.ref,n)}table_grow(e,n,t=0){let r=this.allocStringCached(e);return Tg(this.ref,r,t,n)}local_get(e,n){return Od(this.ref,e,n)}tostack(e){if(this.useShadowStack){let n=pt(e);return assert(n==A.I32||n==A.Unreachable),this.call(h.tostack,[e],n)}return e}local_tee(e,n,t,r=-1){return r==-1&&(r=pt(n)),t&&this.useShadowStack&&(n=this.tostack(n)),Md(this.ref,e,n,r)}global_get(e,n){let t=this.allocStringCached(e);return Ud(this.ref,t,n)}table_get(e,n,t){let r=this.allocStringCached(e);return Eg(this.ref,r,n,t)}load(e,n,t,r,i=0,s=e,a=v.DefaultMemory){let o=this.allocStringCached(a);return Hd(this.ref,e,n,i,s,r,t,o)}store(e,n,t,r,i=0,s=e,a=v.DefaultMemory){let o=this.allocStringCached(a);return Jd(this.ref,e,i,s,n,t,r,o)}atomic_load(e,n,t,r=0,i=v.DefaultMemory){let s=this.allocStringCached(i);return Zd(this.ref,e,r,t,n,s)}atomic_store(e,n,t,r,i=0,s=v.DefaultMemory){let a=this.allocStringCached(s);return ex(this.ref,e,i,n,t,r,a)}atomic_rmw(e,n,t,r,i,s,a=v.DefaultMemory){let o=this.allocStringCached(a);return Ex(this.ref,e,n,t,r,i,s,o)}atomic_cmpxchg(e,n,t,r,i,s,a=v.DefaultMemory){let o=this.allocStringCached(a);return Tx(this.ref,e,n,t,r,i,s,o)}atomic_wait(e,n,t,r,i=v.DefaultMemory){let s=this.allocStringCached(i);return Ix(this.ref,e,n,t,r,s)}atomic_notify(e,n,t=v.DefaultMemory){let r=this.allocStringCached(t);return Nx(this.ref,e,n,r)}atomic_fence(e=null){let n=this.allocStringCached(e);return Ox(this.ref,n)}local_set(e,n,t){return t&&this.useShadowStack&&(n=this.tostack(n)),Rd(this.ref,e,n)}global_set(e,n){let t=this.allocStringCached(e);return Pd(this.ref,t,n)}table_set(e,n,t){let r=this.allocStringCached(e);return Fg(this.ref,r,n,t)}block(e,n,t=A.None){let r=this.allocStringCached(e),i=pe(n),s=dd(this.ref,r,i,n.length,t);return K(i),s}flatten(e,n=A.None){let t=e.length;if(t==0)return this.nop();if(t==1){let r=e[0];switch(H(r)){case 19:case 50:case 23:return r}let i=se(r);return i!=A.Unreachable&&i!=n?this.unreachable():r}return this.block(null,e,n)}br(e,n=0,t=0){let r=this.allocStringCached(e);return Ed(this.ref,r,n,t)}drop(e){return Nc(this.ref,e)}maybeDrop(e){let n=pt(e);return n!=A.None&&n!=A.Unreachable?Nc(this.ref,e):e}maybeDropCondition(e,n){return(Qt(e,this.ref)&~(Ir.ReadsLocal|Ir.ReadsGlobal))!=0?this.block(null,[this.drop(e),n],se(n)):n}loop(e,n){let t=this.allocStringCached(e);return bd(this.ref,t,n)}if(e,n,t=0){return gd(this.ref,e,n,t)}nop(){return bx(this.ref)}return(e=0){return _x(this.ref,e)}select(e,n,t,r){return dx(this.ref,t,e,n,r)}switch(e,n,t,r=0){let i=e.length,s=new Array(i);for(let c=0;c<i;++c)unchecked(s[c]=this.allocStringCached(e[c]));let a=pe(s),o=this.allocStringCached(n),u=Td(this.ref,a,i,o,t,r);return K(a),u}call(e,n,t,r=!1){let i=this.allocStringCached(e),s=pe(n),a=r?zd(this.ref,i,s,n?n.length:0,t):Bd(this.ref,i,s,n?n.length:0,t);return K(s),a}return_call(e,n,t){return this.call(e,n,t,!0)}call_indirect(e,n,t,r,i,s=!1){let a=this.allocStringCached(e??v.DefaultTable),o=pe(t),u=s?Dd(this.ref,a,n,o,t?t.length:0,r,i):Nd(this.ref,a,n,o,t?t.length:0,r,i);return K(o),u}return_call_indirect(e,n,t,r,i){return this.call_indirect(e,n,t,r,i,!0)}unreachable(){return vx(this.ref)}memory_copy(e,n,t,r=v.DefaultMemory,i=v.DefaultMemory){let s=this.allocStringCached(r),a=this.allocStringCached(i);return ag(this.ref,e,n,t,s,a)}memory_fill(e,n,t,r=v.DefaultMemory){let i=this.allocStringCached(r);return cg(this.ref,e,n,t,i)}try(e,n,t,r,i=null){let s=t.length,a=new Array(s);for(let d=0;d<s;++d)a[d]=this.allocStringCached(t[d]);let o=pe(a),u=pe(r),c=this.allocStringCached(e),f=this.allocStringCached(i),p=Sg(this.ref,c,n,o,s,u,r.length,f);return K(u),K(o),p}throw(e,n){let t=this.allocStringCached(e),r=pe(n),i=Ig(this.ref,t,r,n.length);return K(r),i}rethrow(e){let n=this.allocStringCached(e);return zg(this.ref,n)}pop(e){return Rg(this.ref,e)}tuple_make(e){let n=pe(e),t=Ng(this.ref,n,e.length);return K(n),t}tuple_extract(e,n){return Dg(this.ref,e,n)}simd_extract(e,n,t){return Rx(this.ref,e,n,t)}simd_replace(e,n,t,r){return Ux(this.ref,e,n,t,r)}simd_shuffle(e,n,t){assert(t.length==16);let r=xr(t),i=Gx(this.ref,e,n,r);return K(r),i}simd_ternary(e,n,t,r){return Wx(this.ref,e,n,t,r)}simd_shift(e,n,t){return $x(this.ref,e,n,t)}simd_load(e,n,t,r,i=v.DefaultMemory){let s=this.allocStringCached(i);return Jx(this.ref,e,t,r,n,s)}simd_loadstorelane(e,n,t,r,i,s,a=v.DefaultMemory){let o=this.allocStringCached(a);return eg(this.ref,e,t,r,i,n,s,o)}ref_is(e,n){return Lc(this.ref,e,n)}ref_is_null(e){return Ei(se(e))?Lc(this.ref,0,e):this.i32(0)}ref_as(e,n){return Dc(this.ref,e,n)}ref_as_nonnull(e){return Ei(se(e))?Dc(this.ref,0,e):e}ref_func(e,n){let t=this.allocStringCached(e);return mg(this.ref,t,n)}i31_new(e){return Mg(this.ref,e)}i31_get(e,n){return Pg(this.ref,e,n)}addGlobal(e,n,t,r){let i=this.allocStringCached(e);return i3(this.ref,i,n,t,r)}getGlobal(e){let n=this.allocStringCached(e);return s3(this.ref,n)}removeGlobal(e){let n=this.allocStringCached(e);a3(this.ref,n)}addTag(e,n,t){let r=this.allocStringCached(e);return p3(this.ref,r,n,t)}getTag(e){let n=this.allocStringCached(e);return h3(this.ref,n)}removeTag(e){let n=this.allocStringCached(e);d3(this.ref,n)}addFunction(e,n,t,r,i){let s=this.allocStringCached(e),a=pe(r),o=di(this.ref,s,n,t,a,r?r.length:0,i);return K(a),o}setLocalName(e,n,t){q6(e,n,this.allocStringCached(t))}getFunction(e){let n=this.allocStringCached(e);return xi(this.ref,n)}removeFunction(e){let n=this.allocStringCached(e);Rs(this.ref,n)}hasFunction(e){let n=this.allocStringCached(e);return xi(this.ref,n)!=0}addTemporaryFunction(e,n,t){this.hasTemporaryFunction=assert(!this.hasTemporaryFunction);let r=this.allocStringCached(""),i=pe(n),s=di(this.ref,r,dn(n),e,0,0,t);return K(i),s}removeTemporaryFunction(){this.hasTemporaryFunction=!assert(this.hasTemporaryFunction);let e=this.allocStringCached("");Rs(this.ref,e)}setStart(e){A3(this.ref,e)}addFunctionExport(e,n){let t=this.allocStringCached(e),r=this.allocStringCached(n);return cp(this.ref,t,r)}addTableExport(e,n){let t=this.allocStringCached(e),r=this.allocStringCached(n);return Z6(this.ref,t,r)}addMemoryExport(e,n){let t=this.allocStringCached(e),r=this.allocStringCached(n);return J6(this.ref,t,r)}addGlobalExport(e,n){let t=this.allocStringCached(e),r=this.allocStringCached(n);return Q6(this.ref,t,r)}addTagExport(e,n){let t=this.allocStringCached(e),r=this.allocStringCached(n);return e3(this.ref,t,r)}removeExport(e){let n=this.allocStringCached(e);pp(this.ref,n)}hasExport(e){let n=this.allocStringCached(e);return fp(this.ref,n)!=0}addFunctionImport(e,n,t,r,i){let s=this.allocStringCached(e),a=this.allocStringCached(n),o=this.allocStringCached(t);H6(this.ref,s,a,o,r,i)}addTableImport(e,n,t){let r=this.allocStringCached(e),i=this.allocStringCached(n),s=this.allocStringCached(t);X6(this.ref,r,i,s)}addMemoryImport(e,n,t,r=!1){let i=this.allocStringCached(e),s=this.allocStringCached(n),a=this.allocStringCached(t);K6(this.ref,i,s,a,r)}addGlobalImport(e,n,t,r,i=!1){let s=this.allocStringCached(e),a=this.allocStringCached(n),o=this.allocStringCached(t);$6(this.ref,s,a,o,r,i)}addTagImport(e,n,t,r,i){let s=this.allocStringCached(e),a=this.allocStringCached(n),o=this.allocStringCached(t);Y6(this.ref,s,a,o,r,i)}setMemory(e,n,t,r,i=null,s=v.DefaultMemory,a=!1){let o=this.allocStringCached(i),u=this.allocStringCached(s),c=t.length,f=new Array(c),p=new Uint8Array(c),d=new Array(c),m=new Array(c);for(let T=0;T<c;++T){let S=unchecked(t[T]),C=S.buffer,w=S.offset;unchecked(f[T]=xr(C)),unchecked(p[T]=0),unchecked(d[T]=r==2?this.i64(i64_low(w),i64_high(w)):this.i32(i64_low(w))),unchecked(m[T]=C.length)}let g=pe(f),E=xr(p),y=pe(d),b=Xs(m);F3(this.ref,e,n,o,g,E,y,b,c,a,!1,u),K(b),K(y),K(E),K(g);for(let T=c-1;T>=0;--T)K(unchecked(f[T]))}addFunctionTable(e,n,t,r,i){let s=this.allocStringCached(e),a=r.length,o=new Array(a);for(let f=0;f<a;++f)unchecked(o[f]=this.allocStringCached(r[f]));let u=pe(o),c=_3(this.ref,s);c?(b3(c,n),v3(c,t)):c=y3(this.ref,s,n,t,A.Funcref),E3(this.ref,s,s,u,a,i),K(u)}addCustomSection(e,n){let t=this.allocStringCached(e),r=xr(n);R3(this.ref,t,r,n.length),K(r)}getOptimizeLevel(){return J3()}setOptimizeLevel(e){Q3(e)}getShrinkLevel(){return em()}setShrinkLevel(e){nm(e)}getDebugInfo(){return tm()}setDebugInfo(e){rm(e)}getLowMemoryUnused(){return im()}setLowMemoryUnused(e){sm(e)}getZeroFilledMemory(){return am()}setZeroFilledMemory(e){om(e)}getFastMath(){return lm()}setFastMath(e){um(e)}getPassArgument(e){let n=this.allocStringCached(e),t=cm(n);return t?ze(t):null}setPassArgument(e,n){let t=this.allocStringCached(e),r=this.allocStringCached(n);fm(t,r)}clearPassArguments(){pm()}getAlwaysInlineMaxSize(){return hm()}setAlwaysInlineMaxSize(e){dm(e)}getFlexibleInlineMaxSize(){return xm()}setFlexibleInlineMaxSize(e){gm(e)}getOneCallerInlineMaxSize(){return mm()}setOneCallerInlineMaxSize(e){ym(e)}getAllowInliningFunctionsWithLoops(){return _m()}setAllowInliningFunctionsWithLoops(e){bm(e)}getFeatures(){return D3(this.ref)}setFeatures(e){O3(this.ref,e)}runPasses(e,n=0){let t=e.length,r=new Array(t);for(let s=0;s<t;++s)r[s]=pi(e[s]);let i=pe(r);n?j6(n,this.ref,i,t):S3(this.ref,i,t),K(i);for(let s=t-1;s>=0;--s)K(r[s])}optimize(e,n,t=!1,r=!1){if((e>=3||n>=2)&&(e=4),this.setOptimizeLevel(e),this.setShrinkLevel(n),this.setDebugInfo(t),this.setZeroFilledMemory(r),this.setFastMath(!0),this.clearPassArguments(),e>=2&&n==0?(this.setAlwaysInlineMaxSize(12),this.setFlexibleInlineMaxSize(70),this.setOneCallerInlineMaxSize(200),this.setAllowInliningFunctionsWithLoops(e>=3)):(this.setAlwaysInlineMaxSize(e<=1||n>=2?2:6),this.setFlexibleInlineMaxSize(65),this.setOneCallerInlineMaxSize(80),this.setAllowInliningFunctionsWithLoops(!1)),e>0||n>0){let i=new Array;i.push("duplicate-function-elimination"),i.push("remove-unused-module-elements"),e>=2&&(i.push("once-reduction"),i.push("inlining"),i.push("simplify-globals-optimizing")),(e>=3||n>=1)&&(i.push("rse"),i.push("vacuum"),i.push("code-folding"),i.push("ssa-nomerge"),i.push("local-cse"),i.push("remove-unused-brs"),i.push("remove-unused-names"),i.push("merge-blocks"),i.push("precompute-propagate"),i.push("simplify-globals-optimizing"),i.push("gufa-optimizing"),i.push("dae-optimizing")),e>=3&&(i.push("simplify-locals-nostructure"),i.push("flatten"),i.push("vacuum"),i.push("simplify-locals-notee-nostructure"),i.push("vacuum"),i.push("licm"),i.push("merge-locals"),i.push("reorder-locals")),i.push("optimize-instructions"),(e>=3||n>=1)&&i.push("dce"),i.push("remove-unused-brs"),i.push("remove-unused-names"),e>=3||n>=2?(i.push("inlining"),i.push("precompute-propagate"),i.push("simplify-globals-optimizing")):i.push("precompute"),(e>=2||n>=1)&&i.push("pick-load-signs"),i.push("simplify-locals-notee-nostructure"),i.push("vacuum"),(e>=2||n>=1)&&i.push("local-cse"),i.push("reorder-locals"),i.push("coalesce-locals"),i.push("simplify-locals"),i.push("coalesce-locals"),i.push("reorder-locals"),i.push("vacuum"),(e>=2||n>=1)&&(i.push("rse"),i.push("vacuum")),(e>=3||n>=1)&&(i.push("merge-locals"),i.push("vacuum")),(e>=2||n>=1)&&(i.push("simplify-globals-optimizing"),i.push("simplify-globals-optimizing")),i.push("remove-unused-brs"),i.push("remove-unused-names"),i.push("merge-blocks"),e>=3&&i.push("optimize-instructions"),(e>=2||n>=1)&&(i.push("simplify-globals-optimizing"),i.push("dae-optimizing")),(e>=2||n>=2)&&i.push("inlining-optimizing"),this.getLowMemoryUnused()&&(e>=3||n>=1?i.push("optimize-added-constants-propagate"):i.push("optimize-added-constants")),i.push("duplicate-import-elimination"),e>=2||n>=2?i.push("simplify-globals-optimizing"):(i.push("simplify-globals"),i.push("vacuum")),e>=2&&(this.getFeatures()&1024)!=0&&(i.push("heap2local"),i.push("merge-locals"),i.push("local-subtyping")),e>=2||n>=1?(i.push("precompute-propagate"),i.push("simplify-globals-optimizing"),i.push("simplify-globals-optimizing")):i.push("precompute"),i.push("directize"),i.push("dae-optimizing"),i.push("inlining-optimizing"),(e>=2||n>=1)&&(i.push("code-folding"),i.push("ssa-nomerge"),i.push("rse"),i.push("code-pushing"),e>=3&&(i.push("simplify-globals"),i.push("vacuum"),i.push("precompute-propagate"),i.push("inlining-optimizing"),i.push("directize"),i.push("dae-optimizing"),i.push("local-cse"),i.push("merge-locals"),i.push("coalesce-locals"),i.push("simplify-locals"),i.push("vacuum"),i.push("inlining"),i.push("precompute-propagate"),i.push("rse"),i.push("vacuum"),i.push("ssa-nomerge"),i.push("simplify-locals"),i.push("coalesce-locals")),i.push("optimize-instructions"),i.push("remove-unused-brs"),i.push("remove-unused-names"),i.push("merge-blocks"),i.push("vacuum"),i.push("simplify-globals-optimizing"),i.push("remove-unused-brs"),i.push("optimize-instructions")),i.push("duplicate-function-elimination"),n>=2&&i.push("merge-similar-functions"),i.push("memory-packing"),i.push("remove-unused-module-elements"),this.runPasses(i)}}validate(){return T3(this.ref)==1}interpret(){z3(this.ref)}toBinary(e=null){assert(zc()>=C3());let n=this.lit,t=pi(e);w3(n,this.ref,t);let r=ht(n+0),i=ht(n+4),s=ht(n+8),a=new Pl(ey(assert(r),i),ze(s));return t&&K(t),s&&K(s),K(r),a}toText(e=!0){let n=e?k3(this.ref,!0):I3(this.ref),t=ze(n);return n&&K(n),t||""}allocStringCached(e){if(e==null)return 0;let n=this.cachedStringsToPointers;if(n.has(e))return changetype(n.get(e));let t=pi(e);return n.set(e,t),t}readStringCached(e){if(e==0)return null;let n=this.cachedPointersToStrings;if(n.has(e))return changetype(n.get(e));let t=ze(e);return n.set(e,t),t}dispose(){assert(this.ref);for(let e=Map_values(this.cachedStringsToPointers),n=0,t=e.length;n<t;++n){let r=unchecked(e[n]);K(r)}this.cachedStringsToPointers.clear(),this.cachedPointersToStrings.clear(),K(this.lit),ad(this.ref),this.ref=0}createRelooper(){return ss.create(this)}tryCopyTrivialExpression(e){switch(gt(e)){case 8:case 10:case 14:case 20:case 22:case 23:case 37:case 41:return this.copyExpression(e)}return 0}copyExpression(e){return pd(e,this.ref)}runExpression(e,n,t=50,r=1){let i=W3(this.ref,n,t,r),s=H3(i,e);if(s){if(!this.isConstExpression(s))return 0;assert(se(s)==se(e))}return s}isConstExpression(e){switch(H(e)){case 14:case 41:case 43:case 54:return!0;case 16:{if(this.getFeatures()&16384)switch(Xt(e)){case 0:case 1:case 2:case 25:case 26:case 27:return this.isConstExpression(He(e))&&this.isConstExpression(Ie(e))}break}}return!1}addDebugInfoFile(e){let n=pi(e),t=N3(this.ref,n);return K(n),t}getDebugInfoFile(e){return ze(L3(this.ref,e))}setDebugLocation(e,n,t,r,i){W6(e,n,t,r,i)}},xt=Hs;xt.UNLIMITED_MEMORY=-1,xt.UNLIMITED_TABLE=-1;function dn(e){if(!e)return A.None;switch(e.length){case 0:return A.None;case 1:return e[0]}let n=pe(e),t=Uh(n,e.length);return K(n),t}function Bl(e){let n=Ph(e),t=In(n<<2);Vh(e,t);let r=new Array(n);for(let i=0;i<n;++i)unchecked(r[i]=ht(t+(i<<2)));return K(t),r}function Ei(e){return Gh(e)}function H(e){return gt(e)}function se(e){return pt(e)}function Y(e){return nx(e)}function Be(e){return tx(e)}function Pe(e){return rx(e)}function Fe(e){return ix(e)}function Ae(e){return sx(e)}function zl(e){let n=In(16);ax(e,n);let t=new Uint8Array(16);for(let r=0;r<16;++r)t[r]=Pt(n+r);return K(n),t}function Me(e){if(H(e)!=14)return!1;let n=se(e);return n==A.I32?Y(e)==0:n==A.I64?(Be(e)|Pe(e))==0:n==A.F32?Fe(e)==0:n==A.F64?Ae(e)==0:!1}function en(e){if(H(e)!=14)return!1;let n=se(e);return n==A.I32?Y(e)!=0:n==A.I64?(Be(e)|Pe(e))!=0:n==A.F32?Fe(e)!=0:n==A.F64?Ae(e)!=0:!1}function Vt(e){if(H(e)!=14)return!1;let n=se(e);if(n==A.F32){let t=Fe(e);return t==0&&f32_as_i32(t)<0}if(n==A.F64){let t=Ae(e);return t==0&&i64_signbit(f64_as_i64(t))}return!1}function wp(e){if(H(e)!=14)return!1;let n=se(e);return n==A.F32?isNaN(Fe(e)):n==A.F64?isNaN(Ae(e)):!1}function Gt(e,n){let t=H(n),r=se(n);if(r==A.F32||r==A.F64){if(t==14)return isNaN(r==A.F32?Fe(n):Ae(n));if(t==10){let i=e.runExpression(n,0,8);if(i)return isNaN(r==A.F32?Fe(i):Ae(i))}}return!1}function Sn(e){return o0(e)}function Fi(e){return sa(e)}function Jt(e){return zi(e)}function vr(e){return l0(e)}function ns(e){return ze(c0(e))}function Xt(e){return fx(e)}function He(e){return ca(e)}function Ie(e){return fa(e)}function Er(e){return lx(e)}function Ai(e){return ua(e)}function Nl(e){return $d(e)}function Ip(e){return Kd(e)}function kp(e){return oa(e)}function Ll(e){return Xd(e)}function Bp(e){return p0(e)}function zp(e){return h0(e)}function Np(e){return Ni(e)}function Lp(e){return la(e)}function ts(e){return ze(Zs(e))}function rs(e){return Ii(e)}function is(e,n){return ki(e,n)}function Ti(e){return Js(e)}function Fr(e){return Qs(e)}function qt(e){return ea(e)}function Dp(e){return ze(Qc(e))}function Op(e){return na(e)}function Rp(e){return ze(e0(e))}function Mp(e){return Bi(e)}function Dl(e){return pa(e)}function Ol(e){return ha(e)}function Up(e){return da(e)}function Pp(e){return xa(e)}function Vp(e){return Li(e)}function Ar(e){return ze(ta(e))}function un(e){return Br(e)}function Re(e,n){return zr(e,n)}function Gp(e){return aa(e)}function qp(e){return Tr(e)}function Rl(e){return ze(ga(e))}function jp(e){return Ms(e)}function Wp(e){return Us(e)}function Hp(e){let n=op(e),t=new Array(n);for(let r=0;r<n;++r)unchecked(t[r]=lp(e,r));return t}function Xp(e){return ze(u3(e))}function Kp(e){return c3(e)}function Ml(e){return f3(e)}function $p(e){return hp(e)}function Yp(e){return ze(x3(e))}function Zp(e){return g3(e)}function Jp(e){return m3(e)}var ss=class{constructor(e,n){this.module=e,this.ref=n}static create(e){return new ss(e,U3(e.ref))}addBlock(e){return P3(this.ref,e)}addBranch(e,n,t=0,r=0){V3(e,n,t,r)}addBlockWithSwitch(e,n){return G3(this.ref,e,n)}addBranchForSwitch(e,n,t,r=0){let i=Jm(t);q3(e,n,i,t.length,r),K(i)}renderAndDispose(e,n){return j3(this.ref,e,n)}},Ul=class{constructor(e,n){this.values=new Array,this.indexes=new Array,this.cases=new Array,this.defaultIndex=-1,this.module=e,this.condition=n}addCase(e,n){let t=this.cases,r=t.indexOf(n);r<0&&(r=t.length,t.push(n)),this.values.push(e),this.indexes.push(r)}addDefault(e){assert(this.defaultIndex==-1);let n=this.cases;this.defaultIndex=n.length,n.push(e)}render(e,n=""){let t=this.module,r=this.cases,i=r.length;if(!i)return t.drop(this.condition);let s=this.values,a=s.length,o=this.indexes,u=new Array(1+a+1),c=new Array(i);for(let g=0;g<i;++g)unchecked(c[g]=`case${g}${n}`);u[0]=t.local_set(e,this.condition,!1);for(let g=0;g<a;++g){let E=unchecked(o[g]);unchecked(u[1+g]=t.br(c[E],t.binary(15,t.local_get(e,A.I32),t.i32(s[g]))))}let f=this.defaultIndex,p=`default${n}`;u[1+a]=t.br(~f?c[f]:p);let d=t.block(c[0],u);for(let g=1;g<i;++g){let E=r[g-1];E.unshift(d),d=t.block(unchecked(c[g]),E)}let m=r[i-1];return m.unshift(d),t.block(~f?null:p,m)}},Ir=(e=>(e[e.None=0]="None",e[e.Branches=1]="Branches",e[e.Calls=2]="Calls",e[e.ReadsLocal=4]="ReadsLocal",e[e.WritesLocal=8]="WritesLocal",e[e.ReadsGlobal=16]="ReadsGlobal",e[e.WritesGlobal=32]="WritesGlobal",e[e.ReadsMemory=64]="ReadsMemory",e[e.WritesMemory=128]="WritesMemory",e[e.ReadsTable=256]="ReadsTable",e[e.WritesTable=512]="WritesTable",e[e.ImplicitTrap=1024]="ImplicitTrap",e[e.IsAtomic=2048]="IsAtomic",e[e.Throws=4096]="Throws",e[e.DanglingPop=8192]="DanglingPop",e[e.TrapsNeverHappen=16384]="TrapsNeverHappen",e[e.Any=32767]="Any",e))(Ir||{});function Qt(e,n){return M3(e,n)}function as(e,n){return(Qt(e,n)&-21)!=0}function xr(e){if(!e)return 0;let n=e.length,t=In(n);for(let r=0;r<n;++r)Oe(t+r,unchecked(e[r]));return t}function Jm(e){if(!e)return 0;let n=e.length,t=In(n<<2),r=t;for(let i=0;i<n;++i){let s=unchecked(e[i]);ma(r,s),r+=4}return t}function Xs(e){if(!e)return 0;let n=e.length,t=In(n<<2),r=t;for(let i=0;i<n;++i){let s=unchecked(e[i]);ma(r,s),r+=4}return t}function pe(e){if(!e)return 0;assert(ASC_TARGET!=2);let n=e.length,t=In(n<<2),r=t;for(let i=0,s=n;i<s;++i){let a=unchecked(e[i]);ma(r,a),r+=4}return t}function Qm(e){let n=0;for(let t=0,r=e.length;t<r;++t){let i=e.charCodeAt(t)>>>0;i<=127?n+=1:i<=2047?n+=2:Hi(i)&&t+1<r&&wa(e.charCodeAt(t+1))?(t++,n+=4):n+=3}return n}function pi(e){if(e==null)return 0;let n=Qm(e),t=In(n+1)>>>0,r=t;if(n==e.length)for(let i=0,s=e.length;i<s;++i){let a=e.charCodeAt(i)>>>0;Oe(r++,a)}else for(let i=0,s=e.length;i<s;++i){let a=e.charCodeAt(i)>>>0,o;a<=127?Oe(r++,a):a<=2047?(Oe(r++,192|a>>>6),Oe(r++,128|a&63)):Hi(a)&&i+1<s&&wa(o=e.charCodeAt(i+1))?(a=Ia(a,o),++i,Oe(r++,240|a>>>18),Oe(r++,128|a>>>12&63),Oe(r++,128|a>>>6&63),Oe(r++,128|a&63)):(Oe(r++,224|a>>>12),Oe(r++,128|a>>>6&63),Oe(r++,128|a&63))}return Oe(r,0),t}function ey(e,n){let t=new Uint8Array(n);for(let r=0;r<n;++r)unchecked(t[r]=Pt(e+r));return t}function ze(e){if(!e)return null;let n=new Array,t,r,i,s;for(;t=Pt(e++);){if(!(t&128)){n.push(t);continue}if(r=Pt(e++)&63,(t&224)==192){n.push((t&31)<<6|r);continue}if(i=Pt(e++)&63,(t&240)==224?t=(t&15)<<12|r<<6|i:(s=Pt(e++)&63,(t&248)==240?t=(t&7)<<18|r<<12|i<<6|s:assert(!1,"Invalid UTF8 sequence during readString")),t<65536)n.push(t);else{let a=t-65536;n.push(Wi|a>>>10),n.push(Nr|a&1023)}}return String.fromCharCodes(n)}var Pl=class{constructor(e,n){this.output=e,this.sourceMap=n}};function os(e){if(pt(e)!=A.Unreachable)return!1;switch(gt(e)){case 23:case 19:return!1;case 4:return Bi(e)!=0;case 1:if(!Zs(e)){let n=Ii(e);return n>0&&os(ki(e,n-1))}}return!0}var An=!1;function ls(e){if(e==l.void)return A.None;let n=Qp(e);if(n)return n;let t=e;if(e=e.nonNullableType,n=e.ref)return ae(Ut(n),t.is(512));ASC_TARGET&&assert(sizeof()==4),assert(vm()==Mr.Nominal);let r=X3(0),i=new Map;Vn(r,i,e);let s=Ps(r),a=In(max(4*s,8));if(!Z3(r,a,a,a+4)){let o=ht(a),u=ht(a+4);throw K(a),new Error(`type builder error at index ${o}: ${es.toString(u)}`)}for(let o=Map_keys(i),u=0,c=o.length;u<c;++u){let f=o[u];assert(!f.is(512));let p=ht(a+4*u),d=ae(p,!1);assert(!f.ref),f.ref=d,An&&console.log(` set ${f.toString()}`)}return K(a),An&&console.log(` finalize ${e.toString()}`),n=assert(e.ref),ae(Ut(n),t.is(512))}function Qp(e){switch(e.kind){case 0:case 1:case 6:case 2:case 7:case 3:case 8:return A.I32;case 4:case 9:return A.I64;case 5:case 10:{if(e.isInternalReference)break;return e.size==64?A.I64:A.I32}case 11:return A.F32;case 12:return A.F64;case 13:return A.V128;case 14:return ae(oe.Func,e.is(512));case 15:return ae(oe.Extern,e.is(512));case 16:return ae(oe.Any,e.is(512));case 17:return ae(oe.Eq,e.is(512));case 18:return ae(oe.I31,e.is(512));case 19:return ae(oe.Data,e.is(512));case 20:return ae(oe.Array,e.is(512));case 21:return ae(oe.String,e.is(512));case 22:return ae(oe.StringviewWTF8,e.is(512));case 23:return ae(oe.StringviewWTF16,e.is(512));case 24:return ae(oe.StringviewIter,e.is(512));case 25:assert(!1)}return 0}function ny(e){switch(e.kind){case 0:case 1:case 6:return Ht.I8;case 2:case 7:return Ht.I16}return Ht.NotPacked}function Vn(e,n,t){if(t==l.void)return A.None;let r=Qp(t);if(r||(assert(!t.is(512)),r=t.ref))return r;if(n.has(t))return An&&console.log(` prepare ${t.toString()} (seen)`),changetype(n.get(t));An&&console.log(`prepare ${t.toString()}`);let i=t.getClass();if(i){let a=i.base,o=0;a&&(o=Vn(e,n,a.type));let u=Ps(e);Rc(e,1),An&&console.log(` block [${u}]: ${t.toString()}`);let c=Mc(e,u);r=dr(e,c,!1),n.set(t,r);let f=new Array,p=new Array,d=new Array,m=i.members;if(m)for(let b=Map_values(m),T=0,S=b.length;T<S;++T){let C=b[T];if(C.kind!=11)continue;let w=C.type;An&&console.log(`  field ${w.toString()}`),w.is(512)?f.push(dr(e,Ut(Vn(e,n,w.nonNullableType)),!0)):f.push(Vn(e,n,w)),p.push(ny(w)),d.push(1)}let g=pe(f),E=Xs(p),y=Xs(d);return An&&console.log(` concretize [${u}]: ${t.toString()}`),$3(e,u,g,E,y,f.length),a&&(An&&console.log(` set super [${u}]: ${t.toString()} <: ${a.type.toString()} ${o==a.type.ref?" (known)":""}`),Y3(e,u,Ut(o))),K(y),K(E),K(g),r}let s=t.getSignature();if(s){let a=Ps(e);Rc(e,1);let o=dr(e,Mc(e,a),!1);n.set(t,o);let u=new Array,c=new Array,f=s.parameterTypes;for(let g=0,E=f.length;g<E;++g){let y=f[g];y.is(512)?u.push(dr(e,Ut(Vn(e,n,y.nonNullableType)),!0)):u.push(Vn(e,n,y))}let p=s.returnType;c.push(p==l.void?A.None:p.is(512)?dr(e,Ut(Vn(e,n,p.nonNullableType)),!0):Vn(e,n,p));let d;if(u.length>1){let g=pe(u);d=Uc(e,g,u.length),K(g)}else d=u.length?u[0]:A.None;let m;if(c.length>1){let g=pe(c);m=Uc(e,g,c.length),K(g)}else m=c[0];return An&&console.log(` concretize [${a}]: ${t.toString()}`),K3(e,a,d,m),o}throw new Error(`unexpected complex type: ${t.toString()}`)}var Vl=(e=>(e[e.None=0]="None",e[e.Returns=1]="Returns",e[e.ReturnsWrapped=2]="ReturnsWrapped",e[e.ReturnsNonNull=4]="ReturnsNonNull",e[e.Throws=8]="Throws",e[e.Breaks=16]="Breaks",e[e.Continues=32]="Continues",e[e.AccessesThis=64]="AccessesThis",e[e.CallsSuper=128]="CallsSuper",e[e.Terminates=256]="Terminates",e[e.ConditionallyReturns=512]="ConditionallyReturns",e[e.ConditionallyThrows=1024]="ConditionallyThrows",e[e.ConditionallyBreaks=2048]="ConditionallyBreaks",e[e.ConditionallyContinues=4096]="ConditionallyContinues",e[e.ConditionallyAccessesThis=8192]="ConditionallyAccessesThis",e[e.MayReturnNonThis=16384]="MayReturnNonThis",e[e.UncheckedContext=32768]="UncheckedContext",e[e.CtorParamContext=65536]="CtorParamContext",e[e.AnyCategorical=511]="AnyCategorical",e[e.AnyConditional=15872]="AnyConditional",e))(Vl||{}),Gl=(e=>(e[e.None=0]="None",e[e.Constant=1]="Constant",e[e.Wrapped=2]="Wrapped",e[e.NonNull=4]="NonNull",e[e.Initialized=8]="Initialized",e))(Gl||{}),ql=(e=>(e[e.None=0]="None",e[e.Initialized=1]="Initialized",e))(ql||{}),jl=(e=>(e[e.Unknown=0]="Unknown",e[e.True=1]="True",e[e.False=2]="False",e))(jl||{}),Wn=class{constructor(e,n=null){this.targetFunction=e,this.inlineFunction=n,this.parent=null,this.outer=null,this.flags=0,this.continueLabel=null,this.breakLabel=null,this.scopedLocals=null,this.localFlags=[],this.thisFieldFlags=null,this.inlineReturnLabel=null}static createDefault(e){let n=new Wn(e);return e.is(524288)&&n.initThisFieldFlags(),n}static createInline(e,n){let t=new Wn(e,n);return t.inlineReturnLabel=`${n.internalName}|inlined.${n.nextInlineId++}`,n.is(524288)&&t.initThisFieldFlags(),t}get isInline(){return this.inlineFunction!=null}get sourceFunction(){return this.inlineFunction||this.targetFunction}get program(){return this.targetFunction.program}get returnType(){return this.sourceFunction.signature.returnType}get contextualTypeArguments(){return this.sourceFunction.contextualTypeArguments}is(e){return(this.flags&e)==e}isAny(e){return(this.flags&e)!=0}set(e){this.flags|=e}unset(e){this.flags&=~e}deriveConditionalFlags(){let e=this.flags&15872;return this.is(1)&&(e|=512),this.is(8)&&(e|=1024),this.is(16)&&(e|=2048),this.is(32)&&(e|=4096),this.is(64)&&(e|=8192),e}fork(e=!1){let n=new Wn(this.targetFunction,this.inlineFunction);if(n.parent=this,n.outer=this.outer,e?n.flags=this.flags&-6193:(n.flags=this.flags,n.continueLabel=this.continueLabel,n.breakLabel=this.breakLabel),n.localFlags=this.localFlags.slice(),this.sourceFunction.is(524288)){let t=assert(this.thisFieldFlags);n.thisFieldFlags=de(t)}else assert(!this.thisFieldFlags);return n.inlineReturnLabel=this.inlineReturnLabel,n}getTempLocal(e){let n=this.targetFunction.addLocal(e);return this.unsetLocalFlag(n.index,-1),n}getScopedLocal(e){let n=this.scopedLocals;return n&&n.has(e)?assert(n.get(e)):null}addScopedLocal(e,n){let t=this.getTempLocal(n);t.name=e,t.internalName=Ne(e,t.parent,!1);let r=this.scopedLocals;return r?assert(!r.has(e)):this.scopedLocals=r=new Map,t.set(67108864),r.set(e,t),t}addScopedDummyLocal(e,n,t){let r=new nn(e,-1,n,this.targetFunction),i=this.scopedLocals;return i?i.has(e)&&this.program.error(2451,t.range,e):this.scopedLocals=i=new Map,r.set(67108864),i.set(e,r),r}addScopedAlias(e,n,t,r=null){let i=this.scopedLocals;if(!i)this.scopedLocals=i=new Map;else if(i.has(e)){let a=assert(i.get(e));return r&&(a.declaration.range.source.isNative?this.program.error(2300,r.range,e):this.program.errorRelated(2300,r.range,a.declaration.name.range,e)),a}assert(t<this.targetFunction.localsByIndex.length);let s=new nn(e,t,n,this.targetFunction);return s.set(67108864),i.set(e,s),s}freeScopedDummyLocal(e){let n=assert(this.scopedLocals);assert(n.has(e));let t=assert(n.get(e));assert(t.index==-1),n.delete(e)}lookupLocal(e){let n=this;do{let t=n.scopedLocals;if(t&&t.has(e))return assert(t.get(e));n=n.parent}while(n);return null}lookup(e){return this.lookupLocal(e)||this.sourceFunction.lookup(e)}isLocalFlag(e,n,t=!0){if(e<0)return t;let r=this.localFlags;return e<r.length&&(unchecked(r[e])&n)==n}isAnyLocalFlag(e,n,t=!0){if(e<0)return t;let r=this.localFlags;return e<r.length&&(unchecked(r[e])&n)!=0}setLocalFlag(e,n){if(e<0)return;let t=this.localFlags,r=e<t.length?unchecked(t[e]):0;t[e]=r|n}unsetLocalFlag(e,n){if(e<0)return;let t=this.localFlags,r=e<t.length?unchecked(t[e]):0;t[e]=r&~n}initThisFieldFlags(){let e=this.sourceFunction;assert(e.is(524288));let n=e.parent;assert(n.kind==7);let t=n;this.thisFieldFlags=new Map;let r=t.members;if(r)for(let i=Map_values(r),s=0,a=i.length;s<a;++s){let o=i[s];if(o.kind==11){let u=o;(u.parent!=t||u.initializerNode||u.prototype.parameterIndex!=-1||u.type.isAny(640))&&this.setThisFieldFlag(u,1)}}}isThisFieldFlag(e,n){let t=this.thisFieldFlags;return t!=null&&t.has(e)?(changetype(t.get(e))&n)==n:!1}setThisFieldFlag(e,n){let t=this.thisFieldFlags;if(t)if(assert(this.sourceFunction.is(524288)),t.has(e)){let r=changetype(t.get(e));t.set(e,r|n)}else t.set(e,n);else assert(!this.sourceFunction.is(524288))}pushBreakLabel(){let e=this.targetFunction,n=e.nextBreakId++,t=e.breakStack;t?t.push(n):e.breakStack=[n];let r=n.toString();return e.breakLabel=r,r}popBreakLabel(){let e=this.targetFunction,n=assert(e.breakStack),t=assert(n.length);n.pop(),t>1?e.breakLabel=n[t-2].toString():(e.breakLabel=null,e.breakStack=null)}inherit(e){assert(e.targetFunction==this.targetFunction),assert(e.parent==this);let n=e.flags;this.breakLabel!=e.breakLabel&&(n&2064&&(n&=-257),n&=-2065),this.continueLabel!=e.continueLabel&&(n&=-4129),this.flags=this.flags|n,this.localFlags=e.localFlags,this.thisFieldFlags=e.thisFieldFlags}inheritBranch(e,n=0){switch(assert(e.targetFunction==this.targetFunction),n){case 1:this.inherit(e);case 2:return}let t=this.flags,r=e.flags,i=0;t&1?i|=1:r&1?i|=512:i|=(t|r)&512,i|=t&r&2,i|=t&r&4,t&8?i|=8:r&8?i|=1024:i|=(t|r)&1024,t&16?i|=16:e.breakLabel==this.breakLabel?r&16?i|=2048:i|=(t|r)&2048:i|=t&2048,t&32?i|=32:e.continueLabel==this.continueLabel?r&32?i|=4096:i|=(t|r)&4096:i|=t&4096,t&64?r&64?i|=64:i|=8192:r&64&&(i|=8192),i|=(t|r)&16384,i|=t&r&128,t&256&&(i|=256),this.flags=i|t&98304;let s=this.localFlags,a=s.length,o=e.localFlags,u=o.length,c=max(a,u);for(let f=0;f<c;++f){let p=f<a?s[f]:0,d=f<u?o[f]:0;s[f]=p&d&15}}inheritMutual(e,n){assert(e.targetFunction==n.targetFunction),assert(e.targetFunction==this.targetFunction);let t=e.flags,r=n.flags,i=0;t&1?r&1?i|=1:i|=512:r&1?i|=512:i|=(t|r)&512,t&2&&r&2&&(i|=2),t&4&&r&4&&(i|=4),t&8?r&8?i|=8:i|=1024:r&8?i|=1024:i|=(t|r)&1024,t&16?r&16?i|=16:i|=2048:r&16?i|=2048:i|=(t|r)&2048,t&32?r&32?i|=32:i|=4096:r&32?i|=4096:i|=(t|r)&4096,t&64?r&64?i|=64:i|=8192:r&64?i|=8192:i|=(t|r)&8192,i|=(t|r)&16384,t&128&&r&128&&(i|=128),t&256&&r&256&&(i|=256),this.flags=i|this.flags&98304;let s=this.localFlags;if(t&256){if(!(r&256)){let o=n.localFlags;for(let u=0,c=o.length;u<c;++u)s[u]=o[u]}}else if(r&256){let o=e.localFlags;for(let u=0,c=o.length;u<c;++u)s[u]=o[u]}else{let o=e.localFlags,u=o.length,c=n.localFlags,f=c.length,p=max(u,f);for(let d=0;d<p;++d){let m=d<u?o[d]:0,g=d<f?c[d]:0;s[d]=m&g&15}}let a=e.thisFieldFlags;if(a){let o=new Map,u=assert(n.thisFieldFlags);for(let c=Map_keys(a),f=0,p=c.length;f<p;++f){let d=c[f];(changetype(a.get(d))&1)!=0&&u.has(d)&&changetype(u.get(d))&1&&o.set(d,1)}this.thisFieldFlags=o}else assert(!n.thisFieldFlags)}resetIfNeedsRecompile(e,n){let t=this.localFlags.length,r=e.localFlags.length,i=this.targetFunction;assert(i==e.targetFunction);let s=i.localsByIndex;assert(s==e.targetFunction.localsByIndex);let a=!1;for(let o=0,u=min(t,r);o<u;++o){let c=s[o].type;c.isShortIntegerValue&&this.isLocalFlag(o,2)&&!e.isLocalFlag(o,2)&&(this.unsetLocalFlag(o,2),a=!0),c.isNullableReference&&this.isLocalFlag(o,4)&&!e.isLocalFlag(o,4)&&(this.unsetLocalFlag(o,4),a=!0)}return a&&(assert(s.length>=n),s.length=n,this.localFlags.length>n&&(this.localFlags.length=n)),a}isNonnull(e,n){if(!n.isNullableReference)return!0;switch(H(e)){case 9:{if(!vr(e))break;let t=this.targetFunction.localsByIndex[Fi(e)];return!t.type.isNullableReference||this.isLocalFlag(t.index,4,!1)}case 8:{let t=this.targetFunction.localsByIndex[Sn(e)];return!t.type.isNullableReference||this.isLocalFlag(t.index,4,!1)}}return!1}inheritNonnullIfTrue(e,n=null){switch(H(e)){case 9:{if(!vr(e))break;let t=this.targetFunction.localsByIndex[Fi(e)];(!n||n.isLocalFlag(t.index,4))&&this.setLocalFlag(t.index,4),this.inheritNonnullIfTrue(Jt(e),n);break}case 8:{let t=this.targetFunction.localsByIndex[Sn(e)];(!n||n.isLocalFlag(t.index,4))&&this.setLocalFlag(t.index,4);break}case 2:{let t=qt(e);t&&Me(t)&&(this.inheritNonnullIfTrue(Ti(e),n),this.inheritNonnullIfTrue(Fr(e),n));break}case 15:{switch(Er(e)){case 20:case 21:{this.inheritNonnullIfFalse(Ai(e),n);break}}break}case 16:{switch(Xt(e)){case 15:case 40:{let t=He(e),r=Ie(e);en(t)?this.inheritNonnullIfTrue(r,n):en(r)&&this.inheritNonnullIfTrue(t,n);break}case 16:case 41:{let t=He(e),r=Ie(e);Me(t)?this.inheritNonnullIfTrue(r,n):Me(r)&&this.inheritNonnullIfTrue(t,n);break}}break}case 6:{let t=Ar(e);if(t==h.String_eq){assert(un(e)==2);let r=Re(e,0),i=Re(e,1);en(r)?this.inheritNonnullIfTrue(i,n):en(i)&&this.inheritNonnullIfTrue(r,n)}else if(t==h.String_ne){assert(un(e)==2);let r=Re(e,0),i=Re(e,1);Me(r)?this.inheritNonnullIfTrue(i,n):Me(i)&&this.inheritNonnullIfTrue(r,n)}else t==h.String_not?(assert(un(e)==1),this.inheritNonnullIfFalse(Re(e,0),n)):t==h.tostack&&(assert(un(e)==1),this.inheritNonnullIfTrue(Re(e,0),n));break}}}inheritNonnullIfFalse(e,n=null){switch(H(e)){case 15:{switch(Er(e)){case 20:case 21:{this.inheritNonnullIfTrue(Ai(e),n);break}}break}case 2:{let t=Fr(e);qt(e)&&en(t)&&(this.inheritNonnullIfFalse(Ti(e),n),this.inheritNonnullIfFalse(qt(e),n));break}case 16:{switch(Xt(e)){case 15:case 40:{let t=He(e),r=Ie(e);Me(t)?this.inheritNonnullIfTrue(r,n):Me(r)&&this.inheritNonnullIfTrue(t,n);break}case 16:case 41:{let t=He(e),r=Ie(e);en(t)?this.inheritNonnullIfTrue(r,n):en(r)&&this.inheritNonnullIfTrue(t,n);break}}break}case 6:{let t=Ar(e);if(t==h.String_eq){assert(un(e)==2);let r=Re(e,0),i=Re(e,1);Me(r)?this.inheritNonnullIfTrue(i,n):Me(i)&&this.inheritNonnullIfTrue(r,n)}else if(t==h.String_ne){assert(un(e)==2);let r=Re(e,0),i=Re(e,1);en(r)?this.inheritNonnullIfTrue(i,n):en(i)&&this.inheritNonnullIfTrue(r,n)}else t==h.String_not?(assert(un(e)==1),this.inheritNonnullIfTrue(Re(e,0),n)):t==h.tostack&&(assert(un(e)==1),this.inheritNonnullIfFalse(Re(e,0),n));break}}}canOverflow(e,n){if(!n.isShortIntegerValue)return!1;let t;switch(H(e)){case 8:{let r=this.targetFunction.localsByIndex[Sn(e)];return!this.isLocalFlag(r.index,2,!0)||hi(r.type,n)}case 9:return assert(vr(e)),this.canOverflow(Jt(e),n);case 10:{let r=assert(this.program.elementsByName.get(assert(ns(e))));return assert(r.kind==0||r.kind==3),hi(r.type,n)}case 16:{switch(Xt(e)){case 15:case 40:case 57:case 70:case 16:case 41:case 58:case 71:case 17:case 18:case 42:case 43:case 59:case 72:case 19:case 20:case 44:case 45:case 60:case 73:case 21:case 22:case 46:case 47:case 61:case 74:case 23:case 24:case 48:case 49:case 62:case 75:return!1;case 2:return!(H(t=He(e))==14&&(Y(t)==0||Y(t)==1&&!this.canOverflow(Ie(e),n))||H(t=Ie(e))==14&&(Y(t)==0||Y(t)==1&&!this.canOverflow(He(e),n)));case 7:return!(H(t=He(e))==14&&Y(t)<=n.computeSmallIntegerMask(l.i32)||!this.canOverflow(t,n)||H(t=Ie(e))==14&&Y(t)<=n.computeSmallIntegerMask(l.i32)||!this.canOverflow(t,n));case 10:{let r=32-n.size;return H(t=Ie(e))!=14||Y(t)<r}case 11:{let r=32-n.size;return this.canOverflow(He(e),n)&&(H(t=Ie(e))!=14||Y(t)<r)}case 12:{let r=32-n.size;return n.isSignedIntegerValue?!(H(t=Ie(e))==14&&Y(t)>r):this.canOverflow(He(e),n)&&!(H(t=Ie(e))==14&&Y(t)>=r)}case 4:case 5:case 6:return this.canOverflow(He(e),n)||this.canOverflow(Ie(e),n)}break}case 15:{switch(Er(e)){case 20:case 21:return!1;case 0:case 2:case 4:return n.size<7;case 47:return n.size<(n.isUnsignedIntegerValue?32:8);case 49:return n.size<(n.isUnsignedIntegerValue?64:8);case 48:return n.size<(n.isUnsignedIntegerValue?32:16);case 50:return n.size<(n.isUnsignedIntegerValue?64:16);case 51:return n.size<(n.isUnsignedIntegerValue?64:32)}break}case 14:{let r=0;switch(se(e)){case A.I32:{r=Y(e);break}case A.I64:{r=Be(e);break}case A.F32:{r=i32(Fe(e));break}case A.F64:{r=i32(Ae(e));break}case A.V128:return!1;default:assert(!1)}switch(n.kind){case 0:return(r&-2)!=0;case 1:return r<i8.MIN_VALUE||r>i8.MAX_VALUE;case 2:return r<i16.MIN_VALUE||r>i16.MAX_VALUE;case 6:return r<0||r>u8.MAX_VALUE;case 7:return r<0||r>u16.MAX_VALUE}break}case 12:{let r,i=Ll(e);switch(Nl(e)){case 1:{r=i?l.i8:l.u8;break}case 2:{r=i?l.i16:l.u16;break}default:{r=i?l.i32:l.u32;break}}return hi(r,n)}case 1:{if(!ts(e)){let r=assert(rs(e)),i=is(e,r-1);return this.canOverflow(i,n)}break}case 2:return this.canOverflow(Fr(e),n)||this.canOverflow(assert(qt(e)),n);case 17:return this.canOverflow(Dl(e),n)||this.canOverflow(Ol(e),n);case 6:{let r=this.program.instancesByName,i=assert(Ar(e));if(r.has(i)){let s=assert(r.get(i));assert(s.kind==5);let a=s,o=a.signature.returnType;return!a.flow.is(2)||hi(o,n)}return!1}case 23:return!1}return!0}toString(){let e=0,n=this.parent;for(;n;)n=n.parent,++e;let t=new Array;return this.is(1)&&t.push("RETURNS"),this.is(2)&&t.push("RETURNS_WRAPPED"),this.is(4)&&t.push("RETURNS_NONNULL"),this.is(8)&&t.push("THROWS"),this.is(16)&&t.push("BREAKS"),this.is(32)&&t.push("CONTINUES"),this.is(64)&&t.push("ACCESSES_THIS"),this.is(128)&&t.push("CALLS_SUPER"),this.is(256)&&t.push("TERMINATES"),this.is(512)&&t.push("CONDITIONALLY_RETURNS"),this.is(1024)&&t.push("CONDITIONALLY_THROWS"),this.is(2048)&&t.push("CONDITIONALLY_BREAKS"),this.is(4096)&&t.push("CONDITIONALLY_CONTINUES"),this.is(8192)&&t.push("CONDITIONALLY_ACCESSES_THIS"),this.is(16384)&&t.push("MAY_RETURN_NONTHIS"),`Flow(${this.sourceFunction})[${e}] ${t.join(" ")}`}};function hi(e,n){return n.isShortIntegerValue&&(!e.isIntegerValue||e.size>n.size||e.isSignedIntegerValue!=n.isSignedIntegerValue)}var Wl=(e=>(e[e.Report=0]="Report",e[e.Swallow=1]="Swallow",e))(Wl||{}),Hl=class extends mt{constructor(e){super(e.diagnostics),this.currentThisExpression=null,this.currentElementExpression=null,this.discoveredOverload=!1,this.resolvingExpressions=new Set,this.resolveClassPending=new Set,this.program=e}resolveType(e,n,t=null,r=0){switch(e.kind){case 1:return this.resolveNamedType(e,n,t,r);case 2:return this.resolveFunctionType(e,n,t,r);default:assert(!1)}return null}resolveNamedType(e,n,t=null,r=0){let i=e.name,s=e.typeArguments,a=!i.next;if(a){let c=i.identifier.text;if(t&&t.has(c)){let f=assert(t.get(c));if(s&&s.length>0&&r==0&&this.error(2315,e.range,f.toString()),e.isNullable){if(f.isInternalReference)return f.asNullable();r==0&&this.error(204,e.range,f.toString())}return f}}let o=this.resolveTypeName(i,n,r);if(!o)return null;let u=o.shadowType;if(u)o=u;else{if(o.kind==2)return s&&s.length>0&&r==0&&this.error(2315,e.range,o.internalName),e.isNullable&&r==0&&this.error(204,e.range,`${o.name}/i32`),l.i32;if(o.kind==6||o.kind==8){let c=this.resolveClassInclTypeArguments(o,s,n,de(t),e,r);return c?e.isNullable?c.type.asNullable():c.type:null}}if(o.kind==16){let c=o;if(o.is(4194304)){s&&s.length>0&&r==0&&this.error(2315,e.range,o.internalName);let m=c.type;if(e.isNullable){if(m.isInternalReference)return m.asNullable();r==0&&this.error(204,i.range,i.identifier.text)}return m}if(a){let m=i.identifier.text;if(m==v.native)return this.resolveBuiltinNativeType(e,n,t,r);if(m==v.indexof)return this.resolveBuiltinIndexofType(e,n,t,r);if(m==v.valueof)return this.resolveBuiltinValueofType(e,n,t,r);if(m==v.returnof)return this.resolveBuiltinReturnTypeType(e,n,t,r);if(m==v.nonnull)return this.resolveBuiltinNotNullableType(e,n,t,r)}let f=c.typeParameterNodes,p=null;if(f){if(p=this.resolveTypeArguments(f,s,n,t=de(t),e,r),!p)return null}else s&&s.length>0&&this.error(2315,e.range,i.identifier.text);let d=this.resolveType(c.typeNode,o,t,r);if(!d)return null;if(e.isNullable){if(d.isInternalReference)return d.asNullable();r==0&&this.error(204,i.range,i.identifier.text)}return d}return r==0&&this.error(2304,i.range,i.identifier.text),null}resolveFunctionType(e,n,t=null,r=0){let i=e.explicitThisType,s=null;if(i&&(s=this.resolveType(i,n,t,r),!s))return null;let a=e.parameters,o=a.length,u=new Array(o),c=0,f=!1;for(let g=0;g<o;++g){let E=a[g];switch(E.parameterKind){case 0:{c=g+1;break}case 2:{assert(g==o),f=!0;break}}let y=E.type;if(Ve(y))return r==0&&this.error(1110,y.range),null;let b=this.resolveType(y,n,t,r);if(!b)return null;u[g]=b}let p=e.returnType,d;if(Ve(p))r==0&&this.error(1110,p.range),d=l.void;else if(d=this.resolveType(p,n,t,r),!d)return null;let m=new tn(this.program,u,d,s);return m.requiredParameters=c,m.hasRest=f,e.isNullable?m.type.asNullable():m.type}resolveBuiltinNativeType(e,n,t=null,r=0){let i=this.ensureOneTypeArgument(e,r);if(!i)return null;let s=this.resolveType(i,n,t,r);if(!s)return null;switch(s.kind){case 1:case 2:case 3:return l.i32;case 5:if(!this.program.options.isWasm64)return l.i32;case 4:return l.i64;case 6:case 7:case 8:case 0:return l.u32;case 10:if(!this.program.options.isWasm64)return l.u32;case 9:return l.u64;case 11:return l.f32;case 12:return l.f64;case 13:return l.v128;case 25:return l.void;default:assert(!1)}return null}resolveBuiltinIndexofType(e,n,t=null,r=0){let i=this.ensureOneTypeArgument(e,r);if(!i)return null;let s=this.resolveType(i,n,t,r);if(!s)return null;let a=s.classReference;if(!a)return r==0&&this.error(2329,i.range,s.toString()),null;let o=a.lookupOverload(1);if(o){let u=o.signature.parameterTypes;return o.is(32)?(assert(u.length==2),u[1]):(assert(u.length==1),u[0])}return r==0&&this.error(2329,i.range,s.toString()),null}resolveBuiltinValueofType(e,n,t=null,r=0){let i=this.ensureOneTypeArgument(e,r);if(!i)return null;let s=this.resolveType(i,n,t,r);if(!s)return null;let a=s.getClassOrWrapper(this.program);if(a){let o=a.lookupOverload(1);if(o)return o.signature.returnType}return r==0&&this.error(2329,i.range,s.toString()),null}resolveBuiltinReturnTypeType(e,n,t=null,r=0){let i=this.ensureOneTypeArgument(e,r);if(!i)return null;let s=this.resolveType(i,n,t,r);if(!s)return null;let a=s.getSignature();return a?a.returnType:(r==0&&this.error(2757,i.range,s.toString()),null)}resolveBuiltinNotNullableType(e,n,t=null,r=0){let i=this.ensureOneTypeArgument(e,r);if(!i)return null;let s=this.resolveType(i,n,t,r);return s?s.isNullableReference?s.nonNullableType:s:null}resolveTypeName(e,n,t=0){let r=n.lookup(e.identifier.text,!0);if(!r)return t==0&&this.error(2304,e.range,e.identifier.text),null;let i=e,s=e.next;for(;s;){if(!(r=r.getMember(s.identifier.text)))return t==0&&this.error(2339,s.range,s.identifier.text,i.identifier.text),null;i=s,s=s.next}return r}resolveTypeArguments(e,n,t,r=new Map,i=null,s=0){var a=0,o=0;for(let p=0,d=e.length;p<d;++p)e[p].defaultType||++a,++o;let u=n?n.length:0;if(u<a||u>o)return s==0&&this.error(2558,u?fe.join(n[0].range,n[u-1].range):i.range,(u<a?a:o).toString(),u.toString()),null;let c=new Array(o),f=de(r);r.clear();for(let p=0;p<o;++p){let d=p<u?this.resolveType(n[p],t,f,s):this.resolveType(assert(e[p].defaultType),t,de(r),s);if(!d)return null;r.set(e[p].name.text,d),c[p]=d}return c}maybeInferCall(e,n,t,r=0){let i=e.typeArguments;if(i)return n.is(65536)?this.resolveFunctionInclTypeArguments(n,i,t.sourceFunction,de(t.contextualTypeArguments),e,r):(r==0&&this.error(2315,e.expression.range,n.internalName),null);if(n.is(65536)){let s=de(t.contextualTypeArguments),a=assert(n.typeParameterNodes),o=a.length,u=new Set;for(let g=0;g<o;++g){let E=a[g].name.text;s.set(E,l.auto),u.add(E)}let c=n.functionTypeNode.parameters,f=c.length,p=e.args,d=p.length;for(let g=0;g<f;++g){let E=g<d?p[g]:c[g].initializer;if(!E){if(c[g].parameterKind==1)continue;return r==0&&this.error(2554,e.range,f.toString(),d.toString()),null}let y=c[g].type;if(y.hasGenericComponent(a)){let b=this.resolveExpression(E,t,l.auto,1);b&&this.propagateInferredGenericTypes(y,b,n,s,u)}}let m=new Array(o);for(let g=0;g<o;++g){let E=a[g],y=E.name.text;if(s.has(y)){let b=assert(s.get(y));if(b!=l.auto){m[g]=b;continue}let T=E.defaultType;if(T){let S=n.parent,C=null;(S.kind==7||S.kind==5)&&(C=S.contextualTypeArguments);let w=this.resolveType(T,n,C,r);if(!w)return null;m[g]=w;continue}}return r==0&&this.error(1140,e.expression.range.atEnd),null}return this.resolveFunction(n,m,de(t.contextualTypeArguments),r)}return this.resolveFunction(n,null,new Map,r)}propagateInferredGenericTypes(e,n,t,r,i){if(e.kind==1){let s=e,a=s.typeArguments;if(a&&a.length>0){let o=n.classReference;if(o){let u=this.resolveTypeName(s.name,t);if(!u||u.kind!=6)return;if(o.prototype==u){let c=o.typeArguments;if(c&&c.length==a.length){for(let f=0,p=c.length;f<p;++f)this.propagateInferredGenericTypes(a[f],c[f],t,r,i);return}}}}else{let o=s.name.identifier.text;if(r.has(o)){let u=assert(r.get(o));(u==l.auto||i.has(o)&&u.isAssignableTo(n))&&r.set(o,n)}}}else if(e.kind==2){let s=e,a=s.parameters,o=n.signatureReference;if(o){let u=o.parameterTypes;for(let d=0,m=min(u.length,a.length);d<m;++d)this.propagateInferredGenericTypes(a[d].type,u[d],t,r,i);let c=o.returnType;c!=l.void&&this.propagateInferredGenericTypes(s.returnType,c,t,r,i);let f=o.thisType,p=s.explicitThisType;f&&p&&this.propagateInferredGenericTypes(p,f,t,r,i);return}}}getTypeOfElement(e){let n=e.kind;if(n==0&&!this.ensureResolvedLazyGlobal(e,1))return null;if($l(n)){let t=e.type,r=t.getClassOrWrapper(this.program);if(r){let i=r.wrappedType;i&&(t=i)}return t}return null}getElementOfType(e){return e.getClassOrWrapper(this.program)||null}lookupExpression(e,n,t=l.auto,r=0){for(;e.kind==20;)e=e.expression;switch(e.kind){case 7:return this.lookupAssertionExpression(e,n,t,r);case 8:return this.lookupBinaryExpression(e,n,t,r);case 9:return this.lookupCallExpression(e,n,t,r);case 11:return this.lookupCommaExpression(e,n,t,r);case 12:return this.lookupElementAccessExpression(e,n,t,r);case 14:return this.lookupFunctionExpression(e,n,t,r);case 6:case 13:case 18:case 25:return this.lookupIdentifierExpression(e,n,n.sourceFunction,r);case 24:return this.lookupThisExpression(e,n,t,r);case 23:return this.lookupSuperExpression(e,n,t,r);case 15:return this.lookupInstanceOfExpression(e,n,t,r);case 16:return this.lookupLiteralExpression(e,n,t,r);case 17:return this.lookupNewExpression(e,n,t,r);case 21:return this.lookupPropertyAccessExpression(e,n,t,r);case 22:return this.lookupTernaryExpression(e,n,t,r);case 27:return this.lookupUnaryPostfixExpression(e,n,t,r);case 28:return this.lookupUnaryPrefixExpression(e,n,t,r)}return assert(!1),null}resolveExpression(e,n,t=l.auto,r=0){let i=this.resolvingExpressions;if(i.has(e))return null;i.add(e);let s=this.doResolveExpression(e,n,t,r);return i.delete(e),s}doResolveExpression(e,n,t=l.auto,r=0){for(;e.kind==20;)e=e.expression;switch(e.kind){case 7:return this.resolveAssertionExpression(e,n,t,r);case 8:return this.resolveBinaryExpression(e,n,t,r);case 9:return this.resolveCallExpression(e,n,t,r);case 11:return this.resolveCommaExpression(e,n,t,r);case 12:return this.resolveElementAccessExpression(e,n,t,r);case 14:return this.resolveFunctionExpression(e,n,t,r);case 6:case 13:case 18:case 25:return this.resolveIdentifierExpression(e,n,t,n.sourceFunction,r);case 24:return this.resolveThisExpression(e,n,t,r);case 23:return this.resolveSuperExpression(e,n,t,r);case 15:return this.resolveInstanceOfExpression(e,n,t,r);case 16:return this.resolveLiteralExpression(e,n,t,r);case 17:return this.resolveNewExpression(e,n,t,r);case 21:return this.resolvePropertyAccessExpression(e,n,t,r);case 22:return this.resolveTernaryExpression(e,n,t,r);case 27:return this.resolveUnaryPostfixExpression(e,n,t,r);case 28:return this.resolveUnaryPrefixExpression(e,n,t,r)}return assert(!1),null}lookupIdentifierExpression(e,n,t=n.sourceFunction,r=0){switch(e.kind){case 25:case 13:case 18:{let o=this.resolveIdentifierExpression(e,n,l.auto,t,r);return o?this.getElementOfType(o):null}}let i=e.text,s;if(s=n.lookup(i))return this.currentThisExpression=null,this.currentElementExpression=null,s;let a=n.outer;return a&&(s=a.lookup(i))?(this.currentThisExpression=null,this.currentElementExpression=null,s):(s=t.lookup(i))?(this.currentThisExpression=null,this.currentElementExpression=null,s):(s=this.program.lookup(i))?(this.currentThisExpression=null,this.currentElementExpression=null,s):(r==0&&this.error(2304,e.range,i),null)}resolveIdentifierExpression(e,n,t=l.auto,r=n.sourceFunction,i=0){switch(e.kind){case 25:case 13:return l.bool;case 18:{let o=t.getClass();if(o)return o.type.asNullable();{let u=t.getSignature();if(u)return u.type.asNullable();if(t.isExternalReference)return t}return this.program.options.usizeType}}let s=this.lookupIdentifierExpression(e,n,r,i);if(!s)return null;if(s.kind==4){let o=this.resolveFunction(s,null,new Map,i);if(!o)return null;s=o}let a=this.getTypeOfElement(s);return a||i==0&&this.error(225,e.range),a}ensureResolvedLazyGlobal(e,n=0){if(e.is(4194304))return!0;let t=e.typeNode,r=t?this.resolveType(t,e.parent,null,n):this.resolveExpression(assert(e.initializerNode),e.file.startFunction.flow,l.auto,n);return r?(e.setType(r),!0):!1}lookupPropertyAccessExpression(e,n,t,r=0){let i=e.expression,s=this.lookupExpression(i,n,t,r);if(!s)return null;let a=e.property.text;switch(s.kind){case 0:if(!this.ensureResolvedLazyGlobal(s,r))return null;case 3:case 1:case 11:{let o=s,u=o.type;assert(u!=l.void);let c=u.getClassOrWrapper(this.program);if(!c)return r==0&&this.error(2339,e.property.range,a,o.type.toString()),null;s=c;break}case 12:{let o=this.resolveProperty(s,r);if(!o)return null;s=o}case 13:{let o=s,u=assert(o.getterInstance).signature.returnType,c=u.getClassOrWrapper(this.program);if(!c)return r==0&&this.error(2339,e.property.range,a,u.toString()),null;s=c;break}case 17:{let o=s.parent;assert(o.kind==7);let u=o,c=assert(this.currentElementExpression),f=u.lookupOverload(1);if(!f)return r==0&&this.error(2329,c.range,o.internalName),null;let p=f.signature.returnType,d=p.getClassOrWrapper(this.program);if(!d)return r==0&&this.error(2339,e.property.range,a,p.toString()),null;s=d;break}case 4:{let o=s.shadowType;if(o){if(!o.is(4194304)){let c=this.resolveType(o.typeNode,o.parent,null,r);c&&o.setType(c)}let u=o.type.classReference;u&&(s=u.prototype);break}else if(!s.is(65536)&&!s.getMember(a)){let u=this.resolveFunction(s,null,new Map,1);if(u){let c=u.type.getClassOrWrapper(this.program);c&&(s=c)}}break}}switch(s.kind){case 6:case 8:case 7:case 9:{do{let o=s.getMember(a);if(o){if(o.kind==12){let u=this.resolveProperty(o,r);if(!u)return null;o=u,u.is(32)?this.currentThisExpression=null:this.currentThisExpression=i}else this.currentThisExpression=i;return this.currentElementExpression=null,o}if(s.kind==6||s.kind==8){let u=s.basePrototype;if(u)s=u;else break}else if(s.kind==7||s.kind==9){let u=s.base;if(u)s=u;else break}else break}while(!0);break}default:{let o=s.internalName=="~lib/params/Params"?"__get":a,u=s.getMember(o);if(u)return this.currentThisExpression=i,this.currentElementExpression=null,u;break}}return r==0&&this.error(2339,e.property.range,a,s.internalName),null}resolvePropertyAccessExpression(e,n,t,r=0){let i=this.lookupPropertyAccessExpression(e,n,t,r);if(!i)return null;let s=this.getTypeOfElement(i);return s||r==0&&this.error(225,e.range),s}lookupElementAccessExpression(e,n,t,r=0){let i=e.expression,s=this.resolveExpression(i,n,t,r);if(!s)return null;let a=s.getClassOrWrapper(this.program);if(a)do{let o=a.indexSignature;if(o)return this.currentThisExpression=i,this.currentElementExpression=e.elementExpression,o;a=a.base}while(a);return r==0&&this.error(2329,i.range,s.toString()),null}resolveElementAccessExpression(e,n,t,r=0){let i=this.lookupElementAccessExpression(e,n,t,r);if(!i)return null;let s=this.getTypeOfElement(i);return s||r==0&&this.error(225,e.range),s}determineIntegerLiteralType(e,n,t){let r=e.value;if(n){if(i64_gt(i64_add(r,i64_minimum),i64_zero)){let i=e.range;this.error(236,i,i.source.text.substring(i.start-1,i.end))}else if(i64_eq(r,i64_zero)){if(t.isFloatValue)return t.kind==11?l.f32:l.f64;if(!t.isIntegerValue)return l.f64}r=i64_neg(r)}if(t.isValue)switch(t.kind){case 0:{if(i64_is_bool(r))return l.bool;break}case 1:{if(i64_is_i8(r))return l.i8;break}case 6:{if(i64_is_u8(r))return l.u8;break}case 2:{if(i64_is_i16(r))return l.i16;break}case 7:{if(i64_is_u16(r))return l.u16;break}case 3:{if(i64_is_i32(r))return l.i32;break}case 8:{if(i64_is_u32(r))return l.u32;break}case 5:{if(!this.program.options.isWasm64){if(i64_is_i32(r))return l.isize32;break}return l.isize64}case 10:{if(!this.program.options.isWasm64){if(i64_is_u32(r))return l.usize32;break}return l.usize64}case 4:return l.i64;case 9:return l.u64;case 11:return l.f32;case 12:return l.f64}return i64_is_i32(r)?l.i32:i64_is_u32(r)?l.u32:l.i64}lookupAssertionExpression(e,n,t=l.auto,r=0){switch(e.assertionKind){case 1:case 0:{let i=this.resolveType(assert(e.toType),n.sourceFunction,n.contextualTypeArguments,r);return i?this.getElementOfType(i)||(r==0&&this.error(214,e.range,i.toString()),this.currentThisExpression=null,this.currentElementExpression=null,null):null}case 2:return this.lookupExpression(e.expression,n,t,r);case 3:return this.error(100,e.range,"Const assertion"),null}return assert(!1),null}resolveAssertionExpression(e,n,t=l.auto,r=0){switch(e.assertionKind){case 1:case 0:return this.resolveType(assert(e.toType),n.sourceFunction,n.contextualTypeArguments,r);case 2:{let i=this.resolveExpression(e.expression,n,t,r);return i?i.nonNullableType:null}case 3:{let i=this.lookupExpression(e,n,t,r);if(!i)return null;let s=this.getTypeOfElement(i);return s||r==0&&this.error(225,e.range),s}default:assert(!1)}return null}lookupUnaryPrefixExpression(e,n,t=l.auto,r=0){let i=this.resolveUnaryPrefixExpression(e,n,t,r);if(!i)return null;let s=this.getElementOfType(i);return s||r==0&&this.error(2469,e.range,Ue(e.operator),i.toString()),s}resolveUnaryPrefixExpression(e,n,t=l.auto,r=0){let i=e.operand,s=e.operator;switch(s){case 82:if(i.isLiteralKind(1))return this.determineIntegerLiteralType(i,!0,t);case 81:case 87:case 88:{let a=this.resolveExpression(i,n,t,r);if(!a)return null;let o=a.getClassOrWrapper(this.program);if(o){let u=o.lookupOverload(Ye.fromUnaryPrefixToken(s));if(u)return u.signature.returnType}return a.isNumericValue?a:(r==0&&this.error(2469,e.range,Ue(s),a.toString()),null)}case 95:{let a=this.resolveExpression(i,n,t,r);if(!a)return null;let o=a.getClassOrWrapper(this.program);if(o){let u=o.lookupOverload(25);if(u)return u.signature.returnType}return l.bool}case 96:{let a=this.resolveExpression(i,n,t,r);if(!a)return null;let o=a.getClassOrWrapper(this.program);if(o){let u=o.lookupOverload(26);if(u)return u.signature.returnType}return a.isNumericValue?a.intType:(r==0&&this.error(2469,e.range,"~",a.toString()),null)}case 69:return r==0&&this.error(100,e.range,"Spread operator"),null;case 56:return this.program.stringInstance.type;default:assert(!1)}return null}lookupUnaryPostfixExpression(e,n,t=l.auto,r=0){let i=this.resolveUnaryPostfixExpression(e,n,t,r);if(!i)return null;let s=this.getElementOfType(i);return s||r==0&&this.error(2469,e.range,Ue(e.operator),i.toString()),s}resolveUnaryPostfixExpression(e,n,t=l.auto,r=0){let i=e.operator;switch(i){case 87:case 88:{let s=this.resolveExpression(e.operand,n,t,r);if(!s)return null;let a=s.getClassOrWrapper(this.program);if(a){let o=a.lookupOverload(Ye.fromUnaryPostfixToken(i));if(o)return o.signature.returnType}return s.isNumericValue?s:(r==0&&this.error(2469,e.range,Ue(i),s.toString()),null)}}return assert(!1),null}lookupBinaryExpression(e,n,t=l.auto,r=0){let i=this.resolveBinaryExpression(e,n,t,r);return i?this.getElementOfType(i)||(r==0&&this.error(214,e.range,i.toString()),null):null}resolveBinaryExpression(e,n,t=l.auto,r=0){let i=e.left,s=e.right,a=e.operator;switch(a){case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 112:case 113:return this.resolveExpression(i,n,t,r);case 72:case 73:case 74:case 75:{let o=this.resolveExpression(i,n,t,r);if(!o)return null;let u=o.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(Ye.fromBinaryToken(a));if(c)return c.signature.returnType}return o.isNumericValue?l.bool:(r==0&&this.error(2469,e.range,Ue(a),o.toString()),null)}case 76:case 77:{let o=this.resolveExpression(i,n,t,r);if(!o)return null;let u=o.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(Ye.fromBinaryToken(a));if(c)return c.signature.returnType}return l.bool}case 78:case 79:return l.bool;case 81:case 82:case 84:case 85:case 86:case 83:{let o=this.resolveExpression(i,n,t,r);if(!o)return null;let u=o.getClassOrWrapper(this.program);if(u){let p=u.lookupOverload(Ye.fromBinaryToken(a));if(p)return p.signature.returnType}let c=this.resolveExpression(s,n,o,r);if(!c)return null;let f=l.commonDenominator(o,c,!1);return f||r==0&&this.error(2365,e.range,o.toString(),c.toString()),f}case 89:case 90:case 91:{let o=this.resolveExpression(i,n,t,r);if(!o)return null;let u=o.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(Ye.fromBinaryToken(a));if(c)return c.signature.returnType}return o.isIntegerValue?o:(r==0&&this.error(2469,e.range,Ue(a),o.toString()),null)}case 92:case 93:case 94:{let o=this.resolveExpression(i,n,t,r);if(!o)return null;let u=o.getClassOrWrapper(this.program);if(u){let p=u.lookupOverload(Ye.fromBinaryToken(a));if(p)return p.signature.returnType}let c=this.resolveExpression(s,n,t,r);if(!c)return null;let f=l.commonDenominator(o,c,!1);return(!f||!f.isIntegerValue)&&r==0&&this.error(2365,e.range,Ue(a),o.toString(),c.toString()),f}case 97:case 98:return this.resolveExpression(i,n,t,r)}return assert(!1),null}lookupThisExpression(e,n,t=l.auto,r=0){if(n.isInline){let s=n.lookupLocal(v.this_);if(s)return this.currentThisExpression=null,this.currentElementExpression=null,s}let i=n.sourceFunction.parent;return i?(this.currentThisExpression=null,this.currentElementExpression=null,i):(r==0&&this.error(2332,e.range),null)}resolveThisExpression(e,n,t=l.auto,r=0){let i=this.lookupThisExpression(e,n,t,r);if(!i)return null;let s=this.getTypeOfElement(i);return s||r==0&&this.error(225,e.range),s}lookupSuperExpression(e,n,t=l.auto,r=0){if(n.isInline){let s=n.lookupLocal(v.super_);if(s)return this.currentThisExpression=null,this.currentElementExpression=null,s}let i=n.sourceFunction.parent;if(i&&i.kind==7){let s=i.base;if(s)return this.currentThisExpression=null,this.currentElementExpression=null,s}return r==0&&this.error(2335,e.range),null}resolveSuperExpression(e,n,t=l.auto,r=0){let i=this.lookupSuperExpression(e,n,t,r);if(!i)return null;let s=this.getTypeOfElement(i);return s||r==0&&this.error(225,e.range),s}lookupLiteralExpression(e,n,t=l.auto,r=0){switch(this.currentThisExpression=e,this.currentElementExpression=null,e.literalKind){case 1:{let i=this.determineIntegerLiteralType(e,!1,t);return assert(i.getClassOrWrapper(this.program))}case 0:{let i=t==l.f32?l.f32:l.f64;return assert(i.getClassOrWrapper(this.program))}case 2:case 3:return this.program.stringInstance;case 4:return this.program.regexpInstance;case 5:{let i=t.getClass();if(i&&i.prototype==this.program.arrayPrototype)return this.getElementOfType(t);let s=e.elementExpressions,a=s.length,o=l.u8,u=0;for(let c=0,f=a;c<f;++c){let p=s[c];if(p)if(p.kind==18&&a>1)++u;else{let d=l.u8;if(p.kind!=19&&(d=this.resolveExpression(p,n,o),!d))return null;if(d!=o){let m=l.commonDenominator(o,d,!1);m&&(o=m)}}}return o==l.u8?u>0?(r==0&&this.error(204,e.range,"u8"),null):assert(this.resolveClass(this.program.byteArrayPrototype)):(u>0&&o.isInternalReference&&(o=o.asNullable()),assert(this.resolveClass(this.program.arrayPrototype,[o])))}case 6:return t.isClass?t.classReference:(r==0&&this.error(225,e.range),null)}return assert(!1),null}resolveLiteralExpression(e,n,t=l.auto,r=0){let i=this.lookupLiteralExpression(e,n,t,r);if(!i)return null;let s=this.getTypeOfElement(i);return s||r==0&&this.error(225,e.range),s}lookupCallExpression(e,n,t=l.void,r=0){let i=this.resolveCallExpression(e,n,t,r);if(!i)return null;let s=this.getElementOfType(i);return s||r==0&&this.error(214,e.range,i.toString()),s}resolveCallExpression(e,n,t=l.void,r=0){let i=e.expression,s=this.lookupExpression(i,n,t,r);if(!s)return null;switch(s.kind){case 4:{let a=s;if(a.internalName==h.unchecked&&e.args.length>0)return this.resolveExpression(e.args[0],n,t,r);let o=this.maybeInferCall(e,a,n,r);return o?o.signature.returnType:null}case 0:case 1:case 11:{let a=s.type,o=this.getElementOfType(a);if(!o||o.kind!=7)break;s=o}case 7:{let a=s.getTypeArgumentsTo(this.program.functionPrototype);if(a&&a.length>0){let o=a[0];return assert(o.signatureReference).returnType}break}}return r==0&&this.error(2349,i.range,s.internalName),null}lookupCommaExpression(e,n,t=l.auto,r=0){let i=e.expressions;return this.lookupExpression(i[assert(i.length)-1],n,t,r)}resolveCommaExpression(e,n,t=l.auto,r=0){let i=e.expressions;return this.resolveExpression(i[assert(i.length)-1],n,t,r)}lookupInstanceOfExpression(e,n,t=l.auto,r=0){return assert(l.bool.getClassOrWrapper(this.program))}resolveInstanceOfExpression(e,n,t=l.auto,r=0){return l.bool}lookupTernaryExpression(e,n,t,r=0){let i=this.resolveTernaryExpression(e,n,t,r);if(!i)return null;let s=this.getElementOfType(i);return s||r==0&&this.error(214,e.range,i.toString()),s}resolveTernaryExpression(e,n,t,r=0){let i=this.resolveExpression(e.ifThen,n,t,r);if(!i)return null;let s=this.resolveExpression(e.ifElse,n,i,r);if(!s)return null;let a=l.commonDenominator(i,s,!1);return a||r==0&&this.error(2365,e.range,"?:",i.toString(),s.toString()),a}lookupNewExpression(e,n,t,r=0){let i=this.resolveTypeName(e.typeName,n.sourceFunction,r);return i?i.kind==6?this.resolveClassInclTypeArguments(i,e.typeArguments,n.sourceFunction,de(n.contextualTypeArguments),e,r):(r==0&&this.error(2351,e.range),null):null}resolveNewExpression(e,n,t,r=0){let i=this.lookupNewExpression(e,n,t,r);if(!i)return null;let s=this.getTypeOfElement(i);return s||r==0&&this.error(225,e.range),s}lookupFunctionExpression(e,n,t,r=0){let i=this.resolveFunctionExpression(e,n,t,r);if(!i)return null;let s=this.getElementOfType(i);return s||r==0&&this.error(214,e.range,i.toString()),s}resolveFunctionExpression(e,n,t,r=0){let i=e.declaration,s=i.signature,a=i.body,o=this.resolveFunctionType(s,n.sourceFunction,n.contextualTypeArguments,r);if(o&&i.arrowKind!=0&&a&&a.kind==38&&Ve(s.returnType)){let u=a.expression,c=assert(o.getSignature()),f=Wn.createDefault(n.sourceFunction),p=s.parameters;assert(c.parameterTypes.length==p.length);for(let m=0,g=p.length;m<g;m++){let E=p[m],y=c.parameterTypes[m];f.addScopedDummyLocal(E.name.text,y,E)}let d=this.resolveExpression(u,f,t,r);d&&(c.returnType=d)}return o}resolveFunction(e,n,t=new Map,r=0){let i=e.parent.kind==12?e.parent.parent:e.parent,s=null,a=n?Ci(n):"";if(e.is(262144)){assert(i.kind==7||i.kind==9),s=i;let C=e.getResolvedInstance(a);if(C)return C;let w=s.typeArguments;if(w){let B=assert(s.prototype.typeParameterNodes),D=B.length;assert(D==B.length);for(let W=0;W<D;++W){let P=B[W].name.text;t.set(P,w[W])}}}else{assert(i.kind!=7);let C=e.getResolvedInstance(a);if(C)return C}let o=e.functionTypeNode,u=e.typeParameterNodes,c;if(n&&(c=n.length)>0){assert(u&&c==u.length);for(let C=0;C<c;++C)t.set(u[C].name.text,n[C])}else assert(!u||u.length==0);let f=null,p=o.explicitThisType;if(p){if(f=this.resolveType(p,e.parent,t,r),!f)return null;t.set(v.this_,f)}else s&&(f=s.type,t.set(v.this_,f));let d=o.parameters,m=d.length,g=new Array(m),E=0;for(let C=0;C<m;++C){let w=d[C];w.parameterKind==0&&(E=C+1);let B=w.type;if(Ve(B))return r==0&&this.error(1110,B.range),null;let D=this.resolveType(B,e.parent,t,r);if(!D)return null;if(D==l.void)return r==0&&this.error(1110,B.range),null;g[C]=D}let y;if(e.is(4096))y=l.void;else if(e.is(524288))y=s.type;else{let C=o.returnType;if(Ve(C))return r==0&&this.error(1110,C.range),null;let w=this.resolveType(C,e.parent,t,r);if(!w)return null;y=w}let b=new tn(this.program,g,y,f);b.requiredParameters=E;let T=e.name;a.length&&(T+=`<${a}>`);let S=new Hn(T,e,n,b,t);if(e.setResolvedInstance(a,S),s){let C=S.declaration.name.text,w=s.base;for(;w;){let B=w.members;if(B&&B.has(C)){this.discoveredOverload=!0;break}w=w.base}}return S}resolveFunctionInclTypeArguments(e,n,t,r,i,s=0){let a=e.parent.kind==12?e.parent.parent:e.parent,o=null;if(e.is(65536)){if(e.is(262144)){assert(a.kind==7);let u=a,c=u.typeArguments;if(c){let f=assert(u.prototype.typeParameterNodes),p=c.length;assert(p==f.length);for(let d=0;d<p;++d)r.set(f[d].name.text,c[d])}}if(o=this.resolveTypeArguments(assert(e.typeParameterNodes),n,t,r,i,s),!o)return null}else if(n&&n.length>0)return s==0&&this.error(2315,i.range,e.internalName),null;return this.resolveFunction(e,o,r,s)}resolveOverloads(e){let n=e.prototype.overloads;if(!n)return null;let t=assert(e.getClassOrInterface()),r=new Set;for(let i=Set_values(n),s=0,a=i.length;s<a;++s){let o=i[s];assert(!o.isBound);let u=o.parent,c=u.kind==12,f;if(c){let p=u.parent;assert(p.kind==6),f=p.instances}else assert(u.kind==6),f=u.instances;if(f)for(let p=Map_values(f),d=0,m=p.length;d<m;++d){let g=p[d];if(!g.isAssignableTo(t))continue;let E;if(c){let y=assert(g.members.get(u.name));assert(y.kind==12);let b=this.resolveProperty(y);if(!b)continue;e.is(2048)?E=b.getterInstance:(assert(e.is(4096)),E=b.setterInstance)}else{let y=assert(g.members.get(o.name));assert(y.kind==4),E=this.resolveFunction(y,e.typeArguments)}E&&r.add(E)}}return Set_values(r)}resolveClass(e,n,t=new Map,r=0){let i=n?Ci(n):"",s=e.getResolvedInstance(i);if(s)return s;let a=e.name;i.length&&(a+=`<${i}>`),e.kind==8?s=new iu(a,e,n):s=new ps(a,e,n),e.setResolvedInstance(i,s);let o=this.resolveClassPending;if(o.add(s),n){let p=assert(e.typeParameterNodes),d=p.length,m=n.length;assert(m==d);for(let g=0;g<m;++g)t.set(p[g].name.text,n[g])}else{let p=e.typeParameterNodes;assert(!(p&&p.length>0))}s.contextualTypeArguments=t;let u=!1,c=e.basePrototype;if(c){let p=c;do{if(p==e)return this.error(2506,e.identifierNode.range,e.internalName),null;p=p.basePrototype}while(p);let d=assert(e.extendsNode),m=this.resolveClassInclTypeArguments(c,d.typeArguments,e.parent,de(t),d,r);if(!m)return null;s.setBase(m),o.has(m)&&(u=!0)}let f=e.interfacePrototypes;if(f)for(let p=0,d=f.length;p<d;++p){let m=f[p],g=m;do{if(g==e)return this.error(2506,e.identifierNode.range,e.internalName),null;g=g.basePrototype}while(g);let E=assert(e.implementsNodes[p]),y=this.resolveClassInclTypeArguments(m,E.typeArguments,e.parent,de(t),E,r);if(!y)return null;assert(y.kind==9),s.addInterface(y),o.has(y)&&(u=!0)}return u||this.finishResolveClass(s,r),s}finishResolveClass(e,n){let t=e.members;t||(e.members=t=new Map);let r=this.resolveClassPending,i=new Map,s=e.interfaces;if(s)for(let d=Set_values(s),m=0,g=d.length;m<g;++m){let E=d[m];assert(!r.has(E));let y=E.members;if(y)for(let b=Map_keys(y),T=0,S=b.length;T<S;++T){let C=unchecked(b[T]),w=assert(y.get(C));if(t.has(C)){let B=assert(t.get(C));if(!w.isCompatibleOverride(B)){this.errorRelated(2394,w.identifierAndSignatureRange,B.identifierAndSignatureRange);continue}}t.set(C,w),i.set(C,w)}}let a=0,o=e.base;if(o){assert(!r.has(o));let d=o.members;if(d)for(let m=Map_keys(d),g=0,E=m.length;g<E;++g){let y=unchecked(m[g]),b=assert(d.get(y));if(t.has(y)){let T=assert(t.get(y));if(!b.isCompatibleOverride(T)){this.errorRelated(2394,b.identifierAndSignatureRange,T.identifierAndSignatureRange);continue}}t.set(y,b),b.is(128)?i.set(y,b):i.delete(y)}a=o.nextMemoryOffset}let u=e.prototype,c=u.instanceMembers,f=new Array;if(c)for(let d=Map_values(c),m=0,g=d.length;m<g;++m){let E=unchecked(d[m]),y=E.name;switch(E.kind){case 10:{let b=E,T=b.typeNode,S=null,C=null;if(o){let B=o.members;if(B&&B.has(b.name)){let D=assert(B.get(b.name));D.kind==11?C=D:this.errorRelated(2300,b.identifierNode.range,D.identifierNode.range,b.name)}}if(!T)C&&!C.is(512)&&(S=C.type),S||n==0&&this.error(1110,b.identifierNode.range.atEnd);else if(S=this.resolveType(T,u.parent,e.contextualTypeArguments,n),S==l.void){n==0&&this.error(1110,T.range);break}if(!S)break;if(C){let B=o;b.is(512)?C.is(512)?this.errorRelated(2442,b.identifierNode.range,C.identifierNode.range,b.name):this.errorRelated(2325,b.identifierNode.range,C.identifierNode.range,b.name,e.internalName,B.internalName):b.is(1024)?C.is(512)?this.errorRelated(2325,b.identifierNode.range,C.identifierNode.range,b.name,B.internalName,e.internalName):C.is(1024)||this.errorRelated(2444,b.identifierNode.range,C.identifierNode.range,b.name,e.internalName,B.internalName):C.is(512)&&this.errorRelated(2325,b.identifierNode.range,C.identifierNode.range,b.name,B.internalName,e.internalName),S!=C.type&&(this.errorRelated(2416,b.identifierNode.range,C.identifierNode.range,b.name,e.internalName,B.internalName),S=C.type)}let w=new eu(b,e,S);if(assert(nr(S.byteSize)),C)w.memoryOffset=C.memoryOffset;else{let B=S.byteSize-1;a&B&&(a=(a|B)+1),w.memoryOffset=a,a+=S.byteSize}e.add(y,w);break}case 4:{let b=E.toBound(e);e.add(b.name,b);break}case 12:{let b=E.toBound(e);e.add(b.name,b);break}default:assert(!1)}E.is(128)||i.delete(y)}for(let d=0,m=f.length;d<m;++d){let g=f[d],E=g.getterInstance;if(!E)this.error(229,g.identifierNode.range,g.name);else{let y=g.setterInstance;y&&!E.visibilityEquals(y)&&this.errorRelated(2379,E.identifierNode.range,y.identifierNode.range)}}if(e.kind!=9){if(!e.is(128)&&i.size>0)for(let d=Map_keys(i),m=0,g=d.length;m<g;++m){let E=d[m],y=assert(i.get(E));this.errorRelated(2515,e.identifierNode.range,y.identifierNode.range,e.internalName,E,y.parent.internalName)}e.nextMemoryOffset=a;{let d=e.getMember(v.constructor);if(d&&d.parent==e){assert(d.kind==4);let m=this.resolveFunction(d,null,assert(e.contextualTypeArguments),n);m&&(e.constructorInstance=m)}}}let p=u.overloadPrototypes;for(let d=Map_keys(p),m=0,g=d.length;m<g;++m){let E=unchecked(d[m]),y=assert(p.get(E));if(assert(E!=0),y.is(65536))continue;let b;if(y.is(262144)){let S=y.toBound(e);b=this.resolveFunction(S,null,new Map,n)}else b=this.resolveFunction(y,null,new Map,n);if(!b)continue;let T=e.overloads;if(T||(e.overloads=T=new Map),b.is(262144))switch(E){case 27:case 28:case 29:case 30:{let S=b.signature.returnType;S.isAssignableTo(e.type)||n==0&&this.error(2322,y.functionTypeNode.returnType.range,S.toString(),e.type.toString())}}if(T.has(E))n==0&&this.error(213,b.declaration.range);else if(T.set(E,b),E==1||E==2){let S=e.indexSignature;S||(e.indexSignature=S=new tu(e)),E==1&&S.setType(b.signature.returnType)}}assert(r.has(e)),r.delete(e);for(let d=Set_values(r),m=0,g=d.length;m<g;++m){let E=d[m],y=E.base==e,b=E.interfaces;if(b){let T=!1;for(let S=Set_values(b),C=0,w=S.length;C<w;++C){let B=S[C];B==e?y=!0:r.has(B)&&(T=!0)}if(T)continue}y&&this.finishResolveClass(E,n)}}resolveClassInclTypeArguments(e,n,t,r,i,s=0){let a=null;if(e.is(65536)){if(a=this.resolveTypeArguments(assert(e.typeParameterNodes),n,t,r,i,s),!a)return null}else if(n&&n.length>0)return s==0&&this.error(2315,i.range,e.internalName),null;return this.resolveClass(e,a,r,s)}resolveProperty(e,n=0){let t=e.instance;if(t)return t;e.instance=t=new nu(e,e);let r=e.getterPrototype;if(r){let s=this.resolveFunction(r,null,new Map,n);s&&(t.getterInstance=s,t.setType(s.signature.returnType))}let i=e.setterPrototype;if(i){let s=this.resolveFunction(i,null,new Map,n);s&&(t.setterInstance=s,t.is(4194304)||(assert(s.signature.parameterTypes.length==1),t.setType(s.signature.parameterTypes[0])))}return t}ensureOneTypeArgument(e,n=0){let t=e.typeArguments,r=0;return!t||(r=t.length)!=1?(n==0&&this.error(2558,e.range,"1",r.toString()),null):t[0]}},Ls=class{constructor(e,n){this.source=e,this.reportNode=n}},Xl=class extends mt{constructor(e=null,n=[]){super(e),this.backlog=new Array,this.seenlog=new Set,this.donelog=new Set,this.onComment=null,this.currentSource=null,this.dependees=new Map,this.currentModuleName=null,this.tryParseSignatureIsSignature=!1,this.parseParametersThis=null,this.sources=n}parseFile(e,n,t){let r=Lr(n),i=Rr(r);if(this.donelog.has(i))return;if(this.donelog.add(i),this.seenlog.add(i),e==null){let u=this.dependees,c=null;u.has(i)&&(c=assert(u.get(i))),this.error(6054,c?c.reportNode.range:null,n);return}let s=new Ji(t?1:n.startsWith(Cn)?n.indexOf(Xn,Cn.length)<0?3:2:0,r,e);this.sources.push(s),this.currentSource=s,this.currentModuleName=null;let a=new ol(s,this.diagnostics);a.onComment=this.onComment;let o=s.statements;for(;!a.skip(121);){let u=this.parseTopLevelStatement(a,null);u?o.push(u):this.skipStatement(a)}}parseTopLevelStatement(e,n=null){let t=n?n.flags&32768:0,r=-1,i=null;for(;e.skip(114);){r<0&&(r=e.tokenPos);let g=this.parseDecorator(e);if(!g){this.skipStatement(e);continue}i?i.push(g):i=[g]}let s=0,a=0,o=0,u=0;e.skip(18)&&(r<0&&(r=e.tokenPos),t|=2,s=e.tokenPos,a=e.pos,e.skip(13)&&(o=e.tokenPos,u=e.pos));let c=0,f=0,p=n!=null&&n.is(32768);e.skip(12)?p?this.error(1038,e.range()):(r<0&&(r=e.tokenPos),c=r,f=e.pos,t|=32772):p&&(t|=32768);let d=null,m=e.peek();switch(r<0&&(r=e.nextTokenPos),m){case 8:{e.next(),t|=8,e.skip(17)?d=this.parseEnum(e,t,i,r):d=this.parseVariable(e,t,i,r),i=null;break}case 34:t|=16;case 57:{e.next(),d=this.parseVariable(e,t,i,r),i=null;break}case 17:{e.next(),d=this.parseEnum(e,t,i,r),i=null;break}case 24:{e.next(),d=this.parseFunction(e,t,i,r),d&&d.flags&2&&(t|=2),i=null;break}case 0:{let g=e.mark();e.next();let E=e.tokenPos,y=e.pos,b=e.peek(!0);if(e.nextTokenOnNewLine){e.reset(g),d=this.parseStatement(e,!0);break}if(b!=7){b==31&&this.error(1242,e.range(E,y)),e.reset(g),d=this.parseStatement(e,!0);break}else e.discard(g);t|=128}case 7:case 31:{e.next(),d=this.parseClassOrInterface(e,t,i,r),i=null;break}case 36:{let g=e.mark();e.next(),e.peek(!1,1)==115?(e.discard(g),d=this.parseNamespace(e,t,i,r),i=null):(e.reset(g),d=this.parseStatement(e,!0));break}case 28:{e.next(),t|=1,t&2?d=this.parseExportImport(e,r):d=this.parseImport(e);break}case 55:{let g=e.mark();e.next(),e.peek(!1,1)==115?(e.discard(g),d=this.parseTypeDeclaration(e,t,i,r),i=null):(e.reset(g),d=this.parseStatement(e,!0));break}case 35:{let g=e.mark();e.next(),e.peek(!0)==116&&!e.nextTokenOnNewLine?(e.discard(g),d=this.parseModuleDeclaration(e,t)):(e.reset(g),d=this.parseStatement(e,!0));break}default:{t&2?u&&e.skipIdentifier(1)?(f&&this.error(1120,e.range(c,f)),d=this.parseExportDefaultAlias(e,r,o,u),o=u=0):d=this.parseExport(e,r,(t&4)!=0):(a&&this.error(1042,e.range(s,a),"export"),f&&this.error(1042,e.range(c,f),"declare"),n||(d=this.parseStatement(e,!0)));break}}if(i)for(let g=0,E=i.length;g<E;++g)this.error(1206,i[g].range);if(u&&d!=null)switch(d.kind){case 52:case 55:case 51:case 57:case 59:return F.createExportDefaultStatement(d,e.range(r,e.pos));default:this.error(1042,e.range(o,u),"default")}return d}nextFile(){let e=this.backlog;return e.length?assert(e.shift()):null}getDependee(e){let n=this.dependees;return n.has(e)?assert(n.get(e)).source.internalPath:null}finish(){if(this.backlog.length)throw new Error("backlog is not empty");this.backlog=[],this.seenlog.clear(),this.donelog.clear(),this.dependees.clear()}parseTypeName(e){let n=F.createSimpleTypeName(e.readIdentifier(),e.range()),t=n;for(;e.skip(68);)if(e.skip(115)){let r=F.createSimpleTypeName(e.readIdentifier(),e.range());t.next=r,t=r}else return this.error(1003,e.range(e.pos)),null;return n}parseType(e,n=!0,t=!1){let r=e.next(),i=e.tokenPos,s;if(r==64){let a=e.skip(64),o=this.tryParseFunctionType(e);if(o){if(a){if(!e.skip(65))return this.error(1005,e.range(),")"),null;if(!e.skip(93))return this.error(1005,e.range(),"|"),null;e.skip(38)||this.error(1005,e.range(),"null"),o.isNullable=!0}return o}else if(a||this.tryParseSignatureIsSignature)return this.error(1012,e.range()),null;if(n){let u=this.parseType(e,!1,t);if(!u)return null;if(!e.skip(65))return t||this.error(1005,e.range(e.pos),")"),null;s=u,s.range.start=i,s.range.end=e.pos}else return this.error(1012,e.range()),null}else if(r==58)s=F.createNamedType(F.createSimpleTypeName("void",e.range()),[],!1,e.range(i,e.pos));else if(r==51)s=F.createNamedType(F.createSimpleTypeName("this",e.range()),[],!1,e.range(i,e.pos));else if(r==53||r==20)s=F.createNamedType(F.createSimpleTypeName("bool",e.range()),[],!1,e.range(i,e.pos));else if(r==38)s=F.createNamedType(F.createSimpleTypeName("null",e.range()),[],!1,e.range(i,e.pos));else if(r==116)e.readString(),s=F.createNamedType(F.createSimpleTypeName("string",e.range()),[],!1,e.range(i,e.pos));else if(r==115){let a=this.parseTypeName(e);if(!a)return null;let o=null;if(e.skip(72)){do{let u=this.parseType(e,!0,t);if(!u)return null;o?o.push(u):o=[u]}while(e.skip(71));if(!e.skip(73))return t||this.error(1005,e.range(e.pos),">"),null}o||(o=[]),s=F.createNamedType(a,o,!1,e.range(i,e.pos))}else return t||this.error(1110,e.range()),null;for(;e.skip(93);)if(e.skip(38))s.isNullable=!0;else{let a=e.pos,o=this.parseType(e,!1,!0);return t||this.error(1005,o?o.range:e.range(a),"null"),null}for(;e.skip(66);){let a=e.tokenPos;if(!e.skip(67))return t||this.error(1005,e.range(),"]"),null;let o=e.range(a,e.pos),u=!1;if(e.skip(93))if(e.skip(38))u=!0;else return t||this.error(1005,e.range(),"null"),null;if(s=F.createNamedType(F.createSimpleTypeName("Array",o),[s],u,e.range(i,e.pos)),u)break}return s}tryParseFunctionType(e){let n=e.mark(),t=e.tokenPos,r=null,i=null,s=!1,a=null,o=0;if(e.skip(65))s=!0,e.discard(n),r=[];else{s=!1;do{let c=-1,f=0;if(e.skip(69)&&(c=e.tokenPos,s=!0,e.discard(n),f=2),e.skip(51))if(c<0&&(c=e.tokenPos),e.skip(100)){s=!0,e.discard(n);let p=this.parseType(e,!1);if(!p)return null;if(p.kind!=1)return this.error(1003,p.range),this.tryParseSignatureIsSignature=!0,null;i=p}else return e.reset(n),this.tryParseSignatureIsSignature=!1,null;else if(e.skipIdentifier()){c<0&&(c=e.tokenPos);let p=F.createIdentifierExpression(e.readIdentifier(),e.range(e.tokenPos,e.pos));if(e.skip(99)&&(s=!0,e.discard(n),f==2?this.error(1047,e.range()):f=1),e.skip(100)){s=!0,e.discard(n);let d=this.parseType(e);if(!d)return this.tryParseSignatureIsSignature=s,null;let m=F.createParameter(f,p,d,null,e.range(c,e.pos));r?r.push(m):r=[m]}else if(s||e.peek()==71&&(s=!0,e.discard(n)),s){let d=F.createParameter(f,p,F.createOmittedType(e.range(e.pos)),null,e.range(c,e.pos));r?r.push(d):r=[d],this.error(1110,d.type.range)}else r||(a=p,o=f)}else return s?this.error(1003,e.range()):e.reset(n),this.tryParseSignatureIsSignature=s,null}while(e.skip(71));if(!e.skip(65))return s?this.error(1005,e.range(),")"):e.reset(n),this.tryParseSignatureIsSignature=s,null}let u;if(e.skip(80)){if(!s&&(s=!0,e.discard(n),a)){let c=F.createParameter(o,a,F.createOmittedType(a.range.atEnd),null,a.range);r?r.push(c):r=[c],this.error(1110,c.type.range)}if(u=this.parseType(e),!u)return this.tryParseSignatureIsSignature=s,null}else return s?this.error(1005,e.range(),"=>"):e.reset(n),this.tryParseSignatureIsSignature=s,null;return this.tryParseSignatureIsSignature=!0,r||(r=[]),F.createFunctionType(r,u,i,!1,e.range(t,e.pos))}parseDecorator(e){let n=e.tokenPos;if(e.skipIdentifier()){let t=e.readIdentifier(),r=F.createIdentifierExpression(t,e.range(n,e.pos));for(;e.skip(68);)if(e.skipIdentifier(1))t=e.readIdentifier(),r=F.createPropertyAccessExpression(r,F.createIdentifierExpression(t,e.range()),e.range(n,e.pos));else return this.error(1003,e.range()),null;let i;if(e.skip(64)){if(i=this.parseArguments(e),i)return F.createDecorator(r,i,e.range(n,e.pos))}else return F.createDecorator(r,null,e.range(n,e.pos))}else this.error(1003,e.range());return null}parseVariable(e,n,t,r,i=!1){let s=new Array;do{let o=this.parseVariableDeclaration(e,n,t,i);if(!o)return null;o.overriddenModuleName=this.currentModuleName,s.push(o)}while(e.skip(71));let a=F.createVariableStatement(t,s,e.range(r,e.pos));return e.skip(70),a}parseVariableDeclaration(e,n,t,r=!1){if(!e.skipIdentifier())return this.error(1003,e.range()),null;let i=F.createIdentifierExpression(e.readIdentifier(),e.range());al(i.text)&&this.error(1003,i.range);let s=n;e.skip(95)&&(s|=16384);let a=null;e.skip(100)&&(a=this.parseType(e,!0));let o=null;if(e.skip(101)){if(s&32768&&this.error(1039,e.range()),o=this.parseExpression(e,ge.Comma+1),!o)return null}else r||(s&8?s&32768||this.error(1155,i.range):a||this.error(1110,e.range(e.pos)));let u=fe.join(i.range,e.range());return o&&(s&16384)!=0&&this.error(1255,u),F.createVariableDeclaration(i,t,s,a,o,u)}parseEnum(e,n,t,r){if(e.next()!=115)return this.error(1003,e.range()),null;let i=F.createIdentifierExpression(e.readIdentifier(),e.range());if(e.next()!=62)return this.error(1005,e.range(),"{"),null;let s=new Array;for(;!e.skip(63);){let o=this.parseEnumValue(e,0);if(!o)return null;if(s.push(o),!e.skip(71)){if(e.skip(63))break;return this.error(1005,e.range(),"}"),null}}let a=F.createEnumDeclaration(i,t,n,s,e.range(r,e.pos));return a.overriddenModuleName=this.currentModuleName,e.skip(70),a}parseEnumValue(e,n){if(!e.skipIdentifier())return this.error(1003,e.range()),null;let t=F.createIdentifierExpression(e.readIdentifier(),e.range()),r=null;return e.skip(101)&&(r=this.parseExpression(e,ge.Comma+1),!r)?null:F.createEnumValueDeclaration(t,n,r,fe.join(t.range,e.range()))}parseReturn(e){let n=e.tokenPos,t=null;if(e.peek(!0)!=70&&e.nextToken!=63&&!e.nextTokenOnNewLine&&!(t=this.parseExpression(e)))return null;let r=F.createReturnStatement(t,e.range(n,e.pos));return e.skip(70),r}parseTypeParameters(e){let n=new Array,t=!1,r=e.tokenPos;for(;!e.skip(73);){let i=this.parseTypeParameter(e);if(!i)return null;if(i.defaultType?t=!0:t&&(this.error(2706,i.range),i.defaultType=null),n.push(i),!e.skip(71)){if(e.skip(73))break;return this.error(1005,e.range(),">"),null}}return n.length||this.error(1098,e.range(r,e.pos)),n}parseTypeParameter(e){if(e.next()==115){let n=F.createIdentifierExpression(e.readIdentifier(),e.range()),t=null;if(e.skip(19)){let i=this.parseType(e);if(!i)return null;if(i.kind!=1)return this.error(1003,i.range),null;t=i}let r=null;if(e.skip(101)){let i=this.parseType(e);if(!i)return null;if(i.kind!=1)return this.error(1003,i.range),null;r=i}return F.createTypeParameter(n,t,r,fe.join(n.range,e.range()))}else this.error(1003,e.range());return null}parseParameters(e,n=!1){let t=new Array,r=null,i=!1,s=!1,a=null;if(this.parseParametersThis=null,e.skip(51)){if(e.skip(100)){if(a=this.parseType(e),!a)return null;a.kind==1?this.parseParametersThis=a:this.error(1003,a.range)}else return this.error(1005,e.range(),":"),null;if(!e.skip(71))return e.skip(65)?t:(this.error(1005,e.range(),")"),null)}for(;!e.skip(65);){let o=this.parseParameter(e,n);if(!o)return null;switch(r&&!s&&(this.error(1014,r.name.range),s=!0),o.parameterKind){default:{i&&this.error(1016,o.name.range);break}case 1:{i=!0;break}case 2:{r=o;break}}if(t.push(o),!e.skip(71)){if(e.skip(65))break;return this.error(1005,e.range(),")"),null}}return t}parseParameter(e,n=!1){let t=!1,r=!1,i=null,s=0;if(n&&(e.skip(44)?(i=e.range(),s|=256):e.skip(43)?(i=e.range(),s|=1024):e.skip(42)&&(i=e.range(),s|=512),e.peek()==45)){let a=e.mark();e.next(),e.peek()!=100?(e.discard(a),i||(i=e.range()),s|=64):e.reset(a)}if(e.skip(69)&&(s?this.error(1317,e.range()):i=e.range(),t=!0),e.skipIdentifier()){t||(i=e.range());let a=F.createIdentifierExpression(e.readIdentifier(),e.range()),o=null;if((r=e.skip(99))&&t&&this.error(1047,a.range),e.skip(100)){if(o=this.parseType(e),!o)return null}else o=F.createOmittedType(e.range(e.pos));let u=null;if(e.skip(101)&&(t&&this.error(1048,a.range),r?this.error(1015,a.range):r=!0,u=this.parseExpression(e,ge.Comma+1),!u))return null;let c=F.createParameter(t?2:r?1:0,a,o,u,fe.join(assert(i),e.range()));return c.flags|=s,c}else this.error(1003,e.range());return null}parseFunction(e,n,t,r){if(!e.skipIdentifier())return this.error(1003,e.range(e.pos)),null;let i=F.createIdentifierExpression(e.readIdentifier(),e.range());(i.text=="hook"||i.text=="cbak")&&(n|=2);let s=-1,a=null;if(e.skip(72)){if(s=e.tokenPos,a=this.parseTypeParameters(e),!a)return null;n|=65536}if(!e.skip(64))return this.error(1005,e.range(e.pos),"("),null;s<0&&(s=e.tokenPos);let o=this.parseParameters(e);if(!o)return null;let u=this.parseParametersThis,c=(n&4096)!=0;c&&(o.length!=1&&this.error(1049,i.range),o.length>0&&o[0].initializer&&this.error(1052,i.range)),n&2048&&o.length&&this.error(1054,i.range);let f=null;if(e.skip(100)&&(f=this.parseType(e,!0,c),!f))return null;f||(c?f=F.createOmittedType(e.range(e.pos)):f=F.createNamedType(F.createSimpleTypeName("i64",e.range()),[],!1,e.range(e.pos)));let p=F.createFunctionType(o,f,u,!1,e.range(s,e.pos)),d=null;if(e.skip(62)){if(n&32768&&this.error(1183,e.range()),d=this.parseBlockStatement(e,!1),!d)return null;(i.text=="hook"||i.text=="cbak")&&d.statements.push(F.createReturnStatement(F.createIntegerLiteralExpression(0,e.range()),e.range(e.pos)))}else n&32768||this.error(2391,e.range(e.pos));let m=F.createFunctionDeclaration(i,t,n,a,p,d,0,e.range(r,e.pos));return m.overriddenModuleName=this.currentModuleName,e.skip(70),m}parseFunctionExpression(e){let n=e.tokenPos,t,r=0;if(e.token==24){if(e.skipIdentifier()?t=F.createIdentifierExpression(e.readIdentifier(),e.range()):t=F.createEmptyIdentifierExpression(e.range(e.pos)),!e.skip(64))return this.error(1005,e.range(e.pos),"("),null}else r=1,assert(e.token==64),t=F.createEmptyIdentifierExpression(e.range(e.tokenPos));let i=e.pos,s=this.parseParameters(e);return s?this.parseFunctionExpressionCommon(e,t,s,this.parseParametersThis,r,n,i):null}parseFunctionExpressionCommon(e,n,t,r,i,s=-1,a=-1){s<0&&(s=n.range.start),a<0&&(a=s);let o=null;if(i!=2&&e.skip(100)){if(o=this.parseType(e),!o)return null}else o=F.createOmittedType(e.range(e.pos));if(i&&!e.skip(80))return this.error(1005,e.range(e.pos),"=>"),null;let u=F.createFunctionType(t,o,r,!1,e.range(a,e.pos)),c=null;if(i)if(e.skip(62))c=this.parseBlockStatement(e,!1);else{let p=this.parseExpression(e,ge.Comma+1);p&&(c=F.createExpressionStatement(p))}else{if(!e.skip(62))return this.error(1005,e.range(e.pos),"{"),null;c=this.parseBlockStatement(e,!1)}if(!c)return null;let f=F.createFunctionDeclaration(n,null,0,null,u,c,i,e.range(s,e.pos));return F.createFunctionExpression(f)}parseClassOrInterface(e,n,t,r){let i=e.token==31;if(!e.skipIdentifier())return this.error(1003,e.range()),null;let s=F.createIdentifierExpression(e.readIdentifier(),e.range()),a=null;if(e.skip(72)){if(a=this.parseTypeParameters(e),!a)return null;n|=65536}let o=null;if(e.skip(19)){let p=this.parseType(e);if(!p)return null;if(p.kind!=1)return this.error(1003,p.range),null;o=p}let u=null;if(e.skip(27)){i&&this.error(1176,e.range());do{let p=this.parseType(e);if(!p)return null;if(p.kind!=1)return this.error(1003,p.range),null;i||(u||(u=[]),u.push(p))}while(e.skip(71))}if(!e.skip(62))return this.error(1005,e.range(),"{"),null;let c=new Array,f;if(i?(assert(!u),f=F.createInterfaceDeclaration(s,t,n,a,o,null,c,e.range(r,e.pos))):f=F.createClassDeclaration(s,t,n,a,o,u,c,e.range(r,e.pos)),!e.skip(63))do{let p=this.parseClassMember(e,f);if(p)p.kind==65?f.indexSignature=p:(assert(p instanceof rn),c.push(p));else if(this.skipStatement(e),e.skip(121))return this.error(1005,e.range(),"}"),null}while(!e.skip(63));return f.range.end=e.pos,f.overriddenModuleName=this.currentModuleName,f}parseClassExpression(e){let n=e.tokenPos,t;if(e.skipIdentifier()?t=F.createIdentifierExpression(e.readIdentifier(),e.range()):t=F.createEmptyIdentifierExpression(e.range(e.pos)),!e.skip(62))return this.error(1005,e.range(e.pos),"{"),null;let r=new Array,i=F.createClassDeclaration(t,null,0,null,null,null,r,e.range(n,e.pos));if(!e.skip(63))do{let s=this.parseClassMember(e,i);if(s)s.kind==65?i.indexSignature=s:(assert(i instanceof rn),r.push(s));else if(this.skipStatement(e),e.skip(121))return this.error(1005,e.range(),"}"),null}while(!e.skip(63));return i.range.end=e.pos,F.createClassExpression(i)}parseClassMember(e,n){let t=n.kind==57,r=0,i=null;if(e.skip(114)){r=e.tokenPos;do{let xe=this.parseDecorator(e);if(!xe)break;i||(i=new Array),i.push(xe)}while(e.skip(114));t&&i&&this.error(1206,fe.join(i[0].range,i[i.length-1].range))}let s=n.flags&32768;t&&(s|=268435456);let a=0,o=0,u=n.is(32768);e.skip(12)?(t?this.error(1042,e.range(),"declare"):u?this.error(1038,e.range()):(s|=32772,a=e.tokenPos,o=e.pos),r||(r=e.tokenPos)):u&&(s|=32768);let c=0,f=0;e.skip(44)?(t?this.error(1042,e.range(),"public"):(s|=256,c=e.tokenPos,f=e.pos),r||(r=e.tokenPos)):e.skip(42)?(t?this.error(1042,e.range(),"private"):(s|=512,c=e.tokenPos,f=e.pos),r||(r=e.tokenPos)):e.skip(43)&&(t?this.error(1042,e.range(),"protected"):(s|=1024,c=e.tokenPos,f=e.pos),r||(r=e.tokenPos));let p=0,d=0,m=0,g=0;e.skip(48)?(t?this.error(1042,e.range(),"static"):(s|=32,p=e.tokenPos,d=e.pos),r||(r=e.tokenPos)):(s|=262144,e.skip(0)&&(t||!n.is(128)?this.error(1042,e.range(),"abstract"):(s|=128,m=e.tokenPos,g=e.pos),r||(r=e.tokenPos)),n.flags&65536&&(s|=131072));let E=0,y=0;e.skip(40)&&(t||n.extendsType==null?this.error(1042,e.range(),"override"):(s|=8192,E=e.tokenPos,y=e.pos),r||(r=e.tokenPos));let b=0,T=0;if(e.peek()==45){let xe=e.mark();e.next(),e.peek()!=100?(e.discard(xe),s|=64,b=e.tokenPos,T=e.pos,r||(r=b)):e.reset(xe)}let S=e.mark(),C=!1,w=!1,B=0,D=0,W=!1,P=0,j=0;t||(e.skip(25)?e.peek(!0,1)==115&&!e.nextTokenOnNewLine?(s|=2048,w=!0,B=e.tokenPos,D=e.pos,r||(r=B),s&64&&this.error(1042,e.range(b,T),"readonly")):e.reset(S):e.skip(47)?e.peek(!0,1)==115&&!e.nextTokenOnNewLine?(s|=4096,W=!0,P=e.tokenPos,j=e.pos,r||(r=P),s&64&&this.error(1042,e.range(b,T),"readonly")):e.reset(S):e.skip(10)&&(s|=524288,C=!0,r||(r=e.tokenPos),s&32&&this.error(1042,e.range(p,d),"static"),s&128&&this.error(1042,e.range(m,g),"abstract"),s&64&&this.error(1042,e.range(b,T),"readonly")));let ce=w||W,le;if(C)le=F.createConstructorExpression(e.range());else{if(!ce&&e.skip(66)){r||(r=e.tokenPos),s&256?this.error(1042,e.range(c,f),"public"):s&1024?this.error(1042,e.range(c,f),"protected"):s&512&&this.error(1042,e.range(c,f),"private"),s&32&&this.error(1042,e.range(p,d),"static"),s&8192&&this.error(1042,e.range(E,y),"override"),s&128&&this.error(1042,e.range(m,g),"abstract");let xe=this.parseIndexSignature(e,s,i);return xe?(e.skip(70),xe):(s&64&&this.error(1042,e.range(b,T),"readonly"),null)}if(!e.skipIdentifier(2))return this.error(1003,e.range()),null;r||(r=e.tokenPos),le=F.createIdentifierExpression(e.readIdentifier(),e.range())}let Ge=null;if(e.skip(72)){let xe=e.tokenPos;if(Ge=this.parseTypeParameters(e),!Ge)return null;C?this.error(1092,e.range(xe,e.pos)):ce?this.error(1094,e.range(xe,e.pos)):s|=65536}if(e.skip(64)){s&4&&this.error(1031,e.range(a,o),"declare");let xe=e.tokenPos,ee=this.parseParameters(e,C);if(!ee)return null;let on=this.parseParametersThis;if(C)for(let Qe=0,sr=ee.length;Qe<sr;++Qe){let qe=ee[Qe];if(qe.isAny(1856)){let On=F.createFieldDeclaration(qe.name,null,qe.flags|262144,qe.type,null,qe.range);On.parameterIndex=Qe,qe.implicitFieldDeclaration=On,n.members.push(On)}}else w?ee.length&&this.error(1054,le.range):W?(ee.length!=1&&this.error(1049,le.range),ee.length>0&&ee[0].initializer&&this.error(1052,le.range)):le.text=="constructor"&&this.error(230,le.range,"constructor");let Z=null;if(e.skip(100)){if(le.kind==26?this.error(1093,e.range()):W&&this.error(1095,e.range()),Z=this.parseType(e,W||le.kind==26),!Z)return null}else Z=F.createOmittedType(e.range(e.pos)),!W&&le.kind!=26&&this.error(1110,Z.range);let Le=F.createFunctionType(ee,Z,on,!1,e.range(xe,e.pos)),Je=null;if(e.skip(62)){if(s&32768?this.error(1183,e.range()):s&128?this.error(1245,e.range(),le.text):t&&this.error(1005,e.range(),";"),Je=this.parseBlockStatement(e,!1),!Je)return null}else!t&&!(s&32896)&&this.error(2391,e.range());let _n=F.createMethodDeclaration(le,i,s,Ge,Le,Je,e.range(r,e.pos));return t&&e.skip(71)||e.skip(70),_n}else if(C)this.error(2390,le.range);else if(ce)this.error(2391,le.range);else{s&4&&this.error(100,e.range(a,o),"Ambient fields"),s&128&&this.error(1042,e.range(m,g),"abstract"),s&2048&&this.error(1042,e.range(B,D),"get"),s&4096&&this.error(1042,e.range(P,j),"set");let xe=null;if(e.skip(99)&&this.error(219,e.range(r,e.pos)),e.skip(95)&&(s|=16384),e.skip(100)){if(xe=this.parseType(e),!xe)return null}else this.error(1110,e.range());let ee=null;if(e.skip(101)&&(s&32768&&this.error(1039,e.range()),ee=this.parseExpression(e),!ee))return null;let on=e.range(r,e.pos);(s&16384)!=0&&(t||ee||(s&32)!=0)&&this.error(1255,on);let Z=F.createFieldDeclaration(le,i,s,xe,ee,on);return t&&e.skip(71)||e.skip(70),Z}return null}parseIndexSignature(e,n,t){t&&t.length>0&&this.error(1206,fe.join(t[0].range,t[t.length-1].range));let r=e.tokenPos;if(e.skipIdentifier())if(e.readIdentifier()=="key")if(e.skip(100)){let i=this.parseType(e);if(!i)return null;if(i.kind!=1)return this.error(1110,e.range()),null;if(e.skip(67))if(e.skip(100)){let s=this.parseType(e);return s?s.kind!=1?(this.error(1003,s.range),null):F.createIndexSignature(i,s,n,e.range(r,e.pos)):null}else this.error(1005,e.range(),":");else this.error(1005,e.range(),"]")}else this.error(1005,e.range(),":");else this.error(1005,e.range(),"key");else this.error(1003,e.range());return null}parseNamespace(e,n,t,r){if(e.skipIdentifier()){let i=F.createIdentifierExpression(e.readIdentifier(),e.range());if(e.skip(62)){let s=new Array,a=F.createNamespaceDeclaration(i,t,n,s,e.range(r,e.pos));for(;!e.skip(63);){let o=this.parseTopLevelStatement(e,a);if(o){if(o.kind==35)return this.error(1319,o.range),null;s.push(o)}else if(this.skipStatement(e),e.skip(121))return this.error(1005,e.range(),"}"),null}return a.range.end=e.pos,a.overriddenModuleName=this.currentModuleName,e.skip(70),a}else this.error(1005,e.range(),"{")}else this.error(1003,e.range());return null}parseExport(e,n,t){let r=null,i=assert(this.currentSource);if(e.skip(62)){let s=new Array;for(;!e.skip(63);){let o=this.parseExportMember(e);if(!o)return null;if(s.push(o),!e.skip(71)){if(e.skip(63))break;return this.error(1005,e.range(),"}"),null}}if(e.skip(23))if(e.skip(116))r=F.createStringLiteralExpression(e.readString(),e.range());else return this.error(1141,e.range()),null;let a=F.createExportStatement(s,r,t,e.range(n,e.pos));if(r){let o=assert(a.internalPath);this.seenlog.has(o)||(this.dependees.set(o,new Ls(i,r)),this.backlog.push(o),this.seenlog.add(o))}return e.skip(70),a}else if(e.skip(84))if(e.skip(23))if(e.skip(116)){r=F.createStringLiteralExpression(e.readString(),e.range());let s=F.createExportStatement(null,r,t,e.range(n,e.pos)),a=assert(s.internalPath),o=e.source,u=o.exportPaths;return u?u.includes(a)||u.push(a):o.exportPaths=[a],this.seenlog.has(a)||(this.dependees.set(a,new Ls(i,r)),this.backlog.push(a)),e.skip(70),s}else this.error(1141,e.range());else this.error(1005,e.range(),"from");else this.error(1005,e.range(),"{");return null}parseExportMember(e){if(e.skipIdentifier(2)){let n=F.createIdentifierExpression(e.readIdentifier(),e.range()),t=null;if(e.skip(1))if(e.skipIdentifier(2))t=F.createIdentifierExpression(e.readIdentifier(),e.range());else return this.error(1003,e.range()),null;return t?F.createExportMember(n,t,fe.join(n.range,t.range)):F.createExportMember(n,null,n.range)}else this.error(1003,e.range());return null}parseExportDefaultAlias(e,n,t,r){let i=e.readIdentifier(),s=e.range(),a=F.createExportStatement([F.createExportMember(F.createIdentifierExpression(i,s),F.createIdentifierExpression("default",e.range(t,r)),s)],null,!1,e.range(n,e.pos));return e.skip(70),a}parseImport(e){let n=e.tokenPos,t=null,r=null,i=!1;if(e.skip(62))for(t=new Array;!e.skip(63);){let s=this.parseImportDeclaration(e);if(!s)return null;if(t.push(s),!e.skip(71)){if(e.skip(63))break;return this.error(1005,e.range(),"}"),null}}else if(e.skip(84))if(e.skip(1))if(e.skipIdentifier())r=F.createIdentifierExpression(e.readIdentifier(),e.range());else return this.error(1003,e.range()),null;else return this.error(1005,e.range(),"as"),null;else if(e.skip(115,1)){let s=e.readIdentifier(),a=e.range();if(t=[F.createImportDeclaration(F.createIdentifierExpression("default",a),F.createIdentifierExpression(s,a),a)],e.skip(71))return this.error(100,e.range(),"Mixed default and named imports"),null}else i=!0;if(i||e.skip(23))if(e.skip(116)){let s=F.createStringLiteralExpression(e.readString(),e.range()),a;r?(assert(!t),a=F.createWildcardImportStatement(r,s,e.range(n,e.pos))):a=F.createImportStatement(t,s,e.range(n,e.pos));let o=a.internalPath;return this.seenlog.has(o)||(this.dependees.set(o,new Ls(assert(this.currentSource),s)),this.backlog.push(o)),e.skip(70),a}else this.error(1141,e.range());else this.error(1005,e.range(),"from");return null}parseImportDeclaration(e){if(e.skipIdentifier(2)){let n=F.createIdentifierExpression(e.readIdentifier(),e.range()),t=null;if(e.skip(1))if(e.skipIdentifier())t=F.createIdentifierExpression(e.readIdentifier(),e.range());else return this.error(1003,e.range()),null;return t?F.createImportDeclaration(n,t,fe.join(n.range,t.range)):F.createImportDeclaration(n,null,n.range)}else this.error(1003,e.range());return null}parseExportImport(e,n){if(e.skipIdentifier()){let t=F.createIdentifierExpression(e.readIdentifier(),e.range());if(e.skip(101))if(e.skipIdentifier()){let r=F.createIdentifierExpression(e.readIdentifier(),e.range()),i=F.createExportImportStatement(r,t,e.range(n,e.pos));return e.skip(70),i}else this.error(1003,e.range());else this.error(1005,e.range(),"=")}else this.error(1003,e.range());return null}parseStatement(e,n=!1){let t=e.mark(),r=e.next(),i=null;switch(r){case 4:{i=this.parseBreak(e);break}case 8:{i=this.parseVariable(e,8,null,e.tokenPos);break}case 9:{i=this.parseContinue(e);break}case 15:{i=this.parseDoStatement(e);break}case 22:{i=this.parseForStatement(e);break}case 26:{i=this.parseIfStatement(e);break}case 34:{i=this.parseVariable(e,16,null,e.tokenPos);break}case 57:{i=this.parseVariable(e,0,null,e.tokenPos);break}case 62:{i=this.parseBlockStatement(e,n);break}case 46:{n&&this.error(1108,e.range()),i=this.parseReturn(e);break}case 70:return F.createEmptyStatement(e.range(e.tokenPos));case 50:{i=this.parseSwitchStatement(e);break}case 52:{i=this.parseThrowStatement(e);break}case 54:{i=this.parseTryStatement(e);break}case 58:{i=this.parseVoidStatement(e);break}case 59:{i=this.parseWhileStatement(e);break}case 55:if(e.peek(!1,1)==115){i=this.parseTypeDeclaration(e,0,null,e.tokenPos);break}default:{e.reset(t),i=this.parseExpressionStatement(e);break}}return i?e.discard(t):(e.reset(t),this.skipStatement(e)),i}parseBlockStatement(e,n){let t=e.tokenPos,r=new Array;for(;!e.skip(63);){let s=e.mark(),a=this.parseStatement(e,n);if(a)e.discard(s),r.push(a);else{if(e.token==121)return null;e.reset(s),this.skipStatement(e)}}let i=F.createBlockStatement(r,e.range(t,e.pos));return e.skip(70),i}parseBreak(e){let n=null;e.peek(!0)==115&&!e.nextTokenOnNewLine&&(e.next(1),n=F.createIdentifierExpression(e.readIdentifier(),e.range()));let t=F.createBreakStatement(n,e.range());return e.skip(70),t}parseContinue(e){let n=null;e.peek(!0)==115&&!e.nextTokenOnNewLine&&(e.next(1),n=F.createIdentifierExpression(e.readIdentifier(),e.range()));let t=F.createContinueStatement(n,e.range());return e.skip(70),t}parseDoStatement(e){let n=e.tokenPos,t=this.parseStatement(e);if(!t)return null;if(e.skip(59))if(e.skip(64)){let r=this.parseExpression(e);if(!r)return null;if(e.skip(65)){let i=F.createDoStatement(t,r,e.range(n,e.pos));return e.skip(70),i}else this.error(1005,e.range(),")")}else this.error(1005,e.range(),"(");else this.error(1005,e.range(),"while");return null}parseExpressionStatement(e){let n=this.parseExpression(e);if(!n)return null;let t=F.createExpressionStatement(n);return e.skip(70),t}parseForStatement(e){let n=e.tokenPos;if(e.skip(64)){let t=null;if(e.skip(8))t=this.parseVariable(e,8,null,e.tokenPos,!0);else if(e.skip(34))t=this.parseVariable(e,16,null,e.tokenPos,!0);else if(e.skip(57))t=this.parseVariable(e,0,null,e.tokenPos,!0);else if(!e.skip(70)&&(t=this.parseExpressionStatement(e),!t))return null;if(t){if(e.skip(39)){if(t.kind==38)return t.expression.kind!=6?(this.error(1003,t.range),null):this.parseForOfStatement(e,n,t);if(t.kind==47){let r=t.declarations;for(let i=0,s=r.length;i<s;++i){let a=r[i].initializer;a&&this.error(1190,a.range)}return this.parseForOfStatement(e,n,t)}return this.error(1003,t.range),null}if(t.kind==47){let r=t.declarations;for(let i=0,s=r.length;i<s;++i){let a=r[i];a.initializer||(a.flags&8?this.error(1155,a.name.range):a.type||this.error(1110,a.name.range.atEnd))}}}if(e.token==70){let r=null;if(!e.skip(70)&&(r=this.parseExpressionStatement(e),!r))return null;if(e.token==70){let i=null;if(!e.skip(65)){if(i=this.parseExpression(e),!i)return null;if(!e.skip(65))return this.error(1005,e.range(),")"),null}let s=this.parseStatement(e);return s?F.createForStatement(t,r?r.expression:null,i,s,e.range(n,e.pos)):null}else this.error(1005,e.range(),";")}else this.error(1005,e.range(),";")}else this.error(1005,e.range(),"(");return null}parseForOfStatement(e,n,t){let r=this.parseExpression(e);if(!r)return null;if(!e.skip(65))return this.error(1005,e.range(),")"),null;let i=this.parseStatement(e);return i?F.createForOfStatement(t,r,i,e.range(n,e.pos)):null}parseIfStatement(e){let n=e.tokenPos;if(e.skip(64)){let t=this.parseExpression(e);if(!t)return null;if(e.skip(65)){let r=this.parseStatement(e);if(!r)return null;let i=null;return e.skip(16)&&(i=this.parseStatement(e),!i)?null:F.createIfStatement(t,r,i,e.range(n,e.pos))}else this.error(1005,e.range(),")")}else this.error(1005,e.range(),"(");return null}parseSwitchStatement(e){let n=e.tokenPos;if(e.skip(64)){let t=this.parseExpression(e);if(!t)return null;if(e.skip(65))if(e.skip(62)){let r=new Array;for(;!e.skip(63);){let s=this.parseSwitchCase(e);if(!s)return null;r.push(s)}let i=F.createSwitchStatement(t,r,e.range(n,e.pos));return e.skip(70),i}else this.error(1005,e.range(),"{");else this.error(1005,e.range(),")")}else this.error(1005,e.range(),"(");return null}parseSwitchCase(e){let n=e.tokenPos,t,r;if(e.skip(5)){let i=this.parseExpression(e);if(!i)return null;if(e.skip(100)){for(t=new Array;e.peek()!=5&&e.nextToken!=13&&e.nextToken!=63;){if(r=this.parseStatement(e),!r)return null;t.push(r)}return F.createSwitchCase(i,t,e.range(n,e.pos))}else this.error(1005,e.range(),":")}else if(e.skip(13))if(e.skip(100)){for(t=new Array;e.peek()!=5&&e.nextToken!=13&&e.nextToken!=63;){if(r=this.parseStatement(e),!r)return null;t.push(r)}return F.createSwitchCase(null,t,e.range(n,e.pos))}else this.error(1005,e.range(),":");else this.error(1130,e.range());return null}parseThrowStatement(e){let n=e.tokenPos,t=this.parseExpression(e);if(!t)return null;let r=F.createThrowStatement(t,e.range(n,e.pos));return e.skip(70),r}parseTryStatement(e){let n=e.tokenPos,t;if(e.skip(62)){let r=new Array;for(;!e.skip(63);){if(t=this.parseStatement(e),!t)return null;r.push(t)}let i=null,s=null,a=null;if(e.skip(6)){if(!e.skip(64))return this.error(1005,e.range(),"("),null;if(!e.skipIdentifier())return this.error(1003,e.range()),null;if(i=F.createIdentifierExpression(e.readIdentifier(),e.range()),!e.skip(65))return this.error(1005,e.range(),")"),null;if(!e.skip(62))return this.error(1005,e.range(),"{"),null;for(s=[];!e.skip(63);){if(t=this.parseStatement(e),!t)return null;s.push(t)}}if(e.skip(21)){if(!e.skip(62))return this.error(1005,e.range(),"{"),null;for(a=[];!e.skip(63);){if(t=this.parseStatement(e),!t)return null;a.push(t)}}if(!(s||a))return this.error(1005,e.range(),"catch"),null;let o=F.createTryStatement(r,i,s,a,e.range(n,e.pos));return e.skip(70),o}else this.error(1005,e.range(),"{");return null}getRecursiveDepthForTypeDeclaration(e,n,t=0){switch(n.kind){case 1:{let r=n.typeArguments;if(r)for(let i=0,s=r.length;i<s;i++){let a=this.getRecursiveDepthForTypeDeclaration(e,r[i],t+1);if(a!=-1)return a}if(n.name.identifier.text==e)return t;break}case 2:{let r=n,i=this.getRecursiveDepthForTypeDeclaration(e,r.returnType,t+1);if(i!=-1)return i;let s=r.parameters;for(let a=0,o=s.length;a<o;a++)if(i=this.getRecursiveDepthForTypeDeclaration(e,s[a].type,t+1),i!=-1)return i;break}}return-1}parseTypeDeclaration(e,n,t,r){if(e.skipIdentifier()){let i=F.createIdentifierExpression(e.readIdentifier(),e.range()),s=null;if(e.skip(72)){if(s=this.parseTypeParameters(e),!s)return null;n|=65536}if(e.skip(101)){e.skip(93);let a=this.parseType(e);if(!a)return null;let o=this.getRecursiveDepthForTypeDeclaration(i.text,a);if(o>=0)return o==0?this.error(2456,e.range(),i.text):this.error(100,e.range(),"Recursion in type aliases"),null;let u=F.createTypeDeclaration(i,t,n,s,a,e.range(r,e.pos));return e.skip(70),u.overriddenModuleName=this.currentModuleName,u}else this.error(1005,e.range(),"=")}else this.error(1003,e.range());return null}parseModuleDeclaration(e,n){let t=e.tokenPos;assert(e.next()==116);let r=e.readString(),i=F.createModuleDeclaration(r,n,e.range(t,e.pos));return this.currentModuleName=r,e.skip(70),i}parseVoidStatement(e){let n=e.tokenPos,t=this.parseExpression(e,ge.Grouping);if(!t)return null;let r=F.createVoidStatement(t,e.range(n,e.pos));return e.skip(70),r}parseWhileStatement(e){let n=e.tokenPos;if(e.skip(64)){let t=this.parseExpression(e);if(!t)return null;if(e.skip(65)){let r=this.parseStatement(e);if(!r)return null;let i=F.createWhileStatement(t,r,e.range(n,e.pos));return e.skip(70),i}else this.error(1005,e.range(),")")}else this.error(1005,e.range(),"(");return null}parseExpressionStart(e){let n=e.next(1),t=e.tokenPos;switch(n){case 69:case 61:case 95:case 96:case 81:case 82:case 56:case 58:case 14:{let r=this.parseExpression(e,ge.UnaryPrefix);return r?F.createUnaryPrefixExpression(n,r,e.range(t,e.pos)):null}case 87:case 88:{let r=this.parseExpression(e,ge.UnaryPrefix);if(!r)return null;switch(r.kind){case 6:case 12:case 21:break;default:this.error(2357,r.range)}return F.createUnaryPrefixExpression(n,r,e.range(t,e.pos))}case 37:{if(!e.skipIdentifier())return this.error(1003,e.range()),null;let r=this.parseTypeName(e);if(!r)return null;let i=null,s=null;if(e.skip(64)||(i=this.tryParseTypeArgumentsBeforeArguments(e))){if(s=this.parseArguments(e),!s)return null}else s=[];return F.createNewExpression(r,i,s,e.range(t,e.pos))}case 38:return F.createNullExpression(e.range());case 53:return F.createTrueExpression(e.range());case 20:return F.createFalseExpression(e.range());case 51:return F.createThisExpression(e.range());case 10:return F.createConstructorExpression(e.range());case 64:{if(e.skip(65))return this.parseFunctionExpressionCommon(e,F.createEmptyIdentifierExpression(e.range(t)),[],null,1);let r=e.mark(),i=!0;do switch(e.next(1)){case 69:return e.reset(r),this.parseFunctionExpression(e);case 115:{switch(e.readIdentifier(),e.next()){case 65:if(!e.skip(100)&&!e.skip(80)){i=!1;break}case 100:return e.reset(r),this.parseFunctionExpression(e);case 99:{if(e.skip(100)||e.skip(71)||e.skip(65))return e.reset(r),this.parseFunctionExpression(e);i=!1;break}case 71:break;default:{i=!1;break}}break}default:{i=!1;break}}while(i);e.reset(r);let s=this.parseExpression(e);return s?e.skip(65)?(s=F.createParenthesizedExpression(s,e.range(t,e.pos)),this.maybeParseCallExpression(e,s)):(this.error(1005,e.range(),")"),null):null}case 66:{let r=new Array;for(;!e.skip(67);){let i;if(e.peek()==71)i=F.createOmittedExpression(e.range(e.pos));else if(i=this.parseExpression(e,ge.Comma+1),!i)return null;if(r.push(i),!e.skip(71)){if(e.skip(67))break;return this.error(1005,e.range(),"]"),null}}return F.createArrayLiteralExpression(r,e.range(t,e.pos))}case 62:{let r=e.tokenPos,i=new Array,s=new Array,a;for(;!e.skip(63);){if(e.skipIdentifier())a=F.createIdentifierExpression(e.readIdentifier(),e.range());else{if(!e.skip(116))return this.error(1003,e.range()),null;a=F.createIdentifierExpression(e.readString(),e.range()),a.isQuoted=!0}if(i.push(a),e.skip(100)){let o=this.parseExpression(e,ge.Comma+1);if(!o)return null;s.push(o)}else if(!a.isQuoted)s.push(a);else return this.error(1005,e.range(),":"),null;if(!e.skip(71)){if(e.skip(63))break;return this.error(1005,e.range(),"}"),null}}return F.createObjectLiteralExpression(i,s,e.range(r,e.pos))}case 72:{let r=this.parseType(e);if(!r)return null;if(!e.skip(73))return this.error(1005,e.range(),">"),null;let i=this.parseExpression(e,ge.Call);return i?F.createAssertionExpression(0,i,r,e.range(t,e.pos)):null}case 115:{let r=e.readIdentifier();if(r=="null")return F.createNullExpression(e.range());let i=F.createIdentifierExpression(r,e.range(t,e.pos));return e.skip(119)?this.parseTemplateLiteral(e,i):e.peek(!0)==80&&!e.nextTokenOnNewLine?this.parseFunctionExpressionCommon(e,F.createEmptyIdentifierExpression(e.range(t)),[F.createParameter(0,i,F.createOmittedType(i.range.atEnd),null,i.range)],null,2,t):this.maybeParseCallExpression(e,i,!0)}case 49:{e.peek()!=68&&e.nextToken!=64&&this.error(1034,e.range());let r=F.createSuperExpression(e.range(t,e.pos));return this.maybeParseCallExpression(e,r)}case 116:return F.createStringLiteralExpression(e.readString(),e.range(t,e.pos));case 119:return this.parseTemplateLiteral(e);case 117:{let r=e.readInteger();return e.checkForIdentifierStartAfterNumericLiteral(),F.createIntegerLiteralExpression(r,e.range(t,e.pos))}case 118:{let r=e.readFloat();return e.checkForIdentifierStartAfterNumericLiteral(),F.createFloatLiteralExpression(r,e.range(t,e.pos))}case 85:{let r=e.readRegexpPattern();return e.skip(85)?F.createRegexpLiteralExpression(r,e.readRegexpFlags(),e.range(t,e.pos)):(this.error(1005,e.range(),"/"),null)}case 24:{let r=this.parseFunctionExpression(e);return r?this.maybeParseCallExpression(e,r):null}case 7:return this.parseClassExpression(e);default:return n==121?this.error(1126,e.range(t)):this.error(1109,e.range()),null}}tryParseTypeArgumentsBeforeArguments(e){let n=e.mark();if(!e.skip(72))return null;let t=e.tokenPos,r=null;do{if(e.peek()==73)break;let i=this.parseType(e,!0,!0);if(!i)return e.reset(n),null;r?r.push(i):r=[i]}while(e.skip(71));if(e.skip(73)){let i=e.pos;if(e.skip(64))return r||this.error(1099,e.range(t,i)),r}return e.reset(n),null}parseArguments(e){let n=new Array;for(;!e.skip(65);){let t=this.parseExpression(e,ge.Comma+1);if(!t)return null;if(n.push(t),!e.skip(71)){if(e.skip(65))break;return this.error(1005,e.range(),")"),null}}return n}parseExpression(e,n=ge.Comma){assert(n!=ge.None);let t=this.parseExpressionStart(e);if(!t)return null;let r=t.range.start,i;for(;(i=ty(e.peek()))>=n;){let s=e.next();switch(s){case 1:{if(e.skip(8))t=F.createAssertionExpression(3,t,null,e.range(r,e.pos));else{let a=this.parseType(e);if(!a)return null;t=F.createAssertionExpression(1,t,a,e.range(r,e.pos))}break}case 95:{t=F.createAssertionExpression(2,t,null,e.range(r,e.pos)),t=this.maybeParseCallExpression(e,t);break}case 30:{let a=this.parseType(e);if(!a)return null;t=F.createInstanceOfExpression(t,a,e.range(r,e.pos));break}case 66:{let a=this.parseExpression(e);if(!a)return null;if(!e.skip(67))return this.error(1005,e.range(),"]"),null;t=F.createElementAccessExpression(t,a,e.range(r,e.pos)),t=this.maybeParseCallExpression(e,t);break}case 87:case 88:{t.kind!=6&&t.kind!=12&&t.kind!=21&&this.error(2357,t.range),t=F.createUnaryPostfixExpression(s,t,e.range(r,e.pos));break}case 99:{let a=this.parseExpression(e);if(!a)return null;if(!e.skip(100))return this.error(1005,e.range(),":"),null;let o=this.parseExpression(e,n>ge.Comma?ge.Comma+1:ge.Comma);if(!o)return null;t=F.createTernaryExpression(t,a,o,e.range(r,e.pos));break}case 71:{let a=[t];do{if(t=this.parseExpression(e,ge.Comma+1),!t)return null;a.push(t)}while(e.skip(71));t=F.createCommaExpression(a,e.range(r,e.pos));break}case 68:{if(e.skipIdentifier(2)){let a=F.createIdentifierExpression(e.readIdentifier(),e.range());t=F.createPropertyAccessExpression(t,a,e.range(r,e.pos))}else{let a=this.parseExpression(e,i+1);if(!a)return null;if(a.kind==9){if(t=this.joinPropertyCall(e,r,t,a),!t)return null}else return this.error(1003,a.range),null}if(e.skip(119)){if(t=this.parseTemplateLiteral(e,t),!t)return null}else t=this.maybeParseCallExpression(e,t,!0);break}case 101:case 102:case 103:case 105:case 104:case 106:case 107:case 108:case 109:case 110:case 111:case 113:case 112:case 83:{let a=this.parseExpression(e,i);if(!a)return null;t=F.createBinaryExpression(s,t,a,e.range(r,e.pos));break}case 72:case 73:case 74:case 75:case 76:case 78:case 79:case 77:case 81:case 82:case 84:case 85:case 86:case 89:case 90:case 91:case 92:case 93:case 94:case 97:case 98:{let a=this.parseExpression(e,i+1);if(!a)return null;t=F.createBinaryExpression(s,t,a,e.range(r,e.pos));break}default:assert(!1)}}return t}parseTemplateLiteral(e,n=null){let t=n?n.range.start:e.tokenPos,r=new Array,i=new Array,s=new Array,a=new Array;for(r.push(e.readString(0,n!=null)),i.push(e.source.text.substring(e.readStringStart,e.readStringEnd));e.readingTemplateString;){let o=this.parseExpression(e);if(!o)return null;if(s.push(o),!e.skip(100))return this.error(1005,e.range(),":"),null;let u=e.readInteger();if(u<=0)return this.error(1005,e.range(),"length"),null;if(a.push(u),!e.skip(63))return this.error(1005,e.range(),"}"),null;r.push(e.readString(96,n!=null)),i.push(e.source.text.substring(e.readStringStart,e.readStringEnd))}return F.createTemplateLiteralExpression(n,r,i,s,a,e.range(t,e.pos))}joinPropertyCall(e,n,t,r){let i=r.expression;switch(i.kind){case 6:{r.expression=F.createPropertyAccessExpression(t,i,e.range(n,e.pos));break}case 9:{let s=this.joinPropertyCall(e,n,t,i);if(!s)return null;r.expression=s,r.range=e.range(n,e.pos);break}default:return this.error(1003,r.range),null}return r}maybeParseCallExpression(e,n,t=!1){let r=null;for(;e.skip(64)||t&&(r=this.tryParseTypeArgumentsBeforeArguments(e));){let i=this.parseArguments(e);if(!i)break;n=F.createCallExpression(n,r,i,e.range(n.range.start,e.pos)),t=!1}return n}skipStatement(e){e.peek(!0),e.nextTokenOnNewLine&&e.next();do{let n=e.peek(!0);if(n==121||n==70){e.next();break}if(e.nextTokenOnNewLine)break;switch(e.next()){case 115:{e.readIdentifier();break}case 116:case 119:{e.readString();break}case 117:{e.readInteger(),e.checkForIdentifierStartAfterNumericLiteral();break}case 118:{e.readFloat(),e.checkForIdentifierStartAfterNumericLiteral();break}case 62:{this.skipBlock(e);break}}}while(!0);e.readingTemplateString=!1}skipBlock(e){let n=1,t=!0;do switch(e.next()){case 121:{this.error(1005,e.range(),"}"),t=!1;break}case 62:{++n;break}case 63:{--n,n||(t=!1);break}case 115:{e.readIdentifier();break}case 116:{e.readString();break}case 119:{for(e.readString();e.readingTemplateString;)this.skipBlock(e),e.readString(96);break}case 117:{e.readInteger(),e.checkForIdentifierStartAfterNumericLiteral();break}case 118:{e.readFloat(),e.checkForIdentifierStartAfterNumericLiteral();break}}while(t)}},ge=(e=>(e[e.None=0]="None",e[e.Comma=1]="Comma",e[e.Spread=2]="Spread",e[e.Yield=3]="Yield",e[e.Assignment=4]="Assignment",e[e.Conditional=5]="Conditional",e[e.LogicalOr=6]="LogicalOr",e[e.LogicalAnd=7]="LogicalAnd",e[e.BitwiseOr=8]="BitwiseOr",e[e.BitwiseXor=9]="BitwiseXor",e[e.BitwiseAnd=10]="BitwiseAnd",e[e.Equality=11]="Equality",e[e.Relational=12]="Relational",e[e.Shift=13]="Shift",e[e.Additive=14]="Additive",e[e.Multiplicative=15]="Multiplicative",e[e.Exponentiated=16]="Exponentiated",e[e.UnaryPrefix=17]="UnaryPrefix",e[e.UnaryPostfix=18]="UnaryPostfix",e[e.Call=19]="Call",e[e.MemberAccess=20]="MemberAccess",e[e.Grouping=21]="Grouping",e))(ge||{});function ty(e){switch(e){case 71:return 1;case 101:case 102:case 103:case 105:case 104:case 106:case 107:case 108:case 109:case 110:case 111:case 113:case 112:return 4;case 99:return 5;case 98:return 6;case 97:return 7;case 93:return 8;case 94:return 9;case 92:return 10;case 76:case 77:case 78:case 79:return 11;case 1:case 29:case 30:case 72:case 73:case 74:case 75:return 12;case 89:case 90:case 91:return 13;case 81:case 82:return 14;case 84:case 85:case 86:return 15;case 83:return 16;case 87:case 88:return 18;case 68:case 66:case 95:return 20}return 0}var e2=16,Ot=e2-1,Vc=class{constructor(e,n,t,r,i){this.localFile=e,this.localIdentifier=n,this.foreignIdentifier=t,this.foreignPath=r,this.foreignPathAlt=i}},Gc=class{constructor(e,n,t,r){this.localIdentifier=e,this.foreignIdentifier=n,this.foreignPath=t,this.foreignPathAlt=r}},ry=class{constructor(e,n,t){this.foreignPath=e,this.foreignPathAlt=n,this.pathLiteral=t}},Ye=(e=>(e[e.Invalid=0]="Invalid",e[e.IndexedGet=1]="IndexedGet",e[e.IndexedSet=2]="IndexedSet",e[e.UncheckedIndexedGet=3]="UncheckedIndexedGet",e[e.UncheckedIndexedSet=4]="UncheckedIndexedSet",e[e.Add=5]="Add",e[e.Sub=6]="Sub",e[e.Mul=7]="Mul",e[e.Div=8]="Div",e[e.Rem=9]="Rem",e[e.Pow=10]="Pow",e[e.BitwiseAnd=11]="BitwiseAnd",e[e.BitwiseOr=12]="BitwiseOr",e[e.BitwiseXor=13]="BitwiseXor",e[e.BitwiseShl=14]="BitwiseShl",e[e.BitwiseShr=15]="BitwiseShr",e[e.BitwiseShrU=16]="BitwiseShrU",e[e.Eq=17]="Eq",e[e.Ne=18]="Ne",e[e.Gt=19]="Gt",e[e.Ge=20]="Ge",e[e.Lt=21]="Lt",e[e.Le=22]="Le",e[e.Plus=23]="Plus",e[e.Minus=24]="Minus",e[e.Not=25]="Not",e[e.BitwiseNot=26]="BitwiseNot",e[e.PrefixInc=27]="PrefixInc",e[e.PrefixDec=28]="PrefixDec",e[e.PostfixInc=29]="PostfixInc",e[e.PostfixDec=30]="PostfixDec",e))(Ye||{});(e=>{function n(s,a){switch(assert(a.length),s){case 2:case 3:{switch(a.charCodeAt(0)){case 91:{if(a=="[]")return 1;if(a=="[]=")return 2;break}case 123:{if(a=="{}")return 3;if(a=="{}=")return 4;break}case 43:{if(a=="+")return 5;break}case 45:{if(a=="-")return 6;break}case 42:{if(a=="*")return 7;if(a=="**")return 10;break}case 47:{if(a=="/")return 8;break}case 37:{if(a=="%")return 9;break}case 38:{if(a=="&")return 11;break}case 124:{if(a=="|")return 12;break}case 94:{if(a=="^")return 13;break}case 61:{if(a=="==")return 17;break}case 33:{if(a=="!=")return 18;break}case 62:{if(a==">")return 19;if(a==">=")return 20;if(a==">>")return 15;if(a==">>>")return 16;break}case 60:{if(a=="<")return 21;if(a=="<=")return 22;if(a=="<<")return 14;break}}break}case 4:{switch(a.charCodeAt(0)){case 43:{if(a=="+")return 23;if(a=="++")return 27;break}case 45:{if(a=="-")return 24;if(a=="--")return 28;break}case 33:{if(a=="!")return 25;break}case 126:{if(a=="~")return 26;break}}break}case 5:{switch(a.charCodeAt(0)){case 43:{if(a=="++")return 29;break}case 45:{if(a=="--")return 30;break}}break}}return 0}e.fromDecorator=n;function t(s){switch(s){case 81:case 102:return 5;case 82:case 103:return 6;case 84:case 104:return 7;case 85:case 106:return 8;case 86:case 107:return 9;case 83:case 105:return 10;case 92:case 111:return 11;case 93:case 112:return 12;case 94:case 113:return 13;case 89:case 108:return 14;case 90:case 109:return 15;case 91:case 110:return 16;case 76:return 17;case 77:return 18;case 73:return 19;case 75:return 20;case 72:return 21;case 74:return 22}return 0}e.fromBinaryToken=t;function r(s){switch(s){case 81:return 23;case 82:return 24;case 95:return 25;case 96:return 26;case 87:return 27;case 88:return 28}return 0}e.fromUnaryPrefixToken=r;function i(s){switch(s){case 87:return 29;case 88:return 30}return 0}e.fromUnaryPostfixToken=i})(Ye||={});var Kl=class extends mt{constructor(e,n=null){super(n),this.options=e,this.sources=[],this.diagnosticsOffset=0,this.nextClassId=0,this.nextSignatureId=0,this.initialized=!1,this.filesByName=new Map,this.elementsByName=new Map,this.elementsByDeclaration=new Map,this.instancesByName=new Map,this.wrapperClasses=new Map,this.managedClasses=new Map,this.uniqueSignatures=new Array(0),this.moduleExports=new Map,this.moduleImports=new Map,this._arrayBufferViewInstance=null,this._arrayBufferInstance=null,this._arrayPrototype=null,this._staticArrayPrototype=null,this._byteArrayPrototype=null,this._setPrototype=null,this._mapPrototype=null,this._functionPrototype=null,this._int8ArrayPrototype=null,this._int16ArrayPrototype=null,this._int32ArrayPrototype=null,this._int64ArrayPrototype=null,this._uint8ArrayPrototype=null,this._uint8ClampedArrayPrototype=null,this._uint16ArrayPrototype=null,this._uint32ArrayPrototype=null,this._uint64ArrayPrototype=null,this._float32ArrayPrototype=null,this._float64ArrayPrototype=null,this._stringInstance=null,this._regexpInstance=null,this._objectInstance=null,this._templateStringsArrayInstance=null,this._allocInstance=null,this._reallocInstance=null,this._freeInstance=null,this._newInstance=null,this._renewInstance=null,this._linkInstance=null,this._collectInstance=null,this._visitInstance=null,this._typeinfoInstance=null,this._instanceofInstance=null,this._newBufferInstance=null,this._newArrayInstance=null,this._BLOCKInstance=null,this._OBJECTInstance=null,this.nativeDummySignature=null;let t=new Ji(3,Cn+"native.ts","[native code]");this.nativeSource=t,this.parser=new Xl(this.diagnostics,this.sources),this.resolver=new Hl(this);let r=new Si(this,t);this.nativeFile=r,this.filesByName.set(r.internalName,r)}get nativeRange(){return this.nativeSource.range}get arrayBufferViewInstance(){let e=this._arrayBufferViewInstance;return e||(this._arrayBufferViewInstance=e=this.requireClass(v.ArrayBufferView)),e}get arrayBufferInstance(){let e=this._arrayBufferInstance;return e||(this._arrayBufferInstance=e=this.requireClass(v.ArrayBuffer)),e}get arrayPrototype(){let e=this._arrayPrototype;return e||(this._arrayPrototype=e=this.require(v.Array,X.ClassPrototype)),e}get staticArrayPrototype(){let e=this._staticArrayPrototype;return e||(this._staticArrayPrototype=e=this.require(v.StaticArray,X.ClassPrototype)),e}get byteArrayPrototype(){let e=this._byteArrayPrototype;return e||(this._byteArrayPrototype=e=this.require("ByteArray",X.ClassPrototype)),e}get setPrototype(){let e=this._setPrototype;return e||(this._setPrototype=e=this.require(v.Set,X.ClassPrototype)),e}get mapPrototype(){let e=this._mapPrototype;return e||(this._mapPrototype=e=this.require(v.Map,X.ClassPrototype)),e}get functionPrototype(){let e=this._functionPrototype;return e||(this._functionPrototype=e=this.require(v.Function,X.ClassPrototype)),e}get int8ArrayPrototype(){let e=this._int8ArrayPrototype;return e||(this._int8ArrayPrototype=e=this.require(v.Int8Array,X.ClassPrototype)),e}get int16ArrayPrototype(){let e=this._int16ArrayPrototype;return e||(this._int16ArrayPrototype=e=this.require(v.Int16Array,X.ClassPrototype)),e}get int32ArrayPrototype(){let e=this._int32ArrayPrototype;return e||(this._int32ArrayPrototype=e=this.require(v.Int32Array,X.ClassPrototype)),e}get int64ArrayPrototype(){let e=this._int64ArrayPrototype;return e||(this._int64ArrayPrototype=e=this.require(v.Int64Array,X.ClassPrototype)),e}get uint8ArrayPrototype(){let e=this._uint8ArrayPrototype;return e||(this._uint8ArrayPrototype=e=this.require(v.Uint8Array,X.ClassPrototype)),e}get uint8ClampedArrayPrototype(){let e=this._uint8ClampedArrayPrototype;return e||(this._uint8ClampedArrayPrototype=e=this.require(v.Uint8ClampedArray,X.ClassPrototype)),e}get uint16ArrayPrototype(){let e=this._uint16ArrayPrototype;return e||(this._uint16ArrayPrototype=e=this.require(v.Uint16Array,X.ClassPrototype)),e}get uint32ArrayPrototype(){let e=this._uint32ArrayPrototype;return e||(this._uint32ArrayPrototype=e=this.require(v.Uint32Array,X.ClassPrototype)),e}get uint64ArrayPrototype(){let e=this._uint64ArrayPrototype;return e||(this._uint64ArrayPrototype=e=this.require(v.Uint64Array,X.ClassPrototype)),e}get float32ArrayPrototype(){let e=this._float32ArrayPrototype;return e||(this._float32ArrayPrototype=e=this.require(v.Float32Array,X.ClassPrototype)),e}get float64ArrayPrototype(){let e=this._float64ArrayPrototype;return e||(this._float64ArrayPrototype=e=this.require(v.Float64Array,X.ClassPrototype)),e}get stringInstance(){let e=this._stringInstance;return e||(this._stringInstance=e=this.requireClass(v.String)),e}get regexpInstance(){let e=this._regexpInstance;return e||(this._regexpInstance=e=this.requireClass(v.RegExp)),e}get objectInstance(){let e=this._objectInstance;return e||(this._objectInstance=e=this.requireClass(v.Object)),e}get templateStringsArrayInstance(){let e=this._templateStringsArrayInstance;return e||(this._templateStringsArrayInstance=e=this.requireClass(v.TemplateStringsArray)),e}get abortInstance(){let e=this.lookup(v.abort);return!e||e.kind!=X.FunctionPrototype?null:this.resolver.resolveFunction(e,null)}get allocInstance(){let e=this._allocInstance;return e||(this._allocInstance=e=this.requireFunction(v.alloc)),e}get reallocInstance(){let e=this._reallocInstance;return e||(this._reallocInstance=e=this.requireFunction(v.realloc)),e}get freeInstance(){let e=this._freeInstance;return e||(this._freeInstance=e=this.requireFunction(v.free)),e}get newInstance(){let e=this._newInstance;return e||(this._newInstance=e=this.requireFunction(v.new_)),e}get renewInstance(){let e=this._renewInstance;return e||(this._renewInstance=e=this.requireFunction(v.renew)),e}get linkInstance(){let e=this._linkInstance;return e||(this._linkInstance=e=this.requireFunction(v.link)),e}get collectInstance(){let e=this._collectInstance;return e||(this._collectInstance=e=this.requireFunction(v.collect)),e}get visitInstance(){let e=this._visitInstance;return e||(this._visitInstance=e=this.requireFunction(v.visit)),e}get typeinfoInstance(){let e=this._typeinfoInstance;return e||(this._typeinfoInstance=e=this.requireFunction(v.typeinfo)),e}get instanceofInstance(){let e=this._instanceofInstance;return e||(this._instanceofInstance=e=this.requireFunction(v.instanceof_)),e}get newBufferInstance(){let e=this._newBufferInstance;return e||(this._newBufferInstance=e=this.requireFunction(v.newBuffer)),e}get newArrayInstance(){let e=this._newArrayInstance;return e||(this._newArrayInstance=e=this.requireFunction(v.newArray)),e}get BLOCKInstance(){let e=this._BLOCKInstance;return e||(this._BLOCKInstance=e=this.requireClass(v.BLOCK)),e}get OBJECTInstance(){let e=this._OBJECTInstance;return e||(this._OBJECTInstance=e=this.requireClass(v.OBJECT)),e}getSource(e){let n=this.sources;for(let t=0;t<n.length;++t){let r=n[t];if(r.internalPath==e)return r.text}return null}get blockOverhead(){return this.BLOCKInstance.nextMemoryOffset}get objectOverhead(){return this.OBJECTInstance.nextMemoryOffset-this.blockOverhead+Ot&~Ot}get totalOverhead(){return this.blockOverhead+this.objectOverhead}searchFunctionByRef(e){let n=Rl(e);if(n){let t=this.instancesByName;if(t.has(n)){let r=assert(t.get(n));if(r.kind==X.Function)return r}}return null}computeBlockStart(e){let n=this.blockOverhead;return(e+n+Ot&~Ot)-n}computeBlockStart64(e){let n=i64_new(this.blockOverhead);return i64_sub(i64_align(i64_add(e,n),e2),n)}computeBlockSize(e,n){n&&(e+=this.objectOverhead);let t=this.computeBlockStart(e),r=this.blockOverhead,i=(3*this.options.usizeType.byteSize+r+Ot&~Ot)-r;t<i&&(t=i);let s=1<<30,a=3;if(t>=s||(t&a)!=0)throw new Error("invalid block size");return t}makeNativeVariableDeclaration(e,n=0){let t=this.nativeSource.range;return F.createVariableDeclaration(F.createIdentifierExpression(e,t),null,n,null,null,t)}makeNativeTypeDeclaration(e,n=0){let t=this.nativeSource.range,r=F.createIdentifierExpression(e,t);return F.createTypeDeclaration(r,null,n,null,F.createOmittedType(t),t)}makeNativeFunctionDeclaration(e,n=0){let t=this.nativeSource.range,r=this.nativeDummySignature;return r||(this.nativeDummySignature=r=F.createFunctionType([],F.createNamedType(F.createSimpleTypeName(v.void_,t),null,!1,t),null,!1,t)),F.createFunctionDeclaration(F.createIdentifierExpression(e,t),null,n,null,r,null,0,t)}makeNativeNamespaceDeclaration(e,n=0){let t=this.nativeSource.range;return F.createNamespaceDeclaration(F.createIdentifierExpression(e,t),null,n,[],t)}makeNativeFunction(e,n,t=this.nativeFile,r=0,i=q.None){return new Hn(e,new pn(e,t,this.makeNativeFunctionDeclaration(e,r),i),null,n)}getElementByDeclaration(e){let n=this.elementsByDeclaration;return n.has(e)?assert(n.get(e)):null}initialize(){if(this.initialized)return;this.initialized=!0;let e=this.options;this.registerNativeType(v.i8,l.i8),this.registerNativeType(v.i16,l.i16),this.registerNativeType(v.i32,l.i32),this.registerNativeType(v.i64,l.i64),this.registerNativeType(v.isize,e.isizeType),this.registerNativeType(v.u8,l.u8),this.registerNativeType(v.u16,l.u16),this.registerNativeType(v.u32,l.u32),this.registerNativeType(v.u64,l.u64),this.registerNativeType(v.usize,e.usizeType),this.registerNativeType(v.bool,l.bool),this.registerNativeType(v.f32,l.f32),this.registerNativeType(v.f64,l.f64),this.registerNativeType(v.void_,l.void),this.registerNativeType(v.number,l.f64),this.registerNativeType(v.boolean,l.bool),this.nativeFile.add(v.native,new Tn(v.native,this.nativeFile,this.makeNativeTypeDeclaration(v.native,65538),q.Builtin)),this.nativeFile.add(v.indexof,new Tn(v.indexof,this.nativeFile,this.makeNativeTypeDeclaration(v.indexof,65538),q.Builtin)),this.nativeFile.add(v.valueof,new Tn(v.valueof,this.nativeFile,this.makeNativeTypeDeclaration(v.valueof,65538),q.Builtin)),this.nativeFile.add(v.returnof,new Tn(v.returnof,this.nativeFile,this.makeNativeTypeDeclaration(v.returnof,65538),q.Builtin)),this.nativeFile.add(v.nonnull,new Tn(v.nonnull,this.nativeFile,this.makeNativeTypeDeclaration(v.nonnull,65538),q.Builtin)),this.registerNativeType(v.v128,l.v128),this.registerNativeType(v.funcref,l.funcref),this.registerNativeType(v.externref,l.externref),this.registerNativeType(v.anyref,l.anyref),this.registerNativeType(v.eqref,l.eqref),this.registerNativeType(v.i31ref,l.i31ref),this.registerNativeType(v.dataref,l.dataref),this.registerNativeType(v.arrayref,l.arrayref),this.registerNativeType(v.stringref,l.stringref),this.registerNativeType(v.stringview_wtf8,l.stringview_wtf8),this.registerNativeType(v.stringview_wtf16,l.stringview_wtf16),this.registerNativeType(v.stringview_iter,l.stringview_iter),this.registerConstantInteger(v.ASC_TARGET,l.i32,i64_new(e.isWasm64?2:1)),this.registerConstantInteger(v.ASC_RUNTIME,l.i32,i64_new(e.runtime)),this.registerConstantInteger(v.ASC_NO_ASSERT,l.bool,i64_new(e.noAssert?1:0,0)),this.registerConstantInteger(v.ASC_MEMORY_BASE,l.i32,i64_new(e.memoryBase,0)),this.registerConstantInteger(v.ASC_TABLE_BASE,l.i32,i64_new(e.tableBase,0)),this.registerConstantInteger(v.ASC_OPTIMIZE_LEVEL,l.i32,i64_new(e.optimizeLevelHint,0)),this.registerConstantInteger(v.ASC_SHRINK_LEVEL,l.i32,i64_new(e.shrinkLevelHint,0)),this.registerConstantInteger(v.ASC_LOW_MEMORY_LIMIT,l.i32,i64_new(e.lowMemoryLimit,0)),this.registerConstantInteger(v.ASC_EXPORT_RUNTIME,l.bool,i64_new(e.exportRuntime?1:0,0)),this.registerConstantInteger(v.ASC_VERSION_MAJOR,l.i32,i64_new(e.bundleMajorVersion)),this.registerConstantInteger(v.ASC_VERSION_MINOR,l.i32,i64_new(e.bundleMinorVersion)),this.registerConstantInteger(v.ASC_VERSION_PATCH,l.i32,i64_new(e.bundlePatchVersion)),this.registerConstantInteger(v.ASC_FEATURE_SIGN_EXTENSION,l.bool,i64_new(e.hasFeature(1)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_MUTABLE_GLOBALS,l.bool,i64_new(e.hasFeature(2)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_NONTRAPPING_F2I,l.bool,i64_new(e.hasFeature(4)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_BULK_MEMORY,l.bool,i64_new(e.hasFeature(8)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_SIMD,l.bool,i64_new(e.hasFeature(16)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_THREADS,l.bool,i64_new(e.hasFeature(32)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_EXCEPTION_HANDLING,l.bool,i64_new(e.hasFeature(64)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_TAIL_CALLS,l.bool,i64_new(e.hasFeature(128)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_REFERENCE_TYPES,l.bool,i64_new(e.hasFeature(256)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_MULTI_VALUE,l.bool,i64_new(e.hasFeature(512)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_GC,l.bool,i64_new(e.hasFeature(1024)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_MEMORY64,l.bool,i64_new(e.hasFeature(2048)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_RELAXED_SIMD,l.bool,i64_new(e.hasFeature(4096)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_EXTENDED_CONST,l.bool,i64_new(e.hasFeature(8192)?1:0,0)),this.registerConstantInteger(v.ASC_FEATURE_STRINGREF,l.bool,i64_new(e.hasFeature(16384)?1:0,0));let n=new Array,t=new Map,r=new Map,i=new Array,s=new Array;for(let o=0,u=this.sources.length;o<u;++o){let c=this.sources[o],f=new Si(this,c);this.filesByName.set(f.internalName,f);let p=c.statements;for(let d=0,m=p.length;d<m;++d){let g=p[d];switch(g.kind){case 35:{this.initializeExports(g,f,t,r);break}case 36:{this.initializeExportDefault(g,f,i,s);break}case 42:{this.initializeImports(g,f,n,t);break}case 47:{this.initializeVariables(g,f);break}case 51:{this.initializeClass(g,f,i,s);break}case 52:{this.initializeEnum(g,f);break}case 55:{this.initializeFunction(g,f);break}case 57:{this.initializeInterface(g,f,i);break}case 59:{this.initializeNamespace(g,f,i,s);break}case 60:{this.initializeTypeDefinition(g,f);break}}}}for(let o=Map_keys(r),u=0,c=o.length;u<c;++u){let f=o[u],p=assert(r.get(f));for(let d=0,m=p.length;d<m;++d){let g=unchecked(p[d]),E=this.lookupForeignFile(g.foreignPath,g.foreignPathAlt);if(!E){this.error(6054,g.pathLiteral.range,g.pathLiteral.value);continue}f.ensureExportStar(E)}}do{let o=0,u=!1;for(;o<n.length;){let c=n[o],f=c.localIdentifier,p=c.foreignIdentifier,d=assert(this.lookupForeignFile(c.foreignPath,c.foreignPathAlt));if(p){let m=this.lookupForeign(p.text,d,t);m?(c.localFile.add(f.text,m,f),n.splice(o,1),u=!0):++o}else{let m=c.localFile,g=f.text;m.add(g,d.asAliasNamespace(g,m,f),f),n.splice(o,1),u=!0}}if(!u){for(let c=0,f=n.length;c<f;++c){let p=n[c],d=p.foreignIdentifier;d&&this.error(2305,d.range,p.foreignPath,d.text)}break}}while(!0);for(let o=Map_keys(t),u=0,c=o.length;u<c;++u){let f=unchecked(o[u]),p=assert(t.get(f));for(let d=Map_keys(p),m=0,g=d.length;m<g;++m){let E=unchecked(d[m]),y=assert(p.get(E)),b=y.localIdentifier.text,T=y.foreignPath;if(T){let S=assert(this.lookupForeignFile(T,assert(y.foreignPathAlt))),C=this.lookupForeign(b,S,t);C?f.ensureExport(E,C):this.error(2305,y.localIdentifier.range,T,b)}else{let S=f.getMember(b);if(S)f.ensureExport(E,S);else{let C=this.lookup(b);C&&er(C.kind)?f.ensureExport(E,C):this.error(2305,y.foreignIdentifier.range,f.internalName,y.foreignIdentifier.text)}}}}assert(this.arrayBufferInstance.id==0),assert(this.stringInstance.id==1),assert(this.arrayBufferViewInstance.id==2),this.registerWrapperClass(l.i8,v.I8),this.registerWrapperClass(l.i16,v.I16),this.registerWrapperClass(l.i32,v.I32),this.registerWrapperClass(l.i64,v.I64),this.registerWrapperClass(e.isizeType,v.Isize),this.registerWrapperClass(l.u8,v.U8),this.registerWrapperClass(l.u16,v.U16),this.registerWrapperClass(l.u32,v.U32),this.registerWrapperClass(l.u64,v.U64),this.registerWrapperClass(e.usizeType,v.Usize),this.registerWrapperClass(l.bool,v.Bool),this.registerWrapperClass(l.f32,v.F32),this.registerWrapperClass(l.f64,v.F64),e.hasFeature(16)&&this.registerWrapperClass(l.v128,v.V128),e.hasFeature(256)&&(this.registerWrapperClass(l.funcref,v.Funcref),this.registerWrapperClass(l.externref,v.Externref),e.hasFeature(1024)&&(this.registerWrapperClass(l.anyref,v.Anyref),this.registerWrapperClass(l.eqref,v.Eqref),this.registerWrapperClass(l.i31ref,v.I31ref),this.registerWrapperClass(l.dataref,v.Dataref),this.registerWrapperClass(l.arrayref,v.Arrayref)));let a=this.resolver;for(let o=0,u=i.length;o<u;++o){let c=i[o],f=assert(c.extendsNode),p=a.resolveTypeName(f.name,c.parent);if(p){if(c.kind==X.ClassPrototype)if(p.kind==X.ClassPrototype){let d=p;d.hasDecorator(q.Final)&&this.error(211,f.range,d.identifierNode.text),d.hasDecorator(q.Unmanaged)!=c.hasDecorator(q.Unmanaged)&&this.error(207,fe.join(c.identifierNode.range,f.range)),c.extends(d)?this.error(2506,d.identifierNode.range,d.identifierNode.text):c.basePrototype=d}else this.error(1311,f.range);else if(c.kind==X.InterfacePrototype)if(p.kind==X.InterfacePrototype){let d=p;c.extends(d)?this.error(2506,d.identifierNode.range,d.identifierNode.text):c.basePrototype=d}else this.error(2312,f.range)}}for(let o=0,u=i.length;o<u;o++){let c=i[o],f=c.instanceMembers;if(f){let p=Map_values(f);for(let d=0,m=p.length;d<m;d++){let g=p[d],E=g.declaration;if(E.is(8192)){let y=c.basePrototype,b=!1;for(;y;){let T=y.instanceMembers;if(T&&T.has(g.name)){b=!0;break}y=y.basePrototype}if(!b){let T=assert(c.basePrototype);this.error(4117,E.name.range,T.name)}}}}}for(let o=0,u=s.length;o<u;++o){let c=s[o],f=assert(c.implementsNodes);for(let p=0,d=f.length;p<d;++p){let m=f[p],g=a.resolveTypeName(m.name,c.parent);if(g)if(g.kind==X.InterfacePrototype){let E=g,y=c.interfacePrototypes;y||(c.interfacePrototypes=y=new Array),y.push(E)}else this.error(2422,m.range)}}for(let o=0,u=i.length;o<u;++o){let c=i[o],f=c.basePrototype;f&&this.markVirtuals(c,f)}for(let o=0,u=s.length;o<u;++o){let c=s[o],f=c.basePrototype,p=c.interfacePrototypes;if(f&&this.markVirtuals(c,f),p)for(let d=0,m=p.length;d<m;++d)this.markVirtuals(c,p[d])}{let o=e.globalAliases;o||(o=new Map),o.has(v.abort)||o.set(v.abort,h.abort),o.has(v._g)||o.set(v._g,h._g),o.has(v.max_iterations)||o.set(v.max_iterations,h.max_iterations),o.has(v.accept)||o.set(v.accept,h.accept),o.has(v.emit)||o.set(v.emit,h.emit),o.has(v.etxn_details)||o.set(v.etxn_details,h.etxn_details),o.has(v.etxn_fee_base)||o.set(v.etxn_fee_base,h.etxn_fee_base),o.has(v.etxn_reserve)||o.set(v.etxn_reserve,h.etxn_reserve),o.has(v.float_compare)||o.set(v.float_compare,h.float_compare),o.has(v.float_divide)||o.set(v.float_divide,h.float_divide),o.has(v.float_int)||o.set(v.float_int,h.float_int),o.has(v.float_mulratio)||o.set(v.float_mulratio,h.float_mulratio),o.has(v.float_multiply)||o.set(v.float_multiply,h.float_multiply),o.has(v.float_negate)||o.set(v.float_negate,h.float_negate),o.has(v.float_set)||o.set(v.float_set,h.float_set),o.has(v.float_sto)||o.set(v.float_sto,h.float_sto),o.has(v.float_sto_set)||o.set(v.float_sto_set,h.float_sto_set),o.has(v.float_sum)||o.set(v.float_sum,h.float_sum),o.has(v.hook_account)||o.set(v.hook_account,h.hook_account),o.has(v.hook_param)||o.set(v.hook_param,h.hook_param),o.has(v.ledger_seq)||o.set(v.ledger_seq,h.ledger_seq),o.has(v.otxn_field)||o.set(v.otxn_field,h.otxn_field),o.has(v.otxn_slot)||o.set(v.otxn_slot,h.otxn_slot),o.has(v.rollback)||o.set(v.rollback,h.rollback),o.has(v.slot)||o.set(v.slot,h.slot),o.has(v.slot_count)||o.set(v.slot_count,h.slot_count),o.has(v.slot_float)||o.set(v.slot_float,h.slot_float),o.has(v.slot_set)||o.set(v.slot_set,h.slot_set),o.has(v.slot_subarray)||o.set(v.slot_subarray,h.slot_subarray),o.has(v.slot_subfield)||o.set(v.slot_subfield,h.slot_subfield),o.has(v.slot_type)||o.set(v.slot_type,h.slot_type),o.has(v.state)||o.set(v.state,h.state),o.has(v.state_foreign)||o.set(v.state_foreign,h.state_foreign),o.has(v.state_set)||o.set(v.state_set,h.state_set),o.has(v.sto_emplace)||o.set(v.sto_emplace,h.sto_emplace),o.has(v.sto_erase)||o.set(v.sto_erase,h.sto_erase),o.has(v.sto_subarray)||o.set(v.sto_subarray,h.sto_subarray),o.has(v.sto_subfield)||o.set(v.sto_subfield,h.sto_subfield),o.has(v.trace)||o.set(v.trace,h.trace),o.has(v.trace_float)||o.set(v.trace_float,h.trace_float),o.has(v.trace_num)||o.set(v.trace_num,h.trace_num),o.has(v.util_accid)||o.set(v.util_accid,h.util_accid),o.has(v.util_keylet)||o.set(v.util_keylet,h.util_keylet),o.has(v.util_sha512h)||o.set(v.util_sha512h,h.util_sha512h),o.has(v.util_verify)||o.set(v.util_verify,h.util_verify),o.has(v.seed)||o.set(v.seed,h.seed),o.has(v.Math)||o.set(v.Math,v.NativeMath),o.has(v.Mathf)||o.set(v.Mathf,v.NativeMathf);for(let u=Map_keys(o),c=0,f=u.length;c<f;++c){let p=unchecked(u[c]),d=changetype(o.get(p));if(assert(d!=null),!d.length){this.elementsByName.delete(p);continue}let m=d.charCodeAt(0);if(m>=48&&m<=57)this.registerConstantInteger(p,l.i32,i64_new(parseInt(d,10)));else{let g=this.elementsByName;g.has(d)?g.set(p,assert(g.get(d))):this.error(111,null,d)}}}for(let o=Map_values(this.filesByName),u=0,c=o.length;u<c;++u){let f=unchecked(o[u]);f.source.sourceKind==1&&this.markModuleExports(f)}}markVirtuals(e,n){let t=e.instanceMembers;if(t){let r=Map_values(t);do{let i=n.instanceMembers;if(i)for(let a=0,o=r.length;a<o;++a){let u=r[a];if(!u.isAny(524800)&&i.has(u.name)){let c=assert(i.get(u.name));if(u.kind==X.FunctionPrototype&&c.kind==X.FunctionPrototype){let f=u,p=c;f.visibilityEquals(p)||this.errorRelated(2385,f.identifierNode.range,p.identifierNode.range),c.set(268435456);let d=p.overloads;d||(p.overloads=d=new Set),d.add(u);let m=p.instances;if(m)for(let g=Map_values(m),E=0,y=g.length;E<y;++E)g[E].set(268435456)}else if(u.kind==X.PropertyPrototype&&c.kind==X.PropertyPrototype){let f=u,p=c;f.visibilityEquals(p)||this.errorRelated(2385,f.identifierNode.range,p.identifierNode.range),p.set(268435456);let d=p.getterPrototype;if(d){d.set(268435456);let g=f.getterPrototype;if(g){let y=d.overloads;y||(d.overloads=y=new Set),y.add(g)}let E=d.instances;if(E)for(let y=Map_values(E),b=0,T=y.length;b<T;++b)y[b].set(268435456)}let m=p.setterPrototype;if(m&&f.setterPrototype){m.set(268435456);let g=f.setterPrototype;if(g){let y=m.overloads;y||(m.overloads=y=new Set),y.add(g)}let E=m.instances;if(E)for(let y=Map_values(E),b=0,T=y.length;b<T;++b)y[b].set(268435456)}}}}let s=n.basePrototype;if(!s)break;n=s}while(!0)}}lookup(e){let n=this.elementsByName;return n.has(e)?assert(n.get(e)):null}require(e,n){let t=this.lookup(e);if(!t)throw new Error(`Missing standard library component: ${e}`);if(t.kind!=n)throw Error(`Invalid standard library component kind: ${e}`);return t}requireGlobal(e){return this.require(e,X.Global)}requireClass(e){let n=this.require(e,X.ClassPrototype),t=this.resolver.resolveClass(n,null);if(!t)throw new Error(`Invalid standard library class: ${e}`);return t}requireFunction(e,n=null){let t=this.require(e,X.FunctionPrototype),r=this.resolver.resolveFunction(t,n);if(!r)throw new Error(`Invalid standard library function: ${e}`);return r}markModuleExports(e){let n=e.exports;if(n)for(let r=Map_values(n),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]);this.markModuleExport(a)}let t=e.exportsStar;if(t)for(let r=0,i=t.length;r<i;++r)this.markModuleExports(t[r])}markModuleExport(e){switch(e.set(1048576),e.kind){case X.ClassPrototype:{let t=e.instanceMembers;if(t)for(let r=Map_values(t),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]);this.markModuleExport(a)}break}case X.PropertyPrototype:{let t=e,r=t.getterPrototype;r&&this.markModuleExport(r);let i=t.setterPrototype;i&&this.markModuleExport(i);break}case X.Property:case X.Function:case X.Field:case X.Class:assert(!1)}let n=e.members;if(n)for(let t=Map_values(n),r=0,i=t.length;r<i;++r){let s=unchecked(t[r]);this.markModuleExport(s)}}markModuleImport(e,n,t){t.set(2097152);let r=this.moduleImports,i;r.has(e)?i=assert(r.get(e)):(i=new Map,r.set(e,i)),i.set(n,t)}registerNativeType(e,n){let t=new Tn(e,this.nativeFile,this.makeNativeTypeDeclaration(e,2),q.Builtin);t.setType(n),this.nativeFile.add(e,t)}registerWrapperClass(e,n){let t=this.wrapperClasses;assert(!e.isInternalReference&&!t.has(e));let r=assert(this.lookup(n));assert(r.kind==X.ClassPrototype);let i=assert(this.resolver.resolveClass(r,null));i.wrappedType=e,t.set(e,i)}registerConstantInteger(e,n,t){assert(n.isIntegerInclReference);let r=new jt(e,this.nativeFile,q.None,this.makeNativeVariableDeclaration(e,10));r.setConstantIntegerValue(t,n),this.nativeFile.add(e,r)}registerConstantFloat(e,n,t){assert(n.isFloatValue);let r=new jt(e,this.nativeFile,q.None,this.makeNativeVariableDeclaration(e,10));r.setConstantFloatValue(t,n),this.nativeFile.add(e,r)}ensureGlobal(e,n){let t=this.elementsByName;if(t.has(e)){let r=assert(t.get(e));if(r!=n){let i=su(r,n);if(!i)return er(r.kind)?this.errorRelated(2300,n.identifierNode.range,r.declaration.name.range,e):this.error(2300,n.identifierNode.range,e),n;n=i}}return t.set(e,n),n}lookupForeignFile(e,n){let t=this.filesByName;return t.has(e)?assert(t.get(e)):t.has(n)?assert(t.get(n)):null}lookupForeign(e,n,t){do{let i=n.lookupExport(e);if(i)return i;if(t.has(n)){let s=assert(t.get(n));if(s.has(e)){let a=assert(s.get(e)),o=a.foreignPath;if(o){let u=this.lookupForeignFile(o,assert(a.foreignPathAlt));if(!u)return null;e=a.localIdentifier.text,n=u;continue}if(i=n.getMember(a.localIdentifier.text),i)return i}}break}while(!0);let r=n.exportsStar;if(r)for(let i=0,s=r.length;i<s;++i){let a=this.lookupForeign(e,r[i],t);if(a)return a}return null}checkDecorators(e,n){let t=q.None;if(e)for(let r=0,i=e.length;r<i;++r){let s=e[r],a=tr.fromNode(s.name),o=q.fromKind(a);o&&(o==q.Builtin?!(n&o)&&!s.range.source.isLibrary?this.error(212,s.range,s.name.range.toString()):t|=o:n&o?t&o?this.error(213,s.range):t|=o:this.error(212,s.range,s.name.range.toString()))}return t}initializeClass(e,n,t,r){let i=e.name.text,s=new fs(i,n,e,this.checkDecorators(e.decorators,q.Global|q.Final|q.Unmanaged));if(!n.add(i,s))return null;let a=e.implementsTypes;if(a){let u=a.length;u&&(s.hasDecorator(q.Unmanaged)?this.error(208,fe.join(e.name.range,a[u-1].range)):r.push(s))}e.extendsType&&t.push(s);let o=e.members;for(let u=0,c=o.length;u<c;++u){let f=o[u];switch(f.kind){case 54:{this.initializeField(f,s);break}case 58:{let p=f;if(f.isAny(6144))this.initializeProperty(p,s);else{let d=this.initializeMethod(p,s);d&&p.name.kind==26&&(s.constructorPrototype=d)}break}case 65:break;default:assert(!1)}}return s}initializeField(e,n){let t=e.name.text,r=e.decorators,i,s=q.Unsafe;if(n.is(32768)&&(s|=q.External),e.is(32)){if(assert(n.kind!=X.InterfacePrototype),s|=q.Lazy,e.is(64)&&(s|=q.Inline),i=new jt(t,n,this.checkDecorators(r,s),e),!n.add(t,i))return}else if(assert(!e.isAny(6272)),i=new Ql(t,n,e,this.checkDecorators(r,s)),!n.addInstance(t,i))return}initializeMethod(e,n){let t=e.name.text,r=e.is(32),i=q.Inline|q.Unsafe;e.is(65536)||(i|=q.OperatorBinary|q.OperatorPrefix|q.OperatorPostfix),n.is(32768)&&(i|=q.External);let s=new pn(t,n,e,this.checkDecorators(e.decorators,i));if(r){if(assert(e.name.kind!=26),!n.add(t,s))return null}else if(!n.addInstance(t,s))return null;return this.checkOperatorOverloads(e.decorators,s,n),s}checkOperatorOverloads(e,n,t){if(e)for(let r=0,i=e.length;r<i;++r){let s=e[r];switch(s.decoratorKind){case 2:case 3:case 4:case 5:{let a=s.args,o=a?a.length:0;if(o==1){let u=s.args[0];if(u.isLiteralKind(2)){let c=u.value,f=Ye.fromDecorator(s.decoratorKind,c);if(f==0)this.error(224,u.range,c);else{let p=t.overloadPrototypes;p.has(f)?this.error(2393,u.range):(n.operatorKind=f,p.set(f,n))}}else this.error(1141,u.range)}else this.error(2554,s.range,"1",o.toString())}}}}ensureProperty(e,n){let t=e.name.text;if(e.is(32)){let r=n.members;if(r&&r.has(t)){let i=assert(r.get(t));if(i.kind==X.PropertyPrototype)return i}else{let i=new kr(t,n,e);return n.add(t,i)?i:null}}else{let r=n.instanceMembers;if(r&&r.has(t)){let i=assert(r.get(t));if(i.kind==X.PropertyPrototype)return i}else{let i=new kr(t,n,e);return n.addInstance(t,i)?i:null}}return this.error(2718,e.name.range,t),null}initializeProperty(e,n){let t=this.ensureProperty(e,n);if(!t)return;let r=e.name.text,i=e.is(2048);if(i){if(t.getterPrototype){this.error(2718,e.name.range,r);return}}else if(t.setterPrototype){this.error(2718,e.name.range,r);return}let s=new pn((i?Mi:Ui)+r,t,e,this.checkDecorators(e.decorators,q.Inline|q.Unsafe));i?t.getterPrototype=s:t.setterPrototype=s}initializeEnum(e,n){let t=e.name.text,r=new Yl(t,n,e,this.checkDecorators(e.decorators,q.Global|q.Inline|q.Lazy));if(!n.add(t,r))return null;let i=e.values;for(let s=0,a=i.length;s<a;++s)this.initializeEnumValue(i[s],r);return r}initializeEnumValue(e,n){let t=e.name.text,r=new Jl(t,n,e,this.checkDecorators(e.decorators,q.None));n.add(t,r)}initializeExports(e,n,t,r){let i=e.members;if(i)for(let s=0,a=i.length;s<a;++s)this.initializeExport(i[s],n,e.internalPath,t);else{let s;r.has(n)?s=assert(r.get(n)):r.set(n,s=[]);let a=e.internalPath;s.push(new ry(a,a.endsWith(We)?a.substring(0,a.length-We.length):a+We,assert(e.path)))}}initializeExport(e,n,t,r){let i=e.localName.text,s=e.exportedName.text,a=n.lookupExport(s);if(a){this.error(2484,e.exportedName.range,s);return}if(t==null)if(a=n.getMember(i))n.ensureExport(s,a);else{let o;r.has(n)?o=assert(r.get(n)):r.set(n,o=new Map),o.set(s,new Gc(e.localName,e.exportedName,null,null))}else{let o;r.has(n)?o=assert(r.get(n)):r.set(n,o=new Map),o.set(s,new Gc(e.localName,e.exportedName,t,t.endsWith(We)?t.substring(0,t.length-We.length):t+We))}}initializeExportDefault(e,n,t,r){let i=e.declaration,s=null;switch(i.kind){case 52:{s=this.initializeEnum(i,n);break}case 55:{s=this.initializeFunction(i,n);break}case 51:{s=this.initializeClass(i,n,t,r);break}case 57:{s=this.initializeInterface(i,n,t);break}case 59:{s=this.initializeNamespace(i,n,t,r);break}default:assert(!1)}if(s){let a=n.exports;if(!a)n.exports=a=new Map;else if(a.has("default")){let o=assert(a.get("default"));this.errorRelated(2300,i.name.range,o.declaration.name.range,"default");return}a.set("default",s)}}initializeImports(e,n,t,r){let i=e.declarations;if(i)for(let s=0,a=i.length;s<a;++s)this.initializeImport(i[s],n,e.internalPath,t,r);else{let s=e.namespaceName;s&&t.push(new Vc(n,s,null,e.internalPath,e.internalPath+We))}}initializeImport(e,n,t,r,i){let s=t.endsWith(We)?t.substring(0,t.length-We.length):t+We,a=this.lookupForeignFile(t,s);if(a){let o=this.lookupForeign(e.foreignName.text,a,i);if(o){n.add(e.name.text,o,e.name);return}}r.push(new Vc(n,e.name,e.foreignName,t,s))}initializeFunction(e,n){let t=e.name.text,r=q.Unsafe|q.Builtin;e.is(32768)?r|=q.External|q.ExternalJs:(r|=q.Inline,(e.range.source.isLibrary||e.is(2))&&(r|=q.Lazy)),e.is(262144)||n.kind!=X.ClassPrototype&&(r|=q.Global);let i=new pn(t,n,e,this.checkDecorators(e.decorators,r));return n.add(t,i)?i:null}initializeInterface(e,n,t){let r=e.name.text,i=new ru(r,n,e,this.checkDecorators(e.decorators,q.Global));if(!n.add(r,i))return null;e.extendsType&&t.push(i);let s=e.members;for(let a=0,o=s.length;a<o;++a){let u=s[a];switch(u.kind){case 54:{this.initializeFieldAsProperty(u,i);break}case 58:{let c=u;u.isAny(6144)?this.initializeProperty(c,i):this.initializeMethod(c,i);break}default:assert(!1)}}return i}initializeFieldAsProperty(e,n){let t=e.type;t||(t=F.createOmittedType(e.name.range.atEnd)),this.initializeProperty(F.createMethodDeclaration(e.name,e.decorators,e.flags|2048,null,F.createFunctionType([],t,null,!1,e.range),null,e.range),n),e.is(64)||this.initializeProperty(F.createMethodDeclaration(e.name,e.decorators,e.flags|4096,null,F.createFunctionType([F.createParameter(0,e.name,t,null,e.name.range)],F.createOmittedType(e.name.range.atEnd),null,!1,e.range),null,e.range),n)}initializeNamespace(e,n,t,r){let i=e.name.text,s=new cs(i,n,e,this.checkDecorators(e.decorators,q.Global));if(!n.add(i,s))return null;let a=assert(n.getMember(i)),o=e.members;for(let u=0,c=o.length;u<c;++u){let f=o[u];switch(f.kind){case 51:{this.initializeClass(f,s,t,r);break}case 52:{this.initializeEnum(f,s);break}case 55:{this.initializeFunction(f,s);break}case 57:{this.initializeInterface(f,s,t);break}case 59:{this.initializeNamespace(f,s,t,r);break}case 60:{this.initializeTypeDefinition(f,s);break}case 47:{this.initializeVariables(f,s);break}default:assert(!1)}}return s!=a&&En(s,a),a}initializeTypeDefinition(e,n){let t=e.name.text,r=new Tn(t,n,e,this.checkDecorators(e.decorators,q.None));n.add(t,r)}initializeVariables(e,n){let t=e.declarations;for(let r=0,i=t.length;r<i;++r){let s=t[r],a=s.name.text,o=q.Global|q.Lazy;s.is(32768)&&(o|=q.External),s.is(8)&&(o|=q.Inline);let u=new jt(a,n,this.checkDecorators(s.decorators,o),s);n.add(a,u)}}},X=(e=>(e[e.Global=0]="Global",e[e.Local=1]="Local",e[e.Enum=2]="Enum",e[e.EnumValue=3]="EnumValue",e[e.FunctionPrototype=4]="FunctionPrototype",e[e.Function=5]="Function",e[e.ClassPrototype=6]="ClassPrototype",e[e.Class=7]="Class",e[e.InterfacePrototype=8]="InterfacePrototype",e[e.Interface=9]="Interface",e[e.FieldPrototype=10]="FieldPrototype",e[e.Field=11]="Field",e[e.PropertyPrototype=12]="PropertyPrototype",e[e.Property=13]="Property",e[e.Namespace=14]="Namespace",e[e.File=15]="File",e[e.TypeDefinition=16]="TypeDefinition",e[e.IndexSignature=17]="IndexSignature",e))(X||{}),q=(e=>(e[e.None=0]="None",e[e.Global=1]="Global",e[e.OperatorBinary=2]="OperatorBinary",e[e.OperatorPrefix=4]="OperatorPrefix",e[e.OperatorPostfix=8]="OperatorPostfix",e[e.Unmanaged=16]="Unmanaged",e[e.Final=32]="Final",e[e.Inline=64]="Inline",e[e.External=128]="External",e[e.ExternalJs=256]="ExternalJs",e[e.Builtin=512]="Builtin",e[e.Lazy=1024]="Lazy",e[e.Unsafe=2048]="Unsafe",e))(q||{});(e=>{function n(t){switch(t){case 1:return 1;case 2:case 3:return 2;case 4:return 4;case 5:return 8;case 6:return 16;case 7:return 32;case 8:return 64;case 9:return 128;case 10:return 256;case 11:return 512;case 12:return 1024;case 13:return 2048;default:return 0}}e.fromKind=n})(q||={});var us=class{constructor(e,n,t,r,i){this.kind=e,this.name=n,this.internalName=t,this.program=r,this.flags=0,this.decoratorFlags=0,this.members=null,this.shadowType=null,this.program=r,this.name=n,this.internalName=t,i?this.parent=i:(assert(this.kind==15),this.parent=this)}get file(){let e=this;do if(e=e.parent,e.kind==15)return e;while(!0)}is(e){return(this.flags&e)==e}isAny(e){return(this.flags&e)!=0}set(e){this.flags|=e}unset(e){this.flags&=~e}hasDecorator(e){return(this.decoratorFlags&e)==e}hasAnyDecorator(e){return(this.decoratorFlags&e)!=0}getMember(e){let n=this.members;return n&&n.has(e)?assert(n.get(e)):null}lookup(e,n=!1){return this.parent.lookup(e,n)}add(e,n,t=null){let r=n.declaration,i=this.members;if(!i)this.members=i=new Map;else if(i.has(e)){let a=assert(i.get(e));if(a.parent==this){let o=su(a,n);if(o)n=o;else{let u=t||n.identifierNode;return er(a.kind)?this.program.errorRelated(2300,u.range,a.identifierNode.range,u.text):this.program.error(2300,u.range,u.text),!1}}}i.set(e,n);let s=this.program;return(n.kind!=4||!n.isBound)&&(s.elementsByName.set(n.internalName,n),s.elementsByDeclaration.set(r,n)),!0}get isPublic(){return!this.isAny(1536)}get isImplicitlyPublic(){return this.isPublic&&!this.is(256)}visibilityEquals(e){if(this.isPublic==e.isPublic)return!0;let n=1536;return(this.flags&n)==(e.flags&n)}toString(){return`${this.internalName}, kind=${this.kind}`}},n2=new Set;function er(e){return n2.has(e)}var Kn=class extends us{constructor(e,n,t,r,i,s){super(e,n,t,r,i),this.declaration=s,n2.add(e),this.declaration=s,this.flags=s.flags}get isDeclaredInLibrary(){return this.declaration.range.source.isLibrary}get identifierNode(){return this.declaration.name}get identifierAndSignatureRange(){let e=this.declaration,n=e.name;if(e.kind==55||e.kind==58){let t=e.signature;return fe.join(n.range,t.range)}return n.range}get decoratorNodes(){return this.declaration.decorators}isCompatibleOverride(e){let n=this,t=n.kind,r=!1;if(t==e.kind)switch(t){case 4:{let i=this.program.resolver.resolveFunction(n,null);if(!i)return!1;let s=this.program.resolver.resolveFunction(e,null);if(!s)return!1;n=i,e=s,r=!0}case 5:return n.signature.isAssignableTo(e.signature,r);case 12:{let i=this.program.resolver.resolveProperty(n);if(!i)return!1;let s=this.program.resolver.resolveProperty(e);if(!s)return!1;n=i,e=s}case 13:{let i=n,s=e,a=i.getterInstance,o=s.getterInstance;if(a){if(!o||!a.signature.isAssignableTo(o.signature,!0))return!1}else if(o)return!1;let u=i.setterInstance,c=s.setterInstance;if(u){if(!c||!u.signature.isAssignableTo(c.signature,!0))return!1}else if(c)return!1;return!0}}return!1}},t2=new Set;function $l(e){return t2.has(e)}var $n=class extends Kn{constructor(e,n,t,r,i,s){super(e,n,t,r,i,s),this.type=l.void,t2.add(e)}setType(e){assert(!this.is(4194304)),this.type=e,this.set(4194304)}},Si=class extends us{constructor(e,n){super(15,n.normalizedPath,n.internalPath,e,null),this.source=n,this.exports=null,this.exportsStar=null,this.aliasNamespaces=new Array,this.source=n,assert(!e.filesByName.has(this.internalName)),e.filesByName.set(this.internalName,this);let t=this.program.makeNativeFunction(`start:${this.internalName}`,new tn(e,null,l.void),this);t.internalName=t.name,this.startFunction=t}add(e,n,t=null){return n.hasDecorator(1)&&(n=this.program.ensureGlobal(e,n)),super.add(e,n,t)?(n=assert(this.getMember(e)),n.is(2)&&!t&&this.ensureExport(n.name,n),!0):!1}getMember(e){let n=super.getMember(e);if(n)return n;let t=this.exportsStar;if(t){for(let r=0,i=t.length;r<i;++r)if(n=t[r].getMember(e))return n}return null}lookup(e,n=!1){return this.getMember(e)||this.program.lookup(e)}ensureExport(e,n){let t=this.exports;t||(this.exports=t=new Map),t.set(e,n),this.source.sourceKind==3&&this.program.ensureGlobal(e,n);for(let r=0;r<this.aliasNamespaces.length;r++)this.aliasNamespaces[r].add(e,n)}ensureExportStar(e){let n=this.exportsStar;if(!n)this.exportsStar=n=[];else if(n.includes(e))return;n.push(e)}lookupExport(e){let n=this.exports;if(n&&n.has(e))return assert(n.get(e));let t=this.exportsStar;if(t)for(let r=0,i=t.length;r<i;++r){let s=t[r].lookupExport(e);if(s)return s}return null}asAliasNamespace(e,n,t){let r=this.program.makeNativeNamespaceDeclaration(e);r.name=t;let i=new cs(e,n,r);return i.set(67108864),this.copyExportsToNamespace(i),this.aliasNamespaces.push(i),i}copyExportsToNamespace(e){let n=this.exports;if(n)for(let r=Map_keys(n),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]),o=assert(n.get(a));e.add(a,o)}let t=this.exportsStar;if(t)for(let r=0,i=t.length;r<i;++r)t[r].copyExportsToNamespace(e)}},Tn=class extends $n{constructor(e,n,t,r=0){super(16,e,Ne(e,n,!1),n.program,n,t),this.decoratorFlags=r}get typeParameterNodes(){return this.declaration.typeParameters}get typeNode(){return this.declaration.type}},cs=class extends Kn{constructor(e,n,t,r=0){super(14,e,Ne(e,n,!1),n.program,n,t),this.decoratorFlags=r}lookup(e,n=!1){return this.getMember(e)||super.lookup(e,n)}},Yl=class extends $n{constructor(e,n,t,r=0){super(2,e,Ne(e,n,!1),n.program,n,t),this.decoratorFlags=r,this.setType(l.i32)}lookup(e,n=!1){return this.getMember(e)||super.lookup(e,n)}},Zl=(e=>(e[e.None=0]="None",e[e.Integer=1]="Integer",e[e.Float=2]="Float",e))(Zl||{}),yt=class extends $n{constructor(e,n,t,r=t.program.makeNativeVariableDeclaration(n)){super(e,n,Ne(n,t,r.is(262144)),t.program,t,r),this.constantValueKind=0,this.constantIntegerValue=i64_zero,this.constantFloatValue=0,this.flags=r.flags}get typeNode(){return this.declaration.type}get initializerNode(){return this.declaration.initializer}setConstantIntegerValue(e,n){assert(n.isIntegerInclReference),this.type=n,this.constantValueKind=1,this.constantIntegerValue=e,this.set(37748744)}setConstantFloatValue(e,n){assert(n.isFloatValue),this.type=n,this.constantValueKind=2,this.constantFloatValue=e,this.set(37748744)}},Jl=class extends yt{constructor(e,n,t,r=0){super(3,e,n,t),this.isImmutable=!1,this.decoratorFlags=r,this.setType(l.i32)}get valueNode(){return this.declaration.initializer}},jt=class extends yt{constructor(e,n,t,r=n.program.makeNativeVariableDeclaration(e)){super(0,e,n,r),this.decoratorFlags=t}},r2=class{constructor(e,n,t=null){this.name=e,this.type=n,this.initializer=t}},nn=class extends yt{constructor(e,n,t,r,i=r.program.makeNativeVariableDeclaration(e)){super(1,e,r,i),this.index=n,this.originalName=e,this.index=n,assert(t!=l.void),this.setType(t)}},pn=class extends Kn{constructor(e,n,t,r=0){super(4,e,Ne(e,n,t.is(262144)),n.program,n,t),this.operatorKind=0,this.instances=null,this.overloads=null,this.boundPrototypes=null,this.decoratorFlags=r}get typeParameterNodes(){return this.declaration.typeParameters}get functionTypeNode(){return this.declaration.signature}get bodyNode(){return this.declaration.body}get arrowKind(){return this.declaration.arrowKind}get isBound(){let e=this.parent,n=e.kind;return n==12&&(n=e.parent.kind),n==7||n==9}toBound(e){assert(this.is(262144)),assert(!this.isBound);let n=this.boundPrototypes;if(!n)this.boundPrototypes=n=new Map;else if(n.has(e))return assert(n.get(e));let t=this.declaration;assert(t.kind==58);let r=new pn(this.name,e,t,this.decoratorFlags);return r.flags=this.flags,r.operatorKind=this.operatorKind,r.overloads=this.overloads,n.set(e,r),r}getResolvedInstance(e){let n=this.instances;return n&&n.has(e)?assert(n.get(e)):null}setResolvedInstance(e,n){let t=this.instances;t?assert(!t.has(e)):this.instances=t=new Map,t.set(e,n)}},Hn=class extends $n{constructor(e,n,t,r,i=null){super(5,e,Ne(e,n.parent,n.is(262144)),n.program,n.parent,n.declaration),this.localsByIndex=[],this.debugLocations=[],this.ref=0,this.varargsStub=null,this.virtualStub=null,this.memorySegment=null,this.nextInlineId=0,this.nextAnonymousId=0,this.nextBreakId=0,this.breakStack=null,this.breakLabel=null,this.prototype=n,this.typeArguments=t,this.signature=r,this.flags=n.flags|4194304,this.decoratorFlags=n.decoratorFlags,this.contextualTypeArguments=i,this.original=this;let s=n.program;if(this.type=r.type,this.flow=Wn.createDefault(this),!n.is(32768)){let a=0,o=r.thisType;if(o){let c=new nn(v.this_,a++,o,this),f=this.flow.scopedLocals;f||(this.flow.scopedLocals=f=new Map),f.set(v.this_,c),this.localsByIndex[c.index]=c}let u=r.parameterTypes;for(let c=0,f=u.length;c<f;++c){let p=u[c],d=this.getParameterName(c),m=new nn(d,a++,p,this),g=this.flow.scopedLocals;g||(this.flow.scopedLocals=g=new Map),g.set(d,m),this.localsByIndex[m.index]=m}}hs(s,this)}getNonParameterLocalTypes(){let e=this.localsByIndex,n=this.signature,t=e.length,r=n.parameterTypes.length;n.thisType&&++r;let i=t-r,s=new Array(i);for(let a=0;a<i;++a)s[a]=e[r+a].type;return s}getParameterName(e){let n=this.declaration.signature.parameters;return n.length>e?n[e].name.text:au(e)}getClassOrInterface(){let e=this.parent;return e.kind==13&&(e=e.parent),e.kind==7||e.kind==9?e:null}newStub(e){let n=new Hn(this.original.name+Fa+e,this.prototype,this.typeArguments,this.signature.clone(),this.contextualTypeArguments);return n.original=this.original,n.set(this.flags&-8388609|134217728),n}addLocal(e,n=null,t=null){let r=this.localsByIndex,i=r.length,s=n??i.toString();t||(t=this.program.makeNativeVariableDeclaration(s));let a=new nn(s,i,e,this,t);if(n){let o=this.flow,u=o.scopedLocals;if(u||(o.scopedLocals=u=new Map),u.has(n))throw new Error("duplicate local name");u.set(n,a)}return r[i]=a,a}lookup(e,n=!1){if(!n){let t=this.flow.scopedLocals;if(t&&t.has(e))return assert(t.get(e))}return super.lookup(e,n)}finalize(e,n){this.ref=n;let t=this.breakStack;assert(!t||!t.length),this.breakStack=t=null,this.breakLabel=null,this.addDebugInfo(e,n)}addDebugInfo(e,n){if(this.program.options.sourceMap){let t=this.debugLocations;for(let r=0,i=t.length;r<i;++r){let s=t[r],a=s.source;e.setDebugLocation(n,s.debugInfoRef,a.debugInfoIndex,a.lineAt(s.start),a.columnAt()-1)}}if(this.program.options.debugInfo){let t=new Set,r=this.localsByIndex;for(let i=0,s=r.length;i<s;i++){let a=r[i].name;t.has(a)&&(a=`${a}|${i}`),t.add(a),e.setLocalName(n,i,a)}}}},Ql=class extends Kn{constructor(e,n,t,r=0){super(10,e,Ne(e,n,assert(t.is(262144))),n.program,n,t),this.decoratorFlags=r}get typeNode(){return this.declaration.type}get initializerNode(){return this.declaration.initializer}get parameterIndex(){return this.declaration.parameterIndex}},eu=class extends yt{constructor(e,n,t){super(11,e.name,n,e.declaration),this.memoryOffset=-1,this.getterRef=0,this.setterRef=0,this._internalGetterName=null,this._internalSetterName=null,this._internalGetterSignature=null,this._internalSetterSignature=null,this.prototype=e,this.flags=e.flags,this.decoratorFlags=e.decoratorFlags,assert(t!=l.void),this.setType(t),hs(this.program,this)}get thisType(){let e=this.parent;return assert(e.kind==7),e.type}get internalGetterName(){let e=this._internalGetterName;return e==null&&(this._internalGetterName=e=`${this.parent.internalName}${Sr}${Mi}${this.name}`),e}get internalSetterName(){let e=this._internalSetterName;return e==null&&(this._internalSetterName=e=`${this.parent.internalName}${Sr}${Ui}${this.name}`),e}get internalGetterSignature(){let e=this._internalGetterSignature;return e||(this._internalGetterSignature=e=new tn(this.program,null,this.type,this.thisType)),e}get internalSetterSignature(){let e=this._internalSetterSignature;return e||(this._internalSetterSignature=e=new tn(this.program,[this.type],l.void,this.thisType)),e}},kr=class extends Kn{constructor(e,n,t){super(12,e,Ne(e,n,t.is(262144)),n.program,n,t),this.getterPrototype=null,this.setterPrototype=null,this.instance=null,this.boundPrototypes=null,this.flags&=-6145}get isBound(){switch(this.parent.kind){case 7:case 9:return!0}return!1}toBound(e){assert(this.is(262144)),assert(!this.isBound);let n=this.boundPrototypes;if(!n)this.boundPrototypes=n=new Map;else if(n.has(e))return assert(n.get(e));let t=this.declaration;assert(t.kind==58);let r=new kr(this.name,e,t);r.flags=this.flags;let i=this.getterPrototype;i&&(r.getterPrototype=i.toBound(e));let s=this.setterPrototype;return s&&(r.setterPrototype=s.toBound(e)),n.set(e,r),r}},nu=class extends yt{constructor(e,n){super(13,e.name,n,F.createVariableDeclaration(e.identifierNode,null,e.is(262144)?262144:0,null,null,e.identifierNode.range)),this.getterInstance=null,this.setterInstance=null,this.prototype=e,this.flags=e.flags,this.decoratorFlags=e.decoratorFlags,this.is(262144)&&hs(this.program,this)}},tu=class extends $n{constructor(e){super(17,"[]",e.internalName+"[]",e.program,e,e.program.makeNativeVariableDeclaration("[]"))}getGetterInstance(e){return this.parent.lookupOverload(1,e)}getSetterInstance(e){return this.parent.lookupOverload(2,e)}},fs=class extends Kn{constructor(e,n,t,r=0,i=!1){super(i?8:6,e,Ne(e,n,t.is(262144)),n.program,n,t),this.instanceMembers=null,this.basePrototype=null,this.interfacePrototypes=null,this.constructorPrototype=null,this.overloadPrototypes=new Map,this.instances=null,this.extendees=new Set,this.decoratorFlags=r}get typeParameterNodes(){return this.declaration.typeParameters}get extendsNode(){return this.declaration.extendsType}get implementsNodes(){return this.declaration.implementsTypes}get isBuiltinArray(){let e=this.program.arrayBufferViewInstance;return e&&this.extends(e.prototype)}extends(e){let n=this,t=new Set;do{if(t.has(n))break;if(t.add(n),n==e)return!0;n=n.basePrototype}while(n);return!1}addInstance(e,n){let t=n.declaration,r=this.instanceMembers;if(!r)this.instanceMembers=r=new Map;else if(r.has(e)){let i=assert(r.get(e)),s=su(i,n);if(!s)return er(i.kind)?this.program.errorRelated(2300,n.identifierNode.range,i.declaration.name.range,n.identifierNode.text):this.program.error(2300,n.identifierNode.range,n.identifierNode.text),!1;n=s}return r.set(e,n),n.is(2)&&this.is(1048576)&&n.set(1048576),this.program.elementsByDeclaration.set(t,n),!0}getResolvedInstance(e){let n=this.instances;return n&&n.has(e)?n.get(e):null}setResolvedInstance(e,n){let t=this.instances;t?assert(!t.has(e)):this.instances=t=new Map,t.set(e,n)}},ps=class extends $n{constructor(e,n,t=null,r=!1){super(r?9:7,e,Ne(e,n.parent,n.is(262144)),n.program,n.parent,n.declaration),this.base=null,this.interfaces=null,this.contextualTypeArguments=null,this.nextMemoryOffset=0,this.constructorInstance=null,this.overloads=null,this.indexSignature=null,this._id=0,this.rttiFlags=0,this.wrappedType=null,this.extendees=null,this.implementers=null,this.didCheckFieldInitialization=!1,this.visitRef=0;let i=this.program;this.prototype=n,this.flags=n.flags,this.decoratorFlags=n.decoratorFlags,this.typeArguments=t;let s=i.options.usizeType,a=new l(s.kind,s.flags&-129|256,s.size);if(a.classReference=this,this.setType(a),!this.hasDecorator(16)){let u=i.nextClassId++;this._id=u,i.managedClasses.set(u,this)}let o=n.typeParameterNodes;if(t){let u=t.length;if(!o||u!=o.length)throw new Error("type argument count mismatch");if(u){let c=this.contextualTypeArguments;c||(this.contextualTypeArguments=c=new Map);for(let f=0;f<u;++f)c.set(o[f].name.text,t[f])}}else if(o&&o.length>0)throw new Error("type argument count mismatch");hs(i,this)}get id(){return this._id}get isBuiltinArray(){return this.prototype.isBuiltinArray}get isArrayLike(){if(this.isBuiltinArray)return!0;let e=this.getMember("length");return e?(e.kind==11||e.kind==12&&e.getterPrototype!=null)&&(this.lookupOverload(1)!=null||this.lookupOverload(3)!=null):!1}get isInterface(){return this.kind==9}setBase(e){assert(!this.base),this.base=e;let n=e.extendees;n||(e.extendees=n=new Set),n.add(this);let t=e.contextualTypeArguments;if(t){let r=this.contextualTypeArguments;for(let i=Map_keys(t),s=0,a=i.length;s<a;++s){let o=unchecked(i[s]),u=assert(t.get(o));r?r.has(o)||r.set(o,u):(this.contextualTypeArguments=r=new Map,r.set(o,u))}}}addInterface(e){let n=this.interfaces;n||(this.interfaces=n=new Set),n.add(e);let t=e.implementers;t||(e.implementers=t=new Set),t.add(this)}isAssignableTo(e){let n=this;do{if(n==e)return!0;if(e.kind==9){let t=n.interfaces;if(t){for(let r=Set_values(t),i=0,s=r.length;i<s;++i)if(r[i].isAssignableTo(e))return!0}}n=n.base}while(n);return!1}lookupOverload(e,n=!1){if(n)switch(e){case 1:{let r=this.lookupOverload(3);if(r)return r;break}case 2:{let r=this.lookupOverload(4);if(r)return r;break}default:assert(!1)}let t=this;do{let r=t.overloads;if(r!=null&&r.has(e))return assert(r.get(e));t=t.base}while(t);return null}getMethod(e,n=null){let t=this.getMember(e);return t&&t.kind==4?this.program.resolver.resolveFunction(t,n):null}offsetof(e){let n=assert(this.getMember(e));return assert(n.kind==11),n.memoryOffset}createBuffer(e=0){let n=this.program,t=this.nextMemoryOffset+e,r=n.computeBlockSize(t,!0),i=new Uint8Array(n.blockOverhead+r),s=n.OBJECTInstance;return s.writeField("mmInfo",r,i,0),s.writeField("gcInfo",0,i,0),s.writeField("gcInfo2",0,i,0),s.writeField("rtId",this.id,i,0),s.writeField("rtSize",t,i,0),i}writeField(e,n,t,r=this.program.totalOverhead){let i=this.getMember(e);if(i&&i.kind==11){let s=i,a=r+s.memoryOffset,o=s.type.kind;switch(o){case 1:case 6:return assert(!i64_is(n)),me(i32(n),t,a),1;case 2:case 7:return assert(!i64_is(n)),Gi(i32(n),t,a),2;case 3:case 8:return assert(!i64_is(n)),be(i32(n),t,a),4;case 5:case 10:return this.program.options.isWasm64?(i64_is(n)?mi(n,t,a):Vs(i32(n),t,a,o==10),8):(i64_is(n)?mp(n,t,a,o==10):be(i32(n),t,a),4);case 4:case 9:return i64_is(n)?mi(n,t,a):Vs(i32(n),t,a,o==9),8;case 11:return assert(!i64_is(n)),qi(f32(n),t,a),4;case 12:return assert(!i64_is(n)),ji(f64(n),t,a),8}}return assert(!1),0}extends(e){return this.prototype.extends(e)}getTypeArgumentsTo(e){let n=this;do{if(n.prototype==e)return n.typeArguments;n=n.base}while(n);return null}getArrayValueType(){let e=this,n=this.program,t=n.arrayPrototype;if(this.extends(t))return this.getTypeArgumentsTo(t)[0];let r=n.staticArrayPrototype;if(this.extends(r))return this.getTypeArgumentsTo(r)[0];let i=n.arrayBufferViewInstance;for(;e.base!=i;)e=assert(e.base);let s=e.prototype;switch(s.name.charCodeAt(0)){case 70:{if(s==n.float32ArrayPrototype)return l.f32;if(s==n.float64ArrayPrototype)return l.f64;break}case 73:{if(s==n.int8ArrayPrototype)return l.i8;if(s==n.int16ArrayPrototype)return l.i16;if(s==n.int32ArrayPrototype)return l.i32;if(s==n.int64ArrayPrototype)return l.i64;break}case 85:{if(s==n.uint8ArrayPrototype||s==n.uint8ClampedArrayPrototype)return l.u8;if(s==n.uint16ArrayPrototype)return l.u16;if(s==n.uint32ArrayPrototype)return l.u32;if(s==n.uint64ArrayPrototype)return l.u64;break}}return assert(!1),l.void}get isPointerfree(){let e=this.program,n=this.members;if(n){for(let t=Map_values(n),r=0,i=t.length;r<i;++r){let s=unchecked(t[r]);if(s.kind==11&&s.type.isManaged)return!1}if(n.has(v.visit)){let t=this.prototype;if(t==e.arrayPrototype||t==e.staticArrayPrototype||t==e.setPrototype||t==e.mapPrototype){let r=assert(this.getTypeArgumentsTo(t));for(let i=0,s=r.length;i<s;++i)if(r[i].isManaged)return!1;return!0}return!1}}return!0}getAllExtendees(e=null,n=new Set){let t=this.extendees;if(t)for(let r=Set_values(t),i=0,s=r.length;i<s;++i){let a=r[i];if(e){let o=a.prototype.instanceMembers;if(o&&o.has(e))continue}n.add(a),a.getAllExtendees(e,n)}return n}},ru=class extends fs{constructor(e,n,t,r){super(e,n,t,r,!0)}},iu=class extends ps{constructor(e,n,t=null){super(e,n,t,!0)}};function hs(e,n){assert(!e.instancesByName.has(n.internalName)),e.instancesByName.set(n.internalName,n)}function su(e,n){if(assert(e.program==n.program),n.members)return null;let t=null;switch(e.kind){case 4:{switch(n.kind){case 14:{En(n,e),t=e;break}case 16:{e.shadowType||(e.shadowType=n,En(n,e),t=e);break}}break}case 6:case 2:{if(n.kind==14){En(n,e),t=e;break}break}case 14:{switch(n.kind){case 2:case 6:case 4:{En(e,n),t=n;break}case 14:{En(n,e),t=e;break}case 16:{e.shadowType||(e.shadowType=n,En(n,e),t=e);break}}break}case 0:{n.kind==16&&(e.shadowType||(e.shadowType=n,En(n,e),t=e));break}case 16:{switch(n.kind){case 0:case 4:case 14:{n.shadowType||(n.shadowType=e,En(e,n),t=n);break}}break}}if(t){let r=e.is(2)||e.hasDecorator(1),i=n.is(2)||n.hasDecorator(1);r!=i&&e.program.error(2395,t.identifierNode.range,t.identifierNode.text)}return t}function En(e,n){let t=e.members;if(t){let r=n.members;r||(n.members=r=new Map);for(let i=Map_keys(t),s=0,a=i.length;s<a;++s){let o=unchecked(i[s]),u=assert(t.get(o));r.set(o,u)}}}function Ne(e,n,t,r=!1){switch(n.kind){case 15:return r?e:n.internalName+Xn+e;case 5:return r?e:(assert(!t),n.internalName+Ea+e);case 12:case 13:n=n.parent;default:return Ne(n.name,n.parent,n.is(262144),r)+(t?Sr:Pi)+e}}var Ds=[];function au(e){for(let n=Ds.length;n<=e;++n)Ds.push(`$${n}`);return Ds[e]}var ou=(e=>(e[e.Bool=0]="Bool",e[e.I8=1]="I8",e[e.I16=2]="I16",e[e.I32=3]="I32",e[e.I64=4]="I64",e[e.Isize=5]="Isize",e[e.U8=6]="U8",e[e.U16=7]="U16",e[e.U32=8]="U32",e[e.U64=9]="U64",e[e.Usize=10]="Usize",e[e.F32=11]="F32",e[e.F64=12]="F64",e[e.V128=13]="V128",e[e.Funcref=14]="Funcref",e[e.Externref=15]="Externref",e[e.Anyref=16]="Anyref",e[e.Eqref=17]="Eqref",e[e.I31ref=18]="I31ref",e[e.Dataref=19]="Dataref",e[e.Arrayref=20]="Arrayref",e[e.Stringref=21]="Stringref",e[e.StringviewWTF8=22]="StringviewWTF8",e[e.StringviewWTF16=23]="StringviewWTF16",e[e.StringviewIter=24]="StringviewIter",e[e.Void=25]="Void",e))(ou||{}),lu=(e=>(e[e.None=0]="None",e[e.Signed=1]="Signed",e[e.Unsigned=2]="Unsigned",e[e.Integer=4]="Integer",e[e.Float=8]="Float",e[e.Varying=16]="Varying",e[e.Short=32]="Short",e[e.Long=64]="Long",e[e.Value=128]="Value",e[e.Reference=256]="Reference",e[e.Nullable=512]="Nullable",e[e.Vector=1024]="Vector",e[e.External=2048]="External",e[e.Class=4096]="Class",e[e.Function=8192]="Function",e))(lu||{}),G=class{constructor(e,n,t){this.classReference=null,this.signatureReference=null,this._nonNullableType=null,this._nullableType=null,this.ref=0,this.kind=e,this.flags=n,this.size=t,n&512?this._nullableType=this:this._nonNullableType=this}get intType(){if(this==G.auto)return this;switch(this.kind){case 0:case 3:case 11:return G.i32;case 1:return G.i8;case 2:return G.i16;case 12:case 4:return G.i64;case 5:return this.size==64?G.isize64:G.isize32;case 6:return G.u8;case 7:return G.u16;case 8:return G.u32;case 9:return G.u64;case 10:return this.size==64?G.usize64:G.usize32;default:return G.i32}}get exceptVoid(){return this.kind==25?G.auto:this}get byteSize(){return this.size+7>>>3}get alignLog2(){return 31-clz(this.byteSize)}get isValue(){return this.is(128)}get isIntegerValue(){return this.is(132)}get isShortIntegerValue(){return this.is(164)}get isLongIntegerValue(){return this.is(196)}get isSignedIntegerValue(){return this.is(133)}get isUnsignedIntegerValue(){return this.is(134)}get isVaryingIntegerValue(){return this.is(148)}get isIntegerInclReference(){return this.is(4)}get isFloatValue(){return this.is(136)}get isNumericValue(){return this.isIntegerValue||this.isFloatValue}get isBooleanValue(){return this==G.bool}get isVectorValue(){return this.is(1152)}get isReference(){return this.is(256)}get isNullableReference(){return this.is(768)}get isInternalReference(){return this.is(260)}get isExternalReference(){return this.is(2304)}getClass(){return this.isInternalReference?this.classReference:null}get isClass(){return this.getClass()!=null}getClassOrWrapper(e){let n=this.getClass();if(n)return n;{let t=this.getSignature();if(t){let r=t.type,i=assert(e.resolver.resolveClass(e.functionPrototype,[r]));return i.wrappedType=r,i}else{let r=e.wrapperClasses;if(r.has(this))return assert(r.get(this))}}return null}getSignature(){return this.isInternalReference?this.signatureReference:null}get isFunction(){return this.getSignature()!=null}get isManaged(){if(this.isInternalReference){let e=this.classReference;return e?!e.hasDecorator(16):this.signatureReference!=null}return!1}get isUnmanaged(){let e=this.classReference;return e!=null&&e.hasDecorator(16)}get isMemory(){switch(this.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:return!0}return!1}get nonNullableType(){return this.isExternalReference?this:assert(this._nonNullableType)}get nullableType(){return this._nullableType}computeSmallIntegerShift(e){return e.size-this.size}computeSmallIntegerMask(e){let n=this.size;return this.is(2)||(n-=1),-1>>>e.size-n}is(e){return(this.flags&e)==e}isAny(e){return(this.flags&e)!=0}asNullable(){assert(this.isInternalReference);let e=this._nullableType;return e||(assert(!this.isNullableReference),this._nullableType=e=new G(this.kind,this.flags|512,this.size),e.classReference=this.classReference,e.signatureReference=this.signatureReference,e._nonNullableType=this),e}toUnsigned(){switch(this.kind){case 1:return G.u8;case 2:return G.u16;case 3:return G.u32;case 4:return G.u64;case 5:return this.size==64?G.usize64:G.usize32}return this}equals(e){return this.kind!=e.kind?!1:this.isReference?this.classReference==e.classReference&&this.signatureReference==e.signatureReference&&this.isNullableReference==e.isNullableReference:!0}isAssignableTo(e,n=!1){let t,r,i,s;if(this.isReference){if(e.isReference&&(!this.isNullableReference||e.isNullableReference)){if(t=this.getClass()){if(r=e.getClass())return t.isAssignableTo(r)}else if(i=this.getSignature()){if(s=e.getSignature())return i.isAssignableTo(s)}else if(this.isExternalReference&&(this.kind==e.kind||e.kind==16&&this.kind!=15))return!0}}else if(!e.isReference){if(this.isIntegerValue)if(e.isIntegerValue){if(!n||this.isBooleanValue||this.isSignedIntegerValue==e.isSignedIntegerValue)return this.size<=e.size}else{if(e.kind==11)return this.size<=23;if(e.kind==12)return this.size<=52}else if(this.isFloatValue){if(e.isFloatValue)return this.size<=e.size}else if(this.isVectorValue&&e.isVectorValue)return this.size==e.size}return!1}isStrictlyAssignableTo(e,n=!1){return this.isReference?this.isAssignableTo(e):e.isReference?!1:this.isIntegerValue?e.isIntegerValue&&e.size==this.size&&(!n||this.isSignedIntegerValue==e.isSignedIntegerValue):this.kind==e.kind}isChangeableTo(e){if(this.is(4)&&e.is(4)){let n=this.size;return n==e.size&&(n>=32||this.is(1)==e.is(1))}return this.kind==e.kind}canExtendOrImplement(e){let n=this.getClass(),t=e.getClass();if(!n||!t||this.isManaged!=e.isManaged)return!1;if(this.isInternalReference){if(!e.isInternalReference)return!1}else if(this.isExternalReference){if(!e.isExternalReference)return!1}else return!1;return!(n.isInterface&&!t.isInterface)}static commonDenominator(e,n,t){return n.isAssignableTo(e,t)?e:e.isAssignableTo(n,t)?n:null}toString(e=!1){let n=e?"|null":" | null";if(this.isReference){let t=this.getClass();if(t)return this.isNullableReference?t.internalName+n:t.internalName;{let r=this.getSignature();if(r)return this.isNullableReference?`(${r.toString(e)})${n}`:r.toString(e)}}switch(this.kind){case 0:return v.bool;case 1:return v.i8;case 2:return v.i16;case 3:return v.i32;case 4:return v.i64;case 5:return v.isize;case 6:return v.u8;case 7:return v.u16;case 8:return v.u32;case 9:return v.u64;case 10:return v.usize;case 11:return v.f32;case 12:return v.f64;case 13:return v.v128;case 14:return v.funcref;case 15:return v.externref;case 16:return v.anyref;case 17:return v.eqref;case 18:return v.i31ref;case 19:return v.dataref;case 20:return v.arrayref;case 21:return v.stringref;case 22:return v.stringview_wtf8;case 23:return v.stringview_wtf16;case 24:return v.stringview_iter;default:assert(!1);case 25:return v.void_}}toRef(){switch(this.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:return A.I32;case 5:case 10:if(this.size!=64)return A.I32;case 4:case 9:return A.I64;case 11:return A.F32;case 12:return A.F64;case 13:return A.V128;case 14:return ae(oe.Func,this.is(512));case 15:return ae(oe.Extern,this.is(512));case 16:return ae(oe.Any,this.is(512));case 17:return ae(oe.Eq,this.is(512));case 18:return ae(oe.I31,this.is(512));case 19:return ae(oe.Data,this.is(512));case 20:return ae(oe.Array,this.is(512));case 21:return ae(oe.String,this.is(512));case 22:return ae(oe.StringviewWTF8,this.is(512));case 23:return ae(oe.StringviewWTF16,this.is(512));case 24:return ae(oe.StringviewIter,this.is(512));case 25:return A.None}return assert(!1),ls(this)}},l=G;l.i8=new G(1,165,8),l.i16=new G(2,165,16),l.i32=new G(3,133,32),l.i64=new G(4,197,64),l.isize32=new G(5,149,32),l.isize64=new G(5,213,64),l.u8=new G(6,166,8),l.u16=new G(7,166,16),l.u32=new G(8,134,32),l.u64=new G(9,198,64),l.usize32=new G(10,150,32),l.usize64=new G(10,214,64),l.bool=new G(0,166,1),l.f32=new G(11,137,32),l.f64=new G(12,201,64),l.v128=new G(13,1152,128),l.funcref=new G(14,2816,0),l.externref=new G(15,2816,0),l.anyref=new G(16,2816,0),l.eqref=new G(17,2816,0),l.i31ref=new G(18,2816,0),l.dataref=new G(19,2816,0),l.arrayref=new G(20,2816,0),l.stringref=new G(21,2816,0),l.stringview_wtf8=new G(22,2816,0),l.stringview_wtf16=new G(23,2816,0),l.stringview_iter=new G(24,2816,0),l.void=new G(25,0,0),l.auto=new G(G.i32.kind,G.i32.flags,G.i32.size);function Kt(e){let n=e.length,t=new Array(n);for(let r=0;r<n;++r)unchecked(t[r]=e[r].toRef());return t}function Ci(e){let n=e.length;if(!n)return"";let t=new Array(n);for(let r=0;r<n;++r)unchecked(t[r]=e[r].toString(!0));return t.join(",")}var tn=class{constructor(e,n=null,t=null,r=null){this.id=0,this.parameterTypes=n||[],this.requiredParameters=0,this.returnType=t||l.void,this.thisType=r,this.program=e,this.hasRest=!1;let i=e.options.usizeType,s=new l(i.kind,i.flags&-129|256,i.size);this.type=s,s.signatureReference=this;let a=e.uniqueSignatures,o=a.length;for(let u=0;u<o;u++){let c=unchecked(a[u]);if(this.equals(c))return this.id=c.id,this}this.id=e.nextSignatureId++,a.push(this)}get paramRefs(){let e=this.thisType,n=this.parameterTypes,t=n.length;if(!t)return e?e.toRef():A.None;if(e){let r=new Array(1+t);unchecked(r[0]=e.toRef());for(let i=0;i<t;++i)unchecked(r[i+1]=n[i].toRef());return dn(r)}return dn(Kt(n))}get resultRefs(){return this.returnType.toRef()}equals(e){let n=this.thisType,t=e.thisType;if(n){if(!t||!n.equals(t))return!1}else if(t)return!1;if(this.hasRest!=e.hasRest||!this.returnType.equals(e.returnType))return!1;let r=this.parameterTypes,i=e.parameterTypes,s=r.length;if(s!=i.length)return!1;for(let a=0;a<s;++a){let o=unchecked(r[a]),u=unchecked(i[a]);if(!o.equals(u))return!1}return!0}isAssignableTo(e,n=!1){let t=this.thisType,r=e.thisType;if(n){if(t){if(!r||!t.canExtendOrImplement(r))return!1}else if(r)return!1}else if(t){if(!r||!t.isAssignableTo(r))return!1}else if(r)return!1;if(this.hasRest!=e.hasRest)return!1;let i=this.returnType,s=e.returnType;if(!(i==s||i.isAssignableTo(s)))return!1;let a=this.parameterTypes,o=e.parameterTypes,u=a.length;if(u!=o.length)return!1;for(let c=0;c<u;++c){let f=unchecked(a[c]),p=unchecked(o[c]);if(!f.isAssignableTo(p))return!1}return!0}get hasManagedOperands(){let e=this.thisType;if(e&&e.isManaged)return!0;let n=this.parameterTypes;for(let t=0,r=n.length;t<r;++t)if(unchecked(n[t]).isManaged)return!0;return!1}getManagedOperandIndices(){let e=new Array,n=0,t=this.thisType;t&&(t.isManaged&&e.push(n),++n);let r=this.parameterTypes;for(let i=0,s=r.length;i<s;++i)unchecked(r[i]).isManaged&&e.push(n),++n;return e}get hasVectorValueOperands(){let e=this.thisType;if(e&&e.isVectorValue)return!0;let n=this.parameterTypes;for(let t=0,r=n.length;t<r;++t)if(unchecked(n[t]).isVectorValue)return!0;return!1}getVectorValueOperandIndices(){let e=new Array,n=0,t=this.thisType;t&&(t.isVectorValue&&e.push(n),++n);let r=this.parameterTypes;for(let i=0,s=r.length;i<s;++i)unchecked(r[i]).isVectorValue&&e.push(n),++n;return e}toString(e=!1){let n=new Array;n.push(e?"%28":"(");let t=0,r=this.thisType;r&&(n.push(e?"this:":"this: "),assert(!r.signatureReference),n.push(r.toString(e)),t=1);let i=this.parameterTypes,s=i.length;if(s){let a=this.requiredParameters,o=this.hasRest?s-1:-1;for(let u=0;u<s;++u,++t)t&&n.push(e?"%2C":", "),u==o&&n.push("..."),n.push(i[u].toString(e)),u>=a&&u!=o&&n.push("?")}return n.push(e?"%29=>":") => "),n.push(this.returnType.toString(e)),n.join("")}clone(){let e=this.parameterTypes,n=e.length,t=new Array(n);for(let r=0;r<n;++r)unchecked(t[r]=e[r]);return new tn(this.program,t,this.returnType,this.thisType)}},h;(e=>(e.start="~start",e.started="~started",e.argumentsLength="~argumentsLength",e.setArgumentsLength="~setArgumentsLength",e.abort="~lib/builtins/abort",e._g="~lib/builtins/_g",e.max_iterations="~lib/builtins/max_iterations",e.accept="~lib/builtins/$accept",e.emit="~lib/builtins/$emit",e.etxn_details="~lib/builtins/$etxn_details",e.etxn_fee_base="~lib/builtins/$etxn_fee_base",e.etxn_reserve="~lib/builtins/$etxn_reserve",e.float_compare="~lib/builtins/$float_compare",e.float_divide="~lib/builtins/$float_divide",e.float_int="~lib/builtins/$float_int",e.float_mulratio="~lib/builtins/$float_mulratio",e.float_multiply="~lib/builtins/$float_multiply",e.float_negate="~lib/builtins/$float_negate",e.float_set="~lib/builtins/$float_set",e.float_sto="~lib/builtins/$float_sto",e.float_sto_set="~lib/builtins/$float_sto_set",e.float_sum="~lib/builtins/$float_sum",e.hook_account="~lib/builtins/$hook_account",e.hook_param="~lib/builtins/$hook_param",e.ledger_seq="~lib/builtins/ledger_seq",e.otxn_field="~lib/builtins/otxn_field",e.otxn_slot="~lib/builtins/$otxn_slot",e.rollback="~lib/builtins/$rollback",e.slot="~lib/builtins/$slot",e.slot_count="~lib/builtins/$slot_count",e.slot_float="~lib/builtins/$slot_float",e.slot_set="~lib/builtins/$slot_set",e.slot_subarray="~lib/builtins/$slot_subarray",e.slot_subfield="~lib/builtins/$slot_subfield",e.slot_type="~lib/builtins/$slot_type",e.state="~lib/builtins/$state",e.state_foreign="~lib/builtins/$state_foreign",e.state_set="~lib/builtins/$state_set",e.sto_emplace="~lib/builtins/$sto_emplace",e.sto_erase="~lib/builtins/$sto_erase",e.sto_subarray="~lib/builtins/$sto_subarray",e.sto_subfield="~lib/builtins/$sto_subfield",e.trace="~lib/builtins/trace",e.trace_float="~lib/builtins/$trace_float",e.trace_num="~lib/builtins/$trace_num",e.util_accid="~lib/builtins/$util_accid",e.util_keylet="~lib/builtins/$util_keylet",e.util_sha512h="~lib/builtins/$util_sha512h",e.util_verify="~lib/builtins/$util_verify",e.seed="~lib/builtins/seed",e.isBoolean="~lib/builtins/isBoolean",e.isInteger="~lib/builtins/isInteger",e.isSigned="~lib/builtins/isSigned",e.isFloat="~lib/builtins/isFloat",e.isVector="~lib/builtins/isVector",e.isReference="~lib/builtins/isReference",e.isString="~lib/builtins/isString",e.isArray="~lib/builtins/isArray",e.isArrayLike="~lib/builtins/isArrayLike",e.isFunction="~lib/builtins/isFunction",e.isNullable="~lib/builtins/isNullable",e.isDefined="~lib/builtins/isDefined",e.isConstant="~lib/builtins/isConstant",e.isManaged="~lib/builtins/isManaged",e.isVoid="~lib/builtins/isVoid",e.bswap="~lib/builtins/bswap",e.add="~lib/builtins/add",e.sub="~lib/builtins/sub",e.mul="~lib/builtins/mul",e.div="~lib/builtins/div",e.clz="~lib/builtins/clz",e.ctz="~lib/builtins/ctz",e.popcnt="~lib/builtins/popcnt",e.rotl="~lib/builtins/rotl",e.rotr="~lib/builtins/rotr",e.abs="~lib/builtins/abs",e.max="~lib/builtins/max",e.min="~lib/builtins/min",e.ceil="~lib/builtins/ceil",e.floor="~lib/builtins/floor",e.copysign="~lib/builtins/copysign",e.nearest="~lib/builtins/nearest",e.reinterpret="~lib/builtins/reinterpret",e.sqrt="~lib/builtins/sqrt",e.trunc="~lib/builtins/trunc",e.eq="~lib/builtins/eq",e.ne="~lib/builtins/ne",e.rem="~lib/builtins/rem",e.load="~lib/builtins/load",e.store="~lib/builtins/store",e.atomic_load="~lib/builtins/atomic.load",e.atomic_store="~lib/builtins/atomic.store",e.atomic_add="~lib/builtins/atomic.add",e.atomic_sub="~lib/builtins/atomic.sub",e.atomic_and="~lib/builtins/atomic.and",e.atomic_or="~lib/builtins/atomic.or",e.atomic_xor="~lib/builtins/atomic.xor",e.atomic_xchg="~lib/builtins/atomic.xchg",e.atomic_cmpxchg="~lib/builtins/atomic.cmpxchg",e.atomic_wait="~lib/builtins/atomic.wait",e.atomic_notify="~lib/builtins/atomic.notify",e.atomic_fence="~lib/builtins/atomic.fence",e.sizeof="~lib/builtins/sizeof",e.alignof="~lib/builtins/alignof",e.offsetof="~lib/builtins/offsetof",e.nameof="~lib/builtins/nameof",e.lengthof="~lib/builtins/lengthof",e.select="~lib/builtins/select",e.unreachable="~lib/builtins/unreachable",e.changetype="~lib/builtins/changetype",e.assert="~lib/builtins/assert",e.call_indirect="~lib/builtins/call_indirect",e.unchecked="~lib/builtins/unchecked",e.instantiate="~lib/builtins/instantiate",e.idof="~lib/builtins/idof",e.i8="~lib/builtins/i8",e.i16="~lib/builtins/i16",e.i32="~lib/builtins/i32",e.i64="~lib/builtins/i64",e.isize="~lib/builtins/isize",e.u8="~lib/builtins/u8",e.u16="~lib/builtins/u16",e.u32="~lib/builtins/u32",e.u64="~lib/builtins/u64",e.usize="~lib/builtins/usize",e.bool="~lib/builtins/bool",e.f32="~lib/builtins/f32",e.f64="~lib/builtins/f64",e.v128="~lib/builtins/v128",e.i32_clz="~lib/builtins/i32.clz",e.i64_clz="~lib/builtins/i64.clz",e.i32_ctz="~lib/builtins/i32.ctz",e.i64_ctz="~lib/builtins/i64.ctz",e.i32_popcnt="~lib/builtins/i32.popcnt",e.i64_popcnt="~lib/builtins/i64.popcnt",e.i32_rotl="~lib/builtins/i32.rotl",e.i64_rotl="~lib/builtins/i64.rotl",e.i32_rotr="~lib/builtins/i32.rotr",e.i64_rotr="~lib/builtins/i64.rotr",e.f32_abs="~lib/builtins/f32.abs",e.f64_abs="~lib/builtins/f64.abs",e.f32_max="~lib/builtins/f32.max",e.f64_max="~lib/builtins/f64.max",e.f32_min="~lib/builtins/f32.min",e.f64_min="~lib/builtins/f64.min",e.f32_ceil="~lib/builtins/f32.ceil",e.f64_ceil="~lib/builtins/f64.ceil",e.f32_floor="~lib/builtins/f32.floor",e.f64_floor="~lib/builtins/f64.floor",e.f32_copysign="~lib/builtins/f32.copysign",e.f64_copysign="~lib/builtins/f64.copysign",e.f32_nearest="~lib/builtins/f32.nearest",e.f64_nearest="~lib/builtins/f64.nearest",e.i32_reinterpret_f32="~lib/builtins/i32.reinterpret_f32",e.i64_reinterpret_f64="~lib/builtins/i64.reinterpret_f64",e.f32_reinterpret_i32="~lib/builtins/f32.reinterpret_i32",e.f64_reinterpret_i64="~lib/builtins/f64.reinterpret_i64",e.f32_sqrt="~lib/builtins/f32.sqrt",e.f64_sqrt="~lib/builtins/f64.sqrt",e.f32_trunc="~lib/builtins/f32.trunc",e.f64_trunc="~lib/builtins/f64.trunc",e.i32_add="~lib/builtins/i32.add",e.i64_add="~lib/builtins/i64.add",e.f32_add="~lib/builtins/f32.add",e.f64_add="~lib/builtins/f64.add",e.i32_sub="~lib/builtins/i32.sub",e.i64_sub="~lib/builtins/i64.sub",e.f32_sub="~lib/builtins/f32.sub",e.f64_sub="~lib/builtins/f64.sub",e.i32_mul="~lib/builtins/i32.mul",e.i64_mul="~lib/builtins/i64.mul",e.f32_mul="~lib/builtins/f32.mul",e.f64_mul="~lib/builtins/f64.mul",e.i32_div_s="~lib/builtins/i32.div_s",e.i32_div_u="~lib/builtins/i32.div_u",e.i64_div_s="~lib/builtins/i64.div_s",e.i64_div_u="~lib/builtins/i64.div_u",e.f32_div="~lib/builtins/f32.div",e.f64_div="~lib/builtins/f64.div",e.i32_eq="~lib/builtins/i32.eq",e.i64_eq="~lib/builtins/i64.eq",e.f32_eq="~lib/builtins/f32.eq",e.f64_eq="~lib/builtins/f64.eq",e.i32_ne="~lib/builtins/i32.ne",e.i64_ne="~lib/builtins/i64.ne",e.f32_ne="~lib/builtins/f32.ne",e.f64_ne="~lib/builtins/f64.ne",e.i32_rem_s="~lib/builtins/i32.rem_s",e.i32_rem_u="~lib/builtins/i32.rem_u",e.i64_rem_s="~lib/builtins/i64.rem_s",e.i64_rem_u="~lib/builtins/i64.rem_u",e.i32_load8_s="~lib/builtins/i32.load8_s",e.i32_load8_u="~lib/builtins/i32.load8_u",e.i32_load16_s="~lib/builtins/i32.load16_s",e.i32_load16_u="~lib/builtins/i32.load16_u",e.i32_load="~lib/builtins/i32.load",e.i64_load8_s="~lib/builtins/i64.load8_s",e.i64_load8_u="~lib/builtins/i64.load8_u",e.i64_load16_s="~lib/builtins/i64.load16_s",e.i64_load16_u="~lib/builtins/i64.load16_u",e.i64_load32_s="~lib/builtins/i64.load32_s",e.i64_load32_u="~lib/builtins/i64.load32_u",e.i64_load="~lib/builtins/i64.load",e.f32_load="~lib/builtins/f32.load",e.f64_load="~lib/builtins/f64.load",e.i32_store8="~lib/builtins/i32.store8",e.i32_store16="~lib/builtins/i32.store16",e.i32_store="~lib/builtins/i32.store",e.i64_store8="~lib/builtins/i64.store8",e.i64_store16="~lib/builtins/i64.store16",e.i64_store32="~lib/builtins/i64.store32",e.i64_store="~lib/builtins/i64.store",e.f32_store="~lib/builtins/f32.store",e.f64_store="~lib/builtins/f64.store",e.i32_atomic_load8_u="~lib/builtins/i32.atomic.load8_u",e.i32_atomic_load16_u="~lib/builtins/i32.atomic.load16_u",e.i32_atomic_load="~lib/builtins/i32.atomic.load",e.i64_atomic_load8_u="~lib/builtins/i64.atomic.load8_u",e.i64_atomic_load16_u="~lib/builtins/i64.atomic.load16_u",e.i64_atomic_load32_u="~lib/builtins/i64.atomic.load32_u",e.i64_atomic_load="~lib/builtins/i64.atomic.load",e.i32_atomic_store8="~lib/builtins/i32.atomic.store8",e.i32_atomic_store16="~lib/builtins/i32.atomic.store16",e.i32_atomic_store="~lib/builtins/i32.atomic.store",e.i64_atomic_store8="~lib/builtins/i64.atomic.store8",e.i64_atomic_store16="~lib/builtins/i64.atomic.store16",e.i64_atomic_store32="~lib/builtins/i64.atomic.store32",e.i64_atomic_store="~lib/builtins/i64.atomic.store",e.i32_atomic_rmw8_add_u="~lib/builtins/i32.atomic.rmw8.add_u",e.i32_atomic_rmw16_add_u="~lib/builtins/i32.atomic.rmw16.add_u",e.i32_atomic_rmw_add="~lib/builtins/i32.atomic.rmw.add",e.i64_atomic_rmw8_add_u="~lib/builtins/i64.atomic.rmw8.add_u",e.i64_atomic_rmw16_add_u="~lib/builtins/i64.atomic.rmw16.add_u",e.i64_atomic_rmw32_add_u="~lib/builtins/i64.atomic.rmw32.add_u",e.i64_atomic_rmw_add="~lib/builtins/i64.atomic.rmw.add",e.i32_atomic_rmw8_sub_u="~lib/builtins/i32.atomic.rmw8.sub_u",e.i32_atomic_rmw16_sub_u="~lib/builtins/i32.atomic.rmw16.sub_u",e.i32_atomic_rmw_sub="~lib/builtins/i32.atomic.rmw.sub",e.i64_atomic_rmw8_sub_u="~lib/builtins/i64.atomic.rmw8.sub_u",e.i64_atomic_rmw16_sub_u="~lib/builtins/i64.atomic.rmw16.sub_u",e.i64_atomic_rmw32_sub_u="~lib/builtins/i64.atomic.rmw32.sub_u",e.i64_atomic_rmw_sub="~lib/builtins/i64.atomic.rmw.sub",e.i32_atomic_rmw8_and_u="~lib/builtins/i32.atomic.rmw8.and_u",e.i32_atomic_rmw16_and_u="~lib/builtins/i32.atomic.rmw16.and_u",e.i32_atomic_rmw_and="~lib/builtins/i32.atomic.rmw.and",e.i64_atomic_rmw8_and_u="~lib/builtins/i64.atomic.rmw8.and_u",e.i64_atomic_rmw16_and_u="~lib/builtins/i64.atomic.rmw16.and_u",e.i64_atomic_rmw32_and_u="~lib/builtins/i64.atomic.rmw32.and_u",e.i64_atomic_rmw_and="~lib/builtins/i64.atomic.rmw.and",e.i32_atomic_rmw8_or_u="~lib/builtins/i32.atomic.rmw8.or_u",e.i32_atomic_rmw16_or_u="~lib/builtins/i32.atomic.rmw16.or_u",e.i32_atomic_rmw_or="~lib/builtins/i32.atomic.rmw.or",e.i64_atomic_rmw8_or_u="~lib/builtins/i64.atomic.rmw8.or_u",e.i64_atomic_rmw16_or_u="~lib/builtins/i64.atomic.rmw16.or_u",e.i64_atomic_rmw32_or_u="~lib/builtins/i64.atomic.rmw32.or_u",e.i64_atomic_rmw_or="~lib/builtins/i64.atomic.rmw.or",e.i32_atomic_rmw8_xor_u="~lib/builtins/i32.atomic.rmw8.xor_u",e.i32_atomic_rmw16_xor_u="~lib/builtins/i32.atomic.rmw16.xor_u",e.i32_atomic_rmw_xor="~lib/builtins/i32.atomic.rmw.xor",e.i64_atomic_rmw8_xor_u="~lib/builtins/i64.atomic.rmw8.xor_u",e.i64_atomic_rmw16_xor_u="~lib/builtins/i64.atomic.rmw16.xor_u",e.i64_atomic_rmw32_xor_u="~lib/builtins/i64.atomic.rmw32.xor_u",e.i64_atomic_rmw_xor="~lib/builtins/i64.atomic.rmw.xor",e.i32_atomic_rmw8_xchg_u="~lib/builtins/i32.atomic.rmw8.xchg_u",e.i32_atomic_rmw16_xchg_u="~lib/builtins/i32.atomic.rmw16.xchg_u",e.i32_atomic_rmw_xchg="~lib/builtins/i32.atomic.rmw.xchg",e.i64_atomic_rmw8_xchg_u="~lib/builtins/i64.atomic.rmw8.xchg_u",e.i64_atomic_rmw16_xchg_u="~lib/builtins/i64.atomic.rmw16.xchg_u",e.i64_atomic_rmw32_xchg_u="~lib/builtins/i64.atomic.rmw32.xchg_u",e.i64_atomic_rmw_xchg="~lib/builtins/i64.atomic.rmw.xchg",e.i32_atomic_rmw8_cmpxchg_u="~lib/builtins/i32.atomic.rmw8.cmpxchg_u",e.i32_atomic_rmw16_cmpxchg_u="~lib/builtins/i32.atomic.rmw16.cmpxchg_u",e.i32_atomic_rmw_cmpxchg="~lib/builtins/i32.atomic.rmw.cmpxchg",e.i64_atomic_rmw8_cmpxchg_u="~lib/builtins/i64.atomic.rmw8.cmpxchg_u",e.i64_atomic_rmw16_cmpxchg_u="~lib/builtins/i64.atomic.rmw16.cmpxchg_u",e.i64_atomic_rmw32_cmpxchg_u="~lib/builtins/i64.atomic.rmw32.cmpxchg_u",e.i64_atomic_rmw_cmpxchg="~lib/builtins/i64.atomic.rmw.cmpxchg",e.i32_wait="~lib/builtins/i32.wait",e.i64_wait="~lib/builtins/i64.wait",e.v128_splat="~lib/builtins/v128.splat",e.v128_extract_lane="~lib/builtins/v128.extract_lane",e.v128_replace_lane="~lib/builtins/v128.replace_lane",e.v128_shuffle="~lib/builtins/v128.shuffle",e.v128_swizzle="~lib/builtins/v128.swizzle",e.v128_load_splat="~lib/builtins/v128.load_splat",e.v128_load_ext="~lib/builtins/v128.load_ext",e.v128_load_zero="~lib/builtins/v128.load_zero",e.v128_load_lane="~lib/builtins/v128.load_lane",e.v128_store_lane="~lib/builtins/v128.store_lane",e.v128_load="~lib/builtins/v128.load",e.v128_load8x8_s="~lib/builtins/v128.load8x8_s",e.v128_load8x8_u="~lib/builtins/v128.load8x8_u",e.v128_load16x4_s="~lib/builtins/v128.load16x4_s",e.v128_load16x4_u="~lib/builtins/v128.load16x4_u",e.v128_load32x2_s="~lib/builtins/v128.load32x2_s",e.v128_load32x2_u="~lib/builtins/v128.load32x2_u",e.v128_load8_splat="~lib/builtins/v128.load8_splat",e.v128_load16_splat="~lib/builtins/v128.load16_splat",e.v128_load32_splat="~lib/builtins/v128.load32_splat",e.v128_load64_splat="~lib/builtins/v128.load64_splat",e.v128_load32_zero="~lib/builtins/v128.load32_zero",e.v128_load64_zero="~lib/builtins/v128.load64_zero",e.v128_load8_lane="~lib/builtins/v128.load8_lane",e.v128_load16_lane="~lib/builtins/v128.load16_lane",e.v128_load32_lane="~lib/builtins/v128.load32_lane",e.v128_load64_lane="~lib/builtins/v128.load64_lane",e.v128_store8_lane="~lib/builtins/v128.store8_lane",e.v128_store16_lane="~lib/builtins/v128.store16_lane",e.v128_store32_lane="~lib/builtins/v128.store32_lane",e.v128_store64_lane="~lib/builtins/v128.store64_lane",e.v128_store="~lib/builtins/v128.store",e.v128_add="~lib/builtins/v128.add",e.v128_sub="~lib/builtins/v128.sub",e.v128_mul="~lib/builtins/v128.mul",e.v128_div="~lib/builtins/v128.div",e.v128_neg="~lib/builtins/v128.neg",e.v128_add_sat="~lib/builtins/v128.add_sat",e.v128_sub_sat="~lib/builtins/v128.sub_sat",e.v128_shl="~lib/builtins/v128.shl",e.v128_shr="~lib/builtins/v128.shr",e.v128_and="~lib/builtins/v128.and",e.v128_or="~lib/builtins/v128.or",e.v128_xor="~lib/builtins/v128.xor",e.v128_andnot="~lib/builtins/v128.andnot",e.v128_not="~lib/builtins/v128.not",e.v128_bitselect="~lib/builtins/v128.bitselect",e.v128_any_true="~lib/builtins/v128.any_true",e.v128_all_true="~lib/builtins/v128.all_true",e.v128_bitmask="~lib/builtins/v128.bitmask",e.v128_popcnt="~lib/builtins/v128.popcnt",e.v128_min="~lib/builtins/v128.min",e.v128_max="~lib/builtins/v128.max",e.v128_pmin="~lib/builtins/v128.pmin",e.v128_pmax="~lib/builtins/v128.pmax",e.v128_dot="~lib/builtins/v128.dot",e.v128_avgr="~lib/builtins/v128.avgr",e.v128_abs="~lib/builtins/v128.abs",e.v128_sqrt="~lib/builtins/v128.sqrt",e.v128_ceil="~lib/builtins/v128.ceil",e.v128_floor="~lib/builtins/v128.floor",e.v128_trunc="~lib/builtins/v128.trunc",e.v128_nearest="~lib/builtins/v128.nearest",e.v128_eq="~lib/builtins/v128.eq",e.v128_ne="~lib/builtins/v128.ne",e.v128_lt="~lib/builtins/v128.lt",e.v128_le="~lib/builtins/v128.le",e.v128_gt="~lib/builtins/v128.gt",e.v128_ge="~lib/builtins/v128.ge",e.v128_convert="~lib/builtins/v128.convert",e.v128_convert_low="~lib/builtins/v128.convert_low",e.v128_trunc_sat="~lib/builtins/v128.trunc_sat",e.v128_trunc_sat_zero="~lib/builtins/v128.trunc_sat_zero",e.v128_narrow="~lib/builtins/v128.narrow",e.v128_extend_low="~lib/builtins/v128.extend_low",e.v128_extend_high="~lib/builtins/v128.extend_high",e.v128_extadd_pairwise="~lib/builtins/v128.extadd_pairwise",e.v128_demote_zero="~lib/builtins/v128.demote_zero",e.v128_promote_low="~lib/builtins/v128.promote_low",e.v128_q15mulr_sat="~lib/builtins/v128.q15mulr_sat",e.v128_extmul_low="~lib/builtins/v128.extmul_low",e.v128_extmul_high="~lib/builtins/v128.extmul_high",e.i8x16="~lib/builtins/i8x16",e.i16x8="~lib/builtins/i16x8",e.i32x4="~lib/builtins/i32x4",e.i64x2="~lib/builtins/i64x2",e.f32x4="~lib/builtins/f32x4",e.f64x2="~lib/builtins/f64x2",e.i8x16_splat="~lib/builtins/i8x16.splat",e.i8x16_extract_lane_s="~lib/builtins/i8x16.extract_lane_s",e.i8x16_extract_lane_u="~lib/builtins/i8x16.extract_lane_u",e.i8x16_replace_lane="~lib/builtins/i8x16.replace_lane",e.i8x16_add="~lib/builtins/i8x16.add",e.i8x16_sub="~lib/builtins/i8x16.sub",e.i8x16_mul="~lib/builtins/i8x16.mul",e.i8x16_min_s="~lib/builtins/i8x16.min_s",e.i8x16_min_u="~lib/builtins/i8x16.min_u",e.i8x16_max_s="~lib/builtins/i8x16.max_s",e.i8x16_max_u="~lib/builtins/i8x16.max_u",e.i8x16_avgr_u="~lib/builtins/i8x16.avgr_u",e.i8x16_abs="~lib/builtins/i8x16.abs",e.i8x16_neg="~lib/builtins/i8x16.neg",e.i8x16_add_sat_s="~lib/builtins/i8x16.add_sat_s",e.i8x16_add_sat_u="~lib/builtins/i8x16.add_sat_u",e.i8x16_sub_sat_s="~lib/builtins/i8x16.sub_sat_s",e.i8x16_sub_sat_u="~lib/builtins/i8x16.sub_sat_u",e.i8x16_shl="~lib/builtins/i8x16.shl",e.i8x16_shr_s="~lib/builtins/i8x16.shr_s",e.i8x16_shr_u="~lib/builtins/i8x16.shr_u",e.i8x16_all_true="~lib/builtins/i8x16.all_true",e.i8x16_bitmask="~lib/builtins/i8x16.bitmask",e.i8x16_popcnt="~lib/builtins/i8x16.popcnt",e.i8x16_eq="~lib/builtins/i8x16.eq",e.i8x16_ne="~lib/builtins/i8x16.ne",e.i8x16_lt_s="~lib/builtins/i8x16.lt_s",e.i8x16_lt_u="~lib/builtins/i8x16.lt_u",e.i8x16_le_s="~lib/builtins/i8x16.le_s",e.i8x16_le_u="~lib/builtins/i8x16.le_u",e.i8x16_gt_s="~lib/builtins/i8x16.gt_s",e.i8x16_gt_u="~lib/builtins/i8x16.gt_u",e.i8x16_ge_s="~lib/builtins/i8x16.ge_s",e.i8x16_ge_u="~lib/builtins/i8x16.ge_u",e.i8x16_narrow_i16x8_s="~lib/builtins/i8x16.narrow_i16x8_s",e.i8x16_narrow_i16x8_u="~lib/builtins/i8x16.narrow_i16x8_u",e.i8x16_shuffle="~lib/builtins/i8x16.shuffle",e.i8x16_swizzle="~lib/builtins/i8x16.swizzle",e.i16x8_splat="~lib/builtins/i16x8.splat",e.i16x8_extract_lane_s="~lib/builtins/i16x8.extract_lane_s",e.i16x8_extract_lane_u="~lib/builtins/i16x8.extract_lane_u",e.i16x8_replace_lane="~lib/builtins/i16x8.replace_lane",e.i16x8_add="~lib/builtins/i16x8.add",e.i16x8_sub="~lib/builtins/i16x8.sub",e.i16x8_mul="~lib/builtins/i16x8.mul",e.i16x8_min_s="~lib/builtins/i16x8.min_s",e.i16x8_min_u="~lib/builtins/i16x8.min_u",e.i16x8_max_s="~lib/builtins/i16x8.max_s",e.i16x8_max_u="~lib/builtins/i16x8.max_u",e.i16x8_avgr_u="~lib/builtins/i16x8.avgr_u",e.i16x8_abs="~lib/builtins/i16x8.abs",e.i16x8_neg="~lib/builtins/i16x8.neg",e.i16x8_add_sat_s="~lib/builtins/i16x8.add_sat_s",e.i16x8_add_sat_u="~lib/builtins/i16x8.add_sat_u",e.i16x8_sub_sat_s="~lib/builtins/i16x8.sub_sat_s",e.i16x8_sub_sat_u="~lib/builtins/i16x8.sub_sat_u",e.i16x8_shl="~lib/builtins/i16x8.shl",e.i16x8_shr_s="~lib/builtins/i16x8.shr_s",e.i16x8_shr_u="~lib/builtins/i16x8.shr_u",e.i16x8_all_true="~lib/builtins/i16x8.all_true",e.i16x8_bitmask="~lib/builtins/i16x8.bitmask",e.i16x8_eq="~lib/builtins/i16x8.eq",e.i16x8_ne="~lib/builtins/i16x8.ne",e.i16x8_lt_s="~lib/builtins/i16x8.lt_s",e.i16x8_lt_u="~lib/builtins/i16x8.lt_u",e.i16x8_le_s="~lib/builtins/i16x8.le_s",e.i16x8_le_u="~lib/builtins/i16x8.le_u",e.i16x8_gt_s="~lib/builtins/i16x8.gt_s",e.i16x8_gt_u="~lib/builtins/i16x8.gt_u",e.i16x8_ge_s="~lib/builtins/i16x8.ge_s",e.i16x8_ge_u="~lib/builtins/i16x8.ge_u",e.i16x8_narrow_i32x4_s="~lib/builtins/i16x8.narrow_i32x4_s",e.i16x8_narrow_i32x4_u="~lib/builtins/i16x8.narrow_i32x4_u",e.i16x8_extend_low_i8x16_s="~lib/builtins/i16x8.extend_low_i8x16_s",e.i16x8_extend_low_i8x16_u="~lib/builtins/i16x8.extend_low_i8x16_u",e.i16x8_extend_high_i8x16_s="~lib/builtins/i16x8.extend_high_i8x16_s",e.i16x8_extend_high_i8x16_u="~lib/builtins/i16x8.extend_high_i8x16_u",e.i16x8_extadd_pairwise_i8x16_s="~lib/builtins/i16x8.extadd_pairwise_i8x16_s",e.i16x8_extadd_pairwise_i8x16_u="~lib/builtins/i16x8.extadd_pairwise_i8x16_u",e.i16x8_q15mulr_sat_s="~lib/builtins/i16x8.q15mulr_sat_s",e.i16x8_extmul_low_i8x16_s="~lib/builtins/i16x8.extmul_low_i8x16_s",e.i16x8_extmul_low_i8x16_u="~lib/builtins/i16x8.extmul_low_i8x16_u",e.i16x8_extmul_high_i8x16_s="~lib/builtins/i16x8.extmul_high_i8x16_s",e.i16x8_extmul_high_i8x16_u="~lib/builtins/i16x8.extmul_high_i8x16_u",e.i16x8_shuffle="~lib/builtins/i16x8.shuffle",e.i16x8_swizzle="~lib/builtins/i16x8.swizzle",e.i32x4_splat="~lib/builtins/i32x4.splat",e.i32x4_extract_lane="~lib/builtins/i32x4.extract_lane",e.i32x4_replace_lane="~lib/builtins/i32x4.replace_lane",e.i32x4_add="~lib/builtins/i32x4.add",e.i32x4_sub="~lib/builtins/i32x4.sub",e.i32x4_mul="~lib/builtins/i32x4.mul",e.i32x4_min_s="~lib/builtins/i32x4.min_s",e.i32x4_min_u="~lib/builtins/i32x4.min_u",e.i32x4_max_s="~lib/builtins/i32x4.max_s",e.i32x4_max_u="~lib/builtins/i32x4.max_u",e.i32x4_dot_i16x8_s="~lib/builtins/i32x4.dot_i16x8_s",e.i32x4_abs="~lib/builtins/i32x4.abs",e.i32x4_neg="~lib/builtins/i32x4.neg",e.i32x4_shl="~lib/builtins/i32x4.shl",e.i32x4_shr_s="~lib/builtins/i32x4.shr_s",e.i32x4_shr_u="~lib/builtins/i32x4.shr_u",e.i32x4_all_true="~lib/builtins/i32x4.all_true",e.i32x4_bitmask="~lib/builtins/i32x4.bitmask",e.i32x4_eq="~lib/builtins/i32x4.eq",e.i32x4_ne="~lib/builtins/i32x4.ne",e.i32x4_lt_s="~lib/builtins/i32x4.lt_s",e.i32x4_lt_u="~lib/builtins/i32x4.lt_u",e.i32x4_le_s="~lib/builtins/i32x4.le_s",e.i32x4_le_u="~lib/builtins/i32x4.le_u",e.i32x4_gt_s="~lib/builtins/i32x4.gt_s",e.i32x4_gt_u="~lib/builtins/i32x4.gt_u",e.i32x4_ge_s="~lib/builtins/i32x4.ge_s",e.i32x4_ge_u="~lib/builtins/i32x4.ge_u",e.i32x4_trunc_sat_f32x4_s="~lib/builtins/i32x4.trunc_sat_f32x4_s",e.i32x4_trunc_sat_f32x4_u="~lib/builtins/i32x4.trunc_sat_f32x4_u",e.i32x4_trunc_sat_f64x2_s_zero="~lib/builtins/i32x4.trunc_sat_f64x2_s_zero",e.i32x4_trunc_sat_f64x2_u_zero="~lib/builtins/i32x4.trunc_sat_f64x2_u_zero",e.i32x4_extend_low_i16x8_s="~lib/builtins/i32x4.extend_low_i16x8_s",e.i32x4_extend_low_i16x8_u="~lib/builtins/i32x4.extend_low_i16x8_u",e.i32x4_extend_high_i16x8_s="~lib/builtins/i32x4.extend_high_i16x8_s",e.i32x4_extend_high_i16x8_u="~lib/builtins/i32x4.extend_high_i16x8_u",e.i32x4_extadd_pairwise_i16x8_s="~lib/builtins/i32x4.extadd_pairwise_i16x8_s",e.i32x4_extadd_pairwise_i16x8_u="~lib/builtins/i32x4.extadd_pairwise_i16x8_u",e.i32x4_extmul_low_i16x8_s="~lib/builtins/i32x4.extmul_low_i16x8_s",e.i32x4_extmul_low_i16x8_u="~lib/builtins/i32x4.extmul_low_i16x8_u",e.i32x4_extmul_high_i16x8_s="~lib/builtins/i32x4.extmul_high_i16x8_s",e.i32x4_extmul_high_i16x8_u="~lib/builtins/i32x4.extmul_high_i16x8_u",e.i32x4_shuffle="~lib/builtins/i32x4.shuffle",e.i32x4_swizzle="~lib/builtins/i32x4.swizzle",e.i64x2_splat="~lib/builtins/i64x2.splat",e.i64x2_extract_lane="~lib/builtins/i64x2.extract_lane",e.i64x2_replace_lane="~lib/builtins/i64x2.replace_lane",e.i64x2_add="~lib/builtins/i64x2.add",e.i64x2_sub="~lib/builtins/i64x2.sub",e.i64x2_mul="~lib/builtins/i64x2.mul",e.i64x2_abs="~lib/builtins/i64x2.abs",e.i64x2_neg="~lib/builtins/i64x2.neg",e.i64x2_shl="~lib/builtins/i64x2.shl",e.i64x2_shr_s="~lib/builtins/i64x2.shr_s",e.i64x2_shr_u="~lib/builtins/i64x2.shr_u",e.i64x2_all_true="~lib/builtins/i64x2.all_true",e.i64x2_bitmask="~lib/builtins/i64x2.bitmask",e.i64x2_eq="~lib/builtins/i64x2.eq",e.i64x2_ne="~lib/builtins/i64x2.ne",e.i64x2_lt_s="~lib/builtins/i64x2.lt_s",e.i64x2_lt_u="~lib/builtins/i64x2.lt_u",e.i64x2_le_s="~lib/builtins/i64x2.le_s",e.i64x2_le_u="~lib/builtins/i64x2.le_u",e.i64x2_gt_s="~lib/builtins/i64x2.gt_s",e.i64x2_gt_u="~lib/builtins/i64x2.gt_u",e.i64x2_ge_s="~lib/builtins/i64x2.ge_s",e.i64x2_ge_u="~lib/builtins/i64x2.ge_u",e.i64x2_extend_low_i32x4_s="~lib/builtins/i64x2.extend_low_i32x4_s",e.i64x2_extend_low_i32x4_u="~lib/builtins/i64x2.extend_low_i32x4_u",e.i64x2_extend_high_i32x4_s="~lib/builtins/i64x2.extend_high_i32x4_s",e.i64x2_extend_high_i32x4_u="~lib/builtins/i64x2.extend_high_i32x4_u",e.i64x2_extmul_low_i32x4_s="~lib/builtins/i64x2.extmul_low_i32x4_s",e.i64x2_extmul_low_i32x4_u="~lib/builtins/i64x2.extmul_low_i32x4_u",e.i64x2_extmul_high_i32x4_s="~lib/builtins/i64x2.extmul_high_i32x4_s",e.i64x2_extmul_high_i32x4_u="~lib/builtins/i64x2.extmul_high_i32x4_u",e.i64x2_shuffle="~lib/builtins/i64x2.shuffle",e.i64x2_swizzle="~lib/builtins/i64x2.swizzle",e.f32x4_splat="~lib/builtins/f32x4.splat",e.f32x4_extract_lane="~lib/builtins/f32x4.extract_lane",e.f32x4_replace_lane="~lib/builtins/f32x4.replace_lane",e.f32x4_add="~lib/builtins/f32x4.add",e.f32x4_sub="~lib/builtins/f32x4.sub",e.f32x4_mul="~lib/builtins/f32x4.mul",e.f32x4_div="~lib/builtins/f32x4.div",e.f32x4_neg="~lib/builtins/f32x4.neg",e.f32x4_min="~lib/builtins/f32x4.min",e.f32x4_max="~lib/builtins/f32x4.max",e.f32x4_pmin="~lib/builtins/f32x4.pmin",e.f32x4_pmax="~lib/builtins/f32x4.pmax",e.f32x4_abs="~lib/builtins/f32x4.abs",e.f32x4_sqrt="~lib/builtins/f32x4.sqrt",e.f32x4_ceil="~lib/builtins/f32x4.ceil",e.f32x4_floor="~lib/builtins/f32x4.floor",e.f32x4_trunc="~lib/builtins/f32x4.trunc",e.f32x4_nearest="~lib/builtins/f32x4.nearest",e.f32x4_eq="~lib/builtins/f32x4.eq",e.f32x4_ne="~lib/builtins/f32x4.ne",e.f32x4_lt="~lib/builtins/f32x4.lt",e.f32x4_le="~lib/builtins/f32x4.le",e.f32x4_gt="~lib/builtins/f32x4.gt",e.f32x4_ge="~lib/builtins/f32x4.ge",e.f32x4_convert_i32x4_s="~lib/builtins/f32x4.convert_i32x4_s",e.f32x4_convert_i32x4_u="~lib/builtins/f32x4.convert_i32x4_u",e.f32x4_demote_f64x2_zero="~lib/builtins/f32x4.demote_f64x2_zero",e.f32x4_shuffle="~lib/builtins/f32x4.shuffle",e.f32x4_swizzle="~lib/builtins/f32x4.swizzle",e.f64x2_splat="~lib/builtins/f64x2.splat",e.f64x2_extract_lane="~lib/builtins/f64x2.extract_lane",e.f64x2_replace_lane="~lib/builtins/f64x2.replace_lane",e.f64x2_add="~lib/builtins/f64x2.add",e.f64x2_sub="~lib/builtins/f64x2.sub",e.f64x2_mul="~lib/builtins/f64x2.mul",e.f64x2_div="~lib/builtins/f64x2.div",e.f64x2_neg="~lib/builtins/f64x2.neg",e.f64x2_min="~lib/builtins/f64x2.min",e.f64x2_max="~lib/builtins/f64x2.max",e.f64x2_pmin="~lib/builtins/f64x2.pmin",e.f64x2_pmax="~lib/builtins/f64x2.pmax",e.f64x2_abs="~lib/builtins/f64x2.abs",e.f64x2_sqrt="~lib/builtins/f64x2.sqrt",e.f64x2_ceil="~lib/builtins/f64x2.ceil",e.f64x2_floor="~lib/builtins/f64x2.floor",e.f64x2_trunc="~lib/builtins/f64x2.trunc",e.f64x2_nearest="~lib/builtins/f64x2.nearest",e.f64x2_eq="~lib/builtins/f64x2.eq",e.f64x2_ne="~lib/builtins/f64x2.ne",e.f64x2_lt="~lib/builtins/f64x2.lt",e.f64x2_le="~lib/builtins/f64x2.le",e.f64x2_gt="~lib/builtins/f64x2.gt",e.f64x2_ge="~lib/builtins/f64x2.ge",e.f64x2_convert_low_i32x4_s="~lib/builtins/f64x2.convert_low_i32x4_s",e.f64x2_convert_low_i32x4_u="~lib/builtins/f64x2.convert_low_i32x4_u",e.f64x2_promote_low_f32x4="~lib/builtins/f64x2.promote_low_f32x4",e.f64x2_shuffle="~lib/builtins/f64x2.shuffle",e.f64x2_swizzle="~lib/builtins/f64x2.swizzle",e.i31_new="~lib/builtins/i31.new",e.i31_get="~lib/builtins/i31.get",e.data_end="~lib/memory/__data_end",e.stack_pointer="~lib/memory/__stack_pointer",e.heap_base="~lib/memory/__heap_base",e.rtti_base="~lib/rt/__rtti_base",e.visit_globals="~lib/rt/__visit_globals",e.visit_members="~lib/rt/__visit_members",e.tostack="~lib/rt/__tostack",e.isNaN="~lib/number/isNaN",e.isFinite="~lib/number/isFinite",e.ERROR="~lib/diagnostics/ERROR",e.WARNING="~lib/diagnostics/WARNING",e.INFO="~lib/diagnostics/INFO",e.Function="~lib/function/Function",e.memory_size="~lib/memory/memory.size",e.memory_grow="~lib/memory/memory.grow",e.memory_copy="~lib/memory/memory.copy",e.memory_fill="~lib/memory/memory.fill",e.memory_data="~lib/memory/memory.data",e.Int8Array="~lib/typedarray/Int8Array",e.Uint8Array="~lib/typedarray/Uint8Array",e.Uint8ClampedArray="~lib/typedarray/Uint8ClampedArray",e.Int16Array="~lib/typedarray/Int16Array",e.Uint16Array="~lib/typedarray/Uint16Array",e.Int32Array="~lib/typedarray/Int32Array",e.Uint32Array="~lib/typedarray/Uint32Array",e.Int64Array="~lib/typedarray/Int64Array",e.Uint64Array="~lib/typedarray/Uint64Array",e.Float32Array="~lib/typedarray/Float32Array",e.Float64Array="~lib/typedarray/Float64Array",e.String_raw="~lib/string/String.raw",e.String_eq="~lib/string/String.__eq",e.String_ne="~lib/string/String.__ne",e.String_not="~lib/string/String.__not"))(h||={});var iy=class{constructor(e,n,t,r,i,s,a,o){this.compiler=e,this.prototype=n,this.typeArguments=t,this.operands=r,this.thisOperand=i,this.contextualType=s,this.reportNode=a,this.contextIsExact=o}},x=new Map,Ks=new Map,sy=1<<31;function ay(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isBooleanValue?1:0)):t.unreachable()}x.set(h.isBoolean,ay);function oy(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isIntegerValue?1:0)):t.unreachable()}x.set(h.isInteger,oy);function ly(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isSignedIntegerValue?1:0)):t.unreachable()}x.set(h.isSigned,ly);function uy(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isFloatValue?1:0)):t.unreachable()}x.set(h.isFloat,uy);function cy(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isVectorValue?1:0)):t.unreachable()}x.set(h.isVector,cy);function fy(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isReference?1:0)):t.unreachable()}x.set(h.isReference,fy);function py(e){let n=e.compiler,t=n.module,r=Se(e);if(n.currentType=l.bool,!r)return t.unreachable();let i=r.getClass();return Ee(e,t.i32(i&&i.isAssignableTo(n.program.stringInstance)?1:0))}x.set(h.isString,py);function hy(e){let n=e.compiler,t=n.module,r=Se(e);if(n.currentType=l.bool,!r)return t.unreachable();let i=r.getClass();return Ee(e,t.i32(i&&i.extends(n.program.arrayPrototype)?1:0))}x.set(h.isArray,hy);function dy(e){let n=e.compiler,t=n.module,r=Se(e);if(n.currentType=l.bool,!r)return t.unreachable();let i=r.getClass();return Ee(e,t.i32(i&&i.isArrayLike?1:0))}x.set(h.isArrayLike,dy);function xy(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isFunction?1:0)):t.unreachable()}x.set(h.isFunction,xy);function gy(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isNullableReference?1:0)):t.unreachable()}x.set(h.isNullable,gy);function my(e){let n=e.compiler,t=n.module;if(n.currentType=l.bool,_(e)|z(e,1))return t.unreachable();let r=n.resolver.lookupExpression(e.operands[0],n.currentFlow,l.auto,1);return t.i32(r?1:0)}x.set(h.isDefined,my);function yy(e){let n=e.compiler,t=n.module;if(n.currentType=l.bool,_(e)|z(e,1))return t.unreachable();let r=n.compileExpression(e.operands[0],l.auto);return n.currentType=l.bool,as(r,t.ref)?t.block(null,[t.maybeDrop(r),t.i32(0)],se(r)):t.i32(t.isConstExpression(r)?1:0)}x.set(h.isConstant,yy);function _y(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.isManaged?1:0)):t.unreachable()}x.set(h.isManaged,_y);function by(e){let n=e.compiler,t=n.module,r=Se(e);return n.currentType=l.bool,r?Ee(e,t.i32(r.kind==25?1:0)):t.unreachable()}x.set(h.isVoid,by);function vy(e){let n=e.compiler,t=n.module,r=Se(e);if(n.currentType=l.i32,!r)return t.unreachable();let i=r.signatureReference;return i?Ee(e,t.i32(i.parameterTypes.length)):(n.error(2757,e.reportNode.range,r.toString()),t.unreachable())}x.set(h.lengthof,vy);function Ey(e){let n=e.compiler,t=n.module;if(n.currentType=n.options.usizeType,U(e)|z(e,0))return t.unreachable();let r=e.typeArguments[0],i=r.byteSize;return i?wi(n,i64_new(i),e.contextualType):(n.error(203,e.reportNode.typeArgumentsRange,"sizeof",r.toString()),t.unreachable())}x.set(h.sizeof,Ey);function Fy(e){let n=e.compiler,t=n.module;if(n.currentType=n.options.usizeType,U(e)|z(e,0))return t.unreachable();let r=e.typeArguments[0],i=r.byteSize;return nr(i)?wi(n,i64_new(ctz(i)),e.contextualType):(n.error(203,e.reportNode.typeArgumentsRange,"alignof",r.toString()),t.unreachable())}x.set(h.alignof,Fy);function Ay(e){let n=e.compiler,t=n.module;if(n.currentType=n.options.usizeType,U(e)|ve(e,0,1))return t.unreachable();let r=e.operands,i=e.contextualType,s=e.typeArguments[0],a=s.getClassOrWrapper(n.program);if(!a)return n.error(203,e.reportNode.typeArgumentsRange,"offsetof",s.toString()),n.options.isWasm64?i.isIntegerValue&&i.size<=32&&(n.currentType=l.u32):i.isIntegerValue&&i.size==64&&(n.currentType=l.u64),t.unreachable();if(r.length){let o=r[0];if(!o.isLiteralKind(2))return n.error(1141,r[0].range),t.unreachable();let u=o.value,c=a.members;if(c&&c.has(u)){let f=assert(c.get(u));if(f.kind==11)return wi(n,i64_new(f.memoryOffset),i)}return n.error(2460,o.range,a.internalName,u),t.unreachable()}return wi(n,i64_new(a.nextMemoryOffset),i)}x.set(h.offsetof,Ay);function Ty(e){let n=e.compiler,t=n.module,r=Se(e);if(!r)return n.currentType=n.program.stringInstance.type,t.unreachable();let i;if(r.isInternalReference){let s=r.getClass();s?i=s.name:(assert(r.getSignature()),i="Function")}else i=r.toString();return Ee(e,n.ensureStaticString(i))}x.set(h.nameof,Ty);function Sy(e){let n=e.compiler,t=n.module,r=Se(e);if(n.currentType=l.u32,!r)return t.unreachable();let i=r.getSignature();if(i)return Ee(e,t.i32(i.id));let s=r.getClassOrWrapper(n.program);return s&&!s.hasDecorator(16)?Ee(e,t.i32(s.id)):(n.error(203,e.reportNode.typeArgumentsRange,"idof",r.toString()),t.unreachable())}x.set(h.idof,Sy);function Cy(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.typeArguments,i=r?n.compileExpression(e.operands[0],r[0].toUnsigned(),5):n.compileExpression(e.operands[0],l.u32,4),s=n.currentType;if(s.isValue)switch(s.kind){case 0:case 1:case 6:return i;case 2:case 7:{let a=n.currentFlow,o=a.getTempLocal(s);a.setLocalFlag(o.index,2);let u=t.binary(8,t.binary(10,t.local_tee(o.index,i,!1),t.i32(8)),t.binary(12,t.local_get(o.index,A.I32),t.i32(8)));return s.kind==2&&(u=n.ensureSmallIntegerWrap(u,l.i16)),u}case 3:case 8:case 5:case 10:if(s.size==32){let a=n.currentFlow,o=a.getTempLocal(s);return a.setLocalFlag(o.index,2),t.binary(8,t.binary(13,t.binary(7,t.local_tee(o.index,i,!1),t.i32(4278255360)),t.i32(8)),t.binary(14,t.binary(7,t.local_get(o.index,A.I32),t.i32(16711935)),t.i32(8)))}case 4:case 9:{let a=n.currentFlow,o=a.getTempLocal(s);a.setLocalFlag(o.index,2);let u=a.getTempLocal(s);a.setLocalFlag(u.index,2);let c=t.local_tee(u.index,t.binary(33,t.binary(32,t.binary(37,t.local_tee(o.index,i,!1),t.i64(8)),t.i64(16711935,16711935)),t.binary(35,t.binary(32,t.local_get(o.index,A.I64),t.i64(16711935,16711935)),t.i64(8))),!1),f=t.binary(33,t.binary(32,t.binary(37,c,t.i64(16)),t.i64(65535,65535)),t.binary(35,t.binary(32,t.local_get(u.index,A.I64),t.i64(65535,65535)),t.i64(16)));return f=t.binary(39,f,t.i64(32)),f}}return n.error(203,e.reportNode.typeArgumentsRange,"bswap",s.toString()),t.unreachable()}x.set(h.bswap,Cy);function uu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.typeArguments,i=r?n.compileExpression(e.operands[0],r[0],5):n.compileExpression(e.operands[0],l.i32,4),s=n.currentType;if(s.isValue)switch(s.kind){case 0:case 1:case 6:case 2:case 7:case 3:case 8:return t.unary(0,i);case 5:case 10:return t.unary(125,i);case 4:case 9:return t.unary(1,i)}return n.error(203,e.reportNode.typeArgumentsRange,"clz",s.toString()),t.unreachable()}x.set(h.clz,uu);function cu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],5):n.compileExpression(r[0],l.i32,4),a=n.currentType;if(a.isValue)switch(a.kind){case 0:case 1:case 6:case 2:case 7:case 3:case 8:return t.unary(2,s);case 5:case 10:return t.unary(126,s);case 4:case 9:return t.unary(3,s)}return n.error(203,e.reportNode.typeArgumentsRange,"ctz",a.toString()),t.unreachable()}x.set(h.ctz,cu);function fu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],5):n.compileExpression(r[0],l.i32,4),a=n.currentType;if(a.isValue)switch(n.currentType.kind){case 0:return s;case 1:case 6:case 2:case 7:case 3:case 8:return t.unary(4,s);case 4:case 9:return t.unary(5,s);case 5:case 10:return t.unary(127,s)}return n.error(203,e.reportNode.typeArgumentsRange,"popcnt",a.toString()),t.unreachable()}x.set(h.popcnt,fu);function pu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],5):n.compileExpression(r[0],l.i32,4),a=n.currentType;if(a.isValue){let o=n.compileExpression(r[1],a,1);switch(a.kind){case 0:return s;case 1:case 2:case 6:case 7:{let u=n.currentFlow,c=u.getTempLocal(a);u.setLocalFlag(c.index,2);let f=u.getTempLocal(a);return u.setLocalFlag(f.index,2),t.binary(8,t.binary(10,t.local_tee(c.index,s,!1),t.binary(7,t.local_tee(f.index,o,!1),t.i32(a.size-1))),t.binary(12,t.local_get(c.index,A.I32),t.binary(7,t.binary(1,t.i32(0),t.local_get(f.index,A.I32)),t.i32(a.size-1))))}case 3:case 8:return t.binary(13,s,o);case 4:case 9:return t.binary(38,s,o);case 5:case 10:return t.binary(209,s,o)}}return n.error(203,e.reportNode.typeArgumentsRange,"rotl",a.toString()),t.unreachable()}x.set(h.rotl,pu);function hu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],5):n.compileExpression(r[0],l.i32,4),a=n.currentType;if(a.isValue){let o=n.compileExpression(r[1],a,1);switch(a.kind){case 0:return s;case 1:case 2:case 6:case 7:{let u=n.currentFlow,c=u.getTempLocal(a);u.setLocalFlag(c.index,2);let f=u.getTempLocal(a);return u.setLocalFlag(f.index,2),t.binary(8,t.binary(12,t.local_tee(c.index,s,!1),t.binary(7,t.local_tee(f.index,o,!1),t.i32(a.size-1))),t.binary(10,t.local_get(c.index,A.I32),t.binary(7,t.binary(1,t.i32(0),t.local_get(f.index,A.I32)),t.i32(a.size-1))))}case 3:case 8:return t.binary(14,s,o);case 4:case 9:return t.binary(39,s,o);case 5:case 10:return t.binary(210,s,o)}}return n.error(203,e.reportNode.typeArgumentsRange,"rotr",a.toString()),t.unreachable()}x.set(h.rotr,hu);function du(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],5):n.compileExpression(r[0],l.auto,4),a=n.currentType;if(a.isValue)switch(a.kind){case 0:case 6:case 7:case 8:case 9:case 10:return s;case 1:case 2:case 3:{let o=n.currentFlow,u=o.getTempLocal(l.i32),c=o.getTempLocal(l.i32);return t.binary(9,t.binary(0,t.local_tee(c.index,t.binary(11,t.local_tee(u.index,s,!1),t.i32(31)),!1),t.local_get(u.index,A.I32)),t.local_get(c.index,A.I32))}case 5:{let o=n.options,u=n.currentFlow,c=u.getTempLocal(o.usizeType),f=u.getTempLocal(o.usizeType);return t.binary(205,t.binary(196,t.local_tee(f.index,t.binary(207,t.local_tee(c.index,s,!1),n.options.isWasm64?t.i64(63):t.i32(31)),!1),t.local_get(c.index,o.sizeTypeRef)),t.local_get(f.index,o.sizeTypeRef))}case 4:{let o=n.currentFlow,u=o.getTempLocal(l.i64),c=o.getTempLocal(l.i64);return t.binary(34,t.binary(25,t.local_tee(c.index,t.binary(36,t.local_tee(u.index,s,!1),t.i64(63)),!1),t.local_get(u.index,A.I64)),t.local_get(c.index,A.I64))}case 11:return t.unary(8,s);case 12:return t.unary(9,s)}return n.error(203,e.reportNode.typeArgumentsRange,"abs",a.toString()),t.unreachable()}x.set(h.abs,du);function xu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],5):n.compileExpression(r[0],l.auto,4),o=n.currentType;if(o.isValue){let u;!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o,4),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,5))):u=n.compileExpression(r[1],o,5);let c=-1;switch(o.kind){case 1:case 2:case 3:{c=21;break}case 0:case 6:case 7:case 8:{c=22;break}case 4:{c=46;break}case 9:{c=47;break}case 5:{c=217;break}case 10:{c=218;break}case 11:return t.binary(56,a,u);case 12:return t.binary(69,a,u)}if(c!=-1){let f=n.currentFlow,p=o.toRef(),d=f.getTempLocal(o);f.setLocalFlag(d.index,2);let m=f.getTempLocal(o);return f.setLocalFlag(m.index,2),t.select(t.local_tee(d.index,a,!1),t.local_tee(m.index,u,!1),t.binary(c,t.local_get(d.index,p),t.local_get(m.index,p)),p)}}return n.error(203,e.reportNode.typeArgumentsRange,"max",o.toString()),t.unreachable()}x.set(h.max,xu);function gu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],5):n.compileExpression(r[0],l.auto,4),o=n.currentType;if(o.isValue){let u;!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o,4),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,5))):u=n.compileExpression(r[1],o,5);let c=-1;switch(o.kind){case 1:case 2:case 3:{c=17;break}case 0:case 6:case 7:case 8:{c=18;break}case 4:{c=42;break}case 9:{c=43;break}case 5:{c=213;break}case 10:{c=214;break}case 11:return t.binary(55,a,u);case 12:return t.binary(68,a,u)}if(c!=-1){let f=n.currentFlow,p=o.toRef(),d=f.getTempLocal(o);f.setLocalFlag(d.index,2);let m=f.getTempLocal(o);return f.setLocalFlag(m.index,2),t.select(t.local_tee(d.index,a,!1),t.local_tee(m.index,u,!1),t.binary(c,t.local_get(d.index,p),t.local_get(m.index,p)),p)}}return n.error(203,e.reportNode.typeArgumentsRange,"min",o.toString()),t.unreachable()}x.set(h.min,gu);function mu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.auto,0),a=n.currentType;if(a.isValue)switch(a.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return s;case 11:return t.unary(10,s);case 12:return t.unary(11,s)}return n.error(203,e.reportNode.typeArgumentsRange,"ceil",a.toString()),t.unreachable()}x.set(h.ceil,mu);function yu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.auto,0),a=n.currentType;if(a.isValue)switch(a.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return s;case 11:return t.unary(12,s);case 12:return t.unary(13,s)}return n.error(203,e.reportNode.typeArgumentsRange,"floor",a.toString()),t.unreachable()}x.set(h.floor,yu);function _u(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.f64,0),a=n.currentType;if(a.isValue){let o=n.compileExpression(r[1],a,1);switch(a.kind){case 11:return t.binary(54,s,o);case 12:return t.binary(67,s,o)}}return n.error(203,e.reportNode.typeArgumentsRange,"copysign",a.toString()),t.unreachable()}x.set(h.copysign,_u);function bu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.auto,0),a=n.currentType;if(a.isValue)switch(a.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return s;case 11:return t.unary(16,s);case 12:return t.unary(17,s)}return n.error(203,e.reportNode.typeArgumentsRange,"nearest",a.toString()),t.unreachable()}x.set(h.nearest,bu);function Ur(e){let n=e.compiler,t=n.module;if(U(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments[0];if(i.isValue)switch(i.kind){case 3:case 8:{let s=n.compileExpression(r[0],l.f32,1);return n.currentType=i,t.unary(33,s)}case 4:case 9:{let s=n.compileExpression(r[0],l.f64,1);return n.currentType=i,t.unary(34,s)}case 5:case 10:{let s=n.options.isWasm64,a=n.compileExpression(r[0],s?l.f64:l.f32,1);return n.currentType=i,t.unary(s?34:33,a)}case 11:{let s=n.compileExpression(r[0],l.i32,1);return n.currentType=l.f32,t.unary(45,s)}case 12:{let s=n.compileExpression(r[0],l.i64,1);return n.currentType=l.f64,t.unary(46,s)}}return n.error(203,e.reportNode.typeArgumentsRange,"reinterpret",i.toString()),t.unreachable()}x.set(h.reinterpret,Ur);function vu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.f64,0),a=n.currentType;if(a.isValue)switch(a.kind){case 11:return t.unary(18,s);case 12:return t.unary(19,s)}return n.error(203,e.reportNode.typeArgumentsRange,"sqrt",a.toString()),t.unreachable()}x.set(h.sqrt,vu);function Eu(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.auto,0),a=n.currentType;if(a.isValue)switch(a.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return s;case 11:return t.unary(14,s);case 12:return t.unary(15,s)}return n.error(203,e.reportNode.typeArgumentsRange,"trunc",a.toString()),t.unreachable()}x.set(h.trunc,Eu);function wy(e){let n=e.compiler,t=n.module;if(re(e)|z(e,1))return n.currentType=l.bool,t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.auto),a=n.currentType;if(n.currentType=l.bool,a.isValue)switch(a.kind){case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return t.maybeDropCondition(s,t.i32(0));case 11:{if(H(s)==8)return t.binary(58,s,t.local_get(Sn(s),A.F32));let o=n.currentFlow.getTempLocal(l.f32);return t.binary(58,t.local_tee(o.index,s,!1),t.local_get(o.index,A.F32))}case 12:{if(H(s)==8)return t.binary(71,s,t.local_get(Sn(s),A.F64));let o=n.currentFlow.getTempLocal(l.f64);return t.binary(71,t.local_tee(o.index,s,!1),t.local_get(o.index,A.F64))}}return n.error(203,e.reportNode.typeArgumentsRange,"isNaN",a.toString()),t.unreachable()}x.set(h.isNaN,wy);function Iy(e){let n=e.compiler,t=n.module;if(re(e)|z(e,1))return n.currentType=l.bool,t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.auto),a=n.currentType;if(n.currentType=l.bool,a.isValue)switch(a.kind){case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return t.maybeDropCondition(s,t.i32(1));case 11:{if(H(s)==8)return t.binary(57,t.binary(51,s,t.local_get(Sn(s),A.F32)),t.f32(0));let o=n.currentFlow.getTempLocal(l.f32);return t.binary(57,t.binary(51,t.local_tee(o.index,s,!1),t.local_get(o.index,A.F32)),t.f32(0))}case 12:{if(H(s)==8)return t.binary(70,t.binary(64,s,t.local_get(Sn(s),A.F64)),t.f64(0));let o=n.currentFlow.getTempLocal(l.f64);return t.binary(70,t.binary(64,t.local_tee(o.index,s,!1),t.local_get(o.index,A.F64)),t.f64(0))}}return n.error(203,e.reportNode.typeArgumentsRange,"isFinite",a.toString()),t.unreachable()}x.set(h.isFinite,Iy);function Te(e){let n=e.compiler,t=n.module;if(U(e,!0)|ve(e,1,3))return t.unreachable();let r=e.operands,i=e.typeArguments,s=e.contextualType,a=i[0],o=s!=l.auto&&a.isIntegerValue&&s.isIntegerValue&&s.size>a.size?s:a;if(!o.isMemory)return n.error(203,e.reportNode.typeArgumentsRange,"load",o.toString()),n.currentType=l.void,t.unreachable();let u=n.compileExpression(r[0],n.options.usizeType,1),c=r.length,f=0,p=a.byteSize;return c>=2&&(f=Ze(r[1],n),f<0||c==3&&(p=wn(r[2],p,n),p<0))?(n.currentType=o,t.unreachable()):(n.currentType=o,t.load(a.byteSize,a.isSignedIntegerValue,u,o.toRef(),f,p))}x.set(h.load,Te);function sn(e){let n=e.compiler,t=n.module;if(n.currentType=l.void,U(e)|ve(e,2,4))return t.unreachable();let r=e.operands,i=r.length,s=e.typeArguments,a=e.contextualType,o=s[0],u=n.compileExpression(r[0],n.options.usizeType,1),c=e.contextIsExact?n.compileExpression(r[1],a,1):n.compileExpression(r[1],o,o.isIntegerValue?0:1),f=n.currentType;if(!f.isMemory)return n.error(203,e.reportNode.typeArgumentsRange,"store",f.toString()),n.currentType=l.void,t.unreachable();o.isIntegerValue&&(!f.isIntegerValue||f.size<o.size)&&(c=n.convertExpression(c,f,o,!1,r[1]),f=o);let p=0,d=o.byteSize;return i>=3&&(p=Ze(r[2],n),p<0||i==4&&(d=wn(r[3],d,n),d<0))?(n.currentType=l.void,t.unreachable()):(n.currentType=l.void,t.store(o.byteSize,u,c,f.toRef(),p,d))}x.set(h.store,sn);function Pr(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],1):n.compileExpression(r[0],l.auto),o=n.currentType;if(o.isIntegerValue){let u;if(!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,1))):u=n.compileExpression(r[1],o,1),o.isIntegerValue)return n.makeRem(a,u,o,e.reportNode)}return n.error(203,e.reportNode.typeArgumentsRange,"rem",o.toString()),t.unreachable()}x.set(h.rem,Pr);function Vr(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],1):n.compileExpression(r[0],l.auto),o=n.currentType;if(o.isValue){let u;if(!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,1))):u=n.compileExpression(r[1],o,1),o.isNumericValue)return n.makeAdd(a,u,o)}return n.error(203,e.reportNode.typeArgumentsRange,"add",o.toString()),t.unreachable()}x.set(h.add,Vr);function Gr(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],1):n.compileExpression(r[0],l.auto),o=n.currentType;if(o.isValue){let u;if(!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,1))):u=n.compileExpression(r[1],o,1),o.isNumericValue)return n.makeSub(a,u,o)}return n.error(203,e.reportNode.typeArgumentsRange,"sub",o.toString()),t.unreachable()}x.set(h.sub,Gr);function qr(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],1):n.compileExpression(r[0],l.auto),o=n.currentType;if(o.isValue){let u;if(!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,1))):u=n.compileExpression(r[1],o,1),o.isNumericValue)return n.makeMul(a,u,o)}return n.error(203,e.reportNode.typeArgumentsRange,"mul",o.toString()),t.unreachable()}x.set(h.mul,qr);function _t(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],1):n.compileExpression(r[0],l.auto),o=n.currentType;if(o.isValue){let u;if(!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,1))):u=n.compileExpression(r[1],o,1),o.isNumericValue)return n.makeDiv(a,u,o)}return n.error(203,e.reportNode.typeArgumentsRange,"div",o.toString()),t.unreachable()}x.set(h.div,_t);function jr(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],1):n.compileExpression(r[0],l.auto),o=n.currentType;if(o.isValue){let u;if(!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,1))):u=n.compileExpression(r[1],o,1),o.isNumericValue)return n.currentType=l.i32,n.makeEq(a,u,o,e.reportNode)}return n.error(203,e.reportNode.typeArgumentsRange,"eq",o.toString()),t.unreachable()}x.set(h.eq,jr);function Wr(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=r[0],a=i?n.compileExpression(s,i[0],1):n.compileExpression(r[0],l.auto),o=n.currentType;if(o.isValue){let u;if(!i&&s.isNumericLiteral?(u=n.compileExpression(r[1],o),n.currentType!=o&&(a=n.compileExpression(s,o=n.currentType,1))):u=n.compileExpression(r[1],o,1),o.isNumericValue)return n.currentType=l.i32,n.makeNe(a,u,o,e.reportNode)}return n.error(203,e.reportNode.typeArgumentsRange,"ne",o.toString()),t.unreachable()}x.set(h.ne,Wr);function Yn(e){let n=e.compiler,t=n.module;if(R(e,32)|U(e,!0)|ve(e,1,2))return t.unreachable();let r=e.operands,i=e.typeArguments,s=e.contextualType,a=i[0],o=a.isIntegerValue&&s.isIntegerValue&&s.size>a.size?s:a;if(!a.isIntegerValue)return n.error(203,e.reportNode.typeArgumentsRange,"atomic.load",a.toString()),n.currentType=o,t.unreachable();let u=n.compileExpression(r[0],n.options.usizeType,1),c=r.length==2?Ze(r[1],n):0;return c<0?(n.currentType=o,t.unreachable()):(n.currentType=o,t.atomic_load(a.byteSize,u,o.toRef(),c))}x.set(h.atomic_load,Yn);function Zn(e){let n=e.compiler,t=n.module;if(R(e,32)|U(e)|ve(e,2,3))return t.unreachable();let r=e.operands,i=e.typeArguments,s=e.contextualType,a=i[0];if(!a.isIntegerValue)return n.error(203,e.reportNode.typeArgumentsRange,"atomic.store",a.toString()),n.currentType=l.void,t.unreachable();let o=n.compileExpression(r[0],n.options.usizeType,1),u=e.contextIsExact?n.compileExpression(r[1],s,1):n.compileExpression(r[1],a,a.isIntegerValue?0:1),c=n.currentType;a.isIntegerValue&&(!c.isIntegerValue||c.size<a.size)&&(u=n.convertExpression(u,c,a,!1,r[1]),c=a);let f=r.length==3?Ze(r[2],n):0;return f<0?(n.currentType=l.void,t.unreachable()):(n.currentType=l.void,t.atomic_store(a.byteSize,o,u,c.toRef(),f))}x.set(h.atomic_store,Zn);function rr(e,n,t){let r=e.compiler,i=r.module;if(R(e,32)|U(e,!0)|ve(e,2,3))return i.unreachable();let s=e.operands,a=e.typeArguments,o=e.contextualType,u=a[0];if(!u.isIntegerValue||u.size<8)return r.error(203,e.reportNode.typeArgumentsRange,t,u.toString()),i.unreachable();let c=r.compileExpression(s[0],r.options.usizeType,1),f=e.contextIsExact?r.compileExpression(s[1],o,1):r.compileExpression(s[1],u,u.isIntegerValue?0:1),p=r.currentType;u.isIntegerValue&&(!p.isIntegerValue||p.size<u.size)&&(f=r.convertExpression(f,p,u,!1,s[1]),p=u);let d=s.length==3?Ze(s[2],r):0;return d<0?(r.currentType=p,i.unreachable()):(r.currentType=p,i.atomic_rmw(n,u.byteSize,d,c,f,p.toRef()))}function Jn(e){return rr(e,0,"atomic.add")}x.set(h.atomic_add,Jn);function Qn(e){return rr(e,1,"atomic.sub")}x.set(h.atomic_sub,Qn);function et(e){return rr(e,2,"atomic.and")}x.set(h.atomic_and,et);function nt(e){return rr(e,3,"atomic.or")}x.set(h.atomic_or,nt);function tt(e){return rr(e,4,"atomic.xor")}x.set(h.atomic_xor,tt);function rt(e){return rr(e,5,"atomic.xchg")}x.set(h.atomic_xchg,rt);function it(e){let n=e.compiler,t=n.module;if(R(e,32)|U(e,!0)|ve(e,3,4))return t.unreachable();let r=e.operands,i=e.typeArguments,s=e.contextualType,a=i[0];if(!a.isIntegerValue||a.size<8)return n.error(203,e.reportNode.typeArgumentsRange,"atomic.cmpxchg",a.toString()),t.unreachable();let o=n.compileExpression(r[0],n.options.usizeType,1),u=e.contextIsExact?n.compileExpression(r[1],s,1):n.compileExpression(r[1],a,a.isIntegerValue?0:1),c=n.currentType,f=n.compileExpression(r[2],c,1);a.isIntegerValue&&(!c.isIntegerValue||c.size<a.size)&&(u=n.convertExpression(u,c,a,!1,r[1]),f=n.convertExpression(f,c,a,!1,r[2]),c=a);let p=r.length==4?Ze(r[3],n):0;return p<0?(n.currentType=c,t.unreachable()):(n.currentType=c,t.atomic_cmpxchg(a.byteSize,p,o,u,f,c.toRef()))}x.set(h.atomic_cmpxchg,it);function Fu(e){let n=e.compiler,t=n.module;if(R(e,32)|U(e)|ve(e,2,3))return n.currentType=l.i32,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],n.options.usizeType,1),a=n.compileExpression(r[1],i,1),o=r.length==3?n.compileExpression(r[2],l.i64,1):t.i64(-1,-1);switch(n.currentType=l.i32,i.kind){case 3:case 4:case 5:case 8:case 9:case 10:return t.atomic_wait(s,a,o,i.toRef())}return n.error(203,e.reportNode.typeArgumentsRange,"atomic.wait",i.toString()),t.unreachable()}x.set(h.atomic_wait,Fu);function ky(e){let n=e.compiler,t=n.module;if(R(e,32)|_(e)|ve(e,1,2))return n.currentType=l.i32,t.unreachable();let r=e.operands,i=n.compileExpression(r[0],n.options.usizeType,1),s=r.length==2?n.compileExpression(r[1],l.i32,1):t.i32(-1);return n.currentType=l.i32,t.atomic_notify(i,s)}x.set(h.atomic_notify,ky);function By(e){let n=e.compiler,t=n.module;return n.currentType=l.void,R(e,32)|_(e)|z(e,0)?t.unreachable():t.atomic_fence()}x.set(h.atomic_fence,By);function zy(e){let n=e.compiler,t=n.module;if(re(e,!0)|z(e,3))return t.unreachable();let r=e.operands,i=e.typeArguments,s=i?n.compileExpression(r[0],i[0],1):n.compileExpression(r[0],l.auto),a=n.currentType;if(!a.isAny(384))return n.error(203,e.reportNode.typeArgumentsRange,"select",a.toString()),t.unreachable();let o=n.compileExpression(r[1],a,1),u=n.makeIsTrueish(n.compileExpression(r[2],l.bool),n.currentType,r[2]);return n.currentType=a,t.select(s,o,u,a.toRef())}x.set(h.select,zy);function Ny(e){return _(e),z(e,0),e.compiler.module.unreachable()}x.set(h.unreachable,Ny);function Ly(e){let n=e.compiler,t=n.module;return n.currentType=l.i32,_(e)|z(e,0)?t.unreachable():t.memory_size()}x.set(h.memory_size,Ly);function Dy(e){let n=e.compiler,t=n.module;return n.currentType=l.i32,_(e)|z(e,1)?t.unreachable():t.memory_grow(n.compileExpression(e.operands[0],l.i32,1))}x.set(h.memory_grow,Dy);function Oy(e){let n=e.compiler,t=n.module;if(n.currentType=l.void,_(e)|z(e,3))return t.unreachable();let r=e.operands;if(!n.options.hasFeature(8)){let u=n.resolver.resolveFunction(e.prototype,null);return n.currentType=l.void,!u||!n.compileFunction(u,!0)?t.unreachable():n.compileCallDirect(u,r,e.reportNode)}let i=n.options.usizeType,s=n.compileExpression(r[0],i,1),a=n.compileExpression(r[1],i,1),o=n.compileExpression(r[2],i,1);return n.currentType=l.void,t.memory_copy(s,a,o)}x.set(h.memory_copy,Oy);function Ry(e){let n=e.compiler,t=n.module;if(n.currentType=l.void,_(e)|z(e,3))return t.unreachable();let r=e.operands;if(!n.options.hasFeature(8)){let u=n.resolver.resolveFunction(e.prototype,null);return n.currentType=l.void,!u||!n.compileFunction(u,!0)?t.unreachable():n.compileCallDirect(u,r,e.reportNode)}let i=n.options.usizeType,s=n.compileExpression(r[0],i,1),a=n.compileExpression(r[1],l.u8,1),o=n.compileExpression(r[2],i,1);return n.currentType=l.void,t.memory_fill(s,a,o)}x.set(h.memory_fill,Ry);function My(e){let n=e.compiler,t=n.module;if(n.currentType=l.i32,re(e)|ve(e,1,2))return t.unreachable();let r=e.typeArguments,i=e.operands,s=i.length,a=n.options.usizeType,o;if(r&&r.length>0){let u=r[0];if(!u.isValue)return n.error(203,e.reportNode.typeArgumentsRange,"memory.data",u.toString()),n.currentType=a,t.unreachable();let c=i[0];if(c.kind!=16||c.literalKind!=5)return n.error(227,i[0].range),n.currentType=a,t.unreachable();let f=c.elementExpressions,p=f.length,d=new Array(p),m=!0;for(let y=0;y<p;++y){let b=f[y];if(b.kind!=19){let T=n.compileExpression(b,u,1),S=t.runExpression(T,1);S?T=S:m=!1,d[y]=T}else d[y]=n.makeZero(u)}if(!m)return n.error(220,c.range),n.currentType=a,t.unreachable();let g=u.byteSize;if(s==2&&(g=wn(i[1],g,n),g<0))return n.currentType=a,t.unreachable();let E=new Uint8Array(p*u.byteSize);assert(n.writeStaticBuffer(E,0,u,d)==E.byteLength),o=n.addAlignedMemorySegment(E,g).offset}else{let u=n.compileExpression(i[0],l.i32,1),c=t.runExpression(u,1);if(!c)return n.error(220,i[0].range),n.currentType=a,t.unreachable();let f=Y(c);if(f<1)return n.error(222,i[0].range,"1",i32.MAX_VALUE.toString()),n.currentType=a,t.unreachable();let p=16;if(s==2&&(p=wn(i[1],p,n),p<0))return n.currentType=a,t.unreachable();o=n.addAlignedMemorySegment(new Uint8Array(f),p).offset}return n.currentType=a,a==l.usize32?(assert(!i64_high(o)),t.i32(i64_low(o))):t.i64(i64_low(o),i64_high(o))}x.set(h.memory_data,My);function Uy(e){let n=e.compiler,t=n.module;if(_(e)|z(e,1))return t.unreachable();let r=e.operands,i=n.compileExpression(r[0],l.i32,1);return n.currentType=l.i31ref,t.i31_new(i)}x.set(h.i31_new,Uy);function Py(e){let n=e.compiler,t=n.module;if(_(e)|z(e,1))return t.unreachable();let r=e.operands,i=n.compileExpression(r[0],l.i31ref,1);return e.contextualType.is(2)?(n.currentType=l.u32,t.i31_get(i,!1)):(n.currentType=l.i32,t.i31_get(i,!0))}x.set(h.i31_get,Py);function Vy(e){let n=e.compiler,t=n.module;if(U(e,!0)|z(e,1))return t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.auto),a=n.currentType;return n.currentType=i,a.isChangeableTo(i)?s:(n.error(202,e.reportNode.range,a.toString(),i.toString()),t.unreachable())}x.set(h.changetype,Vy);function Gy(e){let n=e.compiler,t=n.module,r=e.typeArguments;if(re(e,!0)|ve(e,1,2))return r&&(assert(r.length),n.currentType=r[0].nonNullableType),t.unreachable();let i=e.operands,s=e.contextualType,a=r?n.compileExpression(i[0],r[0],5):n.compileExpression(i[0],l.bool,4),o=n.currentType;if(n.currentType=o.nonNullableType,n.options.noAssert)return a;let u=t.runExpression(a,0);if(u)switch(se(u)){case A.I32:{if(Y(u))return a;break}case A.I64:{if(Be(u)|Pe(u))return a;break}case A.F32:{if(Fe(u))return a;break}case A.F64:{if(Ae(u))return a;break}}let c=n.makeAbort(i.length==2?i[1]:null,e.reportNode);if(n.currentType=o.nonNullableType,s==l.void)switch(n.currentType=l.void,o.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:return t.if(t.unary(20,a),c);case 4:case 9:return t.if(t.unary(21,a),c);case 5:case 10:return t.if(t.unary(128,a),c);case 11:return t.if(t.binary(57,a,t.f32(0)),c);case 12:return t.if(t.binary(70,a,t.f64(0)),c);case 14:case 15:case 16:case 17:case 19:case 20:case 18:case 21:case 22:case 23:case 24:return t.if(t.ref_is(0,a),c)}else{n.currentType=o.nonNullableType;let f=n.currentFlow;switch(n.currentType.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:{let p=f.getTempLocal(o);return f.setLocalFlag(p.index,2),t.if(t.local_tee(p.index,a,!1),t.local_get(p.index,A.I32),c)}case 4:case 9:{let p=f.getTempLocal(l.i64);return t.if(t.unary(21,t.local_tee(p.index,a,!1)),c,t.local_get(p.index,A.I64))}case 5:case 10:{let p=f.getTempLocal(n.options.usizeType);return t.if(t.unary(128,t.local_tee(p.index,a,o.isManaged)),c,t.local_get(p.index,n.options.sizeTypeRef))}case 11:{let p=f.getTempLocal(l.f32);return t.if(t.binary(57,t.local_tee(p.index,a,!1),t.f32(0)),c,t.local_get(p.index,A.F32))}case 12:{let p=f.getTempLocal(l.f64);return t.if(t.binary(70,t.local_tee(p.index,a,!1),t.f64(0)),c,t.local_get(p.index,A.F64))}case 14:case 15:case 16:case 17:case 19:case 20:case 18:case 21:case 22:case 23:case 24:{let p=f.getTempLocal(o);return t.if(t.ref_is(0,t.local_tee(p.index,a,!1)),c,t.local_get(p.index,o.toRef()))}}}return n.error(203,e.reportNode.typeArgumentsRange,"assert",n.currentType.toString()),c}x.set(h.assert,Gy);function qy(e){let n=e.compiler,t=n.module;if(_(e)|z(e,1))return t.unreachable();let r=n.currentFlow,i=r.is(32768);r.set(32768);let s=n.compileExpression(e.operands[0],e.contextualType);return i||r.unset(32768),s}x.set(h.unchecked,qy);function jy(e){let n=e.compiler,t=n.module;if(re(e,!0)|ve(e,1,i32.MAX_VALUE))return t.unreachable();let r=e.operands,i=e.typeArguments,s;i?(assert(i.length),s=i[0]):s=e.contextualType;let a=n.compileExpression(r[0],l.u32,1),o=r.length-1,u=new Array(o),c=new Array(o);for(let f=0;f<o;++f)u[f]=n.compileExpression(r[1+f],l.auto),c[f]=n.currentType.toRef();return n.currentType=s,t.call_indirect(null,a,u,dn(c),s.toRef())}x.set(h.call_indirect,jy);function Wy(e){let n=e.compiler,t=n.module;if(U(e,!0))return t.unreachable();let r=e.operands,i=e.typeArguments[0].getClass();if(!i)return n.error(2351,e.reportNode.expression.range),t.unreachable();n.currentType=i.type;let s=n.ensureConstructor(i,e.reportNode);return n.checkFieldInitialization(i,e.reportNode),n.compileInstantiate(s,r,0,e.reportNode)}x.set(h.instantiate,Wy);function Au(e,n){let t=e.compiler,r=t.module;_(e);let i=e.operands,s=e.reportNode;return t.emitDiagnostic(102,n,s.range,null,i.length?i[0].range.toString():s.range.toString()),n==3?r.unreachable():r.nop()}function Hy(e){return Au(e,3)}x.set(h.ERROR,Hy);function Xy(e){return Au(e,2)}x.set(h.WARNING,Xy);function Ky(e){return Au(e,1)}x.set(h.INFO,Ky);function $y(e){let n=e.compiler,t=e.prototype.parent;assert(t.kind==7);let r=t;assert(r.prototype==n.program.functionPrototype);let i=assert(r.typeArguments);assert(i.length==1);let s=i[0],a=assert(s.getSignature()),o=a.returnType;if(_(e)|ve(e,1+a.requiredParameters,1+a.parameterTypes.length))return n.currentType=o,n.module.unreachable();let u=n.compileExpression(assert(e.thisOperand),s,1),c=assert(e.operands.shift()),f=a.thisType,p=0;if(f)p=n.compileExpression(c,f,1);else if(c.kind!=18)return n.error(2332,c.range),n.module.unreachable();return n.compileCallIndirect(a,u,e.operands,e.reportNode,p,e.contextualType==l.void)}Ks.set("call",$y);function Yy(e){let n=e.compiler,t=n.module;return n.currentType=e.compiler.program.stringInstance.type,n.error(100,e.reportNode.range,"String.raw"),t.unreachable()}x.set(h.String_raw,Yy);function Zy(e){let n=e.compiler,t=n.module;if(n.currentType=l.i32,_(e)|z(e,1))return t.unreachable();let r=e.operands[0];if(r.kind!=16||r.literalKind!=1)return n.error(220,r.range),t.unreachable();let i=new Array,s=F.createIntegerLiteralExpression(i64_new(++sy),r.range);i.push(s);let a=r.value,o=F.createIntegerLiteralExpression(i64_new(++a));i.push(o);let u=F.createIdentifierExpression(v._g,e.reportNode.expression.range),c=F.createCallExpression(u,null,i,e.reportNode.range);return n.compileCallExpression(c,l.i32)}x.set(h.max_iterations,Zy);function Xe(e,n){let t=e.compiler;return _(e)|z(e,1)?(t.currentType=n,t.module.unreachable()):t.compileExpression(e.operands[0],n,2)}function Jy(e){return Xe(e,l.i8)}x.set(h.i8,Jy);function Qy(e){return Xe(e,l.i16)}x.set(h.i16,Qy);function e4(e){return Xe(e,l.i32)}x.set(h.i32,e4);function n4(e){return Xe(e,l.i64)}x.set(h.i64,n4);function t4(e){return Xe(e,e.compiler.options.isizeType)}x.set(h.isize,t4);function r4(e){return Xe(e,l.u8)}x.set(h.u8,r4);function i4(e){return Xe(e,l.u16)}x.set(h.u16,i4);function s4(e){return Xe(e,l.u32)}x.set(h.u32,s4);function a4(e){return Xe(e,l.u64)}x.set(h.u64,a4);function o4(e){return Xe(e,e.compiler.options.usizeType)}x.set(h.usize,o4);function l4(e){return Xe(e,l.bool)}x.set(h.bool,l4);function u4(e){return Xe(e,l.f32)}x.set(h.f32,u4);function c4(e){return Xe(e,l.f64)}x.set(h.f64,c4);function f4(e){return i2(e)}x.set(h.v128,f4);function i2(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,16))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=new Uint8Array(16),s=new Array(16),a=0;for(let o=0;o<16;++o){let u=n.compileExpression(r[o],l.i8,1),c=t.runExpression(u,1);c?me(Y(c),i,o):(s[o]=u,a++)}if(n.currentType=l.v128,a==0)return t.v128(i);{let o,u=a==16;u?o=t.unary(60,s[0]):o=t.v128(i);for(let c=i32(u);c<16;c++){let f=s[c];f&&(o=t.simd_replace(0,o,c,f))}return o}}x.set(h.i8x16,i2);function p4(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,8))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=new Uint8Array(16),s=new Array(8),a=0;for(let o=0;o<8;++o){let u=n.compileExpression(r[o],l.i16,1),c=t.runExpression(u,1);c?Gi(Y(c),i,o<<1):(s[o]=u,a++)}if(n.currentType=l.v128,a==0)return t.v128(i);{let o,u=a==8;u?o=t.unary(61,s[0]):o=t.v128(i);for(let c=i32(u);c<8;c++){let f=s[c];f&&(o=t.simd_replace(1,o,c,f))}return o}}x.set(h.i16x8,p4);function h4(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,4))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=new Uint8Array(16),s=new Array(4),a=0;for(let o=0;o<4;++o){let u=n.compileExpression(r[o],l.i32,1),c=t.runExpression(u,1);c?be(Y(c),i,o<<2):(s[o]=u,a++)}if(n.currentType=l.v128,a==0)return t.v128(i);{let o,u=a==4;u?o=t.unary(62,s[0]):o=t.v128(i);for(let c=i32(u);c<4;c++){let f=s[c];f&&(o=t.simd_replace(2,o,c,f))}return o}}x.set(h.i32x4,h4);function d4(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=new Uint8Array(16),s=new Array(2),a=0;for(let o=0;o<2;++o){let u=n.compileExpression(r[o],l.i64,1),c=t.runExpression(u,1);if(c){let f=o<<3;be(Be(c),i,f+0),be(Pe(c),i,f+4)}else s[o]=u,a++}if(n.currentType=l.v128,a==0)return t.v128(i);{let o,u=a==2;u?o=t.unary(63,s[0]):o=t.v128(i);for(let c=i32(u);c<2;c++){let f=s[c];f&&(o=t.simd_replace(3,o,c,f))}return o}}x.set(h.i64x2,d4);function x4(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,4))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=new Uint8Array(16),s=new Array(4),a=0;for(let o=0;o<4;++o){let u=n.compileExpression(r[o],l.f32,1),c=t.runExpression(u,1);c?qi(Fe(c),i,o<<2):(s[o]=u,a++)}if(n.currentType=l.v128,a==0)return t.v128(i);{let o,u=a==4;u?o=t.unary(64,s[0]):o=t.v128(i);for(let c=i32(u);c<4;c++){let f=s[c];f&&(o=t.simd_replace(4,o,c,f))}return o}}x.set(h.f32x4,x4);function g4(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=new Uint8Array(16),s=new Array(2),a=0;for(let o=0;o<2;++o){let u=n.compileExpression(r[o],l.f64,1),c=t.runExpression(u,1);c?ji(Ae(c),i,o<<3):(s[o]=u,a++)}if(n.currentType=l.v128,a==0)return t.v128(i);{let o,u=a==2;u?o=t.unary(65,s[0]):o=t.v128(i);for(let c=i32(u);c<2;c++){let f=s[c];f&&(o=t.simd_replace(5,o,c,f))}return o}}x.set(h.f64x2,g4);function bt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],i,1);if(n.currentType=l.v128,i.isValue)switch(i.kind){case 1:case 6:return t.unary(60,s);case 2:case 7:return t.unary(61,s);case 3:case 8:return t.unary(62,s);case 4:case 9:return t.unary(63,s);case 5:case 10:return t.unary(n.options.isWasm64?63:62,s);case 11:return t.unary(64,s);case 12:return t.unary(65,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.splat",i.toString()),t.unreachable()}x.set(h.v128_splat,bt);function Bn(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e,!0)|z(e,2))return t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.u8,1);n.currentType=i;let o=0,u=t.runExpression(a,1);if(u?o=Y(u):n.error(220,r[1].range),i.isValue){let c=16/assert(i.byteSize)-1;switch((o<0||o>c)&&(n.error(222,r[1].range,"Lane index","0",c.toString()),o=0),i.kind){case 1:return t.simd_extract(0,s,o);case 6:return t.simd_extract(1,s,o);case 2:return t.simd_extract(2,s,o);case 7:return t.simd_extract(3,s,o);case 3:case 8:return t.simd_extract(4,s,o);case 4:case 9:return t.simd_extract(5,s,o);case 5:case 10:return t.simd_extract(n.options.isWasm64?5:4,s,o);case 11:return t.simd_extract(6,s,o);case 12:return t.simd_extract(7,s,o)}}return n.error(203,e.reportNode.typeArgumentsRange,"v128.extract_lane",i.toString()),t.unreachable()}x.set(h.v128_extract_lane,Bn);function vt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,3))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.u8,1),o=n.compileExpression(r[2],i,1);n.currentType=l.v128;let u=0,c=t.runExpression(a,1);if(c?u=Y(c):n.error(220,r[1].range),i.isValue){let f=16/assert(i.byteSize)-1;switch((u<0||u>f)&&(n.error(222,r[1].range,"Lane index","0",f.toString()),u=0),i.kind){case 1:case 6:return t.simd_replace(0,s,u,o);case 2:case 7:return t.simd_replace(1,s,u,o);case 3:case 8:return t.simd_replace(2,s,u,o);case 4:case 9:return t.simd_replace(3,s,u,o);case 5:case 10:return t.simd_replace(n.options.isWasm64?3:2,s,u,o);case 11:return t.simd_replace(4,s,u,o);case 12:return t.simd_replace(5,s,u,o)}}return n.error(203,e.reportNode.typeArgumentsRange,"v128.replace_lane",i.toString()),t.unreachable()}x.set(h.v128_replace_lane,vt);function Et(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0];if(i.isValue){let s=i.byteSize,a=16/s;if(assert(Number.isInteger(a)&&nr(a)),z(e,2+a))return n.currentType=l.v128,t.unreachable();let o=n.compileExpression(r[0],l.v128,1),u=n.compileExpression(r[1],l.v128,1);switch(i.kind){case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:{let c=new Uint8Array(16),f=(a<<1)-1;for(let p=0;p<a;++p){let d=r[2+p],m=n.compileExpression(d,l.u8,1),g=t.runExpression(m,1),E=0;switch(g?(E=Y(g),(E<0||E>f)&&(n.error(222,d.range,"Lane index","0",f.toString()),E=0)):n.error(220,d.range),s){case 1:{me(E,c,p);break}case 2:{let y=p<<1,b=E<<1;me(b,c,y),me(b+1,c,y+1);break}case 4:{let y=p<<2,b=E<<2;me(b,c,y),me(b+1,c,y+1),me(b+2,c,y+2),me(b+3,c,y+3);break}case 8:{let y=p<<3,b=E<<3;me(b,c,y),me(b+1,c,y+1),me(b+2,c,y+2),me(b+3,c,y+3),me(b+4,c,y+4),me(b+5,c,y+5),me(b+6,c,y+6),me(b+7,c,y+7);break}default:assert(!1)}}return n.currentType=l.v128,t.simd_shuffle(o,u,c)}}}return n.error(203,e.reportNode.typeArgumentsRange,"v128.shuffle",i.toString()),n.currentType=l.v128,t.unreachable()}x.set(h.v128_shuffle,Et);function Ft(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=n.compileExpression(r[0],l.v128,1),s=n.compileExpression(r[1],l.v128,1);return t.binary(195,i,s)}x.set(h.v128_swizzle,Ft);function Hr(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e,!0)|ve(e,1,3))return t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],n.options.usizeType,1),a=r.length,o=0,u=i.byteSize;if(a>=2&&(o=Ze(r[1],n),o<0||a==3&&(u=wn(r[2],u,n),u<0)))return n.currentType=l.v128,t.unreachable();if(n.currentType=l.v128,i.isValue)switch(i.kind){case 1:case 6:return t.simd_load(0,s,o,u);case 2:case 7:return t.simd_load(1,s,o,u);case 3:case 8:case 11:return t.simd_load(2,s,o,u);case 5:case 10:if(!n.options.isWasm64)return t.simd_load(2,s,o,u);case 4:case 9:case 12:return t.simd_load(3,s,o,u)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.load_splat",i.toString()),t.unreachable()}x.set(h.v128_load_splat,Hr);function At(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e,!0)|ve(e,1,3))return t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],n.options.usizeType,1),a=r.length,o=0,u=i.byteSize;if(a>=2&&(o=Ze(r[1],n),o<0||a==3&&(u=wn(r[2],u,n),u<0)))return n.currentType=l.v128,t.unreachable();if(n.currentType=l.v128,i.isValue)switch(i.kind){case 1:return t.simd_load(4,s,o,u);case 6:return t.simd_load(5,s,o,u);case 2:return t.simd_load(6,s,o,u);case 7:return t.simd_load(7,s,o,u);case 5:if(n.options.isWasm64)break;case 3:return t.simd_load(8,s,o,u);case 10:if(n.options.isWasm64)break;case 8:return t.simd_load(9,s,o,u)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.load_ext",i.toString()),t.unreachable()}x.set(h.v128_load_ext,At);function Tu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e,!0)|ve(e,1,3))return t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],n.options.usizeType,1),a=r.length,o=0,u=i.byteSize;if(a>=2&&(o=Ze(r[1],n),o<0||a==3&&(u=wn(r[2],u,n),u<0)))return n.currentType=l.v128,t.unreachable();if(n.currentType=l.v128,i.isValue)switch(i.kind){case 3:case 8:case 11:return t.simd_load(10,s,o,u);case 4:case 9:case 12:return t.simd_load(11,s,o,u);case 5:case 10:return t.simd_load(n.options.isWasm64?11:10,s,o,u)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.load_zero",i.toString()),t.unreachable()}x.set(h.v128_load_zero,Tu);function Xr(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e,!0)|ve(e,3,5))return t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],n.options.usizeType,1),a=n.compileExpression(r[1],l.v128,1),o=n.compileExpression(r[2],l.u8,1),u=0,c=t.runExpression(o,1);c?u=Y(c):n.error(220,r[2].range);let f=r.length,p=0,d=i.byteSize;if(f>=4&&(p=Ze(r[3],n),p<0||f==5&&(d=wn(r[4],d,n),d<0)))return n.currentType=l.v128,t.unreachable();if(n.currentType=l.v128,i.isValue){let m=16/assert(i.byteSize)-1;switch((u<0||u>m)&&(n.error(222,r[1].range,"Lane index","0",m.toString()),u=0),i.kind){case 1:case 6:return t.simd_loadstorelane(0,s,p,d,u,a);case 2:case 7:return t.simd_loadstorelane(1,s,p,d,u,a);case 3:case 8:case 11:return t.simd_loadstorelane(2,s,p,d,u,a);case 4:case 9:case 12:return t.simd_loadstorelane(3,s,p,d,u,a);case 5:case 10:return t.simd_loadstorelane(n.options.isWasm64?3:2,s,p,d,u,a)}}return n.error(203,e.reportNode.typeArgumentsRange,"v128.load_lane",i.toString()),t.unreachable()}x.set(h.v128_load_lane,Xr);function Kr(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e,!0)|ve(e,3,5))return t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],n.options.usizeType,1),a=n.compileExpression(r[1],l.v128,1),o=n.compileExpression(r[2],l.u8,1),u=0,c=t.runExpression(o,1);c?u=Y(c):n.error(220,r[2].range);let f=r.length,p=0,d=i.byteSize;if(f>=4&&(p=Ze(r[3],n),p<0||f==5&&(d=wn(r[4],d,n),d<0)))return n.currentType=l.v128,t.unreachable();if(n.currentType=l.v128,i.isValue){let m=16/assert(i.byteSize)-1;switch((u<0||u>m)&&(n.error(222,r[1].range,"Lane index","0",m.toString()),u=0),i.kind){case 1:case 6:return t.simd_loadstorelane(4,s,p,d,u,a);case 2:case 7:return t.simd_loadstorelane(5,s,p,d,u,a);case 3:case 8:case 11:return t.simd_loadstorelane(6,s,p,d,u,a);case 4:case 9:case 12:return t.simd_loadstorelane(7,s,p,d,u,a);case 5:case 10:return t.simd_loadstorelane(n.options.isWasm64?7:6,s,p,d,u,a)}}return n.error(203,e.reportNode.typeArgumentsRange,"v128.store_lane",i.toString()),t.unreachable()}x.set(h.v128_store_lane,Kr);function Tt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:case 6:return t.binary(128,s,a);case 2:case 7:return t.binary(139,s,a);case 3:case 8:return t.binary(156,s,a);case 4:case 9:return t.binary(168,s,a);case 5:case 10:return t.binary(n.options.isWasm64?168:156,s,a);case 11:return t.binary(175,s,a);case 12:return t.binary(183,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.add",i.toString()),t.unreachable()}x.set(h.v128_add,Tt);function St(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:case 6:return t.binary(131,s,a);case 2:case 7:return t.binary(142,s,a);case 3:case 8:return t.binary(157,s,a);case 4:case 9:return t.binary(169,s,a);case 5:case 10:return t.binary(n.options.isWasm64?169:157,s,a);case 11:return t.binary(176,s,a);case 12:return t.binary(184,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.sub",i.toString()),t.unreachable()}x.set(h.v128_sub,St);function ir(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 2:case 7:return t.binary(145,s,a);case 3:case 8:return t.binary(158,s,a);case 4:case 9:return t.binary(170,s,a);case 5:case 10:return t.binary(n.options.isWasm64?170:158,s,a);case 11:return t.binary(177,s,a);case 12:return t.binary(185,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.mul",i.toString()),t.unreachable()}x.set(h.v128_mul,ir);function Su(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.binary(178,s,a);case 12:return t.binary(186,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.div",i.toString()),t.unreachable()}x.set(h.v128_div,Su);function $r(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(129,s,a);case 6:return t.binary(130,s,a);case 2:return t.binary(140,s,a);case 7:return t.binary(141,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.add_sat",i.toString()),t.unreachable()}x.set(h.v128_add_sat,$r);function Yr(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(132,s,a);case 6:return t.binary(133,s,a);case 2:return t.binary(143,s,a);case 7:return t.binary(144,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.sub_sat",i.toString()),t.unreachable()}x.set(h.v128_sub_sat,Yr);function zn(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(134,s,a);case 6:return t.binary(135,s,a);case 2:return t.binary(146,s,a);case 7:return t.binary(147,s,a);case 5:if(n.options.isWasm64)break;case 3:return t.binary(159,s,a);case 10:if(n.options.isWasm64)break;case 8:return t.binary(160,s,a);case 11:return t.binary(179,s,a);case 12:return t.binary(187,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.min",i.toString()),t.unreachable()}x.set(h.v128_min,zn);function Nn(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(136,s,a);case 6:return t.binary(137,s,a);case 2:return t.binary(148,s,a);case 7:return t.binary(149,s,a);case 5:if(n.options.isWasm64)break;case 3:return t.binary(161,s,a);case 10:if(n.options.isWasm64)break;case 8:return t.binary(162,s,a);case 11:return t.binary(180,s,a);case 12:return t.binary(188,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.max",i.toString()),t.unreachable()}x.set(h.v128_max,Nn);function Cu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.binary(181,s,a);case 12:return t.binary(189,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.pmin",i.toString()),t.unreachable()}x.set(h.v128_pmin,Cu);function wu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.binary(182,s,a);case 12:return t.binary(190,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.pmax",i.toString()),t.unreachable()}x.set(h.v128_pmax,wu);function s2(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 2:return t.binary(163,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.dot",i.toString()),t.unreachable()}x.set(h.v128_dot,s2);function Iu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 6:return t.binary(138,s,a);case 7:return t.binary(150,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.avgr",i.toString()),t.unreachable()}x.set(h.v128_avgr,Iu);function Ct(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:case 6:return t.binary(76,s,a);case 2:case 7:return t.binary(86,s,a);case 3:case 8:return t.binary(96,s,a);case 4:case 9:return t.binary(106,s,a);case 5:case 10:return t.binary(n.options.isWasm64?106:96,s,a);case 11:return t.binary(112,s,a);case 12:return t.binary(118,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.eq",i.toString()),t.unreachable()}x.set(h.v128_eq,Ct);function wt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:case 6:return t.binary(77,s,a);case 2:case 7:return t.binary(87,s,a);case 3:case 8:return t.binary(97,s,a);case 4:case 9:return t.binary(107,s,a);case 5:case 10:return t.binary(n.options.isWasm64?107:97,s,a);case 11:return t.binary(113,s,a);case 12:return t.binary(119,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.ne",i.toString()),t.unreachable()}x.set(h.v128_ne,wt);function xn(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(78,s,a);case 6:return t.binary(79,s,a);case 2:return t.binary(88,s,a);case 7:return t.binary(89,s,a);case 3:return t.binary(98,s,a);case 8:return t.binary(99,s,a);case 4:return t.binary(108,s,a);case 5:return t.binary(n.options.isWasm64?108:98,s,a);case 10:{if(n.options.isWasm64)break;return t.binary(99,s,a)}case 11:return t.binary(114,s,a);case 12:return t.binary(120,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.lt",i.toString()),t.unreachable()}x.set(h.v128_lt,xn);function gn(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(82,s,a);case 6:return t.binary(83,s,a);case 2:return t.binary(92,s,a);case 7:return t.binary(93,s,a);case 3:return t.binary(102,s,a);case 8:return t.binary(103,s,a);case 4:return t.binary(110,s,a);case 5:return t.binary(n.options.isWasm64?110:102,s,a);case 10:{if(n.options.isWasm64)break;return t.binary(103,s,a)}case 11:return t.binary(116,s,a);case 12:return t.binary(122,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.le",i.toString()),t.unreachable()}x.set(h.v128_le,gn);function mn(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(80,s,a);case 6:return t.binary(81,s,a);case 2:return t.binary(90,s,a);case 7:return t.binary(91,s,a);case 3:return t.binary(100,s,a);case 8:return t.binary(101,s,a);case 4:return t.binary(109,s,a);case 5:return t.binary(n.options.isWasm64?109:100,s,a);case 10:{if(n.options.isWasm64)break;return t.binary(101,s,a)}case 11:return t.binary(115,s,a);case 12:return t.binary(121,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.gt",i.toString()),t.unreachable()}x.set(h.v128_gt,mn);function yn(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(84,s,a);case 6:return t.binary(85,s,a);case 2:return t.binary(94,s,a);case 7:return t.binary(95,s,a);case 3:return t.binary(104,s,a);case 8:return t.binary(105,s,a);case 4:return t.binary(111,s,a);case 5:return t.binary(n.options.isWasm64?111:104,s,a);case 10:{if(n.options.isWasm64)break;return t.binary(105,s,a)}case 11:return t.binary(117,s,a);case 12:return t.binary(123,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.ge",i.toString()),t.unreachable()}x.set(h.v128_ge,yn);function Zr(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 2:return t.binary(191,s,a);case 7:return t.binary(192,s,a);case 3:return t.binary(193,s,a);case 8:return t.binary(194,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.narrow",i.toString()),t.unreachable()}x.set(h.v128_narrow,Zr);function It(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 1:case 6:return t.unary(69,s);case 2:case 7:return t.unary(74,s);case 3:case 8:return t.unary(78,s);case 4:case 9:return t.unary(82,s);case 5:case 10:return t.unary(n.options.isWasm64?82:78,s);case 11:return t.unary(86,s);case 12:return t.unary(93,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.neg",i.toString()),t.unreachable()}x.set(h.v128_neg,It);function kt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.unary(68,s);case 2:return t.unary(73,s);case 3:return t.unary(77,s);case 4:return t.unary(81,s);case 5:return t.unary(n.options.isWasm64?81:77,s);case 6:case 7:case 8:case 9:case 10:return s;case 11:return t.unary(85,s);case 12:return t.unary(92,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.abs",i.toString()),t.unreachable()}x.set(h.v128_abs,kt);function ku(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.unary(87,s);case 12:return t.unary(94,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.sqrt",i.toString()),t.unreachable()}x.set(h.v128_sqrt,ku);function Bu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.unary(88,s);case 12:return t.unary(95,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.ceil",i.toString()),t.unreachable()}x.set(h.v128_ceil,Bu);function zu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.unary(89,s);case 12:return t.unary(96,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.floor",i.toString()),t.unreachable()}x.set(h.v128_floor,zu);function Nu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.unary(90,s);case 12:return t.unary(97,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.trunc",i.toString()),t.unreachable()}x.set(h.v128_trunc,Nu);function Lu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 11:return t.unary(91,s);case 12:return t.unary(98,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.nearest",i.toString()),t.unreachable()}x.set(h.v128_nearest,Lu);function Du(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 5:if(n.options.isWasm64)break;case 3:return t.unary(105,s);case 10:if(n.options.isWasm64)break;case 8:return t.unary(106,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.convert",i.toString()),t.unreachable()}x.set(h.v128_convert,Du);function Ou(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 5:if(n.options.isWasm64)break;case 3:return t.unary(119,s);case 10:if(n.options.isWasm64)break;case 8:return t.unary(120,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.convert_low",i.toString()),t.unreachable()}x.set(h.v128_convert_low,Ou);function Ru(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 5:if(n.options.isWasm64)break;case 3:return t.unary(103,s);case 10:if(n.options.isWasm64)break;case 8:return t.unary(104,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.trunc_sat",i.toString()),t.unreachable()}x.set(h.v128_trunc_sat,Ru);function Mu(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 5:if(n.options.isWasm64)break;case 3:return t.unary(121,s);case 10:if(n.options.isWasm64)break;case 8:return t.unary(122,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.trunc_sat_zero",i.toString()),t.unreachable()}x.set(h.v128_trunc_sat_zero,Mu);function Bt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.unary(107,s);case 6:return t.unary(109,s);case 2:return t.unary(111,s);case 7:return t.unary(113,s);case 5:if(n.options.isWasm64)break;case 3:return t.unary(115,s);case 10:if(n.options.isWasm64)break;case 8:return t.unary(117,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.extend_low",i.toString()),t.unreachable()}x.set(h.v128_extend_low,Bt);function zt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.unary(108,s);case 6:return t.unary(110,s);case 2:return t.unary(112,s);case 7:return t.unary(114,s);case 5:if(n.options.isWasm64)break;case 3:return t.unary(116,s);case 10:if(n.options.isWasm64)break;case 8:return t.unary(118,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.extend_high",i.toString()),t.unreachable()}x.set(h.v128_extend_high,zt);function Jr(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.i32,1);if(n.currentType=l.v128,i.isValue)switch(i.kind){case 1:case 6:return t.simd_shift(0,s,a);case 2:case 7:return t.simd_shift(3,s,a);case 3:case 8:return t.simd_shift(6,s,a);case 4:case 9:return t.simd_shift(9,s,a);case 5:case 10:return t.simd_shift(n.options.isWasm64?9:6,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.shl",i.toString()),t.unreachable()}x.set(h.v128_shl,Jr);function Ln(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.i32,1);if(n.currentType=l.v128,i.isValue)switch(i.kind){case 1:return t.simd_shift(1,s,a);case 6:return t.simd_shift(2,s,a);case 2:return t.simd_shift(4,s,a);case 7:return t.simd_shift(5,s,a);case 3:return t.simd_shift(7,s,a);case 8:return t.simd_shift(8,s,a);case 4:return t.simd_shift(10,s,a);case 9:return t.simd_shift(11,s,a);case 5:return t.simd_shift(n.options.isWasm64?10:7,s,a);case 10:return t.simd_shift(n.options.isWasm64?11:8,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.shr",i.toString()),t.unreachable()}x.set(h.v128_shr,Ln);function ds(e,n){let t=e.compiler,r=t.module;if(R(e,16)|_(e)|z(e,2))return t.currentType=l.v128,r.unreachable();let i=e.operands,s=t.compileExpression(i[0],l.v128,1),a=t.compileExpression(i[1],l.v128,1);return r.binary(n,s,a)}function m4(e){return ds(e,124)}x.set(h.v128_and,m4);function y4(e){return ds(e,125)}x.set(h.v128_or,y4);function _4(e){return ds(e,126)}x.set(h.v128_xor,_4);function b4(e){return ds(e,127)}x.set(h.v128_andnot,b4);function v4(e,n){let t=e.compiler,r=t.module;if(R(e,16)|_(e)|z(e,1))return t.currentType=l.v128,r.unreachable();let i=e.operands,s=t.compileExpression(i[0],l.v128,1);return r.unary(n,s)}function E4(e){return v4(e,66)}x.set(h.v128_not,E4);function F4(e,n){let t=e.compiler,r=t.module;if(R(e,16)|_(e)|z(e,3))return t.currentType=l.v128,r.unreachable();let i=e.operands,s=t.compileExpression(i[0],l.v128,1),a=t.compileExpression(i[1],l.v128,1),o=t.compileExpression(i[2],l.v128,1);return r.simd_ternary(n,s,a,o)}function A4(e){return F4(e,0)}x.set(h.v128_bitselect,A4);function T4(e){let n=e.compiler,t=n.module;if(R(e,16)|_(e)|z(e,1))return n.currentType=l.bool,t.unreachable();let r=e.operands,i=n.compileExpression(r[0],l.v128,1);return n.currentType=l.bool,t.unary(67,i)}x.set(h.v128_any_true,T4);function Qr(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.bool,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(n.currentType=l.bool,i.isValue)switch(i.kind){case 1:case 6:return t.unary(70,s);case 2:case 7:return t.unary(75,s);case 3:case 8:return t.unary(79,s);case 4:case 9:return t.unary(83,s);case 5:case 10:return t.unary(n.options.isWasm64?83:79,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.all_true",i.toString()),t.unreachable()}x.set(h.v128_all_true,Qr);function ei(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.i32,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(n.currentType=l.i32,i.isValue)switch(i.kind){case 1:case 6:return t.unary(71,s);case 2:case 7:return t.unary(76,s);case 3:case 8:return t.unary(80,s);case 4:case 9:return t.unary(84,s);case 5:case 10:return t.unary(n.options.isWasm64?84:80,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.bitmask",i.toString()),t.unreachable()}x.set(h.v128_bitmask,ei);function a2(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(n.currentType=l.v128,i.isValue)switch(i.kind){case 1:case 6:return t.unary(72,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.popcnt",i.toString()),t.unreachable()}x.set(h.v128_popcnt,a2);function ni(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1);if(n.currentType=l.v128,i.isValue)switch(i.kind){case 1:return t.unary(99,s);case 6:return t.unary(100,s);case 2:return t.unary(101,s);case 7:return t.unary(102,s)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.extadd_pairwise",i.toString()),t.unreachable()}x.set(h.v128_extadd_pairwise,ni);function o2(e){let n=e.compiler,t=n.module;if(R(e,16)|re(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments,s=i?i[0]:l.f64,a=n.compileExpression(r[0],l.v128,1);if(n.currentType=l.v128,s.isValue)switch(s.kind){case 12:return t.unary(123,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.demote_zero",s.toString()),t.unreachable()}x.set(h.v128_demote_zero,o2);function l2(e){let n=e.compiler,t=n.module;if(R(e,16)|re(e)|z(e,1))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments,s=i?i[0]:l.f32,a=n.compileExpression(r[0],l.v128,1);if(n.currentType=l.v128,s.isValue)switch(s.kind){case 11:return t.unary(124,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.promote_low",s.toString()),t.unreachable()}x.set(h.v128_promote_low,l2);function u2(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 2:return t.binary(151,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.q15mulr_sat",i.toString()),t.unreachable()}x.set(h.v128_q15mulr_sat,u2);function Nt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(152,s,a);case 6:return t.binary(154,s,a);case 2:return t.binary(164,s,a);case 7:return t.binary(166,s,a);case 3:return t.binary(171,s,a);case 8:return t.binary(173,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.extmul_low",i.toString()),t.unreachable()}x.set(h.v128_extmul_low,Nt);function Lt(e){let n=e.compiler,t=n.module;if(R(e,16)|U(e)|z(e,2))return n.currentType=l.v128,t.unreachable();let r=e.operands,i=e.typeArguments[0],s=n.compileExpression(r[0],l.v128,1),a=n.compileExpression(r[1],l.v128,1);if(i.isValue)switch(i.kind){case 1:return t.binary(153,s,a);case 6:return t.binary(155,s,a);case 2:return t.binary(165,s,a);case 7:return t.binary(167,s,a);case 3:return t.binary(172,s,a);case 8:return t.binary(174,s,a)}return n.error(203,e.reportNode.typeArgumentsRange,"v128.extmul_high",i.toString()),t.unreachable()}x.set(h.v128_extmul_high,Lt);function S4(e){let n=e.compiler,t=n.module;if(_(e)|z(e,1))return n.currentType=l.void,t.unreachable();let r=e.operands,i=n.compileExpression(r[0],l.u32,1);return n.runtimeFeatures|=16,n.currentType=l.void,t.call(h.visit_globals,[i],A.None)}x.set(h.visit_globals,S4);function C4(e){let n=e.compiler,t=n.module;if(_(e)|z(e,2))return n.currentType=l.void,t.unreachable();let r=e.operands,i=n.compileExpression(r[0],n.options.usizeType,1),s=n.compileExpression(r[1],l.u32,1);return n.runtimeFeatures|=32,n.currentType=l.void,t.call(h.visit_members,[i,s],A.None)}x.set(h.visit_members,C4);function w4(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,uu(e)}x.set(h.i32_clz,w4);function I4(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,uu(e)}x.set(h.i64_clz,I4);function k4(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,cu(e)}x.set(h.i32_ctz,k4);function B4(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,cu(e)}x.set(h.i64_ctz,B4);function z4(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,fu(e)}x.set(h.i32_popcnt,z4);function N4(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,fu(e)}x.set(h.i64_popcnt,N4);function L4(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,pu(e)}x.set(h.i32_rotl,L4);function D4(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,pu(e)}x.set(h.i64_rotl,D4);function O4(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,hu(e)}x.set(h.i32_rotr,O4);function R4(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,hu(e)}x.set(h.i64_rotr,R4);function M4(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,du(e)}x.set(h.f32_abs,M4);function U4(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,du(e)}x.set(h.f64_abs,U4);function P4(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,xu(e)}x.set(h.f32_max,P4);function V4(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,xu(e)}x.set(h.f64_max,V4);function G4(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,gu(e)}x.set(h.f32_min,G4);function q4(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,gu(e)}x.set(h.f64_min,q4);function j4(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,mu(e)}x.set(h.f32_ceil,j4);function W4(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,mu(e)}x.set(h.f64_ceil,W4);function H4(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,yu(e)}x.set(h.f32_floor,H4);function X4(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,yu(e)}x.set(h.f64_floor,X4);function K4(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,_u(e)}x.set(h.f32_copysign,K4);function $4(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,_u(e)}x.set(h.f64_copysign,$4);function Y4(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,bu(e)}x.set(h.f32_nearest,Y4);function Z4(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,bu(e)}x.set(h.f64_nearest,Z4);function J4(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.f32,Ur(e)}x.set(h.i32_reinterpret_f32,J4);function Q4(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.f64,Ur(e)}x.set(h.i64_reinterpret_f64,Q4);function e_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.i32,Ur(e)}x.set(h.f32_reinterpret_i32,e_);function n_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.i64,Ur(e)}x.set(h.f64_reinterpret_i64,n_);function t_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,vu(e)}x.set(h.f32_sqrt,t_);function r_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,vu(e)}x.set(h.f64_sqrt,r_);function i_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,Eu(e)}x.set(h.f32_trunc,i_);function s_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,Eu(e)}x.set(h.f64_trunc,s_);function a_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Pr(e)}x.set(h.i32_rem_s,a_);function o_(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.u32,Pr(e)}x.set(h.i32_rem_u,o_);function l_(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,Pr(e)}x.set(h.i64_rem_s,l_);function u_(e){return _(e),e.typeArguments=[l.u64],e.contextualType=l.u64,Pr(e)}x.set(h.i64_rem_u,u_);function c_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Vr(e)}x.set(h.i32_add,c_);function f_(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,Vr(e)}x.set(h.i64_add,f_);function p_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,Vr(e)}x.set(h.f32_add,p_);function h_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,Vr(e)}x.set(h.f64_add,h_);function d_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Gr(e)}x.set(h.i32_sub,d_);function x_(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,Gr(e)}x.set(h.i64_sub,x_);function g_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,Gr(e)}x.set(h.f32_sub,g_);function m_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,Gr(e)}x.set(h.f64_sub,m_);function y_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,qr(e)}x.set(h.i32_mul,y_);function __(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,qr(e)}x.set(h.i64_mul,__);function b_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,qr(e)}x.set(h.f32_mul,b_);function v_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,qr(e)}x.set(h.f64_mul,v_);function E_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,_t(e)}x.set(h.i32_div_s,E_);function F_(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.u32,_t(e)}x.set(h.i32_div_u,F_);function A_(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,_t(e)}x.set(h.i64_div_s,A_);function T_(e){return _(e),e.typeArguments=[l.u64],e.contextualType=l.u64,_t(e)}x.set(h.i64_div_u,T_);function S_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,_t(e)}x.set(h.f32_div,S_);function C_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,_t(e)}x.set(h.f64_div,C_);function w_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,jr(e)}x.set(h.i32_eq,w_);function I_(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i32,jr(e)}x.set(h.i64_eq,I_);function k_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.i32,jr(e)}x.set(h.f32_eq,k_);function B_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.i32,jr(e)}x.set(h.f64_eq,B_);function z_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Wr(e)}x.set(h.i32_ne,z_);function N_(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i32,Wr(e)}x.set(h.i64_ne,N_);function L_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.i32,Wr(e)}x.set(h.f32_ne,L_);function D_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.i32,Wr(e)}x.set(h.f64_ne,D_);function O_(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i32,Te(e)}x.set(h.i32_load8_s,O_);function R_(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,Te(e)}x.set(h.i32_load8_u,R_);function M_(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i32,Te(e)}x.set(h.i32_load16_s,M_);function U_(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,Te(e)}x.set(h.i32_load16_u,U_);function P_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Te(e)}x.set(h.i32_load,P_);function V_(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i64,Te(e)}x.set(h.i64_load8_s,V_);function G_(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,Te(e)}x.set(h.i64_load8_u,G_);function q_(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i64,Te(e)}x.set(h.i64_load16_s,q_);function j_(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,Te(e)}x.set(h.i64_load16_u,j_);function W_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i64,Te(e)}x.set(h.i64_load32_s,W_);function H_(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,Te(e)}x.set(h.i64_load32_u,H_);function X_(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,Te(e)}x.set(h.i64_load,X_);function K_(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,Te(e)}x.set(h.f32_load,K_);function $_(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,Te(e)}x.set(h.f64_load,$_);function Y_(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i32,e.contextIsExact=!0,sn(e)}x.set(h.i32_store8,Y_);function Z_(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i32,e.contextIsExact=!0,sn(e)}x.set(h.i32_store16,Z_);function J_(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,sn(e)}x.set(h.i32_store,J_);function Q_(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i64,e.contextIsExact=!0,sn(e)}x.set(h.i64_store8,Q_);function eb(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i64,e.contextIsExact=!0,sn(e)}x.set(h.i64_store16,eb);function nb(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i64,e.contextIsExact=!0,sn(e)}x.set(h.i64_store32,nb);function tb(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,sn(e)}x.set(h.i64_store,tb);function rb(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,e.contextIsExact=!0,sn(e)}x.set(h.f32_store,rb);function ib(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,e.contextIsExact=!0,sn(e)}x.set(h.f64_store,ib);function sb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,Yn(e)}x.set(h.i32_atomic_load8_u,sb);function ab(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,Yn(e)}x.set(h.i32_atomic_load16_u,ab);function ob(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Yn(e)}x.set(h.i32_atomic_load,ob);function lb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,Yn(e)}x.set(h.i64_atomic_load8_u,lb);function ub(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,Yn(e)}x.set(h.i64_atomic_load16_u,ub);function cb(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,Yn(e)}x.set(h.i64_atomic_load32_u,cb);function fb(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,Yn(e)}x.set(h.i64_atomic_load,fb);function pb(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i32,e.contextIsExact=!0,Zn(e)}x.set(h.i32_atomic_store8,pb);function hb(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i32,e.contextIsExact=!0,Zn(e)}x.set(h.i32_atomic_store16,hb);function db(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,Zn(e)}x.set(h.i32_atomic_store,db);function xb(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i64,e.contextIsExact=!0,Zn(e)}x.set(h.i64_atomic_store8,xb);function gb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,Zn(e)}x.set(h.i64_atomic_store16,gb);function mb(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i64,e.contextIsExact=!0,Zn(e)}x.set(h.i64_atomic_store32,mb);function yb(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,Zn(e)}x.set(h.i64_atomic_store,yb);function _b(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,e.contextIsExact=!0,Jn(e)}x.set(h.i32_atomic_rmw8_add_u,_b);function bb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,e.contextIsExact=!0,Jn(e)}x.set(h.i32_atomic_rmw16_add_u,bb);function vb(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,Jn(e)}x.set(h.i32_atomic_rmw_add,vb);function Eb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,e.contextIsExact=!0,Jn(e)}x.set(h.i64_atomic_rmw8_add_u,Eb);function Fb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,Jn(e)}x.set(h.i64_atomic_rmw16_add_u,Fb);function Ab(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,e.contextIsExact=!0,Jn(e)}x.set(h.i64_atomic_rmw32_add_u,Ab);function Tb(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,Jn(e)}x.set(h.i64_atomic_rmw_add,Tb);function Sb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,e.contextIsExact=!0,Qn(e)}x.set(h.i32_atomic_rmw8_sub_u,Sb);function Cb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,e.contextIsExact=!0,Qn(e)}x.set(h.i32_atomic_rmw16_sub_u,Cb);function wb(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,Qn(e)}x.set(h.i32_atomic_rmw_sub,wb);function Ib(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,e.contextIsExact=!0,Qn(e)}x.set(h.i64_atomic_rmw8_sub_u,Ib);function kb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,Qn(e)}x.set(h.i64_atomic_rmw16_sub_u,kb);function Bb(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,e.contextIsExact=!0,Qn(e)}x.set(h.i64_atomic_rmw32_sub_u,Bb);function zb(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,Qn(e)}x.set(h.i64_atomic_rmw_sub,zb);function Nb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,e.contextIsExact=!0,et(e)}x.set(h.i32_atomic_rmw8_and_u,Nb);function Lb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,e.contextIsExact=!0,et(e)}x.set(h.i32_atomic_rmw16_and_u,Lb);function Db(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,et(e)}x.set(h.i32_atomic_rmw_and,Db);function Ob(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,e.contextIsExact=!0,et(e)}x.set(h.i64_atomic_rmw8_and_u,Ob);function Rb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,et(e)}x.set(h.i64_atomic_rmw16_and_u,Rb);function Mb(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,e.contextIsExact=!0,et(e)}x.set(h.i64_atomic_rmw32_and_u,Mb);function Ub(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,et(e)}x.set(h.i64_atomic_rmw_and,Ub);function Pb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,e.contextIsExact=!0,nt(e)}x.set(h.i32_atomic_rmw8_or_u,Pb);function Vb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,e.contextIsExact=!0,nt(e)}x.set(h.i32_atomic_rmw16_or_u,Vb);function Gb(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,nt(e)}x.set(h.i32_atomic_rmw_or,Gb);function qb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,e.contextIsExact=!0,nt(e)}x.set(h.i64_atomic_rmw8_or_u,qb);function jb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,nt(e)}x.set(h.i64_atomic_rmw16_or_u,jb);function Wb(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,e.contextIsExact=!0,nt(e)}x.set(h.i64_atomic_rmw32_or_u,Wb);function Hb(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,nt(e)}x.set(h.i64_atomic_rmw_or,Hb);function Xb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,e.contextIsExact=!0,tt(e)}x.set(h.i32_atomic_rmw8_xor_u,Xb);function Kb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,e.contextIsExact=!0,tt(e)}x.set(h.i32_atomic_rmw16_xor_u,Kb);function $b(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,tt(e)}x.set(h.i32_atomic_rmw_xor,$b);function Yb(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,e.contextIsExact=!0,tt(e)}x.set(h.i64_atomic_rmw8_xor_u,Yb);function Zb(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,tt(e)}x.set(h.i64_atomic_rmw16_xor_u,Zb);function Jb(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,e.contextIsExact=!0,tt(e)}x.set(h.i64_atomic_rmw32_xor_u,Jb);function Qb(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,tt(e)}x.set(h.i64_atomic_rmw_xor,Qb);function e5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,e.contextIsExact=!0,rt(e)}x.set(h.i32_atomic_rmw8_xchg_u,e5);function n5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,e.contextIsExact=!0,rt(e)}x.set(h.i32_atomic_rmw16_xchg_u,n5);function t5(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,rt(e)}x.set(h.i32_atomic_rmw_xchg,t5);function r5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,e.contextIsExact=!0,rt(e)}x.set(h.i64_atomic_rmw8_xchg_u,r5);function i5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,rt(e)}x.set(h.i64_atomic_rmw16_xchg_u,i5);function s5(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,e.contextIsExact=!0,rt(e)}x.set(h.i64_atomic_rmw32_xchg_u,s5);function a5(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,rt(e)}x.set(h.i64_atomic_rmw_xchg,a5);function o5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,e.contextIsExact=!0,it(e)}x.set(h.i32_atomic_rmw8_cmpxchg_u,o5);function l5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,e.contextIsExact=!0,it(e)}x.set(h.i32_atomic_rmw16_cmpxchg_u,l5);function u5(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,e.contextIsExact=!0,it(e)}x.set(h.i32_atomic_rmw_cmpxchg,u5);function c5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i64,e.contextIsExact=!0,it(e)}x.set(h.i64_atomic_rmw8_cmpxchg_u,c5);function f5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i64,e.contextIsExact=!0,it(e)}x.set(h.i64_atomic_rmw16_cmpxchg_u,f5);function p5(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.i64,e.contextIsExact=!0,it(e)}x.set(h.i64_atomic_rmw32_cmpxchg_u,p5);function h5(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,e.contextIsExact=!0,it(e)}x.set(h.i64_atomic_rmw_cmpxchg,h5);function d5(e){return _(e),e.typeArguments=[l.i32],Fu(e)}x.set(h.i32_wait,d5);function x5(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i32,Fu(e)}x.set(h.i64_wait,x5);function g5(e){return _(e),e.typeArguments=[l.v128],e.contextualType=l.v128,Te(e)}x.set(h.v128_load,g5);function m5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,At(e)}x.set(h.v128_load8x8_s,m5);function y5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,At(e)}x.set(h.v128_load8x8_u,y5);function _5(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,At(e)}x.set(h.v128_load16x4_s,_5);function b5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,At(e)}x.set(h.v128_load16x4_u,b5);function v5(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,At(e)}x.set(h.v128_load32x2_s,v5);function E5(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,At(e)}x.set(h.v128_load32x2_u,E5);function F5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Hr(e)}x.set(h.v128_load8_splat,F5);function A5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Hr(e)}x.set(h.v128_load16_splat,A5);function T5(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Hr(e)}x.set(h.v128_load32_splat,T5);function S5(e){return _(e),e.typeArguments=[l.u64],e.contextualType=l.v128,Hr(e)}x.set(h.v128_load64_splat,S5);function C5(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Tu(e)}x.set(h.v128_load32_zero,C5);function w5(e){return _(e),e.typeArguments=[l.u64],e.contextualType=l.v128,Tu(e)}x.set(h.v128_load64_zero,w5);function I5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Xr(e)}x.set(h.v128_load8_lane,I5);function k5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Xr(e)}x.set(h.v128_load16_lane,k5);function B5(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Xr(e)}x.set(h.v128_load32_lane,B5);function z5(e){return _(e),e.typeArguments=[l.u64],e.contextualType=l.v128,Xr(e)}x.set(h.v128_load64_lane,z5);function N5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Kr(e)}x.set(h.v128_store8_lane,N5);function L5(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Kr(e)}x.set(h.v128_store16_lane,L5);function D5(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Kr(e)}x.set(h.v128_store32_lane,D5);function O5(e){return _(e),e.typeArguments=[l.u64],e.contextualType=l.v128,Kr(e)}x.set(h.v128_store64_lane,O5);function R5(e){return _(e),e.typeArguments=[l.v128],e.contextualType=l.v128,e.contextIsExact=!0,sn(e)}x.set(h.v128_store,R5);function M5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,bt(e)}x.set(h.i8x16_splat,M5);function U5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i32,Bn(e)}x.set(h.i8x16_extract_lane_s,U5);function P5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.i32,Bn(e)}x.set(h.i8x16_extract_lane_u,P5);function V5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,vt(e)}x.set(h.i8x16_replace_lane,V5);function G5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Tt(e)}x.set(h.i8x16_add,G5);function q5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,St(e)}x.set(h.i8x16_sub,q5);function j5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,zn(e)}x.set(h.i8x16_min_s,j5);function W5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,zn(e)}x.set(h.i8x16_min_u,W5);function H5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Nn(e)}x.set(h.i8x16_max_s,H5);function X5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Nn(e)}x.set(h.i8x16_max_u,X5);function K5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Iu(e)}x.set(h.i8x16_avgr_u,K5);function $5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,kt(e)}x.set(h.i8x16_abs,$5);function Y5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,It(e)}x.set(h.i8x16_neg,Y5);function Z5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,$r(e)}x.set(h.i8x16_add_sat_s,Z5);function J5(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,$r(e)}x.set(h.i8x16_add_sat_u,J5);function Q5(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Yr(e)}x.set(h.i8x16_sub_sat_s,Q5);function e8(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Yr(e)}x.set(h.i8x16_sub_sat_u,e8);function n8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Jr(e)}x.set(h.i8x16_shl,n8);function t8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Ln(e)}x.set(h.i8x16_shr_s,t8);function r8(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Ln(e)}x.set(h.i8x16_shr_u,r8);function s8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i32,Qr(e)}x.set(h.i8x16_all_true,s8);function a8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.i32,ei(e)}x.set(h.i8x16_bitmask,a8);function o8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,a2(e)}x.set(h.i8x16_popcnt,o8);function l8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Ct(e)}x.set(h.i8x16_eq,l8);function c8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,wt(e)}x.set(h.i8x16_ne,c8);function f8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,xn(e)}x.set(h.i8x16_lt_s,f8);function p8(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,xn(e)}x.set(h.i8x16_lt_u,p8);function h8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,gn(e)}x.set(h.i8x16_le_s,h8);function d8(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,gn(e)}x.set(h.i8x16_le_u,d8);function x8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,mn(e)}x.set(h.i8x16_gt_s,x8);function g8(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,mn(e)}x.set(h.i8x16_gt_u,g8);function m8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,yn(e)}x.set(h.i8x16_ge_s,m8);function y8(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,yn(e)}x.set(h.i8x16_ge_u,y8);function _8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Zr(e)}x.set(h.i8x16_narrow_i16x8_s,_8);function b8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Zr(e)}x.set(h.i8x16_narrow_i16x8_u,b8);function v8(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Et(e)}x.set(h.i8x16_shuffle,v8);function E8(e){return e.typeArguments=null,e.contextualType=l.v128,Ft(e)}x.set(h.i8x16_swizzle,E8);function F8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,bt(e)}x.set(h.i16x8_splat,F8);function A8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i32,Bn(e)}x.set(h.i16x8_extract_lane_s,A8);function T8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.i32,Bn(e)}x.set(h.i16x8_extract_lane_u,T8);function S8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,vt(e)}x.set(h.i16x8_replace_lane,S8);function C8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Tt(e)}x.set(h.i16x8_add,C8);function w8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,St(e)}x.set(h.i16x8_sub,w8);function I8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,ir(e)}x.set(h.i16x8_mul,I8);function k8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,zn(e)}x.set(h.i16x8_min_s,k8);function B8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,zn(e)}x.set(h.i16x8_min_u,B8);function z8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Nn(e)}x.set(h.i16x8_max_s,z8);function N8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Nn(e)}x.set(h.i16x8_max_u,N8);function L8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Iu(e)}x.set(h.i16x8_avgr_u,L8);function D8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,kt(e)}x.set(h.i16x8_abs,D8);function O8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,It(e)}x.set(h.i16x8_neg,O8);function R8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,$r(e)}x.set(h.i16x8_add_sat_s,R8);function M8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,$r(e)}x.set(h.i16x8_add_sat_u,M8);function U8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Yr(e)}x.set(h.i16x8_sub_sat_s,U8);function P8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Yr(e)}x.set(h.i16x8_sub_sat_u,P8);function V8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Jr(e)}x.set(h.i16x8_shl,V8);function G8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Ln(e)}x.set(h.i16x8_shr_s,G8);function q8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Ln(e)}x.set(h.i16x8_shr_u,q8);function j8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i32,Qr(e)}x.set(h.i16x8_all_true,j8);function W8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.i32,ei(e)}x.set(h.i16x8_bitmask,W8);function H8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Ct(e)}x.set(h.i16x8_eq,H8);function X8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,wt(e)}x.set(h.i16x8_ne,X8);function K8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,xn(e)}x.set(h.i16x8_lt_s,K8);function $8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,xn(e)}x.set(h.i16x8_lt_u,$8);function Y8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,gn(e)}x.set(h.i16x8_le_s,Y8);function Z8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,gn(e)}x.set(h.i16x8_le_u,Z8);function J8(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,mn(e)}x.set(h.i16x8_gt_s,J8);function Q8(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,mn(e)}x.set(h.i16x8_gt_u,Q8);function ev(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,yn(e)}x.set(h.i16x8_ge_s,ev);function nv(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,yn(e)}x.set(h.i16x8_ge_u,nv);function tv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Zr(e)}x.set(h.i16x8_narrow_i32x4_s,tv);function rv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Zr(e)}x.set(h.i16x8_narrow_i32x4_u,rv);function iv(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Bt(e)}x.set(h.i16x8_extend_low_i8x16_s,iv);function sv(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Bt(e)}x.set(h.i16x8_extend_low_i8x16_u,sv);function av(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,zt(e)}x.set(h.i16x8_extend_high_i8x16_s,av);function ov(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,zt(e)}x.set(h.i16x8_extend_high_i8x16_u,ov);function lv(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,ni(e)}x.set(h.i16x8_extadd_pairwise_i8x16_s,lv);function uv(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,ni(e)}x.set(h.i16x8_extadd_pairwise_i8x16_u,uv);function cv(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,u2(e)}x.set(h.i16x8_q15mulr_sat_s,cv);function fv(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Nt(e)}x.set(h.i16x8_extmul_low_i8x16_s,fv);function pv(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Nt(e)}x.set(h.i16x8_extmul_low_i8x16_u,pv);function hv(e){return _(e),e.typeArguments=[l.i8],e.contextualType=l.v128,Lt(e)}x.set(h.i16x8_extmul_high_i8x16_s,hv);function dv(e){return _(e),e.typeArguments=[l.u8],e.contextualType=l.v128,Lt(e)}x.set(h.i16x8_extmul_high_i8x16_u,dv);function xv(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Et(e)}x.set(h.i16x8_shuffle,xv);function gv(e){return e.typeArguments=null,e.contextualType=l.v128,Ft(e)}x.set(h.i16x8_swizzle,gv);function mv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,bt(e)}x.set(h.i32x4_splat,mv);function yv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Bn(e)}x.set(h.i32x4_extract_lane,yv);function _v(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,vt(e)}x.set(h.i32x4_replace_lane,_v);function bv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Tt(e)}x.set(h.i32x4_add,bv);function vv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,St(e)}x.set(h.i32x4_sub,vv);function Ev(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,ir(e)}x.set(h.i32x4_mul,Ev);function Fv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,zn(e)}x.set(h.i32x4_min_s,Fv);function Av(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,zn(e)}x.set(h.i32x4_min_u,Av);function Tv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Nn(e)}x.set(h.i32x4_max_s,Tv);function Sv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Nn(e)}x.set(h.i32x4_max_u,Sv);function Cv(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,s2(e)}x.set(h.i32x4_dot_i16x8_s,Cv);function wv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,kt(e)}x.set(h.i32x4_abs,wv);function Iv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,It(e)}x.set(h.i32x4_neg,Iv);function kv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Jr(e)}x.set(h.i32x4_shl,kv);function Bv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Ln(e)}x.set(h.i32x4_shr_s,Bv);function zv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Ln(e)}x.set(h.i32x4_shr_u,zv);function Nv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,Qr(e)}x.set(h.i32x4_all_true,Nv);function Lv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.i32,ei(e)}x.set(h.i32x4_bitmask,Lv);function Dv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Ct(e)}x.set(h.i32x4_eq,Dv);function Ov(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,wt(e)}x.set(h.i32x4_ne,Ov);function Rv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,xn(e)}x.set(h.i32x4_lt_s,Rv);function Mv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,xn(e)}x.set(h.i32x4_lt_u,Mv);function Uv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,gn(e)}x.set(h.i32x4_le_s,Uv);function Pv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,gn(e)}x.set(h.i32x4_le_u,Pv);function Vv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,mn(e)}x.set(h.i32x4_gt_s,Vv);function Gv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,mn(e)}x.set(h.i32x4_gt_u,Gv);function qv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,yn(e)}x.set(h.i32x4_ge_s,qv);function jv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,yn(e)}x.set(h.i32x4_ge_u,jv);function Wv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Ru(e)}x.set(h.i32x4_trunc_sat_f32x4_s,Wv);function Hv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Ru(e)}x.set(h.i32x4_trunc_sat_f32x4_u,Hv);function Xv(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Mu(e)}x.set(h.i32x4_trunc_sat_f64x2_s_zero,Xv);function Kv(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Mu(e)}x.set(h.i32x4_trunc_sat_f64x2_u_zero,Kv);function $v(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Bt(e)}x.set(h.i32x4_extend_low_i16x8_s,$v);function Yv(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Bt(e)}x.set(h.i32x4_extend_low_i16x8_u,Yv);function Zv(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,zt(e)}x.set(h.i32x4_extend_high_i16x8_s,Zv);function Jv(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,zt(e)}x.set(h.i32x4_extend_high_i16x8_u,Jv);function Qv(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,ni(e)}x.set(h.i32x4_extadd_pairwise_i16x8_s,Qv);function eE(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,ni(e)}x.set(h.i32x4_extadd_pairwise_i16x8_u,eE);function nE(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Nt(e)}x.set(h.i32x4_extmul_low_i16x8_s,nE);function tE(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Nt(e)}x.set(h.i32x4_extmul_low_i16x8_u,tE);function rE(e){return _(e),e.typeArguments=[l.i16],e.contextualType=l.v128,Lt(e)}x.set(h.i32x4_extmul_high_i16x8_s,rE);function iE(e){return _(e),e.typeArguments=[l.u16],e.contextualType=l.v128,Lt(e)}x.set(h.i32x4_extmul_high_i16x8_u,iE);function sE(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Et(e)}x.set(h.i32x4_shuffle,sE);function aE(e){return e.typeArguments=null,e.contextualType=l.v128,Ft(e)}x.set(h.i32x4_swizzle,aE);function oE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,bt(e)}x.set(h.i64x2_splat,oE);function lE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i64,Bn(e)}x.set(h.i64x2_extract_lane,lE);function uE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,vt(e)}x.set(h.i64x2_replace_lane,uE);function cE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,Tt(e)}x.set(h.i64x2_add,cE);function fE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,St(e)}x.set(h.i64x2_sub,fE);function pE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,ir(e)}x.set(h.i64x2_mul,pE);function hE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,kt(e)}x.set(h.i64x2_abs,hE);function dE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,It(e)}x.set(h.i64x2_neg,dE);function xE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,Jr(e)}x.set(h.i64x2_shl,xE);function gE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,Ln(e)}x.set(h.i64x2_shr_s,gE);function mE(e){return _(e),e.typeArguments=[l.u64],e.contextualType=l.v128,Ln(e)}x.set(h.i64x2_shr_u,mE);function yE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i32,Qr(e)}x.set(h.i64x2_all_true,yE);function _E(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.i32,ei(e)}x.set(h.i64x2_bitmask,_E);function bE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,Ct(e)}x.set(h.i64x2_eq,bE);function vE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,wt(e)}x.set(h.i64x2_ne,vE);function EE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,xn(e)}x.set(h.i64x2_lt_s,EE);function FE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,gn(e)}x.set(h.i64x2_le_s,FE);function AE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,mn(e)}x.set(h.i64x2_gt_s,AE);function TE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,yn(e)}x.set(h.i64x2_ge_s,TE);function SE(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Bt(e)}x.set(h.i64x2_extend_low_i32x4_s,SE);function CE(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Bt(e)}x.set(h.i64x2_extend_low_i32x4_u,CE);function wE(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,zt(e)}x.set(h.i64x2_extend_high_i32x4_s,wE);function IE(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,zt(e)}x.set(h.i64x2_extend_high_i32x4_u,IE);function kE(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Nt(e)}x.set(h.i64x2_extmul_low_i32x4_s,kE);function BE(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Nt(e)}x.set(h.i64x2_extmul_low_i32x4_u,BE);function zE(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Lt(e)}x.set(h.i64x2_extmul_high_i32x4_s,zE);function NE(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Lt(e)}x.set(h.i64x2_extmul_high_i32x4_u,NE);function LE(e){return _(e),e.typeArguments=[l.i64],e.contextualType=l.v128,Et(e)}x.set(h.i64x2_shuffle,LE);function DE(e){return e.typeArguments=null,e.contextualType=l.v128,Ft(e)}x.set(h.i64x2_swizzle,DE);function OE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,bt(e)}x.set(h.f32x4_splat,OE);function RE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.f32,Bn(e)}x.set(h.f32x4_extract_lane,RE);function ME(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,vt(e)}x.set(h.f32x4_replace_lane,ME);function UE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Tt(e)}x.set(h.f32x4_add,UE);function PE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,St(e)}x.set(h.f32x4_sub,PE);function VE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,ir(e)}x.set(h.f32x4_mul,VE);function GE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Su(e)}x.set(h.f32x4_div,GE);function qE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,It(e)}x.set(h.f32x4_neg,qE);function jE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,zn(e)}x.set(h.f32x4_min,jE);function WE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Nn(e)}x.set(h.f32x4_max,WE);function HE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Cu(e)}x.set(h.f32x4_pmin,HE);function XE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,wu(e)}x.set(h.f32x4_pmax,XE);function KE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,kt(e)}x.set(h.f32x4_abs,KE);function $E(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,ku(e)}x.set(h.f32x4_sqrt,$E);function YE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Bu(e)}x.set(h.f32x4_ceil,YE);function ZE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,zu(e)}x.set(h.f32x4_floor,ZE);function JE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Nu(e)}x.set(h.f32x4_trunc,JE);function QE(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Lu(e)}x.set(h.f32x4_nearest,QE);function eF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Ct(e)}x.set(h.f32x4_eq,eF);function nF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,wt(e)}x.set(h.f32x4_ne,nF);function tF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,xn(e)}x.set(h.f32x4_lt,tF);function rF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,gn(e)}x.set(h.f32x4_le,rF);function iF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,mn(e)}x.set(h.f32x4_gt,iF);function sF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,yn(e)}x.set(h.f32x4_ge,sF);function aF(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Du(e)}x.set(h.f32x4_convert_i32x4_s,aF);function oF(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Du(e)}x.set(h.f32x4_convert_i32x4_u,oF);function lF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,o2(e)}x.set(h.f32x4_demote_f64x2_zero,lF);function uF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,Et(e)}x.set(h.f32x4_shuffle,uF);function cF(e){return e.typeArguments=null,e.contextualType=l.v128,Ft(e)}x.set(h.f32x4_swizzle,cF);function fF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,bt(e)}x.set(h.f64x2_splat,fF);function pF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.f64,Bn(e)}x.set(h.f64x2_extract_lane,pF);function hF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,vt(e)}x.set(h.f64x2_replace_lane,hF);function dF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Tt(e)}x.set(h.f64x2_add,dF);function xF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,St(e)}x.set(h.f64x2_sub,xF);function gF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,ir(e)}x.set(h.f64x2_mul,gF);function mF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Su(e)}x.set(h.f64x2_div,mF);function yF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,It(e)}x.set(h.f64x2_neg,yF);function _F(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,zn(e)}x.set(h.f64x2_min,_F);function bF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Nn(e)}x.set(h.f64x2_max,bF);function vF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Cu(e)}x.set(h.f64x2_pmin,vF);function EF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,wu(e)}x.set(h.f64x2_pmax,EF);function FF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,kt(e)}x.set(h.f64x2_abs,FF);function AF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,ku(e)}x.set(h.f64x2_sqrt,AF);function TF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Bu(e)}x.set(h.f64x2_ceil,TF);function SF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,zu(e)}x.set(h.f64x2_floor,SF);function CF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Nu(e)}x.set(h.f64x2_trunc,CF);function wF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Lu(e)}x.set(h.f64x2_nearest,wF);function IF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Ct(e)}x.set(h.f64x2_eq,IF);function kF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,wt(e)}x.set(h.f64x2_ne,kF);function BF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,xn(e)}x.set(h.f64x2_lt,BF);function zF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,gn(e)}x.set(h.f64x2_le,zF);function NF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,mn(e)}x.set(h.f64x2_gt,NF);function LF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,yn(e)}x.set(h.f64x2_ge,LF);function DF(e){return _(e),e.typeArguments=[l.i32],e.contextualType=l.v128,Ou(e)}x.set(h.f64x2_convert_low_i32x4_s,DF);function OF(e){return _(e),e.typeArguments=[l.u32],e.contextualType=l.v128,Ou(e)}x.set(h.f64x2_convert_low_i32x4_u,OF);function RF(e){return _(e),e.typeArguments=[l.f32],e.contextualType=l.v128,l2(e)}x.set(h.f64x2_promote_low_f32x4,RF);function MF(e){return _(e),e.typeArguments=[l.f64],e.contextualType=l.v128,Et(e)}x.set(h.f64x2_shuffle,MF);function UF(e){return e.typeArguments=null,e.contextualType=l.v128,Ft(e)}x.set(h.f64x2_swizzle,UF);function PF(e){let n=e.module,t=new Array,r=e.options.sizeTypeRef,i=assert(e.program.visitInstance);e.compileFunction(i,!0);for(let s=Map_values(e.program.elementsByName),a=0,o=s.length;a<o;++a){let u=unchecked(s[a]);if(u.kind!=0)continue;let c=u,f=c.type.getClass();if(f&&!f.hasDecorator(16)&&c.is(8388608))if(c.is(33554432)){let p=c.constantIntegerValue;(i64_low(p)||i64_high(p))&&t.push(n.call(i.internalName,[e.options.isWasm64?n.i64(i64_low(p),i64_high(p)):n.i32(i64_low(p)),n.local_get(0,A.I32)],A.None))}else t.push(n.if(n.local_tee(1,n.global_get(c.internalName,r),!1),n.call(i.internalName,[n.local_get(1,r),n.local_get(0,A.I32)],A.None)))}n.addFunction(h.visit_globals,A.I32,A.None,[r],t.length?n.block(null,t):n.nop())}function c2(e,n){if(assert(n.type.isManaged),n.visitRef)return;let t=e.program,r=e.module,i=t.options.usizeType,s=i.toRef(),a=i.byteSize,o=assert(t.visitInstance),u=new Array,c=n.base;c&&u.push(r.call(`${c.internalName}~visit`,[r.local_get(0,s),r.local_get(1,A.I32)],A.None));let f=!1;if(n.isDeclaredInLibrary){let d=n.getMember("__visit");if(d){assert(d.kind==4);let m=t.resolver.resolveFunction(d,null);if(!m||!e.compileFunction(m))u.push(r.unreachable());else{let g=m.signature,E=assert(g.thisType);assert(g.parameterTypes.length==1&&g.parameterTypes[0]==l.u32&&g.returnType==l.void&&n.type.isStrictlyAssignableTo(E)),u.push(r.call(m.internalName,[r.local_get(0,s),r.local_get(1,A.I32)],A.None))}f=!0}}let p=!1;if(!f){let d=n.members;if(d)for(let m=Map_values(d),g=0,E=m.length;g<E;++g){let y=unchecked(m[g]);if(y.kind==11&&y.parent==n&&y.type.isManaged){let b=y.memoryOffset;assert(b>=0),p=!0,u.push(r.if(r.local_tee(2,r.load(a,!1,r.local_get(0,s),s,b),!1),r.call(o.internalName,[r.local_get(2,s),r.local_get(1,A.I32)],A.None)))}}}n.visitRef=r.addFunction(`${n.internalName}~visit`,dn([s,A.I32]),A.None,p?[s]:null,r.flatten(u,A.None)),c&&c.type.isManaged&&c2(e,c)}function VF(e){let n=e.program,t=e.module,r=n.options.usizeType.toRef(),i=n.managedClasses,s=assert(n.visitInstance);e.compileFunction(s,!0);let a=new Array,o=new Array,u=0;for(let f=Map_keys(i),p=0,d=f.length;p<d;++p){let m=f[p];assert(m==u++);let g=assert(i.get(m));a[p]=g.internalName,g.isPointerfree?o[p]=t.return():(o[p]=t.block(null,[t.call(`${g.internalName}~visit`,[t.local_get(0,r),t.local_get(1,A.I32)],A.None),t.return()],A.None),c2(e,g))}let c=t.block(a[0],[t.switch(a,"invalid",t.load(4,!1,r==A.I64?t.binary(26,t.local_get(0,r),t.i64(8)):t.binary(1,t.local_get(0,r),t.i32(8)),A.I32,0))],A.None);for(let f=0,p=a.length-1;f<p;++f)c=t.block(a[f+1],[c,o[f]],A.None);c=t.block("invalid",[c,o[a.length-1]],A.None),t.addFunction(h.visit_members,dn([r,A.I32]),A.None,null,t.flatten([c,t.unreachable()]))}function Rt(e){let n=64*(1<<e.alignLog2);return e.is(1)&&(n|=2048),e.is(8)&&(n|=4096),e.is(512)&&(n|=8192),e.isManaged&&(n|=16384),n/64}function GF(e){let n=e.program,t=e.module,r=n.managedClasses,i=r.size,s=4+8*i,a=new Uint8Array(s);be(i,a,0);let o=4,u=n.arrayBufferViewInstance,c=u.prototype,f=n.arrayPrototype,p=n.setPrototype,d=n.mapPrototype,m=n.staticArrayPrototype,g=0;for(let b=Map_keys(r),T=0,S=b.length;T<S;++T){let C=unchecked(b[T]),w=assert(r.get(C));assert(C==g++);let B=0;if(w.isPointerfree&&(B|=32),w!=u&&w.extends(c)){let W=w.getArrayValueType();B|=1,B|=64*Rt(W)}else if(w.extends(f)){let W=w.getArrayValueType();B|=2,B|=64*Rt(W)}else if(w.extends(p)){let W=assert(w.getTypeArgumentsTo(p));assert(W.length==1),B|=8,B|=64*Rt(W[0])}else if(w.extends(d)){let W=assert(w.getTypeArgumentsTo(d));assert(W.length==2),B|=16,B|=32768*Rt(W[0]),B|=64*Rt(W[1])}else if(w.extends(m)){let W=w.getArrayValueType();B|=4,B|=64*Rt(W)}be(B,a,o),o+=4,w.rttiFlags=B;let D=w.base;be(D?D.id:0,a,o),o+=4}assert(o==s);let E=n.options.usizeType,y=e.addAlignedMemorySegment(a);if(E.size==8){let b=y.offset;t.addGlobal(h.rtti_base,A.I64,!1,t.i64(i64_low(b),i64_high(b)))}else t.addGlobal(h.rtti_base,A.I32,!1,t.i32(i64_low(y.offset)))}function qF(e,n){let t=e.module,r=e.options.sizeTypeRef,i=assert(n.program.instanceofInstance);e.compileFunction(i);let s=new Array;s.push(t.if(t.unary(r==A.I64?21:20,t.local_get(0,r)),t.return(t.i32(0))));let a=n.instances;if(a&&a.size>0)for(let o=Map_values(a),u=0,c=o.length;u<c;++u){let f=unchecked(o[u]);s.push(t.if(t.call(i.internalName,[t.local_get(0,r),t.i32(f.id)],A.I32),t.return(t.i32(1))))}s.push(t.return(t.i32(0))),t.addFunction(`${n.internalName}~instanceof`,r,A.I32,null,t.flatten(s))}var $t=0;function Se(e){let n=e.compiler,t=e.operands,r=e.typeArguments;if($t=0,t.length==0)return!r||r.length!=1?(n.error(2558,e.reportNode.typeArgumentsRange,"1",r?r.length.toString():"0"),null):r[0];if(t.length==1){if(r&&r.length>0){if(r.length>1)return n.error(2558,e.reportNode.typeArgumentsRange,"1",r.length.toString()),null;$t=n.compileExpression(t[0],r[0],1)}else $t=n.compileExpression(t[0],l.auto);return n.currentType}return r&&r.length>1&&n.error(2558,e.reportNode.typeArgumentsRange,"1",r.length.toString()),n.error(2554,e.reportNode.argumentsRange,"1",t.length.toString()),null}function Ee(e,n){let t=e.compiler.module;return $t&&as($t,t.ref)&&(n=t.block(null,[t.maybeDrop($t),n],se(n))),n}function Ze(e,n){let t=n.module,r;if(n.options.isWasm64){let i=n.compileExpression(e,l.usize64,1),s=t.runExpression(i,1);s?(assert(Pe(s)==0),r=Be(s)):(n.error(220,e.range),r=-1)}else{let i=n.compileExpression(e,l.usize32,1),s=t.runExpression(i,1);s?r=Y(s):(n.error(220,e.range),r=-1)}return r}function wn(e,n,t){let r=Ze(e,t);return r<0?r:r<1||n>16?(t.error(222,e.range,"Alignment","1",n.toString()),-1):nr(r)?r:(t.error(223,e.range,"Alignment"),-1)}function R(e,n){let t=e.compiler;return t.options.hasFeature(n)?0:(t.error(103,e.reportNode.range,Oi(n)),1)}function U(e,n=!1){let t=e.compiler,r=e.typeArguments;if(r){let i=r.length;if(i==1)return 0;assert(i),n&&(t.currentType=r[0]),t.error(2558,e.reportNode.typeArgumentsRange,"1",i.toString())}else t.error(2558,e.reportNode.range,"1","0");return 1}function re(e,n=!1){let t=e.typeArguments;if(t){let r=e.compiler,i=t.length;return i==1?0:(assert(i),n&&(r.currentType=t[0]),r.error(2558,e.reportNode.typeArgumentsRange,"1",i.toString()),1)}return 0}function _(e){if(e.typeArguments){let n=e.prototype;return n.program.error(2315,e.reportNode.typeArgumentsRange,n.internalName),1}return 0}function z(e,n){let t=e.operands;return t.length!=n?(e.compiler.error(2554,e.reportNode.range,n.toString(),t.length.toString()),1):0}function ve(e,n,t){let r=e.operands.length;return r<n?(e.compiler.error(2555,e.reportNode.range,n.toString(),r.toString()),1):r>t?(e.compiler.error(2554,e.reportNode.range,t.toString(),r.toString()),1):0}function wi(e,n,t){let r=e.module;if(t!=l.auto&&t.isIntegerValue)switch(t.kind){case 3:{if(i64_is_i32(n))return e.currentType=l.i32,r.i32(i64_low(n));break}case 8:{if(i64_is_u32(n))return e.currentType=l.u32,r.i32(i64_low(n));break}case 4:case 9:return e.currentType=t,r.i64(i64_low(n),i64_high(n))}return e.options.isWasm64?(e.currentType=l.usize64,r.i64(i64_low(n),i64_high(n))):(e.currentType=l.usize32,assert(!i64_high(n)),r.i32(i64_low(n)))}var jF=class{constructor(){this.stack=new Array,this._currentExpression=0}get currentExpression(){let e=this._currentExpression;if(!e)throw new Error("not walking expressions");return e}get parentExpressionOrNull(){let e=this.stack,n=e.length;return n?e[n-1]:0}visitBlock(e){}visitIf(e){}visitLoop(e){}visitBreak(e){}visitSwitch(e){}visitCallPre(e){}visitCall(e){}visitCallIndirectPre(e){}visitCallIndirect(e){}visitLocalGet(e){}visitLocalSet(e){}visitGlobalGet(e){}visitGlobalSet(e){}visitLoad(e){}visitStore(e){}visitConst(e){}visitUnary(e){}visitBinary(e){}visitSelect(e){}visitDrop(e){}visitReturn(e){}visitMemorySize(e){}visitMemoryGrow(e){}visitNop(e){}visitUnreachable(e){}visitAtomicRMW(e){}visitAtomicCmpxchg(e){}visitAtomicWait(e){}visitAtomicNotify(e){}visitAtomicFence(e){}visitSIMDExtract(e){}visitSIMDReplace(e){}visitSIMDShuffle(e){}visitSIMDTernary(e){}visitSIMDShift(e){}visitSIMDLoad(e){}visitSIMDLoadStoreLane(e){}visitMemoryInit(e){}visitDataDrop(e){}visitMemoryCopy(e){}visitMemoryFill(e){}visitPop(e){}visitRefNull(e){}visitRefIs(e){}visitRefFunc(e){}visitRefEq(e){}visitTry(e){}visitThrow(e){}visitRethrow(e){}visitTupleMake(e){}visitTupleExtract(e){}visitI31New(e){}visitI31Get(e){}visitCallRef(e){}visitRefTest(e){}visitRefCast(e){}visitBrOn(e){}visitStructNew(e){}visitStructGet(e){}visitStructSet(e){}visitArrayNew(e){}visitArrayInit(e){}visitArrayGet(e){}visitArraySet(e){}visitArrayLen(e){}visitArrayCopy(e){}visitRefAs(e){}visitStringNew(e){}visitStringConst(e){}visitStringMeasure(e){}visitStringEncode(e){}visitStringConcat(e){}visitStringEq(e){}visitStringAs(e){}visitStringWTF8Advance(e){}visitStringWTF16Get(e){}visitStringIterNext(e){}visitStringIterMove(e){}visitStringSliceWTF(e){}visitStringSliceIter(e){}visitName(e){}visitLabel(e){}visitIndex(e){}visitTag(e){}visit(e){let n=this._currentExpression;switch(this._currentExpression=assert(e),gt(e)){case 1:{this.stack.push(e);let t=Zs(e);t&&this.visitLabel(t);for(let r=0,i=Ii(e);r<i;++r)this.visit(ki(e,r));assert(this.stack.pop()==e),this.visitBlock(e);break}case 2:{this.stack.push(e),this.visit(Js(e)),this.visit(Qs(e));let t=ea(e);t&&this.visit(t),assert(this.stack.pop()==e),this.visitIf(e);break}case 3:{this.stack.push(e);let t=Qc(e);t&&this.visitLabel(t),this.visit(na(e)),assert(this.stack.pop()==e),this.visitLoop(e);break}case 4:{this.stack.push(e),this.visitLabel(e0(e));let t=Bi(e);t&&this.visit(t);let r=n0(e);r&&this.visit(r),assert(this.stack.pop()==e),this.visitBreak(e);break}case 5:{this.stack.push(e);let t=wd(e);t&&this.visitLabel(t);let r=Sd(e);for(let s=0;s<r;++s)this.visitLabel(Cd(e,s));this.visit(t0(e));let i=r0(e);i&&this.visit(i),assert(this.stack.pop()==e),this.visitSwitch(e);break}case 6:{this.visitCallPre(e),this.stack.push(e),this.visitName(ta(e));let t=Br(e);for(let r=0;r<t;++r)this.visit(zr(e,r));assert(this.stack.pop()==e),this.visitCall(e);break}case 7:{this.visitCallIndirectPre(e),this.stack.push(e),this.visit(s0(e));for(let t=0,r=ra(e);t<r;++t)this.visit(ia(e,t));assert(this.stack.pop()==e),this.visitCallIndirect(e);break}case 8:{this.stack.push(e),this.visitIndex(o0(e)),assert(this.stack.pop()==e),this.visitLocalGet(e);break}case 9:{this.stack.push(e),this.visitIndex(sa(e)),this.visit(zi(e)),assert(this.stack.pop()==e),this.visitLocalSet(e);break}case 10:{this.stack.push(e),this.visitName(c0(e)),assert(this.stack.pop()==e),this.visitGlobalGet(e);break}case 11:{this.stack.push(e),this.visitName(Vd(e)),this.visit(f0(e)),assert(this.stack.pop()==e),this.visitGlobalSet(e);break}case 12:{this.stack.push(e),this.visit(oa(e)),assert(this.stack.pop()==e),this.visitLoad(e);break}case 13:{this.stack.push(e),this.visit(Ni(e)),this.visit(la(e)),assert(this.stack.pop()==e),this.visitStore(e);break}case 14:{this.visitConst(e);break}case 15:{this.stack.push(e),this.visit(ua(e)),assert(this.stack.pop()==e),this.visitUnary(e);break}case 16:{this.stack.push(e),this.visit(ca(e)),this.visit(fa(e)),assert(this.stack.pop()==e),this.visitBinary(e);break}case 17:{this.stack.push(e),this.visit(pa(e)),this.visit(ha(e)),this.visit(da(e)),assert(this.stack.pop()==e),this.visitSelect(e);break}case 18:{this.stack.push(e),this.visit(xa(e)),assert(this.stack.pop()==e),this.visitDrop(e);break}case 19:{let t=Li(e);t&&(this.stack.push(e),this.visit(t),assert(this.stack.pop()==e)),this.visitReturn(e);break}case 20:{this.visitMemorySize(e);break}case 21:{this.stack.push(e),this.visit(aa(e)),assert(this.stack.pop()==e),this.visitMemoryGrow(e);break}case 22:{this.visitNop(e);break}case 23:{this.visitUnreachable(e);break}case 24:{this.stack.push(e),this.visit(g0(e)),this.visit(m0(e)),assert(this.stack.pop()==e),this.visitAtomicRMW(e);break}case 25:{this.stack.push(e),this.visit(y0(e)),this.visit(_0(e)),this.visit(b0(e)),assert(this.stack.pop()==e),this.visitAtomicCmpxchg(e);break}case 26:{this.stack.push(e),this.visit(v0(e)),this.visit(E0(e)),this.visit(F0(e)),assert(this.stack.pop()==e),this.visitAtomicWait(e);break}case 27:{this.stack.push(e),this.visit(A0(e)),this.visit(T0(e)),assert(this.stack.pop()==e),this.visitAtomicNotify(e);break}case 28:{this.visitAtomicFence(e);break}case 29:{this.stack.push(e),this.visit(S0(e)),assert(this.stack.pop()==e),this.visitSIMDExtract(e);break}case 30:{this.stack.push(e),this.visit(C0(e)),this.visit(w0(e)),assert(this.stack.pop()==e),this.visitSIMDReplace(e);break}case 31:{this.stack.push(e),this.visit(I0(e)),this.visit(k0(e)),assert(this.stack.pop()==e),this.visitSIMDShuffle(e);break}case 32:{this.stack.push(e),this.visit(B0(e)),this.visit(z0(e)),this.visit(N0(e)),assert(this.stack.pop()==e),this.visitSIMDTernary(e);break}case 33:{this.stack.push(e),this.visit(L0(e)),this.visit(D0(e)),assert(this.stack.pop()==e),this.visitSIMDShift(e);break}case 34:{this.stack.push(e),this.visit(O0(e)),assert(this.stack.pop()==e),this.visitSIMDLoad(e);break}case 35:{this.stack.push(e),this.visit(R0(e)),this.visit(M0(e)),assert(this.stack.pop()==e),this.visitSIMDLoadStoreLane(e);break}case 36:{this.stack.push(e),this.visit(U0(e)),this.visit(P0(e)),this.visit(V0(e)),assert(this.stack.pop()==e),this.visitMemoryInit(e);break}case 37:{this.visitDataDrop(e);break}case 38:{this.stack.push(e),this.visit(G0(e)),this.visit(q0(e)),this.visit(j0(e)),assert(this.stack.pop()==e),this.visitMemoryCopy(e);break}case 39:{this.stack.push(e),this.visit(W0(e)),this.visit(H0(e)),this.visit(X0(e)),assert(this.stack.pop()==e),this.visitMemoryFill(e);break}case 40:{this.visitPop(e);break}case 41:{this.visitRefNull(e);break}case 42:{this.stack.push(e),this.visit(K0(e)),assert(this.stack.pop()==e),this.visitRefIs(e);break}case 43:{this.stack.push(e),this.visitName(yg(e)),assert(this.stack.pop()==e),this.visitRefFunc(e);break}case 44:{this.stack.push(e),this.visit(Y0(e)),this.visit(Z0(e)),assert(this.stack.pop()==e),this.visitRefEq(e);break}case 49:{this.stack.push(e),this.visit(J0(e));let t=Q0(e);for(let r=0;r<t;++r)this.visit(ef(e,r));assert(this.stack.pop()==e),this.visitTry(e);break}case 50:{this.stack.push(e),this.visitTag(kg(e));let t=nf(e);for(let r=0;r<t;++r)this.visit(tf(e,r));assert(this.stack.pop()==e),this.visitThrow(e);break}case 51:{this.visitRethrow(e);break}case 52:{let t=rf(e);if(t){this.stack.push(e);for(let r=0;r<t;++r)this.visit(sf(e,r));assert(this.stack.pop()==e)}this.visitTupleMake(e);break}case 53:{this.stack.push(e),this.visit(af(e)),assert(this.stack.pop()==e),this.visitTupleExtract(e);break}case 54:{this.stack.push(e),this.visit(of(e)),assert(this.stack.pop()==e),this.visitI31New(e);break}case 55:{this.stack.push(e),this.visit(lf(e)),assert(this.stack.pop()==e),this.visitI31Get(e);break}case 56:{this.stack.push(e);let t=uf(e);if(t)for(let r=0;r<t;++r)this.visit(cf(e,r));this.visit(ff(e)),assert(this.stack.pop()==e),this.visitCallRef(e);break}case 57:{this.stack.push(e),this.visit(pf(e)),assert(this.stack.pop()==e),this.visitRefTest(e);break}case 58:{this.stack.push(e),this.visit(hf(e)),assert(this.stack.pop()==e),this.visitRefCast(e);break}case 59:{this.stack.push(e),this.visitLabel(Hg(e)),this.visit(df(e)),assert(this.stack.pop()==e),this.visitBrOn(e);break}case 60:{let t=xf(e);if(t){this.stack.push(e);for(let r=0;r<t;++r)this.visit(gf(e,r));assert(this.stack.pop()==e)}this.visitStructNew(e);break}case 61:{this.stack.push(e),this.visit(mf(e)),this.visitIndex($g(e)),assert(this.stack.pop()==e),this.visitStructGet(e);break}case 62:{this.stack.push(e),this.visit(yf(e)),this.visitIndex(Zg(e)),this.visit(_f(e)),assert(this.stack.pop()==e),this.visitStructSet(e);break}case 63:{this.stack.push(e),this.visit(vf(e));let t=bf(e);t&&this.visit(t),assert(this.stack.pop()==e),this.visitArrayNew(e);break}case 64:{let t=Ef(e);if(t){this.stack.push(e);for(let r=0;r<t;++r)this.visit(Ff(e,r));assert(this.stack.pop()==e)}this.visitArrayInit(e);break}case 65:{this.stack.push(e),this.visit(Af(e)),this.visit(Tf(e)),assert(this.stack.pop()==e),this.visitArrayGet(e);break}case 66:{this.stack.push(e),this.visit(Sf(e)),this.visit(Cf(e)),this.visit(wf(e)),assert(this.stack.pop()==e),this.visitArraySet(e);break}case 67:{this.stack.push(e),this.visit(If(e)),assert(this.stack.pop()==e),this.visitArrayLen(e);break}case 68:{this.stack.push(e),this.visit(kf(e)),this.visit(Bf(e)),this.visit(zf(e)),this.visit(Nf(e)),this.visit(Lf(e)),assert(this.stack.pop()==e),this.visitArrayCopy(e);break}case 69:{this.stack.push(e),this.visit($0(e)),assert(this.stack.pop()==e),this.visitRefAs(e);break}case 70:{this.stack.push(e),this.visit(Df(e));let t=Of(e);t&&this.visit(t);let r=Rf(e);r&&this.visit(r);let i=Mf(e);i&&this.visit(i),assert(this.stack.pop()==e),this.visitStringNew(e);break}case 71:{this.stack.push(e),assert(this.stack.pop()==e),this.visitStringConst(e);break}case 72:{this.stack.push(e),this.visit(Uf(e)),assert(this.stack.pop()==e),this.visitStringMeasure(e);break}case 73:{this.stack.push(e),this.visit(Pf(e)),this.visit(Vf(e));let t=Gf(e);t&&this.visit(t),assert(this.stack.pop()==e),this.visitStringEncode(e);break}case 74:{this.stack.push(e),this.visit(qf(e)),this.visit(jf(e)),assert(this.stack.pop()==e),this.visitStringConcat(e);break}case 75:{this.stack.push(e),this.visit(Wf(e)),this.visit(Hf(e)),assert(this.stack.pop()==e),this.visitStringEq(e);break}case 76:{this.stack.push(e),this.visit(Xf(e)),assert(this.stack.pop()==e),this.visitStringAs(e);break}case 77:{this.stack.push(e),this.visit(Kf(e)),this.visit($f(e)),this.visit(Yf(e)),assert(this.stack.pop()==e),this.visitStringWTF8Advance(e);break}case 78:{this.stack.push(e),this.visit(Zf(e)),this.visit(Jf(e)),assert(this.stack.pop()==e),this.visitStringWTF16Get(e);break}case 79:{this.stack.push(e),this.visit(Qf(e)),assert(this.stack.pop()==e),this.visitStringIterNext(e);break}case 80:{this.stack.push(e),this.visit(ep(e)),this.visit(np(e)),assert(this.stack.pop()==e),this.visitStringIterMove(e);break}case 81:{this.stack.push(e),this.visit(tp(e)),this.visit(rp(e)),this.visit(ip(e)),assert(this.stack.pop()==e),this.visitStringSliceWTF(e);break}case 82:{this.stack.push(e),this.visit(sp(e)),this.visit(ap(e)),assert(this.stack.pop()==e),this.visitStringSliceIter(e);break}default:throw new Error("unexpected expression kind")}this._currentExpression=n}},Uu=class extends jF{constructor(e){super(),this.module=e,this._currentFunction=0,this._currentGlobal=0}get currentFunction(){let e=this._currentFunction;if(!e)throw new Error("not walking a function");return e}get currentGlobal(){let e=this._currentGlobal;if(!e)throw new Error("not walking a global");return e}walkModule(){this.walkFunctions(),this.walkGlobals()}walkFunctions(){let e=this.module.ref;for(let n=0,t=V6(e);n<t;++n)this.walkFunction(G6(e,n))}walkFunction(e){let n=Tr(e);n&&(this._currentFunction=e,this.visit(n),this._currentFunction=0)}walkGlobals(){let e=this.module.ref;for(let n=0,t=o3(e);n<t;++n)this.walkGlobal(l3(e,n))}walkGlobal(e){this._currentGlobal=e;let n=hp(e);n&&this.visit(n),this._currentGlobal=0}replaceCurrent(e){let n=this.currentExpression,t=this.currentFunction;if(Tr(t)==n)up(t,e);else{let r=assert(this.parentExpressionOrNull);if(!WF(r,n,e))throw Error("failed to replace expression");hd(r)}}};function WF(e,n,t){switch(gt(e)){case 1:{let r=Ii(e);for(let i=0;i<r;++i){let s=ki(e,i);if(s==n)return xd(e,i,t),s}break}case 2:{let r=Js(e);if(r==n)return md(e,t),r;let i=Qs(e);if(i==n)return yd(e,t),i;let s=ea(e);if(s==n)return _d(e,t),s;break}case 3:{let r=na(e);if(r==n)return vd(e,t),r;break}case 4:{let r=Bi(e);if(r==n)return Fd(e,t),r;let i=n0(e);if(i==n)return Ad(e,t),i;break}case 5:{let r=t0(e);if(r==n)return Id(e,t),r;let i=r0(e);if(i==n)return kd(e,t),i;break}case 6:{let r=Br(e);for(let i=0;i<r;++i){let s=zr(e,i);if(s==n)return i0(e,i,t),s}break}case 7:{let r=s0(e);if(r==n)return Ld(e,t),r;let i=ra(e);for(let s=0;s<i;++s){let a=ia(e,s);if(a==n)return a0(e,s,t),a}break}case 8:break;case 9:{let r=zi(e);if(r==n)return u0(e,t),r;break}case 10:break;case 11:{let r=f0(e);if(r==n)return Gd(e,t),r;break}case 12:{let r=oa(e);if(r==n)return Yd(e,t),r;break}case 13:{let r=Ni(e);if(r==n)return d0(e,t),r;let i=la(e);if(i==n)return Qd(e,t),i;break}case 14:break;case 15:{let r=ua(e);if(r==n)return ux(e,t),r;break}case 16:{let r=ca(e);if(r==n)return px(e,t),r;let i=fa(e);if(i==n)return hx(e,t),i;break}case 17:{let r=pa(e);if(r==n)return xx(e,t),r;let i=ha(e);if(i==n)return gx(e,t),i;let s=da(e);if(s==n)return mx(e,t),s;break}case 18:{let r=xa(e);if(r==n)return yx(e,t),r;break}case 19:{let r=Li(e);if(r==n)return x0(e,t),r;break}case 20:break;case 21:{let r=aa(e);if(r==n)return Wd(e,t),r;break}case 22:break;case 23:break;case 24:{let r=g0(e);if(r==n)return Fx(e,t),r;let i=m0(e);if(i==n)return Ax(e,t),i;break}case 25:{let r=y0(e);if(r==n)return Sx(e,t),r;let i=_0(e);if(i==n)return Cx(e,t),i;let s=b0(e);if(s==n)return wx(e,t),s;break}case 26:{let r=v0(e);if(r==n)return kx(e,t),r;let i=E0(e);if(i==n)return Bx(e,t),i;let s=F0(e);if(s==n)return zx(e,t),s;break}case 27:{let r=A0(e);if(r==n)return Lx(e,t),r;let i=T0(e);if(i==n)return Dx(e,t),i;break}case 28:break;case 29:{let r=S0(e);if(r==n)return Mx(e,t),r;break}case 30:{let r=C0(e);if(r==n)return Px(e,t),r;let i=w0(e);if(i==n)return Vx(e,t),i;break}case 31:{let r=I0(e);if(r==n)return qx(e,t),r;let i=k0(e);if(i==n)return jx(e,t),i;break}case 32:{let r=B0(e);if(r==n)return Hx(e,t),r;let i=z0(e);if(i==n)return Xx(e,t),i;let s=N0(e);if(s==n)return Kx(e,t),s;break}case 33:{let r=L0(e);if(r==n)return Yx(e,t),r;let i=D0(e);if(i==n)return Zx(e,t),i;break}case 34:{let r=O0(e);if(r==n)return Qx(e,t),r;break}case 35:{let r=R0(e);if(r==n)return ng(e,t),r;if(M0(e)==n)return tg(e,t),r;break}case 36:{let r=U0(e);if(r==n)return rg(e,t),r;let i=P0(e);if(i==n)return ig(e,t),i;let s=V0(e);if(s==n)return sg(e,t),s;break}case 37:break;case 38:{let r=G0(e);if(r==n)return og(e,t),r;let i=q0(e);if(i==n)return lg(e,t),i;let s=j0(e);if(s==n)return ug(e,t),s;break}case 39:{let r=W0(e);if(r==n)return fg(e,t),r;let i=H0(e);if(i==n)return pg(e,t),i;let s=X0(e);if(s==n)return hg(e,t),s;break}case 40:break;case 41:break;case 42:{let r=K0(e);if(r==n)return xg(e,t),r;break}case 43:break;case 44:{let r=Y0(e);if(r==n)return bg(e,t),r;let i=Z0(e);if(i==n)return vg(e,t),i;break}case 49:{let r=J0(e);if(r==n)return Cg(e,t),r;let i=Q0(e);for(let s=0;s<i;++s){let a=ef(e,s);if(a==n)return wg(e,s,t),a}break}case 50:{let r=nf(e);for(let i=0;i<r;++i){let s=tf(e,i);if(s==n)return Bg(e,i,t),s}break}case 51:break;case 52:{let r=rf(e);for(let i=0;i<r;++i){let s=sf(e,i);if(s==n)return Lg(e,i,t),s}break}case 53:{let r=af(e);if(r==n)return Og(e,t),r;break}case 54:{let r=of(e);if(r==n)return Ug(e,t),r;break}case 55:{let r=lf(e);if(r==n)return Vg(e,t),r;break}case 56:{let r=uf(e);for(let s=0;s<r;++s){let a=cf(e,s);if(a==n)return Gg(e,s,t),a}let i=ff(e);if(i==n)return qg(e,t),i;break}case 57:{let r=pf(e);if(r==n)return jg(e,t),r;break}case 58:{let r=hf(e);if(r==n)return Wg(e,t),r;break}case 59:{let r=df(e);if(r==n)return Xg(e,t),r;break}case 60:{let r=xf(e);for(let i=0;i<r;++i){let s=gf(e,i);if(s==n)return Kg(e,i,t),s}break}case 61:{let r=mf(e);if(r==n)return Yg(e,t),r;break}case 62:{let r=yf(e);if(r==n)return Jg(e,t),r;let i=_f(e);if(i==n)return Qg(e,t),i;break}case 63:{let r=vf(e);if(r==n)return n6(e,t),r;let i=bf(e);if(i==n)return e6(e,t),i;break}case 64:{let r=Ef(e);for(let i=0;i<r;++i){let s=Ff(e,i);if(s==n)return t6(e,i,t),s}break}case 65:{let r=Af(e);if(r==n)return r6(e,t),r;let i=Tf(e);if(i==n)return i6(e,t),i;break}case 66:{let r=Sf(e);if(r==n)return s6(e,t),r;let i=Cf(e);if(i==n)return a6(e,t),i;let s=wf(e);if(s==n)return o6(e,t),s;break}case 67:{let r=If(e);if(r==n)return l6(e,t),r;break}case 68:{let r=kf(e);if(r==n)return u6(e,t),r;let i=Bf(e);if(i==n)return c6(e,t),i;let s=zf(e);if(s==n)return f6(e,t),s;let a=Nf(e);if(a==n)return p6(e,t),a;let o=Lf(e);if(o==n)return h6(e,t),o;break}case 69:{let r=$0(e);if(r==n)return gg(e,t),r;break}case 70:{let r=Df(e);if(r==n)return d6(e,t),r;let i=Of(e);if(i==n)return x6(e,t),i;let s=Rf(e);if(s==n)return g6(e,t),s;let a=Mf(e);if(a==n)return m6(e,t),a;break}case 71:break;case 72:{let r=Uf(e);if(r==n)return y6(e,t),r;break}case 73:{let r=Pf(e);if(r==n)return _6(e,t),r;let i=Vf(e);if(i==n)return b6(e,t),i;let s=Gf(e);if(s==n)return v6(e,t),s;break}case 74:{let r=qf(e);if(r==n)return E6(e,t),r;let i=jf(e);if(i==n)return F6(e,t),i;break}case 75:{let r=Wf(e);if(r==n)return T6(e,t),r;let i=Hf(e);if(i==n)return S6(e,t),i;break}case 76:{let r=Xf(e);if(r==n)return C6(e,t),r;break}case 77:{let r=Kf(e);if(r==n)return w6(e,t),r;let i=$f(e);if(i==n)return I6(e,t),i;let s=Yf(e);if(s==n)return k6(e,t),s;break}case 78:{let r=Zf(e);if(r==n)return B6(e,t),r;let i=Jf(e);if(i==n)return z6(e,t),i;break}case 79:{let r=Qf(e);if(r==n)return N6(e,t),r;break}case 80:{let r=ep(e);if(r==n)return L6(e,t),r;let i=np(e);if(i==n)return D6(e,t),i;break}case 81:{let r=tp(e);if(r==n)return O6(e,t),r;let i=rp(e);if(i==n)return R6(e,t),i;let s=ip(e);if(s==n)return M6(e,t),s;break}case 82:{let r=sp(e);if(r==n)return U6(e,t),r;let i=ap(e);if(i==n)return P6(e,t),i;break}default:throw new Error("unexpected expression id")}return 0}var HF=class extends Uu{constructor(e){super(e.module),this.seenStores=!1,this.ptrType=e.options.sizeTypeRef}checkRT(){return this.module.readStringCached(ga(this.currentFunction)).startsWith("~lib/rt/")}visitStore(e){let n=this.module,t=Ni(e),r=h0(e),i=p0(e);d0(e,n.call("~onstore",[t,n.i32(r),n.i32(i),n.i32(i32(this.checkRT()))],this.ptrType)),this.seenStores=!0}walkModule(){super.walkModule(),this.seenStores&&this.module.addFunctionImport("~onstore","rtrace","onstore",dn([this.ptrType,A.I32,A.I32,A.I32]),this.ptrType)}};function qc(e,n){return gt(n)==6&&e.readStringCached(ta(n))==h.tostack?(assert(Br(n)==1),zr(n,0)):0}function jc(e,n){switch(gt(n)){case 14:return!Me(n);case 8:case 9:return!1}return!0}var XF=class extends Uu{constructor(e){super(e.module),this.slotMaps=new Map,this.tempMaps=new Map,this.exportMap=new Map,this.hasStackCheckFunction=!1,this.callSlotOffset=0,this.callSlotStack=new Array,this.compiler=e}get options(){return this.compiler.options}get ptrType(){return this.options.sizeTypeRef}get ptrSize(){return this.ptrType==A.I64?8:4}get ptrBinaryAdd(){return this.ptrType==A.I64?25:0}get ptrBinarySub(){return this.ptrType==A.I64?26:1}ptrConst(e){return this.ptrType==A.I64?this.module.i64(e):this.module.i32(e)}noteSlot(e,n){let t;if(this.slotMaps.has(e)){if(t=changetype(this.slotMaps.get(e)),t.has(n))return changetype(t.get(n))}else t=new Map,this.slotMaps.set(e,t);let r=t.size;return t.set(n,r),r}noteExport(e,n){!n.length||this.exportMap.set(e,n)}getSharedTemp(e,n){let t;if(this.tempMaps.has(e)){if(t=changetype(this.tempMaps.get(e)),t.has(n))return changetype(t.get(n))}else t=new Map,this.tempMaps.set(e,t);let r=Oc(e)+t.size;return t.set(n,r),r}makeStackOffset(e){assert(e!=0);let n=this.module,t=n.global_set(h.stack_pointer,n.binary(e>=0?this.ptrBinaryAdd:this.ptrBinarySub,n.global_get(h.stack_pointer,this.ptrType),this.ptrConst(abs(e))));return e>0?t:n.block(null,[t,this.makeStackCheck()],A.None)}makeStackFill(e,n){assert(e>0);let t=this.module;if(this.options.hasFeature(8)&&e>16)n.push(t.memory_fill(t.global_get(h.stack_pointer,this.ptrType),t.i32(0),this.ptrConst(e)));else{let r=e;for(;r>=8;)n.push(t.store(8,t.global_get(h.stack_pointer,this.ptrType),t.i64(0),A.I64,e-r)),r-=8;r&&(assert(r==4),n.push(t.store(4,t.global_get(h.stack_pointer,this.ptrType),t.i32(0),A.I32,e-r)))}}makeStackCheck(){let e=this.module;return this.hasStackCheckFunction||(this.hasStackCheckFunction=!0,e.addFunction("~stack_check",A.None,A.None,null,e.if(e.binary(17,e.global_get(h.stack_pointer,this.ptrType),e.global_get(h.data_end,this.ptrType)),this.compiler.makeStaticAbort(this.compiler.ensureStaticString("stack overflow"),this.compiler.program.nativeSource)))),e.call("~stack_check",null,A.None)}updateCallOperands(e){let n=this.module,t=0;for(let r=0,i=e.length;r<i;++r){let s=e[r],a=qc(n,s);if(!a)continue;if(!jc(n,a)){e[r]=a;continue}let o=this.currentFunction,u=Oc(o),c=this.noteSlot(o,u+this.callSlotOffset+r),f=this.getSharedTemp(o,this.ptrType),p=new Array;p.push(n.local_set(f,a,!1)),p.push(n.store(this.ptrSize,n.global_get(h.stack_pointer,this.ptrType),n.local_get(f,this.ptrType),this.ptrType,c*this.ptrSize)),p.push(n.local_get(f,this.ptrType)),e[r]=n.block(null,p,this.ptrType),++t}return t}visitCallPre(e){let n=Br(e),t=new Array(n);for(let i=0;i<n;++i)t[i]=zr(e,i);let r=this.updateCallOperands(t);for(let i=0,s=t.length;i<s;++i)i0(e,i,t[i]);r&&(this.callSlotOffset+=r),this.callSlotStack.push(r)}visitCall(e){let n=this.callSlotStack.pop();n&&(this.callSlotOffset-=n)}visitCallIndirectPre(e){let n=ra(e),t=new Array(n);for(let i=0;i<n;++i)t[i]=ia(e,i);let r=this.updateCallOperands(t);for(let i=0,s=t.length;i<s;++i)a0(e,i,t[i]);r&&(this.callSlotOffset+=r),this.callSlotStack.push(r)}visitCallIndirect(e){let n=this.callSlotStack.pop();n&&(this.callSlotOffset-=n)}visitLocalSet(e){let n=this.module,t=zi(e),r=qc(n,t);if(!r)return;if(!jc(n,r)){u0(e,r);return}let i=sa(e),s=this.noteSlot(this.currentFunction,i),a=new Array;a.push(n.store(this.ptrSize,n.global_get(h.stack_pointer,this.ptrType),n.local_tee(i,r,!1),this.ptrType,s*this.ptrSize)),l0(e)?(a.push(n.local_get(i,this.ptrType)),this.replaceCurrent(n.flatten(a,this.ptrType))):this.replaceCurrent(n.flatten(a,A.None))}updateFunction(e){let n=ga(e),t=Ms(e),r=Us(e),i=assert(Tr(e)),s=op(e),a=new Array;for(let p=0;p<s;++p)a[p]=lp(e,p);let o=this.tempMaps;if(o.has(e)){let p=changetype(o.get(e));for(let d=Map_keys(p),m=0,g=d.length;m<g;++m)a.push(d[m])}let u=this.module.ref;Rs(u,n);let c=pe(a),f=di(u,n,t,r,c,a.length,i);if(this.options.sourceMap||this.options.debugInfo){let p=this.compiler.program.searchFunctionByRef(f);p&&p.addDebugInfo(this.module,f)}K(c)}updateExport(e,n){let t=this.module,r=t.ref;assert(n3(e)==0);let i=r3(e),s=t.readStringCached(i),a=t3(e),o=xi(r,i),u=Ms(o),c=Bl(u),f=c.length,p=Us(o),d=f,m=new Array,g=assert(n.length),E=g*this.ptrSize,y="export:"+s,b=t.allocStringCached(y);if(xi(r,b)==0){let T=new Array;T.push(this.makeStackOffset(-E));for(let w=0;w<g;++w)T.push(t.store(this.ptrSize,t.global_get(h.stack_pointer,this.ptrType),t.local_get(n[w],this.ptrType),this.ptrType,w*this.ptrSize));let S=new Array(f);for(let w=0;w<f;++w)S[w]=t.local_get(w,c[w]);if(p!=A.None){let w=d++;m.push(p),T.push(t.local_set(w,t.call(s,S,p),!1)),T.push(this.makeStackOffset(+E)),T.push(t.local_get(w,p))}else T.push(t.call(s,S,p)),T.push(this.makeStackOffset(+E));let C=pe(m);di(r,b,u,p,C,m.length,t.block(null,T,p)),K(C)}pp(r,a),cp(r,b,a)}walkModule(){super.walkModule();let e=this.module,n=new KF(this);for(let r=Map_keys(this.slotMaps),i=0,s=r.length;i<s;++i){let a=r[i],o=changetype(this.slotMaps.get(a)).size*this.ptrSize;n.frameSize=o,n.walkFunction(a);let u=new Array;u.push(this.makeStackOffset(-o)),this.makeStackFill(o,u);let c=Tr(a),f=pt(c);if(f==A.Unreachable)u.push(c);else if(f==A.None)u.push(c),u.push(this.makeStackOffset(+o));else{let p=this.getSharedTemp(a,f);u.push(e.local_set(p,c,!1)),u.push(this.makeStackOffset(+o)),u.push(e.local_get(p,f))}up(a,e.flatten(u,f))}for(let r=Map_keys(this.tempMaps),i=0,s=r.length;i<s;++i)this.updateFunction(r[i]);let t=this.exportMap;for(let r=Map_keys(t),i=0,s=r.length;i<s;++i){let a=r[i],o=fp(e.ref,e.allocStringCached(a)),u=changetype(t.get(a));this.updateExport(o,u)}}},KF=class extends Uu{constructor(e){super(e.module),this.frameSize=0,this.parentPass=e}visitReturn(e){assert(this.frameSize);let n=this.module,t=Li(e),r=new Array;if(t){let i=pt(t);if(i==A.Unreachable)return;let s=this.parentPass.getSharedTemp(this.currentFunction,i);r.push(n.local_set(s,t,!1)),r.push(this.parentPass.makeStackOffset(+this.frameSize)),x0(e,n.local_get(s,i))}else r.push(this.parentPass.makeStackOffset(+this.frameSize));r.push(e),this.replaceCurrent(n.flatten(r,A.Unreachable))}},f2=class{constructor(e,n=!1){this.seen=new Map,this.program=e,this.includePrivate=n}walk(){for(let e=Map_values(this.program.filesByName),n=0,t=e.length;n<t;++n){let r=unchecked(e[n]);r.source.sourceKind==1&&this.visitFile(r)}}visitFile(e){let n=e.exports;if(n)for(let r=Map_keys(n),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]),o=assert(n.get(a));this.visitElement(a,o)}let t=e.exportsStar;if(t)for(let r=0,i=t.length;r<i;++r){let s=unchecked(t[r]);this.visitFile(s)}}visitElement(e,n){if(n.is(512)&&!this.includePrivate)return;let t=this.seen;if(!n.is(262144)&&t.has(n)){this.visitAlias(e,n,assert(t.get(n)));return}switch(t.set(n,e),n.kind){case 0:{n.is(8388608)&&this.visitGlobal(e,n);break}case 2:{n.is(8388608)&&this.visitEnum(e,n);break}case 3:break;case 4:{this.visitFunctionInstances(e,n);break}case 6:{this.visitClassInstances(e,n);break}case 11:{let r=n;r.is(8388608)&&this.visitField(e,r);break}case 12:{let r=n.instance;if(!r)break;n=r}case 13:{let r=n,i=r.getterInstance;i&&this.visitFunction(e,i);let s=r.setterInstance;s&&this.visitFunction(e,s);break}case 14:{p2(n)&&this.visitNamespace(e,n);break}case 16:break;default:assert(!1)}}visitFunctionInstances(e,n){let t=n.instances;if(t)for(let r=Map_values(t),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]);a.is(8388608)&&this.visitFunction(e,a)}}visitClassInstances(e,n){let t=n.instances;if(t)for(let r=Map_values(t),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]);a.is(8388608)&&this.visitClass(e,a)}}};function p2(e){let n=e.members;if(n)for(let t=Map_values(n),r=0,i=t.length;r<i;++r){let s=unchecked(t[r]);switch(s.kind){case 4:{let a=s.instances;if(a){for(let o=Map_values(a),u=0,c=o.length;u<c;++u)if(unchecked(o[u]).is(8388608))return!0}break}case 6:{let a=s.instances;if(a){for(let o=Map_values(a),u=0,c=o.length;u<c;++u)if(unchecked(o[u]).is(8388608))return!0}break}default:{if(s.is(8388608)||p2(s))return!0;break}}}return!1}var xs=class extends f2{constructor(e,n,t=!1){super(e,t),this.sb=[],this.indentLevel=0,this.needsLiftBuffer=!1,this.needsLowerBuffer=!1,this.needsLiftString=!1,this.needsLowerString=!1,this.needsLiftArray=!1,this.needsLowerArray=!1,this.needsLiftTypedArray=!1,this.needsLowerTypedArray=!1,this.needsLiftStaticArray=!1,this.needsLowerStaticArray=!1,this.needsLiftInternref=!1,this.needsLowerInternref=!1,this.needsRetain=!1,this.needsRelease=!1,this.needsNotNull=!1,this.deferredLifts=new Set,this.deferredLowers=new Set,this.deferredCode=new Array,this.exports=new Array,this.importMappings=new Map,this.esm=n}static build(e,n=!0){return new xs(e,n).build()}visitGlobal(e,n){let t=this.sb,r=n.type;this.exports.push(e),ut(r,Fn.Export)||(k(t,this.indentLevel),t.push(e),t.push(`: {
`),k(t,++this.indentLevel),t.push("// "),t.push(n.internalName),t.push(": "),t.push(r.toString()),t.push(`
`),k(t,this.indentLevel),t.push(`valueOf() { return this.value; },
`),k(t,this.indentLevel),t.push(`get value() {
`),k(t,++this.indentLevel),t.push("return "),this.makeLiftFromValue("exports."+e+".value",r,t),t.push(`;
`),k(t,--this.indentLevel),t.push("}"),n.is(8)||(t.push(`,
`),k(t,this.indentLevel),t.push(`set value(value) {
`),k(t,++this.indentLevel),t.push("exports."),t.push(e),t.push(".value = "),this.makeLowerToValue("value",r,t),t.push(`;
`),k(t,--this.indentLevel),t.push("}")),t.push(`
`),k(t,--this.indentLevel),t.push(`},
`)),this.visitNamespace(e,n)}visitEnum(e,n){let t=this.sb;this.exports.push(e),k(t,this.indentLevel),t.push(e),t.push(`: (values => (
`),k(t,++this.indentLevel),t.push("// "),t.push(n.internalName),t.push(`
`);let r=n.members;if(r)for(let i=Map_values(r),s=0,a=i.length;s<a;++s){let o=i[s];o.kind==3&&(k(t,this.indentLevel),t.push("values[values."),t.push(o.name),o.is(33554432)?(t.push(" = "),t.push(i64_low(o.constantIntegerValue).toString())):(t.push(' = exports["'),t.push(ke(e+"."+o.name,34)),t.push('"].valueOf()')),t.push('] = "'),t.push(ke(o.name,34)),t.push(`",
`))}k(t,this.indentLevel),t.push(`values
`),k(t,--this.indentLevel),t.push(`))({}),
`),this.visitNamespace(e,n)}makeGlobalImport(e,n,t){let r=this.sb,i=t.type;k(r,this.indentLevel),fn(n)?r.push(n):(r.push('"'),r.push(ke(n,34)),r.push('": '));let s=this.ensureModuleId(e);ut(i,Fn.Import)?(r.push(`(
`),k(r,this.indentLevel+1),r.push("// "),r.push(t.internalName),r.push(": "),r.push(t.type.toString()),r.push(`
`),k(r,this.indentLevel+1),e!="env"&&(r.push("__module"),r.push(s.toString()),r.push(".")),r.push(n),r.push(`
`),k(r,this.indentLevel),r.push(")")):(r.push(`{
`),k(r,++this.indentLevel),r.push("// "),r.push(t.internalName),r.push(": "),r.push(t.type.toString()),r.push(`
`),k(r,this.indentLevel),r.push(`// not supported: cannot lower before instantiate completes
`),k(r,--this.indentLevel),r.push("}")),r.push(`,
`)}makeFunctionImport(e,n,t,r=null){let i=this.sb,s=t.signature;if(k(i,this.indentLevel),fn(n)?i.push(n):(i.push('"'),i.push(ke(n,34)),i.push('"')),Os(s,Fn.Import)&&!r)i.push(`: (
`),k(i,this.indentLevel+1),i.push("// "),i.push(t.internalName),i.push(t.signature.toString()),i.push(`
`),k(i,this.indentLevel+1),e!="env"&&(i.push(e),i.push(".")),i.push(n),i.push(`
`),k(i,this.indentLevel),i.push(")");else{i.push("(");let a=s.parameterTypes,o=new Array;for(let f=0,p=a.length;f<p;++f)o.push(t.getParameterName(f));i.push(o.join(", ")),i.push(`) {
`),k(i,++this.indentLevel),i.push("// "),i.push(t.internalName),i.push(t.signature.toString()),i.push(`
`);for(let f=0,p=a.length;f<p;++f){let d=a[f];if(!ut(d,Fn.Export)){let m=t.getParameterName(f);k(i,this.indentLevel),i.push(m),i.push(" = "),this.makeLiftFromValue(m,d,i),i.push(`;
`)}}let u=new Array,c=this.ensureModuleId(e);r?(u.push(`(() => {
`),k(u,1),u.push(`// @external.js
`),Wc(r,1,u),u.push(`
})()`)):(e!="env"&&(u.push("__module"),u.push(c.toString()),u.push(".")),u.push(n),u.push("("),u.push(o.join(", ")),u.push(")")),r=u.join(""),u.length=0,Wc(r,this.indentLevel,u,!0),r=u.join(""),k(i,this.indentLevel),s.returnType!=l.void?(i.push("return "),this.makeLowerToValue(r,s.returnType,i),i.push(`;
`)):(i.push(r),i.push(`;
`)),k(i,--this.indentLevel),i.push("}")}i.push(`,
`)}visitFunction(e,n){if(n.is(512))return;let t=this.sb,r=n.signature;if(this.exports.push(e),!Os(r,Fn.Export)){k(t,this.indentLevel),t.push(e),t.push("(");let i=r.parameterTypes,s=0;for(let u=0,c=i.length;u<c;++u)i[u].isInternalReference&&s++,u>0&&t.push(", "),t.push(n.getParameterName(u));t.push(`) {
`),k(t,++this.indentLevel),t.push("// "),t.push(n.internalName),t.push(r.toString()),t.push(`
`);let a=new Array;for(let u=0,c=i.length;u<c;++u){let f=i[u];if(!ut(f,Fn.Import)){let p=n.getParameterName(u);k(t,this.indentLevel),t.push(p),t.push(" = ");let d=f.isInternalReference&&--s>0;d&&(this.needsRetain=!0,this.needsRelease=!0,t.push("__retain("),a.push(p)),this.makeLowerToValue(p,f,t),d&&t.push(")"),t.push(`;
`)}}a.length&&(k(t,this.indentLevel++),t.push(`try {
`)),r.requiredParameters<i.length&&(k(t,this.indentLevel),t.push(`exports.__setArgumentsLength(arguments.length);
`));let o=new Array;o.push("exports."),o.push(e),o.push("(");for(let u=0,c=i.length;u<c;++u)u>0&&o.push(", "),o.push(n.getParameterName(u));if(o.push(")"),r.returnType!=l.void?(k(t,this.indentLevel),t.push("return "),this.makeLiftFromValue(o.join(""),r.returnType,t)):(k(t,this.indentLevel),t.push(o.join(""))),t.push(`;
`),a.length){k(t,this.indentLevel-1),t.push(`} finally {
`);for(let u=0,c=a.length;u<c;++u)k(t,this.indentLevel),t.push("__release("),t.push(a[u]),t.push(`);
`);k(t,--this.indentLevel),t.push(`}
`)}k(t,--this.indentLevel),t.push(`},
`)}this.visitNamespace(e,n)}visitClass(e,n){}visitInterface(e,n){this.visitClass(e,n)}visitField(e,n){}visitNamespace(e,n){}visitAlias(e,n,t){}getExternalCode(e){let n=qn(10,e.decoratorNodes);if(n){let t=n.args;if(t&&t.length==1){let r=t[0];if(r.kind==16){let i=r;if(i.literalKind==2)return i.value;if(i.literalKind==3){let s=i.parts;if(s.length==1)return s[0]}}}}return null}build(){let e=this.exports,n=this.program.moduleImports,t=this.program,r=t.options,i=this.sb;i.push(""),k(i,this.indentLevel++),this.esm||i.push("export "),i.push(`async function instantiate(module, imports = {}) {
`);let s=i.push("")-1;k(i,this.indentLevel++),i.push(`const adaptedImports = {
`);let a=i.length;for(let m=Map_keys(n),g=0,E=m.length;g<E;++g){let y=m[g],b=this.ensureModuleId(y),T=n.get(y);k(i,this.indentLevel),fn(y)?i.push(y):(i.push('"'),i.push(ke(y,34)),i.push('"'));let S=i.length;i.push(": Object.assign(Object.create("),y=="env"?i.push("globalThis"):(i.push("__module"),i.push(b.toString())),i.push("), "),y=="env"&&i.push("imports.env || {}, "),i.push(`{
`),++this.indentLevel;let C=0;for(let w=Map_keys(T),B=0,D=w.length;B<D;++B){let W=w[B],P=assert(T.get(W));if(P.kind==5){let j=P,ce=this.getExternalCode(j);(!Os(j.signature,Fn.Import)||!fn(W)||ce)&&(this.makeFunctionImport(y,W,P,ce),++C)}else if(P.kind==0){let j=P;(!ut(j.type,Fn.Import)||!fn(W))&&(this.makeGlobalImport(y,W,j),++C)}}--this.indentLevel,C?(k(i,this.indentLevel),i.push(`}),
`)):(i.length=S,y=="env"?i.push(": Object.assign(Object.create(globalThis), imports.env || {})"):(i.push(": __module"),i.push(b.toString())),i.push(`,
`))}--this.indentLevel;let o=i.length>a;o?(k(i,this.indentLevel),i.push(`};
`)):i.length=a-2;let u=this.importMappings,c=new Array;for(let m=Map_keys(u),g=0,E=m.length;g<E;++g){let y=m[g];if(y=="env")c.push(`  const env = imports.env;
`);else{let b=u.get(y);c.push("  const __module"),c.push(b.toString()),c.push(" = imports"),fn(y)?(c.push("."),c.push(y)):(c.push('["'),c.push(ke(y,34)),c.push('"]')),c.push(`;
`)}}i[s]=c.join(""),k(i,this.indentLevel),i.push("const { exports } = await WebAssembly.instantiate(module"),o?i.push(`, adaptedImports);
`):i.push(`, imports);
`),k(i,this.indentLevel),i.push(`const memory = exports.memory || imports.env.memory;
`),k(i,this.indentLevel++),i.push(`const adaptedExports = Object.setPrototypeOf({
`),a=i.length,this.walk(),--this.indentLevel;let f=i.length>a;f?(k(i,this.indentLevel),i.push(`}, exports);
`)):this.needsLiftBuffer||this.needsLowerBuffer||this.needsLiftString||this.needsLowerString||this.needsLiftArray||this.needsLowerArray||this.needsLiftTypedArray||this.needsLowerTypedArray||this.needsLiftStaticArray?i.length=a-2:i.length=a-4;let p=this.deferredCode;if(p.length)for(let m=0,g=p.length;m<g;++m)i.push(p[m]);if(this.needsLiftBuffer){let m=t.OBJECTInstance,g=m.offsetof("rtSize")-m.nextMemoryOffset;i.push(`  function __liftBuffer(pointer) {
    if (!pointer) return null;
    return memory.buffer.slice(pointer, pointer + new Uint32Array(memory.buffer)[pointer - ${-g} >>> 2]);
  }
`)}if(this.needsLowerBuffer){let m=t.arrayBufferInstance.id;i.push(`  function __lowerBuffer(value) {
    if (value == null) return 0;
    const pointer = exports.__new(value.byteLength, ${m}) >>> 0;
    new Uint8Array(memory.buffer).set(new Uint8Array(value), pointer);
    return pointer;
  }
`)}if(this.needsLiftString){let m=t.OBJECTInstance,g=m.offsetof("rtSize")-m.nextMemoryOffset,E=1024;i.push(`  function __liftString(pointer) {
    if (!pointer) return null;
    const
      end = pointer + new Uint32Array(memory.buffer)[pointer - ${-g} >>> 2] >>> 1,
      memoryU16 = new Uint16Array(memory.buffer);
    let
      start = pointer >>> 1,
      string = "";
    while (end - start > ${E}) string += String.fromCharCode(...memoryU16.subarray(start, start += ${E}));
    return string + String.fromCharCode(...memoryU16.subarray(start, end));
  }
`)}if(this.needsLowerString){let m=t.stringInstance.id;i.push(`  function __lowerString(value) {
    if (value == null) return 0;
    const
      length = value.length,
      pointer = exports.__new(length << 1, ${m}) >>> 0,
      memoryU16 = new Uint16Array(memory.buffer);
    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);
    return pointer;
  }
`)}if(this.needsLiftArray){let m=t.arrayBufferViewInstance.offsetof("dataStart"),g=t.arrayBufferViewInstance.nextMemoryOffset;i.push(`  function __liftArray(liftElement, align, pointer) {
    if (!pointer) return null;
    const
      memoryU32 = new Uint32Array(memory.buffer),
      dataStart = memoryU32[pointer + ${m} >>> 2],
      length = memoryU32[pointer + ${g} >>> 2],
      values = new Array(length);
    for (let i = 0; i < length; ++i) values[i] = liftElement(dataStart + (i << align >>> 0));
    return values;
  }
`)}if(this.needsLowerArray){let m=t.arrayBufferInstance.id,g=t.arrayBufferViewInstance,E=g.nextMemoryOffset+4,y=g.offsetof("buffer"),b=g.offsetof("dataStart"),T=g.offsetof("byteLength"),S=T+4;i.push(`  function __lowerArray(lowerElement, id, align, values) {
    if (values == null) return 0;
    const
      length = values.length,
      buffer = exports.__pin(exports.__new(length << align, ${m})) >>> 0,
      header = exports.__pin(exports.__new(${E}, id)) >>> 0,
      memoryU32 = new Uint32Array(memory.buffer);
    memoryU32[header + ${y} >>> 2] = buffer;
    memoryU32[header + ${b} >>> 2] = buffer;
    memoryU32[header + ${T} >>> 2] = length << align;
    memoryU32[header + ${S} >>> 2] = length;
    for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);
    exports.__unpin(buffer);
    exports.__unpin(header);
    return header;
  }
`)}if(this.needsLiftTypedArray){let m=t.arrayBufferViewInstance,g=m.offsetof("dataStart"),E=m.offsetof("byteLength");i.push(`  function __liftTypedArray(constructor, pointer) {
    if (!pointer) return null;
    const memoryU32 = new Uint32Array(memory.buffer);
    return new constructor(
      memory.buffer,
      memoryU32[pointer + ${g} >>> 2],
      memoryU32[pointer + ${E} >>> 2] / constructor.BYTES_PER_ELEMENT
    ).slice();
  }
`)}if(this.needsLowerTypedArray){let m=t.arrayBufferInstance.id,g=t.arrayBufferViewInstance,E=g.nextMemoryOffset,y=g.offsetof("buffer"),b=g.offsetof("dataStart"),T=g.offsetof("byteLength");i.push(`  function __lowerTypedArray(constructor, id, align, values) {
    if (values == null) return 0;
    const
      length = values.length,
      buffer = exports.__pin(exports.__new(length << align, ${m})) >>> 0,
      header = exports.__new(${E}, id) >>> 0,
      memoryU32 = new Uint32Array(memory.buffer);
    memoryU32[header + ${y} >>> 2] = buffer;
    memoryU32[header + ${b} >>> 2] = buffer;
    memoryU32[header + ${T} >>> 2] = length << align;
    new constructor(memory.buffer, buffer, length).set(values);
    exports.__unpin(buffer);
    return header;
  }
`)}if(this.needsLiftStaticArray){let m=t.OBJECTInstance,g=m.offsetof("rtSize")-m.nextMemoryOffset;i.push(`  function __liftStaticArray(liftElement, align, pointer) {
    if (!pointer) return null;
    const
      length = new Uint32Array(memory.buffer)[pointer - ${-g} >>> 2] >>> align,
      values = new Array(length);
    for (let i = 0; i < length; ++i) values[i] = liftElement(pointer + (i << align >>> 0));
    return values;
  }
`)}this.needsLowerStaticArray&&i.push(`  function __lowerStaticArray(lowerElement, id, align, values, typedConstructor) {
    if (values == null) return 0;
    const
      length = values.length,
      buffer = exports.__pin(exports.__new(length << align, id)) >>> 0;
    if (typedConstructor) {
      new typedConstructor(memory.buffer, buffer, length).set(values);
    } else {
      for (let i = 0; i < length; i++) lowerElement(buffer + (i << align >>> 0), values[i]);
    }
    exports.__unpin(buffer);
    return buffer;
  }
`),(this.needsLiftInternref||this.needsLowerInternref)&&i.push(`  class Internref extends Number {}
`),this.needsLiftInternref&&(this.needsRetain=!0,this.needsRelease=!0,i.push(`  const registry = new FinalizationRegistry(__release);
  function __liftInternref(pointer) {
    if (!pointer) return null;
    const sentinel = new Internref(__retain(pointer));
    registry.register(sentinel, pointer);
    return sentinel;
  }
`)),this.needsLowerInternref&&i.push(`  function __lowerInternref(value) {
    if (value == null) return 0;
    if (value instanceof Internref) return value.valueOf();
    throw TypeError("internref expected");
  }
`),(this.needsRetain||this.needsRelease)&&i.push(`  const refcounts = new Map();
`),this.needsRetain&&i.push(`  function __retain(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount) refcounts.set(pointer, refcount + 1);
      else refcounts.set(exports.__pin(pointer), 1);
    }
    return pointer;
  }
`),this.needsRelease&&i.push(`  function __release(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);
      else if (refcount) refcounts.set(pointer, refcount - 1);
      else throw Error(\`invalid refcount '\${refcount}' for reference '\${pointer}'\`);
    }
  }
`),this.needsNotNull&&i.push(`  function __notnull() {
    throw TypeError("value must not be null");
  }
`);let d=r.exportStart;if(d&&i.push(`  exports.${d}();
`),f?i.push(`  return adaptedExports;
}
`):i.push(`  return exports;
}
`),--this.indentLevel,assert(this.indentLevel==0),this.esm){i.push(`export const {
  `),this.program.options.exportMemory&&i.push(`memory,
  `),this.program.options.exportTable&&i.push(`table,
  `);for(let E=0,y=e.length;E<y;++E)E>0&&i.push(`,
  `),i.push(e[E]);i.push(`
} = await (async url => instantiate(
  await (async () => {
    try { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }
    catch { return globalThis.WebAssembly.compile(await (await import("node:fs/promises")).readFile(url)); }
  })(), {
`);let m=!1,g=new Array;for(let E=Map_keys(u),y=0,b=E.length;y<b;++y){let T=E[y];if(T=="env")k(i,2),i.push(`env: globalThis,
`);else{let S=this.ensureModuleId(T);k(i,2),fn(T)?i.push(T):(i.push('"'),i.push(ke(T,34)),i.push('"')),i.push(": __maybeDefault(__import"),i.push(S.toString()),i.push(`),
`),g.push("import * as __import"),g.push(S.toString()),g.push(' from "'),g.push(ke(T,34)),g.push(`";
`),m=!0}}i[0]=g.join(""),i.push(`  }
))(new URL("${ke(r.basenameHint,34)}.wasm", import.meta.url));
`),m&&i.push(`function __maybeDefault(module) {
  return typeof module.default === "object" && Object.keys(module).length == 1
    ? module.default
    : module;
}
`)}return i.join("")}ensureModuleId(e){if(e=="env")return-1;let n=this.importMappings,t=n.has(e)?i32(n.get(e)):n.size;return n.set(e,t),t}makeLiftFromValue(e,n,t=this.sb){if(n.isInternalReference){let r=assert(n.getClassOrWrapper(this.program));if(r.extends(this.program.arrayBufferInstance.prototype))t.push("__liftBuffer("),this.needsLiftBuffer=!0;else if(r.extends(this.program.stringInstance.prototype))t.push("__liftString("),this.needsLiftString=!0;else if(r.extends(this.program.arrayPrototype)){let i=r.getArrayValueType();t.push("__liftArray("),this.makeLiftFromMemory(i,t),t.push(", "),t.push(i.alignLog2.toString()),t.push(", "),this.needsLiftArray=!0}else if(r.extends(this.program.staticArrayPrototype)){let i=r.getArrayValueType();t.push("__liftStaticArray("),this.makeLiftFromMemory(i,t),t.push(", "),t.push(i.alignLog2.toString()),t.push(", "),this.needsLiftStaticArray=!0}else if(r.extends(this.program.arrayBufferViewInstance.prototype))t.push("__liftTypedArray("),r.name=="Uint64Array"?t.push("BigUint64Array"):r.name=="Int64Array"?t.push("BigInt64Array"):t.push(r.name),t.push(", "),this.needsLiftTypedArray=!0;else if(mr(r)){if(t.push("__liftRecord"),t.push(r.id.toString()),t.push("("),!this.deferredLifts.has(r)){this.deferredLifts.add(r);let i=this.indentLevel;this.indentLevel=1,this.deferredCode.push(this.makeLiftRecord(r)),this.indentLevel=i}}else t.push("__liftInternref("),this.needsLiftInternref=!0;t.push(e),e.startsWith("new Uint32Array(")||t.push(" >>> 0"),t.push(")")}else n==l.bool?t.push(`${e} != 0`):n.isUnsignedIntegerValue&&n.size>=32?t.push(n.size==64?`BigInt.asUintN(64, ${e})`:`${e} >>> 0`):t.push(e)}makeLowerToValue(e,n,t=this.sb){if(n.isInternalReference){let r=assert(n.getClassOrWrapper(this.program));if(r.extends(this.program.arrayBufferInstance.prototype))t.push("__lowerBuffer("),this.needsLowerBuffer=!0;else if(r.extends(this.program.stringInstance.prototype))t.push("__lowerString("),this.needsLowerString=!0;else if(r.extends(this.program.arrayPrototype)){let i=r.getArrayValueType();t.push("__lowerArray("),this.makeLowerToMemory(i,t),t.push(", "),t.push(r.id.toString()),t.push(", "),t.push(r.getArrayValueType().alignLog2.toString()),t.push(", "),this.needsLowerArray=!0}else if(r.extends(this.program.staticArrayPrototype)){let i=r.getArrayValueType();t.push("__lowerStaticArray("),this.makeLowerToMemory(i,t),t.push(", "),t.push(r.id.toString()),t.push(", "),t.push(i.alignLog2.toString()),t.push(", "),this.needsLowerStaticArray=!0}else if(r.extends(this.program.arrayBufferViewInstance.prototype)){let i=r.getArrayValueType();t.push("__lowerTypedArray("),i==l.u64?t.push("BigUint64Array"):i==l.i64?t.push("BigInt64Array"):t.push(r.name),t.push(", "),t.push(r.id.toString()),t.push(", "),t.push(r.getArrayValueType().alignLog2.toString()),t.push(", "),this.needsLowerTypedArray=!0}else if(mr(r)){if(t.push("__lowerRecord"),t.push(r.id.toString()),t.push("("),!this.deferredLowers.has(r)){this.deferredLowers.add(r);let i=this.indentLevel;this.indentLevel=1,this.deferredCode.push(this.makeLowerRecord(r)),this.indentLevel=i}}else t.push("__lowerInternref("),this.needsLowerInternref=!0;if(t.push(e),r.extends(this.program.staticArrayPrototype)){let i=r.getArrayValueType();i.isNumericValue&&(t.push(", "),i==l.u8||i==l.bool?t.push("Uint8Array"):i==l.i8?t.push("Int8Array"):i==l.u16?t.push("Uint16Array"):i==l.i16?t.push("Int16Array"):i==l.u32||i==l.usize32?t.push("Uint32Array"):i==l.i32||i==l.isize32?t.push("Int32Array"):i==l.u64||i==l.usize64?t.push("BigUint64Array"):i==l.i64||i==l.isize64?t.push("BigInt64Array"):i==l.f32?t.push("Float32Array"):i==l.f64?t.push("Float64Array"):assert(!1))}t.push(")"),n.is(512)||(this.needsNotNull=!0,t.push(" || __notnull()"))}else t.push(e),n.isIntegerValue&&n.size==64?t.push(" || 0n"):n==l.bool&&t.push(" ? 1 : 0")}makeLiftFromMemory(e,n=this.sb,t=null){if(t||(n.push("pointer => "),t="pointer"),e.isInternalReference){let r=new Array;r.push("new Uint32Array(memory.buffer)["),r.push(t),r.push(" >>> 2]"),this.makeLiftFromValue(r.join(""),e,n)}else{if(e==l.i8)n.push("new Int8Array(memory.buffer)[");else if(e==l.u8||e==l.bool)n.push("new Uint8Array(memory.buffer)[");else if(e==l.i16)n.push("new Int16Array(memory.buffer)[");else if(e==l.u16)n.push("new Uint16Array(memory.buffer)[");else if(e==l.i32||e==l.isize32)n.push("new Int32Array(memory.buffer)[");else if(e==l.u32||e==l.usize32)n.push("new Uint32Array(memory.buffer)[");else if(e==l.i64||e==l.isize64)n.push("new BigInt64Array(memory.buffer)[");else if(e==l.u64||e==l.usize64)n.push("new BigUint64Array(memory.buffer)[");else if(e==l.f32)n.push("new Float32Array(memory.buffer)[");else if(e==l.f64)n.push("new Float64Array(memory.buffer)[");else{n.push('{ throw Error("unsupported type"); }');return}n.push(t),n.push(" >>> "),n.push(e.alignLog2.toString()),n.push("]"),e==l.bool&&n.push(" != 0")}}makeLowerToMemory(e,n=this.sb,t=null,r=null){let i=!0;if((!t||!r)&&(n.push("(pointer, value) => { "),t="pointer",r="value",i=!1),e.isInternalReference)n.push("new Uint32Array(memory.buffer)[");else if(e==l.i8)n.push("new Int8Array(memory.buffer)[");else if(e==l.u8||e==l.bool)n.push("new Uint8Array(memory.buffer)[");else if(e==l.i16)n.push("new Int16Array(memory.buffer)[");else if(e==l.u16)n.push("new Uint16Array(memory.buffer)[");else if(e==l.i32||e==l.isize32)n.push("new Int32Array(memory.buffer)[");else if(e==l.u32||e==l.usize32)n.push("new Uint32Array(memory.buffer)[");else if(e==l.i64||e==l.isize64)n.push("new BigInt64Array(memory.buffer)[");else if(e==l.u64||e==l.usize64)n.push("new BigUint64Array(memory.buffer)[");else if(e==l.f32)n.push("new Float32Array(memory.buffer)[");else if(e==l.f64)n.push("new Float64Array(memory.buffer)[");else{i?n.push('(() => { throw Error("unsupported type") })()'):n.push('throw Error("unsupported type"); }');return}n.push(t),n.push(" >>> "),n.push(e.alignLog2.toString()),n.push("] = "),this.makeLowerToValue(r,e,n),i||n.push("; }")}makeLiftRecord(e){assert(mr(e));let n=new Array;k(n,this.indentLevel),n.push("function __liftRecord"),n.push(e.id.toString()),n.push(`(pointer) {
`),k(n,++this.indentLevel),n.push("// "),n.push(e.type.toString()),n.push(`
`),k(n,this.indentLevel),n.push(`// Hint: Opt-out from lifting as a record by providing an empty constructor
`),k(n,this.indentLevel),n.push(`if (!pointer) return null;
`),k(n,this.indentLevel++),n.push(`return {
`);let t=e.members;if(t)for(let r=Map_keys(t),i=0,s=r.length;i<s;++i){let a=r[i],o=assert(t.get(a));if(o.kind!=11)continue;let u=o;k(n,this.indentLevel),n.push(u.name),n.push(": "),this.makeLiftFromMemory(u.type,n,"pointer + "+u.memoryOffset.toString()),n.push(`,
`)}return k(n,--this.indentLevel),n.push(`};
`),k(n,--this.indentLevel),n.push(`}
`),n.join("")}makeLowerRecord(e){assert(mr(e));let n=new Array;k(n,this.indentLevel),n.push("function __lowerRecord"),n.push(e.id.toString()),n.push(`(value) {
`),k(n,++this.indentLevel),n.push("// "),n.push(e.type.toString()),n.push(`
`),k(n,this.indentLevel),n.push(`// Hint: Opt-out from lowering as a record by providing an empty constructor
`),k(n,this.indentLevel),n.push(`if (value == null) return 0;
`),k(n,this.indentLevel),n.push("const pointer = exports.__pin(exports.__new("),n.push(e.nextMemoryOffset.toString()),n.push(", "),n.push(e.id.toString()),n.push(`));
`);let t=e.members;if(t)for(let r=Map_keys(t),i=0,s=r.length;i<s;++i){let a=r[i],o=assert(t.get(a));if(o.kind!=11)continue;let u=o;k(n,this.indentLevel),this.makeLowerToMemory(u.type,n,"pointer + "+u.memoryOffset.toString(),"value."+a),n.push(`;
`)}return k(n,this.indentLevel),n.push(`exports.__unpin(pointer);
`),k(n,this.indentLevel),n.push(`return pointer;
`),k(n,--this.indentLevel),n.push(`}
`),n.join("")}},Fn=(e=>(e[e.Import=0]="Import",e[e.Export=1]="Export",e))(Fn||{});function ut(e,n){if(n==0){if(e==l.bool||e.isIntegerValue&&e.size==64)return!1}else if(e==l.bool||e.isUnsignedIntegerValue&&e.size>=32)return!1;return!e.isInternalReference}function Os(e,n){let t=e.parameterTypes,r=n==0?1:0;if(!ut(e.returnType,n))return!1;for(let i=0,s=t.length;i<s;++i)if(!ut(t[i],r))return!1;return!0}function mr(e){if(e.base)return!1;let n=e.members;if(n)for(let t=Map_values(n),r=0,i=t.length;r<i;++r){let s=t[r];if(s.isAny(1536)||s.is(524288)&&s.declaration.range!=s.program.nativeRange)return!1}return!0}function Wc(e,n,t,r=!1){let i=0,s=e.length,a=0;for(;a<s;)e.charCodeAt(a)==10&&(r?r=!1:k(t,n),t.push(e.substring(i,i=a+1))),++a;i<s&&(r||k(t,n),t.push(e.substring(i)))}function yr(e){if(!e.isInternalReference)return!1;let n=e.classReference;if(!n)return assert(e.signatureReference),!0;let t=n.program;return n.extends(t.arrayBufferInstance.prototype)||n.extends(t.stringInstance.prototype)||n.extends(t.arrayBufferViewInstance.prototype)?!1:n.extends(t.arrayPrototype)||n.extends(t.staticArrayPrototype)?yr(n.getArrayValueType()):!0}function gr(e){if(!e.isInternalReference)return!1;let n=e.classReference;if(!n)return assert(e.signatureReference),!1;let t=n.program;return n.extends(t.arrayBufferInstance.prototype)||n.extends(t.stringInstance.prototype)||n.extends(t.arrayBufferViewInstance.prototype)||n.extends(t.arrayPrototype)||n.extends(t.staticArrayPrototype)?!0:mr(n)}var Pu=class{constructor(){this.target=1,this.runtime=2,this.debugInfo=!1,this.noAssert=!1,this.exportMemory=!0,this.importMemory=!1,this.initialMemory=0,this.maximumMemory=0,this.sharedMemory=!1,this.zeroFilledMemory=!1,this.importTable=!1,this.exportTable=!1,this.sourceMap=!1,this.exportStart=null,this.memoryBase=0,this.tableBase=0,this.globalAliases=null,this.features=15,this.noUnsafe=!1,this.pedantic=!1,this.lowMemoryLimit=0,this.exportRuntime=!1,this.stackSize=0,this.bundleMajorVersion=0,this.bundleMinorVersion=0,this.bundlePatchVersion=0,this.optimizeLevelHint=0,this.shrinkLevelHint=0,this.basenameHint="output",this.bindingsHint=!1}get isWasm64(){return this.target==2}get usizeType(){return this.target==2?l.usize64:l.usize32}get isizeType(){return this.target==2?l.isize64:l.isize32}get sizeTypeRef(){return this.target==2?A.I64:A.I32}get willOptimize(){return this.optimizeLevelHint>0||this.shrinkLevelHint>0}hasFeature(e){return(this.features&e)!=0}},Vu=(e=>(e[e.None=0]="None",e[e.ConvImplicit=1]="ConvImplicit",e[e.ConvExplicit=2]="ConvExplicit",e[e.MustWrap=4]="MustWrap",e[e.WillDrop=8]="WillDrop",e[e.PreferStatic=16]="PreferStatic",e[e.IsThis=32]="IsThis",e))(Vu||{}),Gu=(e=>(e[e.None=0]="None",e[e.Data=1]="Data",e[e.Stack=2]="Stack",e[e.Heap=4]="Heap",e[e.Rtti=8]="Rtti",e[e.visitGlobals=16]="visitGlobals",e[e.visitMembers=32]="visitMembers",e[e.setArgumentsLength=64]="setArgumentsLength",e))(Gu||{}),ct;(e=>(e.DefaultNamespace="env",e.Memory="memory",e.Table="table"))(ct||={});var Yt;(e=>(e.Memory="memory",e.Table="table",e.argumentsLength="__argumentsLength",e.setArgumentsLength="__setArgumentsLength"))(Yt||={});var Hc=["__new","__pin","__unpin","__collect"],Xc=["__rtti_base"],gs=class extends mt{constructor(e){super(e.diagnostics),this.currentParent=null,this.currentType=l.void,this.memorySegments=[],this.stringSegments=new Map,this.functionTable=[],this.builtinArgumentsLength=0,this.runtimeFeatures=0,this.inlineStack=[],this.lazyFunctions=new Set,this.pendingClassInstanceOf=new Set,this.virtualStubs=new Set,this.pendingElements=new Set,this.doneModuleExports=new Set,this.hasCustomFunctionExports=!1,this.desiresExportRuntime=!1,this.f32ModInstance=null,this.f64ModInstance=null,this.f32PowInstance=null,this.f64PowInstance=null,this.i32PowInstance=null,this.i64PowInstance=null,this._reusableCallExpression=null,this.program=e;let n=e.options,t=xt.create(n.stackSize>0,n.sizeTypeRef);this.module=t,n.memoryBase?(this.memoryOffset=i64_new(n.memoryBase),t.setLowMemoryUnused(!1)):!n.lowMemoryLimit&&n.optimizeLevelHint>=2?(this.memoryOffset=i64_new(1024),t.setLowMemoryUnused(!0)):(this.memoryOffset=i64_new(8),t.setLowMemoryUnused(!1));let r=0;n.hasFeature(1)&&(r|=32),n.hasFeature(2)&&(r|=2),n.hasFeature(4)&&(r|=4),n.hasFeature(8)&&(r|=16),n.hasFeature(16)&&(r|=8),n.hasFeature(32)&&(r|=1),n.hasFeature(64)&&(r|=64),n.hasFeature(128)&&(r|=128),n.hasFeature(256)&&(r|=256),n.hasFeature(512)&&(r|=512),n.hasFeature(1024)&&(r|=1024),n.hasFeature(2048)&&(r|=2048),n.hasFeature(4096)&&(r|=8192),n.hasFeature(8192)&&(r|=16384),n.hasFeature(16384)&&(r|=32768),t.setFeatures(r);let i=e.makeNativeFunction(h.start,new tn(e,[],l.void));i.internalName=h.start,this.currentFlow=i.flow,this.currentBody=new Array,this.shadowStack=new XF(this)}get resolver(){return this.program.resolver}get options(){return this.program.options}static compile(e){return new gs(e).compile()}compile(){let e=this.options,n=this.module,t=this.program,r=this.resolver,i=e.stackSize>0;this.program.initialize();let s=this.currentFlow.targetFunction;assert(s.internalName==h.start);let a=this.currentBody;assert(a.length==0),e.isWasm64?(n.addGlobal(h.data_end,A.I64,!0,n.i64(0)),n.addGlobal(h.heap_base,A.I64,!0,n.i64(0)),n.addGlobal(h.rtti_base,A.I64,!0,n.i64(0))):(n.addGlobal(h.data_end,A.I32,!0,n.i32(0)),n.addGlobal(h.heap_base,A.I32,!0,n.i32(0)),n.addGlobal(h.rtti_base,A.I32,!0,n.i32(0)));let o=t.filesByName;for(let y=Map_values(o),b=0,T=y.length;b<T;++b){let S=unchecked(y[b]);S.source.sourceKind==1&&(this.compileFile(S),this.compileModuleExports(S))}if(this.options.exportRuntime||this.options.bindingsHint&&this.desiresExportRuntime){for(let y=0,b=Hc.length;y<b;++y){let T=Hc[y],S=t.requireFunction(T);this.compileFunction(S)&&!n.hasExport(T)&&n.addFunctionExport(S.internalName,T)}for(let y=0,b=Xc.length;y<b;++y){let T=Xc[y],S=t.requireGlobal(T);this.compileGlobal(S)&&!n.hasExport(T)&&n.addGlobalExport(S.internalName,T)}}let u=t.requireFunction(v._g);u.is(8388608)||(this.compileFunction(u),n.addFunctionExport(h._g,v._g));let c=this.lazyFunctions;do{let y=new Array;for(let b=Set_values(c),T=0,S=b.length;T<S;++T){let C=unchecked(b[T]);y.push(C)}c.clear();for(let b=0,T=y.length;b<T;++b)this.compileFunction(unchecked(y[b]),!0)}while(c.size);for(let y=Set_values(this.pendingClassInstanceOf),b=0,T=y.length;b<T;++b){let S=unchecked(y[b]);qF(this,S)}let f=this.functionTable,p=this.virtualStubs;for(let y=0,b=f.length;y<b;++y){let T=f[y];T.is(268435456)?(assert(T.is(262144)),f[y]=this.ensureVirtualStub(T)):T.signature.requiredParameters<T.signature.parameterTypes.length&&(f[y]=this.ensureVarargsStub(T))}let d=new Set;do{r.discoveredOverload=!1;for(let y=Set_values(p),b=0,T=y.length;b<T;++b){let S=unchecked(y[b]),C=r.resolveOverloads(S);if(C)for(let w=0,B=C.length;w<B;++w)this.compileFunction(C[w]);d.add(S)}}while(p.size>d.size||r.discoveredOverload);d.clear();for(let y=Set_values(p),b=0,T=y.length;b<T;++b)this.finalizeVirtualStub(y[b]);n.removeGlobal(h.rtti_base),this.runtimeFeatures&8&&GF(this),this.runtimeFeatures&16&&PF(this),this.runtimeFeatures&32&&VF(this);let m=i64_align(this.memoryOffset,e.usizeType.byteSize);n.removeGlobal(h.data_end),((this.runtimeFeatures&1)!=0||i)&&(e.isWasm64?n.addGlobal(h.data_end,A.I64,!1,n.i64(i64_low(m),i64_high(m))):n.addGlobal(h.data_end,A.I32,!1,n.i32(i64_low(m)))),n.removeGlobal(h.stack_pointer),((this.runtimeFeatures&2)!=0||i)&&(m=i64_align(i64_add(m,i64_new(e.stackSize)),e.usizeType.byteSize),e.isWasm64?n.addGlobal(h.stack_pointer,A.I64,!0,n.i64(i64_low(m),i64_high(m))):n.addGlobal(h.stack_pointer,A.I32,!0,n.i32(i64_low(m)))),n.removeGlobal(h.heap_base),((this.runtimeFeatures&4)!=0||i)&&(e.isWasm64?n.addGlobal(h.heap_base,A.I64,!1,n.i64(i64_low(m),i64_high(m))):n.addGlobal(h.heap_base,A.I32,!1,n.i32(i64_low(m)))),this.initDefaultMemory(m),this.initDefaultTable(),this.runtimeFeatures&64&&(n.addFunction(h.setArgumentsLength,A.I32,A.None,null,n.global_set(this.ensureArgumentsLength(),n.local_get(0,A.I32))),n.addFunctionExport(h.setArgumentsLength,Yt.setArgumentsLength));let g=!a.length,E=e.exportStart;if(!g||E!=null){let y=s.signature;!g&&E!=null&&(n.addGlobal(h.started,A.I32,!0,n.i32(0)),a.unshift(n.global_set(h.started,n.i32(1))),a.unshift(n.if(n.global_get(h.started,A.I32),n.return())));let b=n.addFunction(s.internalName,y.paramRefs,y.resultRefs,Kt(s.getNonParameterLocalTypes()),n.flatten(a));s.finalize(n,b),E==null?n.setStart(b):!fn(E)||n.hasExport(E)?this.error(110,this.program.nativeRange,E):n.addFunctionExport(s.internalName,E)}return i&&this.shadowStack.walkModule(),t.lookup("ASC_RTRACE")!=null&&new HF(this).walkModule(),n}initDefaultMemory(e){this.memoryOffset=e;let n=this.options,t=this.module,r=this.memorySegments,i=0,s=xt.UNLIMITED_MEMORY,a=!1;(n.memoryBase||r.length)&&(i=u32(i64_low(i64_shr_u(i64_align(e,65536),i64_new(16))))),n.initialMemory&&(n.initialMemory<i?this.error(105,null,i.toString()):i=n.initialMemory),n.maximumMemory&&(n.maximumMemory<i?this.error(106,null,i.toString()):s=n.maximumMemory),n.sharedMemory&&(a=!0,n.maximumMemory||(this.error(107,null),a=!1),n.hasFeature(32)||(this.error(108,null),a=!1));let o=n.lowMemoryLimit;if(o){let u=i64_new(o&-16);i64_gt(e,u)&&this.error(104,null,i64_to_string(e),i64_to_string(u))}t.setMemory(i,s,r,n.target,n.exportMemory?Yt.Memory:null,v.DefaultMemory,a),n.importMemory&&t.addMemoryImport(v.DefaultMemory,ct.DefaultNamespace,ct.Memory,a)}initDefaultTable(){let e=this.options,n=this.module;e.importTable&&(n.addTableImport(v.DefaultTable,ct.DefaultNamespace,ct.Table),e.pedantic&&e.willOptimize&&this.pedantic(901,null)),e.exportTable&&(n.addTableExport(v.DefaultTable,Yt.Table),e.pedantic&&e.willOptimize&&this.pedantic(902,null));let t=e.tableBase;t||(t=1);let r=this.functionTable,i=new Array(r.length);for(let o=0,u=r.length;o<u;++o)i[o]=r[o].internalName;let s=t+r.length,a=xt.UNLIMITED_TABLE;e.importTable||e.exportTable||(a=s,e.willOptimize&&n.setPassArgument("directize-initial-contents-immutable","true")),n.addFunctionTable(v.DefaultTable,s,a,i,n.i32(t))}compileModuleExports(e){let n=e.exports;if(n)for(let r=Map_keys(n),i=0,s=r.length;i<s;++i){let a=unchecked(r[i]),o=assert(n.get(a));this.compileModuleExport(a,o)}let t=e.exportsStar;if(t)for(let r=0,i=t.length;r<i;++r)this.compileModuleExports(t[r])}compileModuleExport(e,n,t=""){let r=this.module;switch(n.kind){case 4:{let i=n;if(!i.is(65536)){let s=this.resolver.resolveFunction(i,null);s&&this.compileModuleExport(e,s,t);return}break}case 5:{let i=n;if(!i.hasDecorator(512)){let s=i.signature;if(s.requiredParameters<s.parameterTypes.length&&(i=this.ensureVarargsStub(i),this.runtimeFeatures|=64),this.compileFunction(i),i.is(8388608)){let a=t+e;if(!r.hasExport(a)&&(r.addFunctionExport(i.internalName,a),this.hasCustomFunctionExports=!0,s.hasManagedOperands&&this.shadowStack.noteExport(a,s.getManagedOperandIndices()),!this.desiresExportRuntime)){let o=s.thisType;if(o&&gr(o)||yr(s.returnType))this.desiresExportRuntime=!0;else{let u=s.parameterTypes;for(let c=0,f=u.length;c<f;++c)if(gr(u[c])){this.desiresExportRuntime=!0;break}}}return}}break}case 0:{let i=n;if(!(i.is(8)||i.is(96))&&!this.options.hasFeature(2)){this.warning(103,i.identifierNode.range,"mutable-globals");return}if(this.compileGlobal(i),i.is(8388608)){let s=t+e;if(!r.hasExport(s)&&(r.addGlobalExport(n.internalName,s),!this.desiresExportRuntime)){let a=i.type;(yr(a)||!i.is(8)&&gr(a))&&(this.desiresExportRuntime=!0)}i.type==l.v128&&this.warning(112,i.typeNode?assert(i.typeNode).range:i.identifierNode.range,"v128");return}break}case 2:{this.compileEnum(n);let i=n.members;if(i){let s=t+e+Pi;for(let a=Map_keys(i),o=0,u=a.length;o<u;++o){let c=unchecked(a[o]),f=assert(i.get(c));f.is(512)||this.compileModuleExport(c,f,s)}}return}case 3:{let i=n;if(!i.isImmutable&&!this.options.hasFeature(2)){this.error(103,i.identifierNode.range,"mutable-globals");return}if(i.is(8388608)){let s=t+e;r.hasExport(s)||r.addGlobalExport(n.internalName,s);return}break}}this.warning(235,n.identifierNode.range)}compileFileByPath(e,n){let t,r=this.program.filesByName,i;if(r.has(e))t=assert(r.get(e));else if(r.has(i=e+We))t=assert(r.get(i));else{this.error(6054,n.range,e);return}this.compileFile(t)}compileFile(e){if(e.is(8388608))return;e.set(8388608);let n=e.startFunction,t=n.signature,r=this.currentBody,i=new Array;this.currentBody=i;let s=this.currentFlow,a=n.flow;this.currentFlow=a;for(let o=e.source.statements,u=0,c=o.length;u<c;++u)this.compileTopLevelStatement(o[u],i);if(this.currentFlow=s,this.currentBody=r,i.length){let o=this.module,u=n.localsByIndex,c=u.length,f=new Array(c);for(let d=0;d<c;++d)f[d]=u[d].type.toRef();let p=o.addFunction(n.internalName,t.paramRefs,t.resultRefs,f,o.flatten(i));n.finalize(o,p),r.push(o.call(n.internalName,null,A.None))}}compileGlobal(e){if(e.is(8388608))return!e.is(16777216);e.set(8388608);let n=this.pendingElements;n.add(e);let t=this.module,r=0,i=e.typeNode,s=e.initializerNode;if(!e.is(4194304))if(i){let d=this.resolver.resolveType(i,e.parent);if(!d)return e.set(16777216),n.delete(e),!1;if(d==l.void)return this.error(1110,i.range),e.set(16777216),n.delete(e),!1;e.setType(d),this.checkTypeSupported(e.type,i)}else if(s){let d=this.currentFlow;if(e.hasDecorator(1024)&&(this.currentFlow=e.file.startFunction.flow),r=this.compileExpression(s,l.auto,20),this.currentFlow=d,this.currentType==l.void)return this.error(2322,s.range,this.currentType.toString(),"<auto>"),e.set(16777216),n.delete(e),!1;e.setType(this.currentType)}else return this.error(1110,e.identifierNode.range.atEnd),e.set(16777216),n.delete(e),!1;if(e.is(32768)&&e.hasDecorator(512)){let d=e.internalName;return d==h.data_end?this.runtimeFeatures|=1:d==h.stack_pointer?this.runtimeFeatures|=2:d==h.heap_base?this.runtimeFeatures|=4:d==h.rtti_base&&(this.runtimeFeatures|=8),n.delete(e),!0}let a=e.type,o=a.toRef(),u=e.is(8)||e.is(96),c=e.hasDecorator(64);if(e.is(32768))return u||this.options.hasFeature(2)?(Kc(e,e.declaration),this.program.markModuleImport(ft,jn,e),t.addGlobalImport(e.internalName,ft,jn,o,!u),n.delete(e),!this.desiresExportRuntime&&gr(a)&&(this.desiresExportRuntime=!0),!0):(this.error(103,e.declaration.range,"mutable-globals"),e.set(16777216),n.delete(e),!1);let f=!1;if(s){if(!r){let d=this.currentFlow;e.hasDecorator(1024)&&(this.currentFlow=e.file.startFunction.flow),r=this.compileExpression(s,a,21),this.currentFlow=d}if(!t.isConstExpression(r))if(u){let d=t.runExpression(r,1);d?r=d:f=!0}else f=!0;if(f&&H(r)==10){let d=assert(ns(r));if(!Ml(t.getGlobal(d))){let m=this.program.elementsByName;m.has(d)&&assert(m.get(d)).is(32768)&&(f=!1)}}if(c)if(f)this.warning(206,s.range);else{switch(assert(H(r)==14),se(r)){case A.I32:{e.constantValueKind=1,e.constantIntegerValue=i64_new(Y(r),0);break}case A.I64:{e.constantValueKind=1,e.constantIntegerValue=i64_new(Be(r),Pe(r));break}case A.F32:{e.constantValueKind=2,e.constantFloatValue=Fe(r);break}case A.F64:{e.constantValueKind=2,e.constantFloatValue=Ae(r);break}default:return assert(!1),e.set(16777216),n.delete(e),!1}e.set(33554432)}}else e.is(33554432)?r=this.compileInlineConstant(e,e.type,16):r=this.makeZero(a);let p=e.internalName;return f?(c&&this.error(212,qn(8,e.decoratorNodes).range,"inline"),t.addGlobal(p,o,!0,this.makeZero(a)),this.currentBody.push(t.global_set(p,r))):c||t.addGlobal(p,o,!u,r),n.delete(e),!0}compileEnum(e){if(e.is(8388608))return!e.is(16777216);e.set(8388608);let n=this.pendingElements;n.add(e);let t=this.module,r=this.currentParent;this.currentParent=e;let i=null,s=!1,a=e.is(8)||e.hasDecorator(64),o=e.members;if(o)for(let u=Map_values(o),c=0,f=u.length;c<f;++c){let p=unchecked(u[c]);if(p.kind!=3)continue;let d=!1,m=p,g=m.valueNode;m.set(8388608);let E=this.currentFlow;e.hasDecorator(1024)&&(this.currentFlow=e.file.startFunction.flow);let y;if(g){if(y=this.compileExpression(g,l.i32,1),H(y)!=14){let b=t.runExpression(y,1);b?y=b:(e.is(8)&&this.error(2474,g.range),d=!0)}}else if(i==null)y=t.i32(0);else if(s&&this.error(1061,m.identifierNode.range.atEnd),a){let b=i64_add(i.constantIntegerValue,i64_new(1));assert(!i64_high(b)),y=t.i32(i64_low(b))}else{y=t.binary(0,t.global_get(i.internalName,A.I32),t.i32(1));let b=t.runExpression(y,1);b?y=b:(e.is(8)&&this.error(2474,p.declaration.range),d=!0)}this.currentFlow=E,d?(t.addGlobal(m.internalName,A.I32,!0,t.i32(0)),this.currentBody.push(this.makeGlobalAssignment(m,y,l.i32,!1)),s=!0):(a?(m.setConstantIntegerValue(i64_new(Y(y)),l.i32),m.is(1048576)&&t.addGlobal(m.internalName,A.I32,!1,y)):t.addGlobal(m.internalName,A.I32,!1,y),m.isImmutable=!0,s=!1),i=m}return this.currentParent=r,n.delete(e),!0}compileFunction(e,n=!1){if(e.is(8388608))return!e.is(16777216);if(!n){if(e.hasDecorator(512))return!0;if(e.hasDecorator(1024))return this.lazyFunctions.add(e),!0}let t=e.prototype.functionTypeNode.parameters,r=t.length;if(r>=2){let p=new Set;p.add(t[0].name.text);for(let d=1;d<r;d++){let m=t[d].name,g=m.text;p.has(g)?this.error(2300,m.range,g):p.add(g)}}e.set(8388608);let i=this.pendingElements;i.add(e);let s=this.currentType,a=this.module,o=e.signature,u=e.prototype.bodyNode,c=e.declaration;assert(c.kind==55||c.kind==58),this.checkSignatureSupported(e.signature,c.signature);let f;if(u){if(e.is(32768)&&this.error(1183,e.identifierNode.range),e.hasAnyDecorator(384)){let g=e.decoratorNodes,E;(E=qn(9,g))&&this.error(212,E.range,"external"),(E=qn(10,g))&&this.error(212,E.range,"external.js")}let p=this.currentFlow,d=e.flow;this.currentFlow=d;let m=new Array;this.compileFunctionBody(e,m)||m.push(a.unreachable()),this.currentFlow=p,f=a.addFunction(e.internalName,o.paramRefs,o.resultRefs,Kt(e.getNonParameterLocalTypes()),a.flatten(m,e.signature.returnType.toRef()))}else if(e.is(32768)){if(Kc(e,c),this.program.markModuleImport(ft,jn,e),a.addFunctionImport(e.internalName,ft,jn,o.paramRefs,o.resultRefs),f=a.getFunction(e.internalName),!this.desiresExportRuntime){let p=o.thisType;if(p&&yr(p)||gr(o.returnType))this.desiresExportRuntime=!0;else{let d=o.parameterTypes;for(let m=0,g=d.length;m<g;++m)if(yr(d[m])){this.desiresExportRuntime=!0;break}}}}else e.is(128)||e.parent.kind==9?f=a.addFunction(e.internalName,o.paramRefs,o.resultRefs,null,a.unreachable()):(this.error(2391,e.identifierNode.range),f=0,e.set(16777216));if((e.is(32768)||e.is(2))&&o.hasVectorValueOperands){let p,d=e.prototype.functionTypeNode;if(o.returnType==l.v128)p=d.returnType.range;else{let m=o.getVectorValueOperandIndices()[0];p=d.parameters[m].range}this.warning(112,p,"v128")}return e.finalize(a,f),this.currentType=s,i.delete(e),!0}compileFunctionBody(e,n){let t=this.module,r=assert(e.prototype.bodyNode),i=e.signature.returnType,s=this.currentFlow,a=e.signature.thisType?assert(s.lookupLocal(v.this_)):null,o=n.length;if(r.kind==30)n=this.compileStatements(r.statements,!0,n);else{assert(r.kind==38),assert(e.prototype.arrowKind),assert(!e.isAny(530432));let u=this.compileExpression(r.expression,i,1);s.canOverflow(u,i)||s.set(2),s.isNonnull(u,i)&&s.set(4),n?n.push(u):n=[u],s.is(256)||(s.canOverflow(u,i)||s.set(2),s.isNonnull(u,i)&&s.set(4),s.set(257))}if(e.is(524288)){assert(e.is(262144)),a=assert(a);let u=assert(e.parent);assert(u.kind==7);let c=u;if(s.isAny(8256)||!s.is(256)){let f=new Array;f.push(this.makeConditionalAllocation(c,a.index)),this.makeFieldInitializationInConstructor(c,f);for(let p=n.length-1;p>=o;--p)n[p+1]=n[p];n[o]=t.flatten(f,A.None),s.is(16384)&&this.options.pedantic&&this.pedantic(905,e.identifierNode.range)}s.is(16384)&&!c.hasDecorator(32)&&this.error(231,c.identifierNode.range),s.is(256)||(n.push(t.local_get(a.index,this.options.sizeTypeRef)),s.set(261)),c.base&&!s.is(128)&&this.error(2377,e.prototype.declaration.range)}else if(i!=l.void&&!s.is(256))return this.error(2355,e.prototype.functionTypeNode.returnType.range),!1;return!0}compileField(e){return this.compileFieldGetter(e),this.compileFieldSetter(e),e.is(8388608)}compileFieldGetter(e){if(e.getterRef)return!0;let n=this.module,t=e.type,r=t.toRef(),i=this.options.sizeTypeRef;if(e.getterRef=n.addFunction(e.internalGetterName,i,r,null,n.load(t.byteSize,t.isSignedIntegerValue,n.local_get(0,i),r,e.memoryOffset)),e.setterRef)e.set(8388608);else{let s=e.typeNode;s&&this.checkTypeSupported(e.type,s)}return!0}compileFieldSetter(e){if(e.setterRef)return!0;let n=e.type,t=this.options.sizeTypeRef,r=n.toRef(),i=this.module,s=i.store(n.byteSize,i.local_get(0,t),i.local_get(1,r),r,e.memoryOffset);if(n.isManaged){let a=e.parent;if(assert(a.kind==7),a.type.isManaged){let o=this.program.linkInstance;this.compileFunction(o),s=i.block(null,[s,i.call(o.internalName,[i.local_get(0,t),i.local_get(1,r),i.i32(0)],A.None)],A.None)}}if(e.setterRef=i.addFunction(e.internalSetterName,dn([t,r]),A.None,null,s),e.getterRef)e.set(8388608);else{let a=e.typeNode;a&&this.checkTypeSupported(e.type,a)}return!0}addAlignedMemorySegment(e,n=16){assert(nr(n));let t=i64_align(this.memoryOffset,n),r=new vi(e,t);return this.memorySegments.push(r),this.memoryOffset=i64_add(t,i64_new(e.length)),r}addRuntimeMemorySegment(e){let n=this.program.computeBlockStart64(this.memoryOffset),t=new vi(e,n);return this.memorySegments.push(t),this.memoryOffset=i64_add(n,i64_new(e.length)),t}ensureStaticString(e){let n=this.ensureStaticStringPtr(e);return this.currentType=this.program.stringInstance.type,this.module.usize(n)}ensureStaticStringPtr(e){let n=this.program,t=n.totalOverhead,r=assert(n.stringInstance),i,s=this.stringSegments;if(s.has(e))i=assert(s.get(e));else{let a=e.length,o=r.createBuffer(a);for(let u=0;u<a;++u){let c=e.charCodeAt(u);c>=128&&this.error(100,null,"Unicode not supported"),o[t+u]=c}i=this.addRuntimeMemorySegment(o),s.set(e,i)}return i64_add(i.offset,i64_new(t))}writeStaticBuffer(e,n,t,r){let i=r.length,s=t.byteSize,a=t.toRef();switch(a){case A.I32:{switch(s){case 1:{for(let o=0;o<i;++o){let u=r[o];assert(se(u)==a),assert(H(u)==14),me(Y(u),e,n),n+=1}break}case 2:{for(let o=0;o<i;++o){let u=r[o];assert(se(u)==a),assert(H(u)==14),Gi(Y(u),e,n),n+=2}break}case 4:{for(let o=0;o<i;++o){let u=r[o];assert(se(u)==a),assert(H(u)==14),be(Y(u),e,n),n+=4}break}default:assert(!1)}break}case A.I64:{for(let o=0;o<i;++o){let u=r[o];assert(se(u)==a),assert(H(u)==14),mi(i64_new(Be(u),Pe(u)),e,n),n+=8}break}case A.F32:{for(let o=0;o<i;++o){let u=r[o];assert(se(u)==a),assert(H(u)==14),qi(Fe(u),e,n),n+=4}break}case A.F64:{for(let o=0;o<i;++o){let u=r[o];assert(se(u)==a),assert(H(u)==14),ji(Ae(u),e,n),n+=8}break}case A.V128:{for(let o=0;o<i;++o){let u=r[o];assert(se(u)==a),assert(H(u)==14),yp(zl(u),e,n),n+=16}break}case A.None:break;default:assert(!1)}return n}addStaticBuffer(e,n,t=this.program.arrayBufferInstance.id){let r=this.program,i=r.arrayBufferInstance.createBuffer(n.length*e.byteSize);return this.program.OBJECTInstance.writeField("rtId",t,i,0),this.writeStaticBuffer(i,r.totalOverhead,e,n),this.addRuntimeMemorySegment(i)}addStaticArrayHeader(e,n,t=null){let r=this.program;t||(t=assert(this.resolver.resolveClass(this.program.arrayPrototype,[e])));let i=Cr(n.buffer,r.OBJECTInstance.offsetof("rtSize")),s=i32(i/e.byteSize),a=i64_add(n.offset,i64_new(r.totalOverhead)),o=t.createBuffer();return assert(t.writeField("buffer",a,o)),assert(t.writeField("dataStart",a,o)),assert(t.writeField("byteLength",i,o)),assert(t.writeField("length_",s,o)),this.addRuntimeMemorySegment(o)}ensureRuntimeFunction(e){assert(e.is(8388608)&&!e.is(134217728));let n=this.program,t=e.memorySegment;if(!t){let r=this.functionTable,i=this.options.tableBase;i||(i=1);let s=i+r.length;r.push(e);let a=assert(this.resolver.resolveClass(n.functionPrototype,[e.type])),o=a.createBuffer();assert(a.writeField("_index",s,o)),assert(a.writeField("_env",0,o)),e.memorySegment=t=this.addRuntimeMemorySegment(o)}return i64_add(t.offset,i64_new(n.totalOverhead))}compileTopLevelStatement(e,n){switch(e.kind){case 51:{let t=e.members;for(let r=0,i=t.length;r<i;++r)this.compileTopLevelStatement(t[r],n);break}case 52:{let t=this.program.getElementByDeclaration(e);t&&(assert(t.kind==2),t.hasDecorator(1024)||this.compileEnum(t));break}case 59:{let t=e,r=this.program.getElementByDeclaration(t);if(r){let i=this.currentParent;this.currentParent=r;let s=t.members;for(let a=0,o=s.length;a<o;++a)this.compileTopLevelStatement(s[a],n);this.currentParent=i}break}case 47:{let t=e.declarations;for(let r=0,i=t.length;r<i;++r){let s=this.program.getElementByDeclaration(t[r]);s&&(assert(s.kind==0),!s.is(32768)&&!s.hasDecorator(1024)&&this.compileGlobal(s))}break}case 54:{let t=this.program.getElementByDeclaration(e);t&&t.kind==0&&(t.hasDecorator(1024)||this.compileGlobal(t));break}case 35:{let t=e,r=t.internalPath;r!=null&&this.compileFileByPath(r,assert(t.path));break}case 36:{this.compileTopLevelStatement(e.declaration,n);break}case 42:{let t=e;this.compileFileByPath(t.internalPath,t.path);break}case 55:case 58:case 57:case 65:case 60:break;default:{let t=this.compileStatement(e);H(t)!=22&&n.push(t);break}}}compileStatement(e,n=!1){let t=this.module,r;switch(e.kind){case 30:{r=this.compileBlockStatement(e);break}case 31:{r=this.compileBreakStatement(e);break}case 32:{r=this.compileContinueStatement(e);break}case 33:{r=this.compileDoStatement(e);break}case 34:{r=this.compileEmptyStatement(e);break}case 38:{r=this.compileExpressionStatement(e);break}case 39:{r=this.compileForStatement(e);break}case 40:{r=this.compileForOfStatement(e);break}case 41:{r=this.compileIfStatement(e);break}case 43:{r=this.compileReturnStatement(e,n);break}case 44:{r=this.compileSwitchStatement(e);break}case 45:{r=this.compileThrowStatement(e);break}case 46:{r=this.compileTryStatement(e);break}case 47:{r=this.compileVariableStatement(e),r||(r=t.nop());break}case 48:{r=this.compileVoidStatement(e);break}case 49:{r=this.compileWhileStatement(e);break}case 60:{this.error(100,e.range,"Inner type alias"),r=t.unreachable();break}case 50:{r=t.nop();break}default:assert(!1),r=t.unreachable()}return this.options.sourceMap&&this.addDebugLocation(r,e.range),r}compileStatements(e,n=!1,t=null){let r=e.length;t||(t=new Array(r),t.length=0);let i=this.module,s=this.currentFlow;for(let a=0;a<r;++a){let o=this.compileStatement(e[a],n&&a==r-1);switch(H(o)){case 1:if(!ts(o)){for(let u=0,c=rs(o);u<c;++u)t.push(is(o,u));break}default:t.push(o);case 22:}if(s.isAny(272)){os(o)&&t.push(i.unreachable());break}}return t}compileBlockStatement(e){let n=e.statements,t=this.currentFlow,r=t.fork();this.currentFlow=r;let i=this.compileStatements(n);return t.inherit(r),this.currentFlow=t,this.module.flatten(i)}compileBreakStatement(e){let n=this.module,t=e.label;if(t)return this.error(100,t.range,"Break label"),n.unreachable();let r=this.currentFlow,i=r.breakLabel;return i==null?(this.error(1105,e.range),n.unreachable()):(r.set(16),n.br(i))}compileContinueStatement(e){let n=this.module,t=e.label;if(t)return this.error(100,t.range,"Continue label"),n.unreachable();let r=this.currentFlow,i=r.continueLabel;return i==null?(this.error(1104,e.range),n.unreachable()):(r.set(288),n.br(i))}compileDoStatement(e){return this.doCompileDoStatement(e)}doCompileDoStatement(e){let n=this.module,t=this.currentFlow,r=t.targetFunction.localsByIndex.length,i=t.pushBreakLabel(),s=t.fork(!0);this.currentFlow=s;let a=`do-break|${i}`;s.breakLabel=a;let o=`do-continue|${i}`;s.continueLabel=o;let u=`do-loop|${i}`,c=s.fork();this.currentFlow=c;let f=new Array,p=e.body;p.kind==30?this.compileStatements(p.statements,!1,f):f.push(this.compileStatement(p));let d=c.isAny(4128);if(c.isAny(272)&&!d)f.push(n.unreachable()),s.inherit(c);else{let g=s.fork();this.currentFlow=g;let E=this.makeIsTrueish(this.compileExpression(e.condition,l.i32),this.currentType,e.condition),y=this.evaluateCondition(E);if(d&&(f=[n.block(o,f)]),y==2)f.push(n.drop(E)),s.inherit(c);else if(y==1&&!c.isAny(2064))f.push(n.drop(E)),f.push(n.br(u)),s.set(256);else if(f.push(n.br(u,E)),s.inherit(g),t.resetIfNeedsRecompile(s,r))return t.popBreakLabel(),this.currentFlow=t,this.doCompileDoStatement(e)}t.inherit(s),t.popBreakLabel(),this.currentFlow=t;let m=n.block(a,[n.loop(u,n.flatten(f))]);return t.is(256)&&(m=n.block(null,[m,n.unreachable()])),m}compileEmptyStatement(e){return this.module.nop()}compileExpressionStatement(e){return this.compileExpression(e.expression,l.void,1)}compileForStatement(e){return this.doCompileForStatement(e)}doCompileForStatement(e){let n=this.module,t=this.currentFlow,r=t.targetFunction.localsByIndex.length,i=t.pushBreakLabel(),s=new Array,a=t.fork(!0);this.currentFlow=a;let o=`for-break${i}`;a.breakLabel=o;let u=`for-continue|${i}`;a.continueLabel=u;let c=`for-loop|${i}`,f=e.initializer;f&&(assert(f.kind==38||f.kind==47),s.push(this.compileStatement(f)));let p=a.fork();this.currentFlow=p;let d,m,g=e.condition;if(g){if(d=this.makeIsTrueish(this.compileExpression(g,l.bool),this.currentType,g),m=this.evaluateCondition(d),m==2)return s.push(n.drop(d)),a.inherit(p),t.inherit(a),t.popBreakLabel(),this.currentFlow=t,n.flatten(s)}else d=n.i32(1),m=1;let E=a.getTempLocal(l.bool),y=new Array;y.push(n.local_set(E.index,d,!1)),a.inherit(p),this.currentFlow=a;let b=a.fork();b.inheritNonnullIfTrue(d),this.currentFlow=b;let T=new Array,S=e.body;S.kind==30?this.compileStatements(S.statements,!1,T):T.push(this.compileStatement(S)),b.isAny(272)&&T.push(n.unreachable()),m==1?a.inherit(b):a.inheritBranch(b);let C=new Array;if(C.push(n.block(u,T)),!b.is(256)||b.isAny(4128)){let w=e.incrementor;if(w){let B=a.fork();this.currentFlow=B,C.push(this.compileExpression(w,l.void,9)),a.inherit(B),this.currentFlow=a}if(C.push(n.br(c)),t.resetIfNeedsRecompile(a,r))return t.popBreakLabel(),this.currentFlow=t,this.doCompileForStatement(e)}return y.push(n.if(n.local_get(E.index,A.I32),n.flatten(C))),s.push(n.block(o,[n.loop(c,n.flatten(y))])),this.currentFlow=a,t.inherit(a),t.popBreakLabel(),t.is(256)&&s.push(n.unreachable()),this.currentFlow=t,n.flatten(s)}compileForOfStatement(e){return this.error(100,e.range,"Iterators"),this.module.unreachable()}compileIfStatement(e){let n=this.module,t=e.ifTrue,r=e.ifFalse,i=this.makeIsTrueish(this.compileExpression(e.condition,l.bool),this.currentType,e.condition);switch(this.evaluateCondition(i)){case 1:return n.block(null,[n.drop(i),this.compileStatement(t)]);case 2:return r?n.block(null,[n.drop(i),this.compileStatement(r)]):n.drop(i)}let s=this.currentFlow,a=new Array,o=s.fork();if(this.currentFlow=o,o.inheritNonnullIfTrue(i),t.kind==30?this.compileStatements(t.statements,!1,a):a.push(this.compileStatement(t)),o.isAny(272)&&a.push(n.unreachable()),this.currentFlow=s,r){let u=new Array,c=s.fork();return this.currentFlow=c,c.inheritNonnullIfFalse(i),r.kind==30?this.compileStatements(r.statements,!1,u):u.push(this.compileStatement(r)),c.isAny(272)&&u.push(n.unreachable()),this.currentFlow=s,s.inheritMutual(o,c),n.if(i,n.flatten(a),n.flatten(u))}else return s.inheritBranch(o),s.inheritNonnullIfFalse(i,o.isAny(272)?null:o),n.if(i,n.flatten(a))}compileReturnStatement(e,n){let t=this.module,r=0,i=this.currentFlow,s=i.returnType,a=e.value;if(a){let o=1;i.sourceFunction.is(1048576)&&(o|=4),r=this.compileExpression(a,s,o),i.canOverflow(r,s)||i.set(2),i.isNonnull(r,s)&&i.set(4),i.sourceFunction.is(524288)&&a.kind!=24&&i.set(16384)}else if(s!=l.void)return this.error(2322,e.range,"void",s.toString()),this.currentType=s,t.unreachable();return i.set(257),i.isInline?r?n?r:this.currentType==l.void?t.block(null,[r,t.br(assert(i.inlineReturnLabel))]):t.br(assert(i.inlineReturnLabel),0,r):n?t.nop():t.br(assert(i.inlineReturnLabel)):r?n?r:this.currentType==l.void?t.block(null,[r,t.return()]):t.return(r):n?t.nop():t.return()}compileSwitchStatement(e){let n=this.module,t=e.cases,r=t.length;if(!r)return this.compileExpression(e.condition,l.void,1);let i=this.currentFlow,s=i.pushBreakLabel(),a=i.getTempLocal(l.u32).index,o=new Array(1+r);o[0]=n.local_set(a,this.compileExpression(e.condition,l.u32,1),!1);let u=1,c=-1;for(let m=0;m<r;++m){let g=t[m].label;g?o[u++]=n.br(`case${m}|${s}`,n.binary(15,n.local_get(a,A.I32),this.compileExpression(g,l.u32,1))):c=m}o[u]=n.br(c>=0?`case${c}|${s}`:`break|${s}`);let f=n.block(`case0|${s}`,o,A.None),p=511,d=0;for(let m=0;m<r;++m){let g=t[m].statements,E=g.length,y=i.fork();this.currentFlow=y;let b=`break|${s}`;y.breakLabel=b;let T=m==r-1,S=T?b:`case${m+1}|${s}`,C=new Array(1+E);C[0]=f;let w=1,B=!1;for(let D=0;D<E;++D){let W=this.compileStatement(g[D]);if(H(W)!=22&&(C[w++]=W),y.isAny(272)){y.is(256)&&(B=!0);break}}C.length=w,(B||T||y.isAny(2064))&&(p&=y.flags),d|=y.deriveConditionalFlags(),y.unset(2064),this.currentFlow=i,f=n.block(S,C,A.None)}return i.popBreakLabel(),c>=0&&(i.flags|=p&-17),i.flags|=d&-2049,f}compileThrowStatement(e){this.currentFlow.set(264);let n=new Array,t=e.value,r=null;if(t.kind==17){let i=t.args;i.length&&(r=i[0])}return n.push(this.makeAbort(r,e)),this.module.flatten(n)}compileTryStatement(e){return this.error(100,e.range,"Exceptions"),this.module.unreachable()}compileVariableStatement(e){let n=this.module,t=e.declarations,r=t.length,i=this.currentFlow,s=new Array,a=this.resolver;for(let o=0;o<r;++o){let u=t[o],c=u.name.text,f=null,p=0,d=u.type,m=u.initializer;if(d){if(f=a.resolveType(d,i.sourceFunction,de(i.contextualTypeArguments)),!f)continue;if(this.checkTypeSupported(f,d),m){let y=this.pendingElements,b=i.addScopedDummyLocal(c,f,e);y.add(b),p=this.compileExpression(m,f,1),y.delete(b),i.freeScopedDummyLocal(c)}}else if(m){let y=this.pendingElements,b=i.addScopedDummyLocal(c,l.auto,e);if(y.add(b),p=this.compileExpression(m,l.auto),y.delete(b),i.freeScopedDummyLocal(c),this.currentType==l.void){this.error(2322,u.range,this.currentType.toString(),"<auto>");continue}f=this.currentType}else{this.error(1110,u.name.range.atEnd);continue}let g=u.is(8),E=!1;if(g)if(p){let y=n.runExpression(p,1);if(y){p=y;let b=null;switch(se(p)){case A.I32:{b=new nn(c,-1,f,i.targetFunction),b.setConstantIntegerValue(i64_new(Y(p),0),f);break}case A.I64:{b=new nn(c,-1,f,i.targetFunction),b.setConstantIntegerValue(i64_new(Be(p),Pe(p)),f);break}case A.F32:{b=new nn(c,-1,f,i.targetFunction),b.setConstantFloatValue(Fe(p),f);break}case A.F64:{b=new nn(c,-1,f,i.targetFunction),b.setConstantFloatValue(Ae(p),f);break}}if(b){let T=i.scopedLocals;if(!T)i.scopedLocals=T=new Map;else if(T.has(c)){let S=assert(T.get(c));return this.errorRelated(2300,u.name.range,S.declaration.name.range,c),this.module.unreachable()}T.set(c,b),E=!0}}}else this.error(1155,u.range);if(!E){let y;if(u.isAny(24)||i.isInline){let b=i.getScopedLocal(c);b?(b.declaration.range.source.isNative?this.error(2300,u.name.range,c):this.errorRelated(2300,u.name.range,b.declaration.name.range,c),y=b):y=i.addScopedLocal(c,f),g&&i.setLocalFlag(y.index,1)}else{let b=i.lookupLocal(c);if(b){this.errorRelated(2300,u.name.range,b.declaration.name.range,c);continue}y=i.targetFunction.addLocal(f,c,u),i.unsetLocalFlag(y.index,-1),g&&i.setLocalFlag(y.index,1)}p?s.push(this.makeLocalAssignment(y,p,f,!1)):y.type.isShortIntegerValue&&i.setLocalFlag(y.index,2)}}return this.currentType=l.void,s.length==0?0:n.flatten(s)}compileVoidStatement(e){return this.compileExpression(e.expression,l.void,10)}compileWhileStatement(e){return this.doCompileWhileStatement(e)}doCompileWhileStatement(e){let n=this.module,t=this.currentFlow,r=t.targetFunction.localsByIndex.length,i=t.pushBreakLabel(),s=new Array,a=t.fork(!0);this.currentFlow=a;let o=`while-break|${i}`;a.breakLabel=o;let u=`while-continue|${i}`;a.continueLabel=u;let c=a.fork();this.currentFlow=c;let f=this.makeIsTrueish(this.compileExpression(e.condition,l.bool),this.currentType,e.condition),p=this.evaluateCondition(f);if(p==2)return s.push(n.drop(f)),t.popBreakLabel(),this.currentFlow=t,n.flatten(s);let d=a.getTempLocal(l.bool);s.push(n.local_set(d.index,f,!1)),a.inherit(c),this.currentFlow=a;let m=a.fork();m.inheritNonnullIfTrue(f),this.currentFlow=m;let g=new Array,E=e.body;if(E.kind==30?this.compileStatements(E.statements,!1,g):g.push(this.compileStatement(E)),m.is(256))g.push(n.unreachable()),p==1?a.inherit(m):a.inheritBranch(m);else if(p==1&&!m.isAny(2064))g.push(n.br(u)),a.set(256);else{let b=m.is(16);if(b?g.push(n.unreachable()):g.push(n.br(u)),p==1?a.inherit(m):a.inheritBranch(m),!b&&t.resetIfNeedsRecompile(a,r))return t.popBreakLabel(),this.currentFlow=t,this.doCompileWhileStatement(e)}s.push(n.if(n.local_get(d.index,A.I32),n.flatten(g))),this.currentFlow=a,t.inherit(a),t.popBreakLabel(),this.currentFlow=t;let y=n.block(o,[n.loop(u,n.flatten(s))]);return p==1&&t.is(256)&&(y=n.block(null,[y,n.unreachable()])),y}compileInlineConstant(e,n,t){assert(e.is(37748736));let r=e.type;switch(this.currentType=r,r.kind){case 0:return this.module.i32(e.constantValueKind==1?i64_ne(e.constantIntegerValue,i64_zero):0);case 1:case 2:{let i=r.computeSmallIntegerShift(l.i32);return this.module.i32(e.constantValueKind==1?i64_low(e.constantIntegerValue)<<i>>i:0)}case 6:case 7:{let i=e.type.computeSmallIntegerMask(l.i32);return this.module.i32(e.constantValueKind==1?i64_low(e.constantIntegerValue)&i:0)}case 3:case 8:return this.module.i32(e.constantValueKind==1?i64_low(e.constantIntegerValue):0);case 5:case 10:if(!e.program.options.isWasm64)return this.module.i32(e.constantValueKind==1?i64_low(e.constantIntegerValue):0);case 4:case 9:return e.constantValueKind==1?this.module.i64(i64_low(e.constantIntegerValue),i64_high(e.constantIntegerValue)):this.module.i64(0);case 12:{if(!(e.hasDecorator(512)&&n==l.f32))return this.module.f64(e.constantFloatValue);this.currentType=l.f32}case 11:return this.module.f32(e.constantFloatValue);default:return assert(!1),this.module.unreachable()}}compileExpression(e,n,t=0){for(;e.kind==20;)e=e.expression;this.currentType=n,n==l.void&&(t|=8);let r;switch(e.kind){case 7:{r=this.compileAssertionExpression(e,n,t);break}case 8:{r=this.compileBinaryExpression(e,n,t);break}case 9:{r=this.compileCallExpression(e,n,t);break}case 11:{r=this.compileCommaExpression(e,n,t);break}case 12:{r=this.compileElementAccessExpression(e,n,t);break}case 14:{r=this.compileFunctionExpression(e,n,t);break}case 6:case 13:case 18:case 24:case 23:case 25:{r=this.compileIdentifierExpression(e,n,t);break}case 15:{r=this.compileInstanceOfExpression(e,n,t);break}case 16:{r=this.compileLiteralExpression(e,n,t);break}case 17:{r=this.compileNewExpression(e,n,t);break}case 21:{r=this.compilePropertyAccessExpression(e,n,t);break}case 22:{r=this.compileTernaryExpression(e,n,t);break}case 27:{r=this.compileUnaryPostfixExpression(e,n,t);break}case 28:{r=this.compileUnaryPrefixExpression(e,n,t);break}case 29:{let a=e;r=a.expr,this.currentType=a.type;break}case 10:{this.error(100,e.range,"Block-scoped class declarations or expressions"),r=this.module.unreachable();break}default:assert(!1),r=this.module.unreachable()}let i=this.currentType,s=(t&4)!=0;return i!=n.nonNullableType&&(t&2?(r=this.convertExpression(r,i,n,!0,e),this.currentType=i=n):t&1&&(r=this.convertExpression(r,i,n,!1,e),this.currentType=i=n)),s&&(r=this.ensureSmallIntegerWrap(r,i)),this.options.sourceMap&&this.addDebugLocation(r,e.range),r}convertExpression(e,n,t,r,i){let s=this.module;if(n.kind==25)return t.kind==25?e:(this.error(2322,i.range,n.toString(),t.toString()),s.unreachable());if(t.kind==25)return s.drop(e);if(n.isReference||t.isReference)return this.currentFlow.isNonnull(e,n)?n=n.nonNullableType:r&&n.isNullableReference&&!t.isNullableReference&&(this.options.noAssert||(e=this.makeRuntimeNonNullCheck(e,n,i)),n=n.nonNullableType),n.isAssignableTo(t)?(assert(t.isExternalReference||n.kind==t.kind),this.currentType=t,e):r&&t.nonNullableType.isAssignableTo(n)?t.isExternalReference?(this.error(100,i.range,"ref.cast"),this.currentType=t,s.unreachable()):(assert(n.kind==t.kind),this.options.noAssert||(e=this.makeRuntimeDowncastCheck(e,n,t,i)),this.currentType=t,e):(this.error(2322,i.range,n.toString(),t.toString()),this.currentType=t,s.unreachable());if(assert(!n.isReference&&!t.isReference),t.kind==n.kind)return this.currentType=t,e;if(!t.isBooleanValue&&(t.isVectorValue||n.isVectorValue))return this.error(2322,i.range,n.toString(),t.toString()),s.unreachable();if(n.isAssignableTo(t)||r||this.error(200,i.range,n.toString(),t.toString()),n.isFloatValue)if(t.isFloatValue)n.kind==11?t.kind==12&&(e=s.unary(43,e)):t.kind==11&&(e=s.unary(44,e));else if(t.isIntegerValue)if(n.kind==11)if(t.isBooleanValue)e=this.makeIsTrueish(e,l.f32,i);else if(t.isSignedIntegerValue){let a=this.options.hasFeature(4);t.isLongIntegerValue?e=s.unary(a?56:26,e):e=s.unary(a?52:25,e)}else{let a=this.options.hasFeature(4);t.isLongIntegerValue?e=s.unary(a?57:28,e):e=s.unary(a?53:27,e)}else if(t.isBooleanValue)e=this.makeIsTrueish(e,l.f64,i);else if(t.isSignedIntegerValue){let a=this.options.hasFeature(4);t.isLongIntegerValue?e=s.unary(a?58:30,e):e=s.unary(a?54:29,e)}else{let a=this.options.hasFeature(4);t.isLongIntegerValue?e=s.unary(a?59:32,e):e=s.unary(a?55:31,e)}else assert(t.flags==0,"void type expected"),e=s.drop(e);else n.isIntegerValue&&t.isFloatValue?t.kind==11?n.isLongIntegerValue?e=s.unary(n.isSignedIntegerValue?39:41,e):e=s.unary(n.isSignedIntegerValue?35:37,e):n.isLongIntegerValue?e=s.unary(n.isSignedIntegerValue?40:42,e):e=s.unary(n.isSignedIntegerValue?36:38,e):n==l.v128&&t.isBooleanValue?e=this.makeIsTrueish(e,l.v128,i):n.isLongIntegerValue?t.isBooleanValue?e=s.binary(41,e,s.i64(0)):t.isLongIntegerValue||(e=s.unary(24,e)):t.isLongIntegerValue?e=s.unary(n.isSignedIntegerValue?22:23,this.ensureSmallIntegerWrap(e,n)):n.isShortIntegerValue?n.size<t.size&&(e=this.ensureSmallIntegerWrap(e,n)):!r&&!this.options.isWasm64&&n.isVaryingIntegerValue&&!t.isVaryingIntegerValue&&this.warning(201,i.range,n.toString(),t.toString());return this.currentType=t,e}compileAssertionExpression(e,n,t){let r=t&-4;switch(e.assertionKind){case 0:case 1:{let i=this.currentFlow,s=this.resolver.resolveType(assert(e.toType),i.sourceFunction,de(i.contextualTypeArguments));return s?this.compileExpression(e.expression,s,r|2):this.module.unreachable()}case 2:{assert(!e.toType);let i=this.compileExpression(e.expression,n.exceptVoid,r),s=this.currentType;return this.currentFlow.isNonnull(i,s)?this.info(210,e.expression.range):this.options.noAssert||(i=this.makeRuntimeNonNullCheck(i,s,e)),this.currentType=s.nonNullableType,i}case 3:return this.error(100,e.range,"Const assertion"),this.module.unreachable();default:assert(!1)}return this.module.unreachable()}compileBinaryExpression(e,n,t){let r=this.module,i=e.left,s=e.right,a,o,u,c,f,p,d=!1;switch(e.operator){case 72:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(21);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!0),!f||!f.isNumericValue)return this.error(2365,e.range,"<",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f,p=this.makeLt(a,u,f),this.currentType=l.bool;break}case 73:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(19);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!0),!f||!f.isNumericValue)return this.error(2365,e.range,">",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f,p=this.makeGt(a,u,f),this.currentType=l.bool;break}case 74:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(22);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!0),!f||!f.isNumericValue)return this.error(2365,e.range,"<=",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f,p=this.makeLe(a,u,f),this.currentType=l.bool;break}case 75:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(20);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!0),!f||!f.isNumericValue)return this.error(2365,e.range,">=",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f,p=this.makeGe(a,u,f),this.currentType=l.bool;break}case 78:case 76:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(17);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f)return this.error(2365,e.range,Ue(e.operator),o.toString(),c.toString()),this.currentType=n,r.unreachable();f.isFloatValue&&((Gt(r,u)||Gt(r,a))&&this.warning(907,e.range),(Vt(u)||Vt(a))&&this.warning(908,e.range)),a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f,p=this.makeEq(a,u,f,e),this.currentType=l.bool;break}case 79:case 77:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClass();if(y){let b=y.lookupOverload(18);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f)return this.error(2365,e.range,Ue(e.operator),o.toString(),c.toString()),this.currentType=n,r.unreachable();f.isFloatValue&&((Gt(r,u)||Gt(r,a))&&this.warning(907,e.range),(Vt(u)||Vt(a))&&this.warning(908,e.range)),a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f,p=this.makeNe(a,u,f,e),this.currentType=l.bool;break}case 101:return this.compileAssignment(i,s,n);case 102:d=!0;case 81:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(5);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isNumericValue)return this.error(2469,e.range,"+",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isNumericValue)return this.error(2365,e.range,"+",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeAdd(a,u,f);break}case 103:d=!0;case 82:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(6);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isNumericValue)return this.error(2469,e.range,"-",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!o.isNumericValue)return this.error(2365,e.range,"-",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeSub(a,u,f);break}case 104:d=!0;case 84:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(7);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isNumericValue)return this.error(2469,e.range,"*",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isNumericValue)return this.error(2365,e.range,"*",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeMul(a,u,f);break}case 105:d=!0;case 83:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(10);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isNumericValue)return this.error(2469,e.range,"**",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isNumericValue)return this.error(2365,e.range,"**",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makePow(a,u,f,e);break}case 106:d=!0;case 85:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(8);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isNumericValue)return this.error(2469,e.range,"/",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isNumericValue)return this.error(2365,e.range,"/",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeDiv(a,u,f);break}case 107:d=!0;case 86:{a=this.compileExpression(i,n),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(9);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isNumericValue)return this.error(2469,e.range,"%",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isNumericValue)return this.error(2365,e.range,"%",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeRem(a,u,f,e);break}case 108:d=!0;case 89:{a=this.compileExpression(i,n.intType),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(14);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(!o.isIntegerValue)return this.error(2469,e.range,"<<",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=this.currentType,p=this.makeShl(a,u,c);break}case 109:d=!0;case 90:{a=this.compileExpression(i,n.intType),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(15);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(!o.isIntegerValue)return this.error(2469,e.range,">>",o.toString()),this.module.unreachable();u=this.compileExpression(s,o,1),c=this.currentType,p=this.makeShr(a,u,c);break}case 110:d=!0;case 91:{a=this.compileExpression(i,n.intType),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(16);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(!o.isIntegerValue)return this.error(2469,e.range,">>>",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=this.currentType,p=this.makeShru(a,u,c);break}case 111:d=!0;case 92:{a=this.compileExpression(i,n.intType),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(11);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isIntegerValue)return this.error(2469,e.range,"&",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isIntegerValue)return this.error(2365,e.range,"&",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeAnd(a,u,f);break}case 112:d=!0;case 93:{a=this.compileExpression(i,n.intType),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(12);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isIntegerValue)return this.error(2469,e.range,"|",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isIntegerValue)return this.error(2365,e.range,"|",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeOr(a,u,f);break}case 113:d=!0;case 94:{a=this.compileExpression(i,n.intType),o=this.currentType;let y=o.getClassOrWrapper(this.program);if(y){let b=y.lookupOverload(13);if(b){p=this.compileBinaryOverload(b,i,a,o,s,e);break}}if(d){if(!o.isIntegerValue)return this.error(2469,e.range,"^",o.toString()),r.unreachable();u=this.compileExpression(s,o,1),c=f=this.currentType}else{if(u=this.compileExpression(s,o),c=this.currentType,f=l.commonDenominator(o,c,!1),!f||!f.isIntegerValue)return this.error(2365,e.range,"^",o.toString(),c.toString()),this.currentType=n,r.unreachable();a=this.convertExpression(a,o,f,!1,i),o=f,u=this.convertExpression(u,c,f,!1,s),c=f}p=this.makeXor(a,u,f);break}case 97:{let y=this.currentFlow,b=t&4;a=this.compileExpression(i,n.exceptVoid,b),o=this.currentType;let T=y.fork();if(this.currentFlow=T,T.inheritNonnullIfTrue(a),n==l.bool||n==l.void){a=this.makeIsTrueish(a,o,i);let S=this.evaluateCondition(a);S==2?p=a:(u=this.compileExpression(s,o,b),c=this.currentType,u=this.makeIsTrueish(u,c,s),S==1?p=u:p=r.if(a,u,r.i32(0))),this.currentFlow=y,this.currentType=l.bool}else{if(u=this.compileExpression(s,o,b|1),c=this.currentType,this.currentFlow=y,p=r.tryCopyTrivialExpression(a))p=r.if(this.makeIsTrueish(a,this.currentType,i),u,p);else{let S=y.getTempLocal(o);y.canOverflow(a,o)||y.setLocalFlag(S.index,2),y.isNonnull(a,o)&&y.setLocalFlag(S.index,4),p=r.if(this.makeIsTrueish(r.local_tee(S.index,a,o.isManaged),o,i),u,r.local_get(S.index,o.toRef()))}this.currentType=o}break}case 98:{let y=this.currentFlow,b=t&4;a=this.compileExpression(i,n.exceptVoid,b),o=this.currentType;let T=y.fork();if(this.currentFlow=T,T.inheritNonnullIfFalse(a),n==l.bool||n==l.void){a=this.makeIsTrueish(a,o,i);let S=this.evaluateCondition(a);S==1?p=a:(u=this.compileExpression(s,o,b),c=this.currentType,u=this.makeIsTrueish(u,c,s),S==2?p=u:p=r.if(a,r.i32(1),u)),this.currentFlow=y,this.currentType=l.bool}else{if(u=this.compileExpression(s,o,b|1),c=this.currentType,this.currentFlow=y,p=r.tryCopyTrivialExpression(a))p=r.if(this.makeIsTrueish(a,o,i),p,u);else{let S=y.getTempLocal(o).index;y.canOverflow(a,o)||y.setLocalFlag(S,2),y.isNonnull(a,o)&&y.setLocalFlag(S,4),p=r.if(this.makeIsTrueish(r.local_tee(S,a,o.isManaged),o,i),r.local_get(S,o.toRef()),u)}this.currentType=o}break}default:assert(!1),p=this.module.unreachable()}if(!d)return p;let m=this.resolver,g=m.lookupExpression(i,this.currentFlow);if(!g)return r.unreachable();let E=m.getTypeOfElement(g);return E||(E=l.void),this.currentType.isStrictlyAssignableTo(E)?this.makeAssignment(g,p,this.currentType,s,m.currentThisExpression,m.currentElementExpression,n!=l.void):(this.error(2322,e.range,this.currentType.toString(),E.toString()),r.unreachable())}makeLt(e,n,t){let r=this.module;switch(t.kind){case 1:case 2:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:return r.binary(17,e,n);case 4:return r.binary(42,e,n);case 5:return r.binary(213,e,n);case 0:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 8:return r.binary(18,e,n);case 9:return r.binary(43,e,n);case 10:return r.binary(214,e,n);case 11:return r.binary(59,e,n);case 12:return r.binary(72,e,n)}return assert(!1),r.unreachable()}makeGt(e,n,t){let r=this.module;switch(t.kind){case 1:case 2:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:return r.binary(21,e,n);case 4:return r.binary(46,e,n);case 5:return r.binary(217,e,n);case 0:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 8:return r.binary(22,e,n);case 9:return r.binary(47,e,n);case 10:return r.binary(218,e,n);case 11:return r.binary(61,e,n);case 12:return r.binary(74,e,n)}return assert(!1),r.unreachable()}makeLe(e,n,t){let r=this.module;switch(t.kind){case 1:case 2:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:return r.binary(19,e,n);case 4:return r.binary(44,e,n);case 5:return r.binary(215,e,n);case 0:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 8:return r.binary(20,e,n);case 9:return r.binary(45,e,n);case 10:return r.binary(216,e,n);case 11:return r.binary(60,e,n);case 12:return r.binary(73,e,n)}return assert(!1),r.unreachable()}makeGe(e,n,t){let r=this.module;switch(t.kind){case 1:case 2:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:return r.binary(23,e,n);case 4:return r.binary(48,e,n);case 5:return r.binary(219,e,n);case 0:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 8:return r.binary(24,e,n);case 9:return r.binary(49,e,n);case 10:return r.binary(220,e,n);case 11:return r.binary(62,e,n);case 12:return r.binary(75,e,n)}return assert(!1),r.unreachable()}makeEq(e,n,t,r){let i=this.module;switch(t.kind){case 0:case 1:case 2:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:case 8:return i.binary(15,e,n);case 4:case 9:return i.binary(40,e,n);case 5:case 10:return i.binary(211,e,n);case 11:return i.binary(57,e,n);case 12:return i.binary(70,e,n);case 13:return i.unary(70,i.binary(76,e,n));case 17:case 18:case 19:case 20:return i.ref_eq(e,n);case 21:return i.string_eq(e,n);case 22:case 23:case 24:case 14:case 15:case 16:return this.error(203,r.range,"ref.eq",t.toString()),i.unreachable()}return assert(!1),i.unreachable()}makeNe(e,n,t,r){let i=this.module;switch(t.kind){case 0:case 1:case 2:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:case 8:return i.binary(16,e,n);case 4:case 9:return i.binary(41,e,n);case 5:case 10:return i.binary(212,e,n);case 11:return i.binary(58,e,n);case 12:return i.binary(71,e,n);case 13:return i.unary(67,i.binary(77,e,n));case 17:case 18:case 19:case 20:return i.unary(20,i.ref_eq(e,n));case 21:return i.unary(20,i.string_eq(e,n));case 22:case 23:case 24:case 14:case 15:case 16:return this.error(203,r.range,"ref.eq",t.toString()),i.unreachable()}return assert(!1),i.unreachable()}makeAdd(e,n,t){let r=this.module;switch(t.kind){case 0:case 1:case 2:case 6:case 7:case 3:case 8:return r.binary(0,e,n);case 4:case 9:return r.binary(25,e,n);case 5:case 10:return r.binary(196,e,n);case 11:return r.binary(50,e,n);case 12:return r.binary(63,e,n)}return assert(!1),r.unreachable()}makeSub(e,n,t){let r=this.module;switch(t.kind){case 0:case 1:case 2:case 6:case 7:case 3:case 8:return r.binary(1,e,n);case 4:case 9:return r.binary(26,e,n);case 5:case 10:return r.binary(197,e,n);case 11:return r.binary(51,e,n);case 12:return r.binary(64,e,n)}return assert(!1),r.unreachable()}makeMul(e,n,t){let r=this.module;switch(t.kind){case 0:case 1:case 2:case 6:case 7:case 3:case 8:return r.binary(2,e,n);case 4:case 9:return r.binary(27,e,n);case 5:case 10:return r.binary(198,e,n);case 11:return r.binary(52,e,n);case 12:return r.binary(65,e,n)}return assert(!1),r.unreachable()}makePow(e,n,t,r){let i=this.module;switch(t.kind){case 0:return i.select(i.i32(1),i.binary(15,n,i.i32(0)),e,A.I32);case 1:case 6:case 2:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:case 8:{if(this.options.willOptimize&&H(e)==14&&H(n)==14){let o=Y(e),u=Y(n);return this.currentType=t,i.i32(i64_low(i64_pow(i64_new(o),i64_new(u))))}let s=this.i32PowInstance;if(!s){let o=this.program.lookup(v.ipow32);if(!o)return this.error(2304,r.range,"ipow32"),i.unreachable();assert(o.kind==4),this.i32PowInstance=s=this.resolver.resolveFunction(o,null)}if(!s||!this.compileFunction(s))return i.unreachable();let a=this.makeCallDirect(s,[e,n],r);return t.size<32&&(a=this.ensureSmallIntegerWrap(a,t)),a}case 4:case 9:{if(this.options.willOptimize&&H(e)==14&&H(n)==14){let a=i64_new(Be(e),Pe(e)),o=i64_new(Be(n),Pe(n)),u=i64_pow(a,o);return this.currentType=t,i.i64(i64_low(u),i64_high(u))}let s=this.i64PowInstance;if(!s){let a=this.program.lookup(v.ipow64);if(!a)return this.error(2304,r.range,"ipow64"),i.unreachable();assert(a.kind==4),this.i64PowInstance=s=this.resolver.resolveFunction(a,null)}return!s||!this.compileFunction(s)?i.unreachable():this.makeCallDirect(s,[e,n],r)}case 5:case 10:{let s=this.options.isWasm64;if(this.options.willOptimize&&H(e)==14&&H(n)==14)if(s){let o=i64_new(Be(e),Pe(e)),u=i64_new(Be(n),Pe(n)),c=i64_pow(o,u);return this.currentType=t,i.i64(i64_low(c),i64_high(c))}else{let o=Y(e),u=Y(n);return this.currentType=t,i.i32(i64_low(i64_pow(i64_new(o),i64_new(u))))}let a=s?this.i64PowInstance:this.i32PowInstance;if(!a){let o=this.program.lookup(s?v.ipow64:v.ipow32);if(!o)return this.error(2304,r.range,s?"ipow64":"ipow32"),i.unreachable();assert(o.kind==4),a=this.resolver.resolveFunction(o,null),s?this.i64PowInstance=a:this.i32PowInstance=a}return!a||!this.compileFunction(a)?i.unreachable():this.makeCallDirect(a,[e,n],r)}case 11:{if(this.options.willOptimize&&H(e)==14&&H(n)==14){let a=Fe(e),o=Fe(n);return this.currentType=t,i.f32(f32(Gs(a,o)))}let s=this.f32PowInstance;if(!s){let a=this.program.lookup(v.Mathf);if(!a)return this.error(2304,r.range,"Mathf"),i.unreachable();let o=a.members;if(!o||!o.has(v.pow))return this.error(2304,r.range,"Mathf.pow"),i.unreachable();let u=assert(o.get(v.pow));assert(u.kind==4),this.f32PowInstance=s=this.resolver.resolveFunction(u,null)}return!s||!this.compileFunction(s)?i.unreachable():this.makeCallDirect(s,[e,n],r)}case 12:{if(this.options.willOptimize&&H(e)==14&&H(n)==14){let a=Ae(e),o=Ae(n);return this.currentType=t,i.f64(Gs(a,o))}let s=this.f64PowInstance;if(!s){let a=this.program.lookup(v.Math);if(!a)return this.error(2304,r.range,"Math"),i.unreachable();let o=a.members;if(!o||!o.has(v.pow))return this.error(2304,r.range,"Math.pow"),i.unreachable();let u=assert(o.get(v.pow));assert(u.kind==4),this.f64PowInstance=s=this.resolver.resolveFunction(u,null)}return!s||!this.compileFunction(s)?i.unreachable():this.makeCallDirect(s,[e,n],r)}}return assert(!1),i.unreachable()}makeDiv(e,n,t){let r=this.module;switch(t.kind){case 1:case 2:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:return r.binary(3,e,n);case 4:return r.binary(28,e,n);case 5:return r.binary(199,e,n);case 0:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 8:return r.binary(4,e,n);case 9:return r.binary(29,e,n);case 10:return r.binary(200,e,n);case 11:return r.binary(53,e,n);case 12:return r.binary(66,e,n)}return assert(!1),r.unreachable()}makeRem(e,n,t,r){let i=this.module;switch(t.kind){case 1:case 2:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 3:return i.binary(5,e,n);case 4:return i.binary(30,e,n);case 5:return i.binary(201,e,n);case 0:case 6:case 7:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 8:return i.binary(6,e,n);case 9:return i.binary(31,e,n);case 10:return i.binary(202,e,n);case 11:{let s=this.f32ModInstance;if(!s){let a=this.program.lookup(v.Mathf);if(!a)return this.error(2304,r.range,"Mathf"),i.unreachable();let o=a.members;if(!o||!o.has(v.mod))return this.error(2304,r.range,"Mathf.mod"),i.unreachable();let u=assert(o.get(v.mod));assert(u.kind==4),this.f32ModInstance=s=this.resolver.resolveFunction(u,null)}return!s||!this.compileFunction(s)?i.unreachable():this.makeCallDirect(s,[e,n],r)}case 12:{let s=this.f64ModInstance;if(!s){let a=this.program.lookup(v.Math);if(!a)return this.error(2304,r.range,"Math"),i.unreachable();let o=a.members;if(!o||!o.has(v.mod))return this.error(2304,r.range,"Math.mod"),i.unreachable();let u=assert(o.get(v.mod));assert(u.kind==4),this.f64ModInstance=s=this.resolver.resolveFunction(u,null)}return!s||!this.compileFunction(s)?i.unreachable():this.makeCallDirect(s,[e,n],r)}}return assert(!1),i.unreachable()}makeShl(e,n,t){let r=this.module;switch(t.kind){case 0:return e;case 1:case 2:case 6:case 7:return r.binary(10,e,r.binary(7,n,r.i32(t.size-1)));case 3:case 8:return r.binary(10,e,n);case 4:case 9:return r.binary(35,e,n);case 5:case 10:return r.binary(206,e,n)}return assert(!1),r.unreachable()}makeShr(e,n,t){let r=this.module;switch(t.kind){case 0:return e;case 1:case 2:return r.binary(11,this.ensureSmallIntegerWrap(e,t),r.binary(7,n,r.i32(t.size-1)));case 6:case 7:return r.binary(12,this.ensureSmallIntegerWrap(e,t),r.binary(7,n,r.i32(t.size-1)));case 3:return r.binary(11,e,n);case 4:return r.binary(36,e,n);case 5:return r.binary(207,e,n);case 8:return r.binary(12,e,n);case 9:return r.binary(37,e,n);case 10:return r.binary(208,e,n)}return assert(!1),r.unreachable()}makeShru(e,n,t){let r=this.module;switch(t.kind){case 0:return e;case 1:case 2:case 6:case 7:return r.binary(12,this.ensureSmallIntegerWrap(e,t),r.binary(7,n,r.i32(t.size-1)));case 3:case 8:return r.binary(12,e,n);case 4:case 9:return r.binary(37,e,n);case 5:case 10:return r.binary(208,e,n)}return assert(!1),r.unreachable()}makeAnd(e,n,t){let r=this.module;switch(t.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:return r.binary(7,e,n);case 4:case 9:return r.binary(32,e,n);case 5:case 10:return r.binary(203,e,n)}return assert(!1),r.unreachable()}makeOr(e,n,t){let r=this.module;switch(t.kind){case 0:case 1:case 2:case 6:case 7:return r.binary(8,e,n);case 3:case 8:return r.binary(8,e,n);case 4:case 9:return r.binary(33,e,n);case 5:case 10:return r.binary(204,e,n)}return assert(!1),r.unreachable()}makeXor(e,n,t){let r=this.module;switch(t.kind){case 0:case 1:case 2:case 6:case 7:return r.binary(9,e,n);case 3:case 8:return r.binary(9,e,n);case 4:case 9:return r.binary(34,e,n);case 5:case 10:return r.binary(205,e,n)}return assert(!1),r.unreachable()}compileUnaryOverload(e,n,t,r){return this.makeCallDirect(e,[t],r,!1)}compileBinaryOverload(e,n,t,r,i,s){if(e.hasDecorator(512))if(i.isLiteralKind(2)){let f=i.value.length,p=new Array;p.push(n),p.push(i);let d=F.createIdentifierExpression("__eq"+f.toString(),s.range),m=F.createCallExpression(d,null,p,s.range),g=s.operator;return(g==79||g==77)&&(m=F.createUnaryPrefixExpression(95,m,m.range)),this.compileExpression(m,l.bool)}else return this.error(1141,i.range),this.module.unreachable();let a,o=e.signature,u=o.parameterTypes;e.is(262144)?(t=this.convertExpression(t,r,assert(o.thisType),!1,n),a=u[0]):(t=this.convertExpression(t,r,u[0],!1,n),a=u[1]);let c=this.compileExpression(i,a,1);return this.makeCallDirect(e,[t,c],s)}compileAssignment(e,n,t){let r=this.program.resolver,i=this.currentFlow,s=r.lookupExpression(e,i);if(!s)return this.module.unreachable();let a=r.currentThisExpression,o=r.currentElementExpression,u;switch(s.kind){case 0:if(!this.compileGlobal(s))return this.module.unreachable();case 1:case 11:{if(this.pendingElements.has(s))return this.error(2448,e.range,s.internalName),this.module.unreachable();u=s.type,s.hasDecorator(2048)&&this.checkUnsafe(e);break}case 12:{let p=s,d=r.resolveProperty(p);if(!d)return this.module.unreachable();s=d}case 13:{let p=s,d=p.setterInstance;if(!d)return this.error(2540,e.range,p.internalName),this.module.unreachable();assert(d.signature.parameterTypes.length==1),u=d.signature.parameterTypes[0],d.hasDecorator(2048)&&this.checkUnsafe(e);break}case 17:{let p=s.parent;assert(p.kind==7);let d=p,m=i.is(32768),g=d.lookupOverload(2,m);if(!g)return d.lookupOverload(1,m)?this.error(2542,e.range,d.internalName):this.error(2329,e.range,d.internalName),this.module.unreachable();let E=g.signature.parameterTypes;assert(E.length==2),u=E[1],g.hasDecorator(2048)&&this.checkUnsafe(e),!m&&this.options.pedantic&&this.pedantic(904,e.range);break}default:return this.error(2540,e.range,s.internalName),this.module.unreachable()}assert(u!=l.void);let c=this.compileExpression(n,u),f=this.currentType;return this.makeAssignment(s,this.convertExpression(c,f,u,!1,n),f,n,a,o,t!=l.void)}makeAssignment(e,n,t,r,i,s,a){let o=this.module,u=this.currentFlow;switch(e.kind){case 1:{let c=e;return u.isLocalFlag(c.index,1,!0)?(this.error(2540,r.range,e.internalName),this.currentType=a?c.type:l.void,o.unreachable()):this.makeLocalAssignment(c,n,t,a)}case 0:{let c=e;return this.compileGlobal(c)?e.isAny(72)?(this.error(2540,r.range,e.internalName),this.currentType=a?c.type:l.void,o.unreachable()):this.makeGlobalAssignment(c,n,t,a):o.unreachable()}case 11:{let c=e,f=c.initializerNode,p=u.sourceFunction.is(524288);if(c.is(64)&&(!p||f))return this.error(2540,r.range,c.internalName),o.unreachable();i=assert(i),p&&i.kind==24&&u.setThisFieldFlag(c,1);let d=c.parent;return assert(d.kind==7),this.makeFieldAssignment(c,n,t,this.compileExpression(i,d.type,33),a)}case 13:{let c=e,f=c.setterInstance;if(!f)return this.error(2540,r.range,e.internalName),o.unreachable();if(assert(f.signature.parameterTypes.length==1),c.is(262144)){let p=assert(f.signature.thisType),d=this.compileExpression(assert(i),p,33);if(!a)return this.makeCallDirect(f,[d,n],r);let m=assert(e.getterInstance);assert(m.signature.thisType==p);let g=m.signature.returnType,E=g.toRef(),y=u.getTempLocal(g);return o.block(null,[this.makeCallDirect(f,[o.local_tee(y.index,d,g.isManaged),n],r),this.makeCallDirect(m,[o.local_get(y.index,E)],r)],E)}else{if(!a)return this.makeCallDirect(f,[n],r);let p=assert(e.getterInstance);return o.block(null,[this.makeCallDirect(f,[n],r),this.makeCallDirect(p,null,r)],p.signature.returnType.toRef())}}case 17:{let c=e.parent;assert(c.kind==7);let f=c;assert(f.kind==7);let p=u.is(32768),d=f.lookupOverload(1,p);if(!d)return this.error(2329,r.range,f.internalName),o.unreachable();let m=f.lookupOverload(2,p);if(!m)return this.error(2542,r.range,f.internalName),this.currentType=a?d.signature.returnType:l.void,o.unreachable();assert(m.signature.parameterTypes.length==2);let g=f.type,E=this.compileExpression(assert(i),g,33),y=m.signature.parameterTypes[0],b=d.signature.parameterTypes[0];if(!y.equals(b))return this.errorRelated(237,d.identifierAndSignatureRange,m.identifierAndSignatureRange,f.internalName),this.currentType=a?d.signature.returnType:l.void,o.unreachable();let T=this.compileExpression(assert(s),y,1),S=this.currentType;if(a){let C=u.getTempLocal(g),w=u.getTempLocal(S),B=d.signature.returnType;return o.block(null,[this.makeCallDirect(m,[o.local_tee(C.index,E,g.isManaged),o.local_tee(w.index,T,S.isManaged),n],r),this.makeCallDirect(d,[o.local_get(C.index,C.type.toRef()),o.local_get(w.index,w.type.toRef())],r)],B.toRef())}else return this.makeCallDirect(m,[E,T,n],r)}default:this.error(2541,r.range)}return o.unreachable()}makeLocalAssignment(e,n,t,r){let i=this.module,s=this.currentFlow,a=e.type;assert(a!=l.void);let o=e.index;return a.isNullableReference&&(!t.isNullableReference||s.isNonnull(n,a)?s.setLocalFlag(o,4):s.unsetLocalFlag(o,4)),s.setLocalFlag(o,8),a.isShortIntegerValue&&(s.canOverflow(n,a)?s.unsetLocalFlag(o,2):s.setLocalFlag(o,2)),r?(this.currentType=a,i.local_tee(o,n,a.isManaged)):(this.currentType=l.void,i.local_set(o,n,a.isManaged))}makeGlobalAssignment(e,n,t,r){let i=this.module,s=e.type;assert(s!=l.void);let a=s.toRef();return n=this.ensureSmallIntegerWrap(n,s),r?(this.currentType=s,i.block(null,[i.global_set(e.internalName,n),i.global_get(e.internalName,a)],a)):(this.currentType=l.void,i.global_set(e.internalName,n))}makeFieldAssignment(e,n,t,r,i){let s=this.module,a=this.currentFlow,o=e.type,u=o.toRef();assert(e.parent.kind==7);let c=e.parent.type;if(!e.is(8388608)){e.set(8388608);let f=e.typeNode;f&&this.checkTypeSupported(e.type,f)}if(i){this.compileField(e);let f=a.getTempLocal(c),p=s.block(null,[s.call(e.internalSetterName,[s.local_tee(f.index,r,c.isManaged),n],A.None),s.call(e.internalGetterName,[s.local_get(f.index,c.toRef())],u)],u);return this.currentType=o,p}else{this.compileFieldSetter(e);let f=s.call(e.internalSetterName,[r,n],A.None);return this.currentType=l.void,f}}compileCallExpression(e,n,t){let r=this.module,i=this.currentFlow;if(e.expression.kind==23){let c=this.currentFlow,f=c.sourceFunction;if(!f.is(524288))return this.error(2337,e.range),r.unreachable();let p=assert(f.parent);assert(p.kind==7);let d=p,m=d.base;if(!m)return this.error(2335,e.expression.range),r.unreachable();let g=assert(c.lookupLocal(v.this_)),E=this.options.sizeTypeRef,y=this.ensureConstructor(m,e);this.checkFieldInitialization(m,e);let b=this.compileCallDirect(y,e.args,e,r.local_get(g.index,E));return c.isAny(8256)?(this.error(17009,e.range),r.unreachable()):(c.set(192),this.currentType=l.void,r.local_set(g.index,b,d.type.isManaged))}let s=this.resolver.lookupExpression(e.expression,i);if(!s)return r.unreachable();let a=this.resolver.currentThisExpression,o,u;switch(s.kind){case 4:{let c=s;if(c.hasDecorator(512))return this.compileCallExpressionBuiltin(c,e,n);let f=this.resolver.maybeInferCall(e,c,i);if(!f)return this.module.unreachable();s=f}case 5:{let c=s,f=0;return c.is(262144)&&(f=this.compileExpression(assert(a),assert(c.signature.thisType),33)),this.compileCallDirect(c,e.args,e,f,t)}case 1:{let c=s;if(o=c.type.signatureReference,o){if(c.parent!=i.targetFunction)return this.error(100,e.range,"Closures"),r.unreachable();if(c.is(33554432)){let f=c.constantIntegerValue;this.options.isWasm64?u=r.i64(i64_low(f),i64_high(f)):(assert(!i64_high(f)),u=r.i32(i64_low(f)))}else u=r.local_get(c.index,this.options.sizeTypeRef);break}return this.error(2349,e.range,c.type.toString()),r.unreachable()}case 0:{let c=s;if(o=c.type.signatureReference,o){u=r.global_get(c.internalName,c.type.toRef());break}return this.error(2349,e.range,c.type.toString()),r.unreachable()}case 11:{let c=s,f=c.type;if(o=f.signatureReference,o){let p=c.parent;assert(p.kind==7);let d=this.options.usizeType;u=r.load(d.byteSize,!1,this.compileExpression(assert(a),p.type,33),d.toRef(),c.memoryOffset);break}return this.error(2349,e.range,f.toString()),r.unreachable()}case 12:{let c=this.resolver.resolveProperty(s);if(!c)return r.unreachable();s=c}case 13:{let c=s,f=c.getterInstance,p=assert(this.resolver.getTypeOfElement(s));if(!f)return this.error(2349,e.range,p.toString()),r.unreachable();let d=0;if(c.is(262144)&&(d=this.compileExpression(assert(a),assert(f.signature.thisType),33)),u=this.compileCallDirect(f,[],e.expression,d),o=this.currentType.signatureReference,!o)return this.error(2349,e.range,this.currentType.toString()),r.unreachable();break}case 7:{let c=s.getTypeArgumentsTo(this.program.functionPrototype);if(c&&c.length>0){let f=c[0];o=f.getSignature(),u=this.compileExpression(e.expression,f,1);break}}default:{let c=this.resolver.getTypeOfElement(s);return c?this.error(2757,e.range,c.toString()):this.error(225,e.range),r.unreachable()}}return this.compileCallIndirect(assert(o),u,e.args,e,0,n==l.void)}compileCallExpressionLike(e,n,t,r,i,s=0){let a=this._reusableCallExpression;return a?(a.expression=e,a.typeArguments=n,a.args=t,a.range=r):this._reusableCallExpression=a=F.createCallExpression(e,n,t,r),this.compileCallExpression(a,i,s)}compileCallExpressionBuiltin(e,n,t){e.hasDecorator(2048)&&this.checkUnsafe(n);let r=null,i=e.typeParameterNodes,s=n.typeArguments;n.typeArguments&&(e.is(65536)||this.error(2315,n.range,e.internalName),r=this.resolver.resolveTypeArguments(assert(i),s,this.currentFlow.sourceFunction.parent,de(this.currentFlow.contextualTypeArguments),n));let a=n.expression,o=new iy(this,e,r,n.args,a.kind==21?a.expression:null,t,n,!1),u=e.internalName;if(x.has(u))return assert(x.get(u))(o);let c=e.parent;if(c.kind==7&&c.prototype==this.program.functionPrototype){let f=e.name;if(Ks.has(f))return assert(Ks.get(f))(o)}return assert(!1),this.module.unreachable()}checkCallSignature(e,n,t,r){let i=e.thisType;if(t!=(i!=null))return this.error(2685,r.range),!1;let s=e.hasRest;if(s)return this.error(100,r.range,"Rest parameters"),!1;let a=e.requiredParameters,o=e.parameterTypes.length;return n<a?(this.error(a<o?2555:2554,r.range,a.toString(),n.toString()),!1):n>o&&!s?(this.error(2554,r.range,o.toString(),n.toString()),!1):!0}checkUnsafe(e,n=null){this.options.noUnsafe&&!e.range.source.isLibrary&&(n?this.errorRelated(101,e.range,n.range):this.error(101,e.range))}compileCallDirect(e,n,t,r=0,i=0){let s=n.length,a=e.signature;if(!this.checkCallSignature(a,s,r!=0,t))return this.currentType=a.returnType,this.module.unreachable();e.hasDecorator(2048)&&this.checkUnsafe(t);let o=this.currentFlow.sourceFunction;if(o.is(524288)&&t.isAccessOnThis){let d=o.parent;assert(d.kind==7),this.checkFieldInitialization(d,t)}if(e.hasDecorator(64)&&(!e.is(268435456)||t.isAccessOnSuper)){assert(!e.is(134217728));let d=this.inlineStack;if(d.includes(e))this.warning(217,t.range,e.internalName);else{let m=a.parameterTypes;assert(s<=m.length);let g=new Array(s);for(let y=0;y<s;++y)g[y]=this.compileExpression(n[y],m[y],1);d.push(e);let E=this.makeCallInline(e,g,r,(i&8)!=0);return d.pop(),E}}let u=r?s+1:s,c=new Array(u),f=0;r&&(c[0]=r,f=1);let p=a.parameterTypes;for(let d=0;d<s;++d,++f){let m=p[d],g=this.compileExpression(n[d],m,1);c[f]=g}return assert(f==u),this.makeCallDirect(e,c,t,(i&8)!=0)}makeCallInline(e,n,t=0,r=!1){let i=this.module,s=n?n.length:0,a=e.signature.parameterTypes,o=a.length,u=this.currentFlow,c=Wn.createInline(u.targetFunction,e),f=[];if(t){let m=assert(e.parent);assert(m.kind==7);let g=m,E=assert(e.signature.thisType),y=c.addScopedLocal(v.this_,E);f.push(i.local_set(y.index,t,E.isManaged));let b=g.base;b&&c.addScopedAlias(v.super_,b.type,y.index)}else assert(!e.signature.thisType);for(let m=0;m<s;++m){let g=n[m],E=a[m],y=c.addScopedLocal(e.getParameterName(m),E);u.canOverflow(g,E)||c.setLocalFlag(y.index,2),c.isNonnull(g,E)&&c.setLocalFlag(y.index,4),f.push(i.local_set(y.index,g,E.isManaged))}this.currentFlow=c;let p=e.is(524288);p&&c.set(65536);for(let m=s;m<o;++m){let g=a[m],E=this.compileExpression(assert(e.prototype.functionTypeNode.parameters[m].initializer),g,1),y=c.addScopedLocal(e.getParameterName(m),g);f.push(this.makeLocalAssignment(y,E,g,!1))}if(c.unset(65536),this.compileFunctionBody(e,f),p){let m=e.parent;assert(m.kind==7),this.checkFieldInitializationInFlow(m,c)}let d=c.returnType;return this.currentFlow=u,this.currentType=d,i.block(c.inlineReturnLabel,f,d.toRef())}ensureArgumentsLength(){let e=h.argumentsLength;if(!this.builtinArgumentsLength){let n=this.module;this.builtinArgumentsLength=n.addGlobal(e,A.I32,!0,n.i32(0))}return e}ensureVarargsStub(e){let n=e.varargsStub;if(n)return n;let t=e.signature,r=t.parameterTypes,i=e.prototype.functionTypeNode.parameters,s=t.returnType,a=e.is(262144),o=t.requiredParameters,u=o,c=r.length,f=c;a&&(++u,++f);let p=assert(f-u),d=new Array(u),m=0,g=new Array,E=this.module,y=t.thisType;y&&(d[0]=E.local_get(0,y.toRef()),m=1);for(let P=0;P<o;++P,++m){let j=r[P];d[m]=E.local_get(m,j.toRef())}assert(m==u),n=e.newStub("varargs"),n.signature.requiredParameters=c,e.varargsStub=n;let b=this.currentFlow,T=n.flow;e.is(524288)&&T.set(65536),this.currentFlow=T;let S=p+1,C=new Array(S),w=`of${p}`;for(let P=0;P<S;++P)C[P]=`${P}${w}`;let B=this.ensureArgumentsLength(),D=E.block(C[0],[E.block("outOfRange",[E.switch(C,"outOfRange",o?E.binary(1,E.global_get(B,A.I32),E.i32(o)):E.global_get(B,A.I32))]),E.unreachable()]);for(let P=0;P<p;++P,++m){let j=r[o+P],ce=i[o+P],le=ce.initializer,Ge;le?(Ge=this.compileExpression(le,j,1),Ge=E.local_set(m,Ge,j.isManaged)):(this.error(215,ce.range),Ge=E.unreachable()),D=E.block(C[P+1],[D,Ge]),d[m]=E.local_get(m,j.toRef())}assert(m==f),g.push(D),g.push(this.makeCallDirect(e,d,e.declaration.name)),this.currentFlow=b;let W=E.addFunction(n.internalName,n.signature.paramRefs,n.signature.resultRefs,Kt(n.getNonParameterLocalTypes()),E.flatten(g,s.toRef()));return n.set(8388608),n.finalize(E,W),n}ensureVirtualStub(e){let n=e.virtualStub;if(n)return n;n=e.newStub("virtual"),e.virtualStub=n;let t=this.module;return n.ref=t.addFunction(n.internalName,n.signature.paramRefs,n.signature.resultRefs,null,t.unreachable()),this.virtualStubs.add(e),n}finalizeVirtualStub(e){let n=this.ensureVirtualStub(e);if(n.is(8388608))return;assert(e.parent.kind==7||e.parent.kind==9);let t=this.module,r=this.options.usizeType.toRef(),i=e.signature.parameterTypes,s=e.signature.returnType,a=i.length,o=1+i.length,u=new Ul(this.module,t.load(4,!1,t.binary(r==A.I64?26:1,t.local_get(0,r),r==A.I64?t.i64(8):t.i32(8)),A.I32)),c=this.resolver.resolveOverloads(e);if(c)for(let p=0,d=c.length;p<d;++p){let m=c[p];if(!m.is(8388608))continue;let g=m.type,E=e.type;if(!g.isAssignableTo(E)){this.error(2322,m.identifierNode.range,g.toString(),E.toString());continue}let y=m.signature,b=y.parameterTypes,T=b.length,S=new Array(1+T);S[0]=t.local_get(0,r);for(let j=1;j<=a;++j)S[j]=t.local_get(j,i[j-1].toRef());let C=!1;for(let j=a;j<T;++j)S[1+j]=this.makeZero(b[j]),C=!0;let w=C?this.ensureVarargsStub(m).internalName:m.internalName,B=y.returnType.toRef(),D=new Array;C&&D.push(t.global_set(this.ensureArgumentsLength(),t.i32(a))),s==l.void?(D.push(t.call(w,S,B)),D.push(t.return())):D.push(t.return(t.call(w,S,B)));let W=assert(m.getClassOrInterface());u.addCase(W.id,D);let P=W.getAllExtendees(e.declaration.name.text);for(let j=Set_values(P),ce=0,le=j.length;ce<le;++ce){let Ge=j[ce];u.addCase(Ge.id,D)}}let f;if(e.prototype.bodyNode){let p=new Array(a);p[0]=t.local_get(0,r);for(let d=0,m=i.length;d<m;++d)p[1+d]=t.local_get(1+d,i[d].toRef());f=t.call(e.internalName,p,s.toRef())}else f=t.unreachable();n.ref&&t.removeFunction(n.internalName),n.ref=t.addFunction(n.internalName,n.signature.paramRefs,n.signature.resultRefs,[A.I32],t.block(null,[u.render(o),f],s.toRef())),n.set(8388608)}operandsTostack(e,n){if(!this.options.stackSize)return;let t=this.module,r=0,i=e.thisType;if(i){if(i.isManaged){let o=n[0],u=t.runExpression(o,0);Me(u)||(n[r]=t.tostack(o))}++r}let s=0,a=e.parameterTypes;for(assert(a.length>=n.length-r);r<n.length;){if(a[s].isManaged){let o=n[r],u=t.runExpression(o,0);Me(u)||(n[r]=t.tostack(o))}++r,++s}}makeCallDirect(e,n,t,r=!1){if(e.hasDecorator(64))if(e.is(268435456))this.warning(228,t.range,e.internalName);else{assert(!e.is(134217728));let m=this.inlineStack;if(m.includes(e))this.warning(217,t.range,e.internalName);else{m.push(e);let g;if(e.is(262144)){let E=assert(n);assert(E.length),g=this.makeCallInline(e,E.slice(1),E[0],r)}else g=this.makeCallInline(e,n,0,r);return m.pop(),g}}let i=this.module,s=n?n.length:0,a=s,o=e.signature.requiredParameters,u=e.signature.parameterTypes,c=u.length,f=c;if(e.is(262144)&&(++o,++f,--a),assert(s>=o),!this.compileFunction(e))return i.unreachable();let p=e.signature.returnType;if(s<f){n||(n=new Array(f),n.length=0);let m=e.prototype.functionTypeNode.parameters;assert(m.length==u.length);let g=!0;for(let E=a;E<c;++E){let y=m[E].initializer;if(y){if(y.compilesToConst){n.push(this.compileExpression(y,u[E],1));continue}let b=this.resolver.lookupExpression(y,e.flow,u[E],1);if(b&&b.kind==0){let T=b;if(this.compileGlobal(T)){T.is(33554432)?n.push(this.compileInlineConstant(T,u[E],1)):n.push(this.convertExpression(i.global_get(T.internalName,T.type.toRef()),T.type,u[E],!1,y));continue}}}n.push(this.makeZero(u[E])),g=!1}if(!g&&!e.is(2097152)){let E=e;if(e=this.ensureVarargsStub(e),!this.compileFunction(e))return i.unreachable();e.flow.flags=E.flow.flags;let y=p.toRef(),b=n[f-1];assert(!(Qt(b,i.ref)&32));let T=u[c-1];n[f-1]=i.block(null,[i.global_set(this.ensureArgumentsLength(),i.i32(a)),b],T.toRef()),this.operandsTostack(e.signature,n);let S=i.call(e.internalName,n,y);return p!=l.void&&r?(S=i.drop(S),this.currentType=l.void):this.currentType=p,S}}e.is(268435456)&&!t.isAccessOnSuper&&(e=this.ensureVirtualStub(e)),n&&this.operandsTostack(e.signature,n);let d=i.call(e.internalName,n,p.toRef());return this.currentType=p,d}compileCallIndirect(e,n,t,r,i=0,s=!1){let a=t.length;if(!this.checkCallSignature(e,a,i!=0,r))return this.module.unreachable();let o=i?a+1:a,u=new Array(o),c=0;i&&(u[0]=i,c=1);let f=e.parameterTypes;for(let p=0;p<a;++p,++c)u[c]=this.compileExpression(t[p],f[p],1);return assert(c==o),this.makeCallIndirect(e,n,r,u,s)}makeCallIndirect(e,n,t,r=null,i=!1){let s=this.module,a=r?r.length:0,o=a,u=e.requiredParameters,c=e.parameterTypes,f=e.returnType,p=c.length,d=p;if(e.thisType&&(++u,++d,--o),assert(a>=u),a<d){r||(r=new Array(d),r.length=0);let y=e.parameterTypes;for(let b=o;b<p;++b)r.push(this.makeZero(y[b]))}let m=this.ensureArgumentsLength(),g=this.options.sizeTypeRef;if(Qt(n,s.ref)&32){let y=this.currentFlow.getTempLocal(this.options.usizeType).index;n=s.block(null,[s.local_set(y,n,!0),s.global_set(m,s.i32(o)),s.local_get(y,g)],g)}else n=s.block(null,[s.global_set(m,s.i32(o)),n],g);r&&this.operandsTostack(e,r);let E=s.call_indirect(null,s.load(4,!1,n,A.I32),r,e.paramRefs,e.resultRefs);return this.currentType=f,E}compileCommaExpression(e,n,t){let r=e.expressions,i=r.length,s=new Array(i--);for(let a=0;a<i;++a)s[a]=this.compileExpression(r[a],l.void,9);return s[i]=this.compileExpression(r[i],n,t),this.module.flatten(s,this.currentType.toRef())}compileElementAccessExpression(e,n,t){let r=this.module,i=e.expression,s=this.resolver.resolveExpression(i,this.currentFlow);if(s){let a=s.getClassOrWrapper(this.program);if(a){let o=this.currentFlow.is(32768),u=a.lookupOverload(1,o);if(u){let c=assert(u.signature.thisType),f=this.compileExpression(i,c,1);return!o&&this.options.pedantic&&this.pedantic(904,e.range),this.compileCallDirect(u,[e.elementExpression],e,f,t)}}this.error(2329,e.expression.range,s.toString())}return r.unreachable()}compileFunctionExpression(e,n,t){let r=e.declaration.clone();assert(!r.typeParameters);let i=this.currentFlow,s=i.sourceFunction,a=r.name.text.length>0,o=!a||n!=l.void,u=new pn(o?`${a?r.name.text:"anonymous"}|${s.nextAnonymousId++}`:r.name.text,s,r,0),c,f=de(i.contextualTypeArguments),p=this.module,d=n.signatureReference;if(d){let E=u.functionTypeNode,y=E.parameters,b=y.length,T=d.parameterTypes,S=T.length;if(b>S)return this.error(2554,e.range,S.toString(),b.toString()),p.unreachable();for(let P=0;P<b;++P){let j=y[P];if(!Ve(j.type)){let ce=this.resolver.resolveType(j.type,s.parent,f);if(!ce)return p.unreachable();if(!T[P].isStrictlyAssignableTo(ce))return this.error(2322,j.range,T[P].toString(),ce.toString()),p.unreachable()}}let C=d.returnType;if(!Ve(E.returnType)){let P=this.resolver.resolveType(E.returnType,s.parent,f);if(!P)return p.unreachable();if(C==l.void?P!=l.void:!P.isStrictlyAssignableTo(C))return this.error(2322,E.returnType.range,P.toString(),C.toString()),p.unreachable()}let w=d.thisType,B=E.explicitThisType;if(B){if(!w)return this.error(2332,B.range),p.unreachable();let P=this.resolver.resolveType(B,s.parent,f);if(!P)return p.unreachable();if(!w.isStrictlyAssignableTo(P))return this.error(2322,B.range,w.toString(),P.toString()),p.unreachable()}let D=new tn(this.program,T,C,w);D.requiredParameters=S,c=new Hn(u.name,u,null,D,f),c.flow.outer=i;let W=this.compileFunction(c);if(this.currentType=d.type,!W)return p.unreachable()}else{if(c=this.resolver.resolveFunction(u,null,f),!c)return this.module.unreachable();c.flow.outer=i;let E=this.compileFunction(c);if(this.currentType=c.signature.type,!E)return p.unreachable()}let m=this.ensureRuntimeFunction(c),g=this.options.isWasm64?p.i64(i64_low(m),i64_high(m)):p.i32(i64_low(m));if(!o){let E=c.name,y=i.getScopedLocal(E);if(y)y.declaration.range.source.isNative?this.error(2300,r.name.range,E):this.errorRelated(2300,r.name.range,y.declaration.name.range,E);else{let b=c.type,T=i.addScopedLocal(c.name,b);i.setLocalFlag(T.index,1),g=p.local_tee(T.index,g,b.isManaged)}}return g}maybeCompileEnclosingSource(e){let n=e.range.source.internalPath,t=this.program.filesByName;assert(t.has(n)),assert(t.get(n)).is(8388608)||this.compileFileByPath(n,e)}compileIdentifierExpression(e,n,t){let r=this.module,i=this.currentFlow,s=i.sourceFunction;switch(e.kind){case 18:{let u=this.options;if(n.isReference){let c=n.getClass();if(c)return this.currentType=c.type.asNullable(),u.isWasm64?r.i64(0):r.i32(0);let f=n.getSignature();return f?(this.currentType=f.type.asNullable(),u.isWasm64?r.i64(0):r.i32(0)):this.makeZero(n)}return this.currentType=u.usizeType,this.warning(226,e.range,this.currentType.toString()),u.isWasm64?r.i64(0):r.i32(0)}case 25:return this.currentType=l.bool,r.i32(1);case 13:return this.currentType=l.bool,r.i32(0);case 24:{let u=s.signature.thisType;if(!u)return this.error(2332,e.range),this.currentType=this.options.usizeType,r.unreachable();if(s.is(524288)&&(i.is(65536)&&this.error(2333,e.range),!(t&32))){let f=s.parent;assert(f.kind==7),this.checkFieldInitialization(f,e)}let c=assert(i.lookupLocal(v.this_));return i.set(64),this.currentType=u,r.local_get(c.index,u.toRef())}case 23:{if(s.is(524288)&&(i.is(65536)?this.error(2336,e.range):i.is(128)||this.error(17011,e.range)),i.isInline){let u=i.lookupLocal(v.this_);if(u){let c=assert(u.type.getClass()).base;if(c)return this.currentType=c.type,r.local_get(u.index,c.type.toRef())}}if(s.is(262144)){let u=assert(s.parent);assert(u.kind==7);let c=u.base;if(c){let f=c.type;return this.currentType=f,r.local_get(0,f.toRef())}}return this.error(2335,e.range),this.currentType=this.options.usizeType,r.unreachable()}}this.maybeCompileEnclosingSource(e);let a=this.currentParent;a||(a=s);let o=this.resolver.lookupIdentifierExpression(e,i,a);if(!o)return this.currentType==l.void&&(this.currentType=l.i32),r.unreachable();switch(o.kind){case 1:{let u=o,c=u.type;if(assert(c!=l.void),this.pendingElements.has(u))return this.error(2448,e.range,u.internalName),this.currentType=c,r.unreachable();if(u.is(33554432))return this.compileInlineConstant(u,n,t);let f=u.index;return assert(f>=0),c.isNullableReference&&i.isLocalFlag(f,4,!1)&&(c=c.nonNullableType),this.currentType=c,o.parent!=i.targetFunction?(this.error(100,e.range,"Closures"),r.unreachable()):r.local_get(f,c.toRef())}case 0:{let u=o;if(!this.compileGlobal(u))return r.unreachable();let c=u.type;return this.pendingElements.has(u)?(this.error(2448,e.range,u.internalName),this.currentType=c,r.unreachable()):(assert(c!=l.void),u.is(33554432)?this.compileInlineConstant(u,n,t):(this.currentType=c,r.global_get(u.internalName,c.toRef())))}case 3:{let u=o;return o.is(8388608)?(this.currentType=l.i32,u.is(33554432)?(assert(u.constantValueKind==1),r.i32(i64_low(u.constantIntegerValue))):r.global_get(u.internalName,A.I32)):(this.error(2651,e.range),this.currentType=l.i32,r.unreachable())}case 4:{let u=o,c=u.typeParameterNodes;if(c&&c.length!=0){this.error(1140,e.range);break}let f=this.resolver.resolveFunction(u,null,de(i.contextualTypeArguments));if(!f||!this.compileFunction(f))return r.unreachable();if(f.hasDecorator(512))return this.error(100,e.range,"First-class built-ins"),this.currentType=f.type,r.unreachable();if(n.isExternalReference)return this.currentType=l.funcref,r.ref_func(f.internalName,ls(f.type));let p=this.ensureRuntimeFunction(f);return this.currentType=f.signature.type,this.options.isWasm64?r.i64(i64_low(p),i64_high(p)):r.i32(i64_low(p))}}return this.error(234,e.range),r.unreachable()}compileInstanceOfExpression(e,n,t){let r=this.currentFlow,i=e.isType;if(i.kind==1){let a=i;if(!(a.isNullable||a.hasTypeArguments)){let o=this.resolver.resolveTypeName(a.name,r.sourceFunction,1);if(o&&o.kind==6){let u=o;if(u.is(65536))return this.makeInstanceofClass(e,u)}}}let s=this.resolver.resolveType(e.isType,r.sourceFunction,de(r.contextualTypeArguments));return s?this.makeInstanceofType(e,s):(this.currentType=l.bool,this.module.unreachable())}makeInstanceofType(e,n){let t=this.module,r=this.currentFlow,i=this.compileExpression(e.expression,n),s=this.currentType;if(this.currentType=l.bool,n.isValue)return t.maybeDropCondition(i,t.i32(s==n?1:0));if(s.isValue)return t.maybeDropCondition(i,t.i32(0));let a=s.toRef();if(s.isNullableReference&&!n.isNullableReference){if(s.nonNullableType.isAssignableTo(n))return t.binary(a==A.I64?41:16,i,this.makeZero(s));if(n.isAssignableTo(s)){let o=this.program;if(s.isUnmanaged||n.isUnmanaged)this.error(2365,e.range,"instanceof",s.toString(),n.toString());else{let u=r.getTempLocal(s).index,c=assert(o.instanceofInstance);this.compileFunction(c);let f=t.if(t.unary(a==A.I64?21:20,t.local_tee(u,i,s.isManaged)),t.i32(0),this.makeCallDirect(c,[t.local_get(u,a),t.i32(n.classReference.id)],e));return this.options.pedantic&&this.pedantic(903,e.range),f}}}else{if(s.isAssignableTo(n))return t.maybeDropCondition(i,t.i32(1));if(n.isAssignableTo(s)){let o=this.program;if(s.isUnmanaged||n.isUnmanaged)this.error(2365,e.range,"instanceof",s.toString(),n.toString());else{let u=r.getTempLocal(s).index,c=assert(o.instanceofInstance);return this.compileFunction(c),t.if(t.unary(a==A.I64?21:20,t.local_tee(u,i,s.isManaged)),t.i32(0),this.makeCallDirect(c,[t.local_get(u,a),t.i32(n.classReference.id)],e))}}}return t.maybeDropCondition(i,t.i32(0))}makeInstanceofClass(e,n){let t=this.module,r=this.compileExpression(e.expression,l.auto),i=this.currentType,s=i.toRef();this.currentType=l.bool;let a=i.getClass();if(a){if(a.extends(n))return i.isNullableReference?t.binary(s==A.I64?41:16,r,this.makeZero(i)):t.maybeDropCondition(r,t.i32(1));if(n.extends(a.prototype))return this.pendingClassInstanceOf.add(n),t.call(`${n.internalName}~instanceof`,[r],A.I32)}return t.maybeDropCondition(r,t.i32(0))}compileLiteralExpression(e,n,t,r=!1){let i=this.module;switch(e.literalKind){case 5:return assert(!r),this.compileArrayLiteral(e,n,t);case 0:{let s=e.value;return r&&(s=-s),n==l.f32?i.f32(s):(this.currentType=l.f64,i.f64(s))}case 1:{let s=e,a=this.resolver.determineIntegerLiteralType(s,r,n);this.currentType=a;let o=s.value,u=1;switch(r&&(a.isFloatValue?u=-1:o=i64_neg(o)),a.kind){case 5:if(!this.options.isWasm64)return i.i32(i64_low(o));case 4:return i.i64(i64_low(o),i64_high(o));case 10:if(!this.options.isWasm64)return i.i32(i64_low(o));case 9:return i.i64(i64_low(o),i64_high(o));case 11:return i.f32(u*i64_to_f32(o));case 12:return i.f64(u*i64_to_f64(o));default:return i.i32(i64_low(o))}}case 2:return assert(!r),this.compileStringLiteral(e,t);case 3:return assert(!r),this.compileTemplateLiteral(e,t);case 6:return assert(!r),this.compileObjectLiteral(e,n);case 4:return this.error(100,e.range,"Regular expressions"),this.currentType=n,i.unreachable()}return assert(!1),i.unreachable()}compileStringLiteral(e,n){return this.ensureStaticString(e.value)}compileTemplateLiteral(e,n){let t=e.tag,r=e.parts,i=r.length,s=e.expressions,a=s.length,o=e.exprLengths;assert(a==i-1),assert(o.length==a);let u=this.module,c=this.program.stringInstance.type;if(!t){if(i==1)return this.ensureStaticString(r[0]);let b=i64_new(0);for(let D=0;D<i;++D)b=i64_add(b,r[D].length);for(let D=0;D<a;++D)b=i64_add(b,o[D]);let T=F.createIdentifierExpression("newStringBuffer",e.range),S=new Array;S.push(F.createIntegerLiteralExpression(b,e.range));let C=F.createCallExpression(T,null,S,e.range),w=r[0],B=w.length;B&&(T=F.createIdentifierExpression("__copy"+B.toString(),e.range),S=new Array,S.push(C),S.push(F.createStringLiteralExpression(w,e.range)),C=F.createCallExpression(T,null,S,e.range));for(let D=1;D<i;++D)B=i64_low(o[D-1]),T=F.createIdentifierExpression("__copy"+B.toString(),e.range),S=new Array,S.push(C),S.push(s[D-1]),C=F.createCallExpression(T,null,S,e.range),w=r[D],B=w.length,B&&(T=F.createIdentifierExpression("__copy"+B.toString(),e.range),S=new Array,S.push(C),S.push(F.createStringLiteralExpression(w,e.range)),C=F.createCallExpression(T,null,S,e.range));return T=F.createIdentifierExpression("convertStringBuffer",e.range),S=new Array,S.push(C),S.push(F.createIntegerLiteralExpression(b,e.range)),C=F.createCallExpression(T,null,S,e.range),this.compileCallExpression(C,c)}let f=this.program.templateStringsArrayInstance,p=f,d=this.resolver.lookupExpression(t,this.currentFlow,l.auto,1);if(d)switch(d.kind){case 4:{let b=this.resolver.resolveFunction(d,null,new Map,1);if(!b)break;d=b}case 5:{let b=d.signature.parameterTypes;if(b.length){let T=b[0].getClass();T&&!T.extends(f.prototype)&&(p=assert(this.resolver.resolveClass(this.program.arrayPrototype,[c])))}break}}let m=e.rawParts;assert(m.length==i);let g=new Array(i);for(let b=0;b<i;++b)g[b]=this.ensureStaticString(r[b]);let E;if(p==f){let b=new Array(i);for(let S=0;S<i;++S)b[S]=this.ensureStaticString(m[S]);E=this.addStaticArrayHeader(c,this.addStaticBuffer(this.options.usizeType,g),p);let T=this.addStaticArrayHeader(c,this.addStaticBuffer(this.options.usizeType,b));p.writeField("raw",i64_add(T.offset,i64_new(this.program.totalOverhead)),E.buffer)}else E=this.addStaticArrayHeader(c,this.addStaticBuffer(this.options.usizeType,g),p);let y=s.slice();return y.unshift(F.createCompiledExpression(u.usize(i64_add(E.offset,i64_new(this.program.totalOverhead))),p.type,this.program.nativeRange)),this.error(100,e.range,"Tagged template literals"),this.compileCallExpressionLike(t,null,y,e.range,c)}compileArrayLiteral(e,n,t){let r=this.module,i=this.currentFlow,s=this.program,a=n.getClass();if(a&&a.extends(s.staticArrayPrototype))return this.compileStaticArrayLiteral(e,n,t);let o=this.resolver.lookupExpression(e,i,this.currentType);if(!o)return r.unreachable();assert(o.kind==7);let u=o,c=u.type,f=u.prototype!=s.byteArrayPrototype?u.getTypeArgumentsTo(s.arrayPrototype)[0]:l.u8,p=u.prototype!=s.byteArrayPrototype?assert(s.arrayBufferInstance):u,d=i.getTempLocal(this.options.usizeType),m=i.getTempLocal(p.type),g=e.elementExpressions,E=g.length,y=new Array(E),b=!f.isExternalReference;for(let D=0;D<E;++D){let W=g[D];if(W.kind!=19){let P=this.compileExpression(W,f,1);if(se(P)!=f.toRef())b=!1;else{let j=r.runExpression(P,1);j?P=j:b=!1}y[D]=P}else y[D]=this.makeZero(f)}if(b){let D=s.totalOverhead,W=this.addStaticBuffer(f,y,p.id),P=i64_add(W.offset,i64_new(D));if(u.prototype==s.byteArrayPrototype){let j=this.options.isWasm64?r.i64(i64_low(P),i64_high(P)):r.i32(i64_low(P));return this.currentType=c,j}if(t&16){let j=this.addStaticArrayHeader(f,W),ce=i64_add(j.offset,i64_new(D));return this.currentType=c,s.options.isWasm64?this.module.i64(i64_low(ce),i64_high(ce)):this.module.i32(i64_low(ce))}else return this.makeNewArray(u,E,P,e)}let T=u.lookupOverload(2,!0);if(!T)return this.error(2542,e.range,u.internalName),this.currentType=c,r.unreachable();let S=c.toRef(),C=new Array;C.push(r.local_set(d.index,this.makeNewArray(u,E,i64_new(0),e),c.isManaged));let w=0,B=u.getMember("dataStart");B&&(assert(B.kind==11),w=B.memoryOffset),C.push(r.local_set(m.index,r.load(c.byteSize,!1,r.local_get(d.index,S),S,w),!0));for(let D=0;D<E;++D)C.push(r.call(T.internalName,[r.local_get(d.index,S),r.i32(D),y[D]],A.None));return C.push(r.local_get(d.index,S)),E&&this.compileFunction(T),this.currentType=c,r.flatten(C,S)}makeNewArray(e,n,t,r){let i=this.program,s=this.module;assert(!e.extends(i.staticArrayPrototype));let a=e.prototype!=i.byteArrayPrototype?e.getArrayValueType():l.u8,o=this.makeCallDirect(i.newArrayInstance,[s.i32(n),i.options.isWasm64?s.i64(a.alignLog2):s.i32(a.alignLog2),s.i32(e.id),i.options.isWasm64?s.i64(i64_low(t),i64_high(t)):s.i32(i64_low(t))],r);return this.currentType=e.type,o}compileStaticArrayLiteral(e,n,t){let r=this.module,i=this.currentFlow,s=this.program,a=assert(n.getClass()),o=a.type,u=assert(a.getTypeArgumentsTo(s.staticArrayPrototype))[0],c=i.getTempLocal(this.options.usizeType),f=e.elementExpressions,p=f.length,d=new Array(p),m=!u.isExternalReference;for(let S=0;S<p;++S){let C=f[S];if(C.kind!=19){let w=this.compileExpression(C,u,1),B=r.runExpression(w,1);B?w=B:m=!1,d[S]=w}else d[S]=this.makeZero(u)}let g=this.options.isWasm64,E=d.length<<u.alignLog2;if(m){let S=this.addStaticBuffer(u,d,a.id),C=i64_add(S.offset,i64_new(s.totalOverhead));if(t&16){let w=this.options.isWasm64?r.i64(i64_low(C),i64_high(C)):r.i32(i64_low(C));return this.currentType=o,w}else{let w=this.makeCallDirect(s.newBufferInstance,[g?r.i64(E):r.i32(E),r.i32(a.id),g?r.i64(i64_low(C),i64_high(C)):r.i32(i64_low(C))],e);return this.currentType=o,w}}let y=a.lookupOverload(2,!0);if(!y)return this.error(2542,e.range,a.internalName),this.currentType=o,r.unreachable();let b=o.toRef(),T=new Array;T.push(r.local_set(c.index,this.makeCallDirect(s.newBufferInstance,[g?r.i64(E):r.i32(E),r.i32(a.id)],e),o.isManaged));for(let S=0;S<p;++S)T.push(r.call(y.internalName,[r.local_get(c.index,b),r.i32(S),d[S]],A.None));return T.push(r.local_get(c.index,b)),p&&this.compileFunction(y),this.currentType=o,r.flatten(T,b)}compileObjectLiteral(e,n){let t=this.module,r=n.getClass();if(!r)return this.error(2322,e.range,"<object>",n.toString()),t.unreachable();let i=r.type;if(this.currentType=i.nonNullableType,r.kind==9)return this.error(100,e.range,"Interface hidden classes"),t.unreachable();if(r.is(128))return this.error(2511,e.range),t.unreachable();let s=r.prototype.constructorPrototype;if(s)return this.errorRelated(216,e.range,s.identifierNode.range,i.toString()),t.unreachable();i.isManaged||this.checkUnsafe(e,qn(6,r.decoratorNodes));let a=e.names,o=a.length,u=e.values,c=r.members,f=!1,p=new Array,d=this.currentFlow.getTempLocal(i),m=i.toRef();assert(o==u.length);let g=new Set;if(c)for(let y=Map_keys(c),b=0,T=y.length;b<T;++b){let S=y[b],C=assert(c.get(S));C&&C.kind==11&&g.add(C)}for(let y=0;y<o;++y){let b=a[y].text,T=r.getMember(b);if(!T||T.kind!=11){this.error(2339,a[y].range,b,i.toString()),f=!0;continue}if(T.is(512)){this.error(2341,a[y].range,b,i.toString()),f=!0;continue}if(T.is(1024)){this.error(2445,a[y].range,b,i.toString()),f=!0;continue}let S=T,C=S.type,w=this.compileExpression(u[y],C,1);p.push(t.call(S.internalSetterName,[t.local_get(d.index,m),w],A.None)),this.compileFieldSetter(S),g.delete(S)}if(this.currentType=i.nonNullableType,f)return t.unreachable();for(let y=Set_values(g),b=0,T=y.length;b<T;++b){let S=y[b],C=S.type;if(!S.initializerNode){if(C.isReference&&!C.isNullableReference){this.error(2741,e.range,S.name,"<object>",i.toString()),f=!0;continue}switch(C.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:{p.push(t.call(S.internalSetterName,[t.local_get(d.index,m),this.makeZero(C)],A.None)),this.compileFieldSetter(S);continue}}this.error(2741,e.range,S.name,"<object>",i.toString()),f=!0}}if(f)return t.unreachable();let E=this.ensureConstructor(r,e);return p.unshift(t.local_set(d.index,this.compileInstantiate(E,[],0,e),i.isManaged)),p.push(t.local_get(d.index,m)),this.currentType=i.nonNullableType,t.flatten(p,m)}compileNewExpression(e,n,t){let r=this.module,i=this.currentFlow,s=this.resolver.resolveTypeName(e.typeName,i.sourceFunction);if(!s)return r.unreachable();if(s.kind!=6)return this.error(2351,e.typeName.range),this.module.unreachable();if(s.is(128))return this.error(2511,e.typeName.range),this.module.unreachable();let a=s,o=null,u=e.typeArguments,c;if(!u&&(c=n.classReference)&&c.prototype==a&&c.is(65536)?o=this.resolver.resolveClass(a,c.typeArguments,de(i.contextualTypeArguments)):o=this.resolver.resolveClassInclTypeArguments(a,u,i.sourceFunction.parent,de(i.contextualTypeArguments),e),!o)return r.unreachable();n==l.void&&(t|=8);let f=this.ensureConstructor(o,e);return f.hasDecorator(64)||this.checkFieldInitialization(o,e),this.compileInstantiate(f,e.args,t,e)}ensureConstructor(e,n){let t=e.constructorInstance;if(t){if(t.is(8388608))return t;t.hasDecorator(64)||this.compileFunction(t)}else{let r=e.base,i=de(e.contextualTypeArguments);if(r){let b=this.ensureConstructor(r,n);this.checkFieldInitialization(r,n),t=new Hn(v.constructor,new pn(v.constructor,e,b.declaration.clone()),null,b.signature,i)}else t=new Hn(v.constructor,new pn(v.constructor,e,this.program.makeNativeFunctionDeclaration(v.constructor,786432)),null,new tn(this.program,null,e.type,e.type),i);t.set(8388608),t.prototype.setResolvedInstance("",t),e.is(1048576)&&t.set(1048576),e.constructorInstance=t;let s=e.members;s||(e.members=s=new Map),s.set("constructor",t.prototype);let a=this.currentFlow,o=t.flow;this.currentFlow=o;let u=t.signature,c=this.module,f=this.options.sizeTypeRef,p=new Array;if(p.push(this.makeConditionalAllocation(e,0)),r){let b=u.parameterTypes,T=b.length,S=new Array(1+T);S[0]=c.local_get(0,f);for(let C=1;C<=T;++C)S[C]=c.local_get(C,b[C-1].toRef());p.push(c.local_set(0,this.makeCallDirect(assert(r.constructorInstance),S,n,!1),r.type.isManaged))}this.makeFieldInitializationInConstructor(e,p),p.push(c.local_get(0,f)),this.currentFlow=a;let d=t.localsByIndex,m=new Array,g=1+u.parameterTypes.length,E=d.length;if(E>g)for(let b=g;b<E;++b)m.push(d[b].type.toRef());let y=c.addFunction(t.internalName,u.paramRefs,u.resultRefs,m,c.flatten(p,f));t.finalize(c,y)}return t}checkFieldInitialization(e,n=null){if(e.didCheckFieldInitialization)return;e.didCheckFieldInitialization=!0;let t=assert(e.constructorInstance);this.checkFieldInitializationInFlow(e,t.flow,n)}checkFieldInitializationInFlow(e,n,t=null){let r=e.members;if(r)for(let i=Map_values(r),s=0,a=i.length;s<a;++s){let o=i[s];if(o.kind==11&&o.parent==e){let u=o;!u.initializerNode&&!n.isThisFieldFlag(u,1)?u.is(16384)||(t?this.errorRelated(2564,u.declaration.name.range,t.range,u.internalName):this.error(2564,u.declaration.name.range,u.internalName)):u.is(16384)&&(u.type.isReference?this.warning(233,u.identifierNode.range,u.internalName):this.pedantic(906,u.identifierNode.range))}}}compileInstantiate(e,n,t,r){assert(e.is(524288));let i=e.parent;assert(i.kind==7);let s=i;(s.type.isUnmanaged||e.hasDecorator(2048))&&this.checkUnsafe(r);let a=this.compileCallDirect(e,n,r,this.makeZero(this.options.usizeType),t);return se(a)!=A.None&&(this.currentType=s.type),a}compilePropertyAccessExpression(e,n,t){let r=this.module,i=this.currentFlow;this.maybeCompileEnclosingSource(e);let s=this.resolver,a=s.lookupExpression(e,i,n);if(!a)return r.unreachable();let o=s.currentThisExpression;switch(a.hasDecorator(2048)&&this.checkUnsafe(e),a.kind){case 0:{let u=a;if(!this.compileGlobal(u))return r.unreachable();let c=u.type;return assert(c!=l.void),this.pendingElements.has(u)?(this.error(2448,e.range,u.internalName),this.currentType=c,r.unreachable()):u.is(33554432)?this.compileInlineConstant(u,n,t):(this.currentType=c,r.global_get(u.internalName,c.toRef()))}case 3:{let u=a,c=assert(u.parent);assert(c.kind==2);let f=c;return this.compileEnum(f)?(this.currentType=l.i32,u.is(33554432)?(assert(u.constantValueKind==1),this.compileInlineConstant(u,n,t)):(assert(u.type==l.i32),r.global_get(u.internalName,A.I32))):(this.currentType=l.i32,this.module.unreachable())}case 11:{let u=a,c=u.type;assert(u.memoryOffset>=0);let f=u.parent;assert(f.kind==7),o=assert(o);let p=this.compileExpression(o,f.type,33),d=this.currentType;if(i.sourceFunction.is(524288)&&o.kind==24&&!i.isThisFieldFlag(u,1)&&!u.is(16384)&&this.errorRelated(2565,e.range,u.identifierNode.range,u.internalName),d.isNullableReference&&(i.isNonnull(p,d)||this.error(2531,o.range)),!u.is(8388608)){u.set(8388608);let g=u.typeNode;g&&this.checkTypeSupported(u.type,g)}this.currentType=c;let m=r.load(c.byteSize,c.isSignedIntegerValue,p,c.toRef(),u.memoryOffset);return u.is(16384)&&c.isReference&&!c.isNullableReference&&(m=this.makeRuntimeNonNullCheck(m,c,e)),m}case 12:{let u=a,c=this.resolver.resolveProperty(u);if(!c)return r.unreachable();a=c}case 13:{let u=a.getterInstance;if(!u)return r.unreachable();let c=0;return u.is(262144)&&(c=this.compileExpression(assert(o),assert(u.signature.thisType),33)),this.compileCallDirect(u,[],e,c)}case 4:{let u=a,c=this.resolver.resolveFunction(u,null);if(!c)return r.unreachable();if(a.internalName=="~lib/params/Params.__get"){let p=[F.createStringLiteralExpression(e.property.text,e.property.range)];return this.compileCallDirect(c,p,e)}if(!this.compileFunction(c))return r.unreachable();this.currentType=c.type;let f=this.ensureRuntimeFunction(c);return this.options.isWasm64?r.i64(i64_low(f),i64_high(f)):r.i32(i64_low(f))}}return this.error(234,e.range),this.module.unreachable()}compileTernaryExpression(e,n,t){let r=this.module,i=e.ifThen,s=e.ifElse,a=this.makeIsTrueish(this.compileExpression(e.condition,l.bool),this.currentType,e.condition),o=this.evaluateCondition(a);if(o==1)return r.maybeDropCondition(a,this.compileExpression(i,n));if(o==2)return r.maybeDropCondition(a,this.compileExpression(s,n));let u=this.currentFlow,c=u.fork();c.inheritNonnullIfTrue(a),this.currentFlow=c;let f=this.compileExpression(i,n),p=this.currentType,d=u.fork();d.inheritNonnullIfFalse(a),this.currentFlow=d;let m=this.compileExpression(s,n==l.auto?p:n),g=this.currentType;if(n==l.void)p!=l.void&&(f=r.drop(f),p=l.void),g!=l.void&&(m=r.drop(m),g=l.void),this.currentType=l.void;else{let E=l.commonDenominator(p,g,!1);if(!E)return this.error(2322,s.range,g.toString(),p.toString()),this.currentType=n,r.unreachable();f=this.convertExpression(f,p,E,!1,i),p=E,m=this.convertExpression(m,g,E,!1,s),g=E,this.currentType=E}return this.currentFlow=u,u.inheritMutual(c,d),r.if(a,f,m)}compileUnaryPostfixExpression(e,n,t){let r=this.module,i=this.currentFlow,s=this.compileExpression(e.operand,n.exceptVoid,0),a=null;n!=l.void&&(a=i.getTempLocal(this.currentType),s=r.local_tee(a.index,s,this.currentType.isManaged));let o;switch(e.operator){case 87:{let d=this.currentType.getClassOrWrapper(this.program);if(d){let m=d.lookupOverload(29);if(m){let g=m.is(262144);if(a&&!g&&(s=Jt(s),a=null),o=this.compileUnaryOverload(m,e.operand,s,e),g)break;return o}}if(!this.currentType.isValue)return this.error(2469,e.range,"++",this.currentType.toString()),r.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:{o=r.binary(0,s,r.i32(1));break}case 4:case 9:{o=r.binary(25,s,r.i64(1));break}case 5:case 10:{o=r.binary(196,s,this.makeOne(this.currentType));break}case 11:{o=r.binary(50,s,r.f32(1));break}case 12:{o=r.binary(63,s,r.f64(1));break}default:return this.error(2469,e.range,"++",this.currentType.toString()),r.unreachable()}break}case 88:{let d=this.currentType.getClassOrWrapper(this.program);if(d){let m=d.lookupOverload(30);if(m){let g=m.is(262144);if(a&&!g&&(s=Jt(s),a=null),o=this.compileUnaryOverload(m,e.operand,s,e),m.is(262144))break;return o}}if(!this.currentType.isValue)return this.error(2469,e.range,"--",this.currentType.toString()),r.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:{o=r.binary(1,s,r.i32(1));break}case 4:case 9:{o=r.binary(26,s,r.i64(1));break}case 5:case 10:{o=r.binary(197,s,this.makeOne(this.currentType));break}case 11:{o=r.binary(51,s,r.f32(1));break}case 12:{o=r.binary(64,s,r.f64(1));break}default:return this.error(2469,e.range,"--",this.currentType.toString()),r.unreachable()}break}default:return assert(!1),r.unreachable()}let u=this.resolver,c=u.lookupExpression(e.operand,i);if(!c)return r.unreachable();if(!a)return this.makeAssignment(c,o,this.currentType,e.operand,u.currentThisExpression,u.currentElementExpression,!1);let f=this.makeAssignment(c,o,this.currentType,e.operand,u.currentThisExpression,u.currentElementExpression,!1);this.currentType=a.type;let p=a.type.toRef();return r.block(null,[f,r.local_get(a.index,p)],p)}compileUnaryPrefixExpression(e,n,t){let r=this.module,i=!1,s;switch(e.operator){case 81:{s=this.compileExpression(e.operand,n.exceptVoid,0);let u=this.currentType.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(23);if(c)return this.compileUnaryOverload(c,e.operand,s,e)}if(!this.currentType.isValue)return this.error(2469,e.range,"+",this.currentType.toString()),r.unreachable();break}case 82:{let u=e.operand;if(u.isNumericLiteral){s=this.compileLiteralExpression(u,n,0,!0),this.options.sourceMap&&this.addDebugLocation(s,e.range);break}s=this.compileExpression(e.operand,n.exceptVoid,0);let c=this.currentType.getClassOrWrapper(this.program);if(c){let f=c.lookupOverload(24);if(f)return this.compileUnaryOverload(f,e.operand,s,e)}if(!this.currentType.isValue)return this.error(2469,e.range,"-",this.currentType.toString()),r.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:{s=r.binary(1,r.i32(0),s);break}case 4:case 9:{s=r.binary(26,r.i64(0),s);break}case 5:case 10:{s=r.binary(197,this.makeZero(this.currentType),s);break}case 11:{s=r.unary(6,s);break}case 12:{s=r.unary(7,s);break}default:this.error(2469,e.range,"-",this.currentType.toString()),s=r.unreachable()}break}case 87:{i=!0,s=this.compileExpression(e.operand,n.exceptVoid,0);let u=this.currentType.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(27);if(c){if(s=this.compileUnaryOverload(c,e.operand,s,e),c.is(262144))break;return s}}if(!this.currentType.isValue)return this.error(2469,e.range,"++",this.currentType.toString()),r.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:{s=r.binary(0,s,this.module.i32(1));break}case 4:case 9:{s=r.binary(25,s,r.i64(1));break}case 5:case 10:{s=r.binary(196,s,this.makeOne(this.currentType));break}case 11:{s=r.binary(50,s,r.f32(1));break}case 12:{s=r.binary(63,s,r.f64(1));break}default:this.error(2469,e.range,"++",this.currentType.toString()),s=r.unreachable()}break}case 88:{i=!0,s=this.compileExpression(e.operand,n.exceptVoid,0);let u=this.currentType.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(28);if(c){if(s=this.compileUnaryOverload(c,e.operand,s,e),c.is(262144))break;return s}}if(!this.currentType.isValue)return this.error(2469,e.range,"--",this.currentType.toString()),r.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:{s=r.binary(1,s,r.i32(1));break}case 4:case 9:{s=r.binary(26,s,r.i64(1));break}case 5:case 10:{s=r.binary(197,s,this.makeOne(this.currentType));break}case 11:{s=r.binary(51,s,r.f32(1));break}case 12:{s=r.binary(64,s,r.f64(1));break}default:this.error(2469,e.range,"--",this.currentType.toString()),s=r.unreachable()}break}case 95:{s=this.compileExpression(e.operand,n.exceptVoid,0);let u=this.currentType.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(25);if(c)return this.compileUnaryOverload(c,e.operand,s,e)}s=r.unary(20,this.makeIsTrueish(s,this.currentType,e.operand)),this.currentType=l.bool;break}case 96:{s=this.compileExpression(e.operand,n==l.void?l.i32:n.isFloatValue?l.i64:n,0);let u=this.currentType.getClassOrWrapper(this.program);if(u){let c=u.lookupOverload(26);if(c)return this.compileUnaryOverload(c,e.operand,s,e)}if(!this.currentType.isValue)return this.error(2469,e.range,"~",this.currentType.toString()),r.unreachable();switch(s=this.convertExpression(s,this.currentType,this.currentType.intType,!1,e.operand),this.currentType.kind){case 0:case 1:case 2:case 3:case 6:case 7:case 8:{s=r.binary(9,s,r.i32(-1));break}case 4:case 9:{s=r.binary(34,s,r.i64(-1,-1));break}case 5:case 10:{s=r.binary(205,s,this.makeNegOne(this.currentType));break}default:this.error(2469,e.range,"~",this.currentType.toString()),s=r.unreachable()}break}case 56:return this.compileTypeof(e,n,t);case 69:return this.error(100,e.range,"Spread operator"),r.unreachable();default:return assert(!1),r.unreachable()}if(!i)return s;let a=this.resolver,o=a.lookupExpression(e.operand,this.currentFlow);return o?this.makeAssignment(o,s,this.currentType,e.operand,a.currentThisExpression,a.currentElementExpression,n!=l.void):r.unreachable()}compileTypeof(e,n,t){let r=e.operand,i=0,s=this.program.stringInstance,a;if(r.kind==18)a="object";else{let o=this.resolver.lookupExpression(r,this.currentFlow,l.auto,1);if(o)switch(o.kind){case 6:case 14:case 2:{a="object";break}case 4:{a="function";break}default:{i=this.compileExpression(r,l.auto);let u=this.currentType;if(i=this.convertExpression(i,u,l.void,!0,r),u.isReference)if(u.getSignature())a="function";else{let c=u.getClass();c?c.prototype==s.prototype?a="string":a="object":a="externref"}else u==l.bool?a="boolean":u.isNumericValue?a="number":a="undefined";break}}else{switch(r.kind){case 6:break;case 21:case 12:if(r=(r.kind==21,r.expression),!this.resolver.resolveExpression(r,this.currentFlow,l.auto,0))return this.currentType=s.type,this.module.unreachable();default:i=this.compileExpression(r,l.auto),i=this.convertExpression(i,this.currentType,l.void,!0,r)}a="undefined"}}return this.currentType=s.type,i?this.module.block(null,[i,this.ensureStaticString(a)],this.options.sizeTypeRef):this.ensureStaticString(a)}ensureSmallIntegerWrap(e,n){let t=this.module,r=this.currentFlow;switch(n.kind){case 0:{r.canOverflow(e,n)&&(e=t.binary(16,e,t.i32(0)));break}case 1:{r.canOverflow(e,n)&&(e=this.options.hasFeature(1)?t.unary(47,e):t.binary(11,t.binary(10,e,t.i32(24)),t.i32(24)));break}case 2:{r.canOverflow(e,n)&&(e=this.options.hasFeature(1)?t.unary(48,e):t.binary(11,t.binary(10,e,t.i32(16)),t.i32(16)));break}case 6:{r.canOverflow(e,n)&&(e=t.binary(7,e,t.i32(255)));break}case 7:{r.canOverflow(e,n)&&(e=t.binary(7,e,t.i32(65535)));break}}return e}addDebugLocation(e,n){let t=this.currentFlow.targetFunction,r=n.source;r.debugInfoIndex<0&&(r.debugInfoIndex=this.module.addDebugInfoFile(r.normalizedPath)),n.debugInfoRef=e,t.debugLocations.push(n)}checkFeatureEnabled(e,n){return this.options.hasFeature(e)?!0:(this.error(103,n.range,Oi(e)),!1)}checkTypeSupported(e,n){switch(e.kind){case 13:return this.checkFeatureEnabled(16,n);case 14:case 15:return this.checkFeatureEnabled(256,n);case 16:case 17:case 18:case 19:case 20:return this.checkFeatureEnabled(256,n)&&this.checkFeatureEnabled(1024,n);case 21:case 22:case 23:case 24:return this.checkFeatureEnabled(256,n)&&this.checkFeatureEnabled(16384,n)}let t=e.getClass();if(t)do{let r=t.typeArguments;if(r){for(let i=0,s=r.length;i<s;++i)if(!this.checkTypeSupported(r[i],n))return!1}t=t.base}while(t);else{let r=e.getSignature();if(r){let i=r.thisType;if(i&&!this.checkTypeSupported(i,n))return!1;let s=r.parameterTypes;for(let o=0,u=s.length;o<u;++o)if(!this.checkTypeSupported(s[o],n))return!1;let a=r.returnType;if(!this.checkTypeSupported(a,n))return!1}}return!0}checkSignatureSupported(e,n){let t=!0,r=n.explicitThisType;r&&(this.checkTypeSupported(assert(e.thisType),r)||(t=!1));let i=e.parameterTypes,s=n.parameters;for(let a=0,o=i.length;a<o;++a){let u;s.length>a?u=s[a]:u=n,this.checkTypeSupported(i[a],u)||(t=!1)}return this.checkTypeSupported(e.returnType,n.returnType)||(t=!1),t}evaluateCondition(e){let n=se(e);if(n==A.Unreachable)return 0;assert(n==A.I32);let t=this.module.runExpression(e,0);return t?Y(t)?1:2:0}makeZero(e){let n=this.module;switch(e.kind){default:assert(!1);case 0:case 1:case 2:case 3:case 6:case 7:case 8:return n.i32(0);case 5:case 10:if(e.size!=64)return n.i32(0);case 4:case 9:return n.i64(0);case 11:return n.f32(0);case 12:return n.f64(0);case 13:return n.v128(Sp);case 14:case 15:case 16:case 17:case 19:case 20:case 21:case 22:case 23:case 24:return n.ref_null(e.toRef());case 18:return e.is(512)?n.ref_null(e.toRef()):n.i31_new(n.i32(0))}}makeOne(e){let n=this.module;switch(e.kind){default:assert(!1);case 0:case 1:case 2:case 3:case 6:case 7:case 8:return n.i32(1);case 5:case 10:if(e.size!=64)return n.i32(1);case 4:case 9:return n.i64(1);case 11:return n.f32(1);case 12:return n.f64(1);case 18:return n.i31_new(n.i32(1))}}makeNegOne(e){let n=this.module;switch(e.kind){default:assert(!1);case 1:case 2:case 3:case 6:case 7:case 8:return n.i32(-1);case 5:case 10:if(e.size!=64)return n.i32(-1);case 4:case 9:return n.i64(-1,-1);case 11:return n.f32(-1);case 12:return n.f64(-1);case 13:return n.v128(Cp);case 18:return n.i31_new(n.i32(-1))}}makeIsTrueish(e,n,t){let r=this.module;switch(n.kind){case 1:case 2:case 6:case 7:e=this.ensureSmallIntegerWrap(e,n);case 0:case 3:case 8:return e;case 4:case 9:return r.binary(41,e,r.i64(0));case 5:case 10:return n.size==64?r.binary(41,e,r.i64(0)):e;case 11:{let i=this.options;return i.shrinkLevelHint>1&&i.hasFeature(4)?r.unary(20,r.unary(20,r.unary(53,r.unary(10,r.unary(8,e))))):r.binary(20,r.binary(1,r.binary(10,r.unary(33,e),r.i32(1)),r.i32(2)),r.i32(4278190078))}case 12:{let i=this.options;return i.shrinkLevelHint>1&&i.hasFeature(4)?r.unary(20,r.unary(20,r.unary(55,r.unary(11,r.unary(9,e))))):r.binary(45,r.binary(26,r.binary(35,r.unary(34,e),r.i64(1)),r.i64(2)),r.i64(4294967294,4292870143))}case 13:return r.unary(67,e);case 14:case 15:case 16:case 17:case 18:case 19:case 21:case 22:case 23:case 24:return r.unary(20,r.ref_is_null(e));case 25:default:return this.error(1345,t.range,n.toString()),r.i32(0)}}makeToString(e,n,t){let r=this.program.stringInstance.type;if(n==r)return e;let i=n.getClassOrWrapper(this.program);if(i){let s=i.getMethod("toString");if(s){let a=s.signature;if(!this.checkCallSignature(a,0,!0,t))return this.currentType=r,this.module.unreachable();if(!n.isStrictlyAssignableTo(assert(a.thisType)))return this.errorRelated(2685,t.range,s.identifierAndSignatureRange),this.currentType=r,this.module.unreachable();let o=a.returnType;return o.isStrictlyAssignableTo(r)?this.makeCallDirect(s,[e],t):(this.errorRelated(2322,t.range,s.identifierAndSignatureRange,o.toString(),r.toString()),this.currentType=r,this.module.unreachable())}}return this.error(2322,t.range,n.toString(),r.toString()),this.currentType=r,this.module.unreachable()}makeAllocation(e){let n=this.program;assert(e.program==n);let t=this.module,r=this.options;if(this.currentType=e.type,e.hasDecorator(16)){let i=n.allocInstance;return this.compileFunction(i),t.call(i.internalName,[r.isWasm64?t.i64(e.nextMemoryOffset):t.i32(e.nextMemoryOffset)],r.sizeTypeRef)}else{let i=n.newInstance;return this.compileFunction(i),t.call(i.internalName,[r.isWasm64?t.i64(e.nextMemoryOffset):t.i32(e.nextMemoryOffset),t.i32(e.id)],r.sizeTypeRef)}}makeConditionalAllocation(e,n){let t=this.module,r=e.type.toRef();return assert(r==this.options.sizeTypeRef),t.if(t.unary(r==A.I64?21:20,t.local_get(n,r)),t.local_set(n,this.makeAllocation(e),e.type.isManaged))}makeFieldInitializationInConstructor(e,n=[]){let t=e.members;if(!t)return n;let r=this.module,i=this.currentFlow,s=i.isInline,a=s?i.lookupLocal(v.this_).index:0,o=this.options.sizeTypeRef,u=null;for(let c=Map_values(t),f=0,p=c.length;f<p;++f){let d=unchecked(c[f]);if(d.kind!=11||d.parent!=e)continue;let m=d;assert(!m.isAny(8));let g=m.prototype,E=g.parameterIndex;if(E<0){u||(u=new Array),u.push(m);continue}let y=m.type.toRef();assert(!g.initializerNode),this.compileFieldSetter(m),n.push(r.call(m.internalSetterName,[r.local_get(a,o),r.local_get(s?i.lookupLocal(m.name).index:1+E,y)],A.None))}if(u)for(let c=0,f=u.length;c<f;++c){let p=unchecked(u[c]),d=p.type,m=p.prototype,g=m.initializerNode;assert(m.parameterIndex<0),this.compileFieldSetter(p),n.push(r.call(p.internalSetterName,[r.local_get(a,o),g?this.compileExpression(g,d,1):this.makeZero(d)],A.None))}return this.currentType=l.void,n}makeAbort(e,n){let t=this.program,r=t.abortInstance;if(!r||!this.compileFunction(r))return this.module.unreachable();let i=t.stringInstance,s;return e?s=this.compileExpression(e,i.type,1):s=this.makeZero(i.type),this.makeStaticAbort(s,n)}makeStaticAbort(e,n){return this.module.unreachable()}makeRuntimeNonNullCheck(e,n,t){let r=this.module,i=this.currentFlow,s=i.getTempLocal(n).index;i.canOverflow(e,n)||i.setLocalFlag(s,2),i.setLocalFlag(s,4);let a=this.makeStaticAbort(this.ensureStaticString("unexpected null"),t);if(n.isExternalReference){let o=r.local_get(s,n.toRef());this.options.hasFeature(1024)&&(o=r.ref_as_nonnull(o)),e=r.if(r.ref_is_null(r.local_tee(s,e,!1)),a,o)}else e=r.if(r.local_tee(s,e,n.isManaged),r.local_get(s,n.toRef()),a);return this.currentType=n.nonNullableType,e}makeRuntimeDowncastCheck(e,n,t,r){assert(t.isReference&&t.nonNullableType.isAssignableTo(n));let i=this.module,s=this.currentFlow,a=s.getTempLocal(n).index,o=this.program.instanceofInstance;assert(this.compileFunction(o));let u=this.makeStaticAbort(this.ensureStaticString("unexpected downcast"),r);return!t.isNullableReference||s.isNonnull(e,n)?e=i.if(i.call(o.internalName,[i.local_tee(a,e,n.isManaged),i.i32(t.classReference.id)],A.I32),i.local_get(a,n.toRef()),u):e=i.if(i.local_tee(a,e,n.isManaged),i.if(i.call(o.internalName,[i.local_get(a,n.toRef()),i.i32(t.classReference.id)],A.I32),i.local_get(a,n.toRef()),u),i.usize(0)),this.currentType=t,e}};function Kc(e,n){ft=n.range.source.simplePath,jn=Ne(e.name,e.parent,e.is(262144),!0);let t=n.overriddenModuleName;if(t&&(ft=t),!e.hasDecorator(128))return;let r=e.program,i=assert(qn(9,n.decorators)),s=i.args;if(s&&s.length>0){let a=s[0];a.isLiteralKind(2)?(jn=a.value,s.length>=2&&(a=s[1],a.isLiteralKind(2)?(ft=jn,jn=a.value,s.length>2&&r.error(2554,i.range,"2",s.length.toString())):r.error(1141,a.range))):r.error(1141,a.range)}else r.error(2555,i.range,"1","0")}var ft,jn,ms=class extends f2{constructor(e,n,t=!1){super(e,t),this.sb=[],this.indentLevel=0,this.seenObjectTypes=new Map,this.deferredTypings=new Array,this.esm=n}static build(e,n=!0){return new ms(e,n).build()}visitGlobal(e,n){let t=this.sb,r=n.type,i=this.toTypeScriptType(r,Mt.EXPORT);k(t,this.indentLevel),t.push("/** "),t.push(n.internalName),t.push(` */
`),k(t,this.indentLevel),t.push("export "),this.esm&&t.push("declare "),t.push("const "),t.push(e),t.push(`: {
`),k(t,++this.indentLevel),t.push("/** @type `"),t.push(r.toString()),t.push("` */\n"),k(t,this.indentLevel),t.push("get value(): "),t.push(i),n.is(8)?t.push(`
`):(t.push(`;
`),k(t,this.indentLevel),t.push("set value(value: "),t.push(i),t.push(`);
`)),k(t,--this.indentLevel),t.push(`};
`)}visitEnum(e,n){let t=this.sb;k(t,this.indentLevel),t.push("/** "),t.push(n.internalName),t.push(` */
`),k(t,this.indentLevel++),t.push("export "),this.esm&&t.push("declare "),t.push("enum "),t.push(e),t.push(` {
`);let r=n.members;if(r)for(let i=Map_keys(r),s=0,a=i.length;s<a;++s){let o=unchecked(i[s]);assert(r.get(o)).kind==3&&(k(t,this.indentLevel),t.push("/** @type `i32` */\n"),k(t,this.indentLevel),t.push(o),t.push(`,
`))}k(t,--this.indentLevel),t.push(`}
`)}visitFunction(e,n){let t=this.sb,r=n.signature;k(t,this.indentLevel),t.push(`/**
`),k(t,this.indentLevel),t.push(" * "),t.push(n.internalName),t.push(`
`);let i=r.parameterTypes,s=i.length;for(let u=0;u<s;++u)k(t,this.indentLevel),t.push(" * @param "),t.push(n.getParameterName(u)),t.push(" `"),t.push(i[u].toString()),t.push("`\n");let a=r.returnType;a!=l.void&&(k(t,this.indentLevel),t.push(" * @returns `"),t.push(a.toString()),t.push("`\n")),k(t,this.indentLevel),t.push(` */
`),k(t,this.indentLevel),t.push("export "),this.esm&&t.push("declare "),t.push("function "),t.push(e),t.push("(");let o=r.requiredParameters;for(let u=0;u<s;++u)u&&t.push(", "),t.push(n.getParameterName(u)),u>=o&&t.push("?"),t.push(": "),t.push(this.toTypeScriptType(i[u],Mt.IMPORT));t.push("): "),t.push(this.toTypeScriptType(a,Mt.EXPORT)),t.push(`;
`)}visitClass(e,n){}visitInterface(e,n){}visitField(e,n){}visitNamespace(e,n){}visitAlias(e,n,t){}build(){let e=this.sb;this.esm||(e.push(`declare namespace __AdaptedExports {
`),++this.indentLevel),this.program.options.exportMemory&&(k(e,this.indentLevel),e.push(`/** Exported memory */
`),k(e,this.indentLevel),e.push(`export ${this.esm?"declare ":""}const memory: WebAssembly.Memory;
`)),this.program.options.exportTable&&(k(e,this.indentLevel),e.push(`/** Exported table */
`),k(e,this.indentLevel),e.push(`export ${this.esm?"declare ":""}const table: WebAssembly.Table;
`)),this.walk(),this.esm||(--this.indentLevel,e.push(`}
`));let n=this.deferredTypings;for(let t=0,r=n.length;t<r;++t)e.push(n[t]);if(!this.esm){e.push(`/** Instantiates the compiled WebAssembly module with the given imports. */
`),e.push(`export declare function instantiate(module: WebAssembly.Module, imports: {
`);let t=this.program.moduleImports;for(let r=Map_keys(t),i=0,s=r.length;i<s;++i){let a=r[i];e.push("  "),fn(a)?e.push(a):(e.push('"'),e.push(ke(a,34)),e.push('"')),e.push(`: unknown,
`)}e.push(`}): Promise<typeof __AdaptedExports>;
`)}return e.join("")}isPlainObject(e){if(e.base)return!1;let n=e.members;if(n)for(let t=Map_values(n),r=0,i=t.length;r<i;++r){let s=t[r];if(s.isAny(1536)||s.is(524288)&&s.declaration.range!=this.program.nativeRange)return!1}return!0}toTypeScriptType(e,n){if(e.isInternalReference){let t=new Array,r=assert(e.getClassOrWrapper(this.program));if(r.extends(this.program.arrayBufferInstance.prototype))t.push("ArrayBuffer");else if(r.extends(this.program.stringInstance.prototype))t.push("string");else if(r.extends(this.program.arrayPrototype)){let i=r.getArrayValueType();t.push("Array<"),t.push(this.toTypeScriptType(i,n)),t.push(">")}else if(r.extends(this.program.staticArrayPrototype)){let i=r.getArrayValueType();t.push("ArrayLike<"),t.push(this.toTypeScriptType(i,n)),t.push(">")}else if(r.extends(this.program.arrayBufferViewInstance.prototype)){let i=r.getArrayValueType();i==l.i8?t.push("Int8Array"):i==l.u8?r.extends(this.program.uint8ClampedArrayPrototype)?t.push("Uint8ClampedArray"):t.push("Uint8Array"):i==l.i16?t.push("Int16Array"):i==l.u16?t.push("Uint16Array"):i==l.i32?t.push("Int32Array"):i==l.u32?t.push("Uint32Array"):i==l.i64?t.push("BigInt64Array"):i==l.u64?t.push("BigUint64Array"):i==l.f32?t.push("Float32Array"):i==l.f64?t.push("Float64Array"):t.push("unknown")}else{let i=this.seenObjectTypes,s;if(i.has(r))s=assert(i.get(r)),t.push(s),this.isPlainObject(r)&&t.push(n==Mt.EXPORT?"<never>":"<undefined>");else{let a=this.isPlainObject(r);s=`${a?"__Record":"__Internref"}${r.id}`,t.push(s),i.set(r,s),a?(t.push(n==Mt.EXPORT?"<never>":"<undefined>"),this.deferredTypings.push(this.makeRecordType(r,n))):this.deferredTypings.push(this.makeInternrefType(r))}}return e.is(512)&&t.push(" | null"),t.join("")}else{if(e==l.bool)return"boolean";if(e==l.void)return"void";if(e.isNumericValue)return e.isLongIntegerValue?"bigint":"number"}return"unknown"}makeRecordType(e,n){let t=new Array,r=e.members;if(t.push("/** "),t.push(e.internalName),t.push(` */
declare interface __Record`),t.push(e.id.toString()),t.push(`<TOmittable> {
`),r)for(let i=Map_keys(r),s=0,a=i.length;s<a;++s){let o=i[s],u=assert(r.get(o));if(u.kind!=11)continue;let c=u;t.push("  /** @type `"),t.push(c.type.toString()),t.push("` */\n  "),t.push(c.name),t.push(": "),t.push(this.toTypeScriptType(c.type,n)),this.fieldAcceptsUndefined(c.type)&&t.push(" | TOmittable"),t.push(`;
`)}return t.push(`}
`),t.join("")}fieldAcceptsUndefined(e){return e.isInternalReference?e.is(512):!0}makeInternrefType(e){let n=new Array;n.push("/** "),n.push(e.internalName),n.push(` */
`),n.push("declare class __Internref"),n.push(e.id.toString()),n.push(` extends Number {
`);let t=e;do n.push("  private __nominal"),n.push(t.id.toString()),n.push(`: symbol;
`),t=t.base;while(t);return n.push(`}
`),n.join("")}},Mt=(e=>(e[e.IMPORT=0]="IMPORT",e[e.EXPORT=1]="EXPORT",e))(Mt||{});function h2(){return new Pu}function d2(e,n){e.target=n}function x2(e,n){e.runtime=n}function g2(e,n){e.noAssert=n}function m2(e,n){e.exportMemory=n}function y2(e,n){e.importMemory=n}function _2(e,n){e.initialMemory=n}function b2(e,n){e.maximumMemory=n}function v2(e,n){e.sharedMemory=n}function E2(e,n){e.importTable=n}function F2(e,n){e.exportTable=n}function A2(e,n){e.sourceMap=n}function T2(e,n){e.memoryBase=n}function S2(e,n){e.tableBase=n}function C2(e,n,t){let r=e.globalAliases;r||(e.globalAliases=r=new Map),r.set(n,t)}function w2(e,n){let t=e.globalAliases;t&&t.delete(n)}function I2(e,n){e.exportStart=n}function k2(e,n){e.noUnsafe=n}function B2(e,n){e.lowMemoryLimit=n}function z2(e,n){e.exportRuntime=n}var N2=32768;function L2(e,n){e.stackSize=n}function D2(e,n,t,r){e.bundleMajorVersion=n,e.bundleMinorVersion=t,e.bundlePatchVersion=r}var O2=1,R2=2,M2=4,U2=8,P2=16,V2=32,G2=64,q2=128,j2=256,W2=512,H2=1024,X2=2048,K2=4096,$2=8192,Y2=16384;function Z2(e,n){e.features|=n}function J2(e,n){e.features&=~n}function Q2(e,n,t){e.optimizeLevelHint=n,e.shrinkLevelHint=t}function e1(e,n){e.basenameHint=n}function n1(e,n){e.bindingsHint=n}function t1(e,n){e.pedantic=n}function r1(e,n){e.debugInfo=n}function i1(e){return new Kl(e)}function s1(e){return e.diagnosticsOffset<e.diagnostics.length?e.diagnostics[e.diagnosticsOffset++]:null}function a1(e,n){return e.getSource(n)}function o1(e){return e.code}function l1(e){return e.category}function u1(e){return e.message}function c1(e){return e.range}function f1(e){return e.relatedRange}function p1(e){return e.start}function h1(e){return e.end}function d1(e){return e.source}function x1(e){return e.normalizedPath}function g1(e){return e.category==1}function m1(e){return e.category==2}function y1(e){return e.category==3}function _1(e,n,t,r=!1){e.parser.parseFile(n,t,r)}function b1(e){return e.parser.nextFile()}function v1(e,n){return e.parser.getDependee(n)}function E1(e){e.initialize()}function F1(e){return e.parser.finish(),new gs(e).compile()}function A1(e,n){return ms.build(e,n)}function T1(e,n){return xs.build(e,n)}function S1(e){return e.ref}function C1(e){return e.validate()}function w1(e,n,t,r=!1,i=!1){e.optimize(n,t,r,i)}var qu=class{constructor(){this.sb=[],this.indentLevel=0}static build(e){let n=new qu;return n.visitNode(e),n.finish()}visitNode(e){switch(e.kind){case 0:{this.visitSource(e);break}case 1:{this.visitNamedTypeNode(e);break}case 2:{this.visitFunctionTypeNode(e);break}case 4:{this.visitTypeParameter(e);break}case 13:case 18:case 23:case 24:case 25:case 26:case 6:{this.visitIdentifierExpression(e);break}case 7:{this.visitAssertionExpression(e);break}case 8:{this.visitBinaryExpression(e);break}case 9:{this.visitCallExpression(e);break}case 10:{this.visitClassExpression(e);break}case 11:{this.visitCommaExpression(e);break}case 12:{this.visitElementAccessExpression(e);break}case 14:{this.visitFunctionExpression(e);break}case 15:{this.visitInstanceOfExpression(e);break}case 16:{this.visitLiteralExpression(e);break}case 17:{this.visitNewExpression(e);break}case 20:{this.visitParenthesizedExpression(e);break}case 21:{this.visitPropertyAccessExpression(e);break}case 22:{this.visitTernaryExpression(e);break}case 27:{this.visitUnaryPostfixExpression(e);break}case 28:{this.visitUnaryPrefixExpression(e);break}case 30:{this.visitBlockStatement(e);break}case 31:{this.visitBreakStatement(e);break}case 32:{this.visitContinueStatement(e);break}case 33:{this.visitDoStatement(e);break}case 34:{this.visitEmptyStatement(e);break}case 35:{this.visitExportStatement(e);break}case 36:{this.visitExportDefaultStatement(e);break}case 37:{this.visitExportImportStatement(e);break}case 38:{this.visitExpressionStatement(e);break}case 39:{this.visitForStatement(e);break}case 40:{this.visitForOfStatement(e);break}case 41:{this.visitIfStatement(e);break}case 42:{this.visitImportStatement(e);break}case 43:{this.visitReturnStatement(e);break}case 44:{this.visitSwitchStatement(e);break}case 45:{this.visitThrowStatement(e);break}case 46:{this.visitTryStatement(e);break}case 47:{this.visitVariableStatement(e);break}case 49:{this.visitWhileStatement(e);break}case 50:{this.visitModuleDeclaration(e);break}case 51:{this.visitClassDeclaration(e);break}case 52:{this.visitEnumDeclaration(e);break}case 53:{this.visitEnumValueDeclaration(e);break}case 54:{this.visitFieldDeclaration(e);break}case 55:{this.visitFunctionDeclaration(e);break}case 56:{this.visitImportDeclaration(e);break}case 57:{this.visitInterfaceDeclaration(e);break}case 58:{this.visitMethodDeclaration(e);break}case 59:{this.visitNamespaceDeclaration(e);break}case 60:{this.visitTypeDeclaration(e);break}case 61:{this.visitVariableDeclaration(e);break}case 62:{this.serializeDecorator(e);break}case 63:{this.visitExportMember(e);break}case 5:{this.serializeParameter(e);break}case 64:{this.visitSwitchCase(e);break}case 65:{this.visitIndexSignature(e);break}default:assert(!1)}}visitSource(e){let n=e.statements;for(let t=0,r=n.length;t<r;++t)this.visitNodeAndTerminate(n[t])}visitTypeNode(e){switch(e.kind){case 1:{this.visitNamedTypeNode(e);break}case 2:{this.visitFunctionTypeNode(e);break}default:assert(!1)}}visitTypeName(e){this.visitIdentifierExpression(e.identifier);let n=this.sb,t=e.next;for(;t;)n.push("."),this.visitIdentifierExpression(t.identifier),t=t.next}visitNamedTypeNode(e){this.visitTypeName(e.name);let n=e.typeArguments;if(n){let t=n.length,r=this.sb;if(t){r.push("<"),this.visitTypeNode(n[0]);for(let i=1;i<t;++i)r.push(", "),this.visitTypeNode(n[i]);r.push(">")}e.isNullable&&r.push(" | null")}}visitFunctionTypeNode(e){let n=e.isNullable,t=this.sb;t.push(n?"((":"(");let r=e.explicitThisType;r&&(t.push("this: "),this.visitTypeNode(r));let i=e.parameters,s=i.length;if(s){r&&t.push(", "),this.serializeParameter(i[0]);for(let o=1;o<s;++o)t.push(", "),this.serializeParameter(i[o])}let a=e.returnType;a?(t.push(") => "),this.visitTypeNode(a)):t.push(") => void"),n&&t.push(") | null")}visitTypeParameter(e){this.visitIdentifierExpression(e.name);let n=e.extendsType;n&&(this.sb.push(" extends "),this.visitTypeNode(n));let t=e.defaultType;t&&(this.sb.push("="),this.visitTypeNode(t))}visitIdentifierExpression(e){e.isQuoted?this.visitStringLiteral(e.text):this.sb.push(e.text)}visitArrayLiteralExpression(e){let n=this.sb;n.push("[");let t=e.elementExpressions,r=t.length;if(r){let i=t[0];i&&this.visitNode(i);for(let s=1;s<r;++s)i=t[s],n.push(", "),i&&this.visitNode(i)}n.push("]")}visitObjectLiteralExpression(e){let n=this.sb,t=e.names,r=e.values,i=t.length;if(assert(i==r.length),i){n.push(`{
`),k(n,++this.indentLevel),this.visitNode(t[0]),n.push(": "),this.visitNode(r[0]);for(let s=1;s<i;++s){n.push(`,
`),k(n,this.indentLevel);let a=t[s],o=r[s];a==o?this.visitNode(a):(this.visitNode(a),n.push(": "),this.visitNode(o))}n.push(`
`),k(n,--this.indentLevel),n.push("}")}else n.push("{}")}visitAssertionExpression(e){let n=this.sb;switch(e.assertionKind){case 0:{n.push("<"),this.visitTypeNode(assert(e.toType)),n.push(">"),this.visitNode(e.expression);break}case 1:{this.visitNode(e.expression),n.push(" as "),this.visitTypeNode(assert(e.toType));break}case 2:{this.visitNode(e.expression),n.push("!");break}case 3:{this.visitNode(e.expression),n.push(" as const");break}default:assert(!1)}}visitBinaryExpression(e){let n=this.sb;this.visitNode(e.left),n.push(" "),n.push(Ue(e.operator)),n.push(" "),this.visitNode(e.right)}visitCallExpression(e){this.visitNode(e.expression),this.visitArguments(e.typeArguments,e.args)}visitArguments(e,n){let t=this.sb;if(e){let i=e.length;if(i){t.push("<"),this.visitTypeNode(e[0]);for(let s=1;s<i;++s)t.push(", "),this.visitTypeNode(e[s]);t.push(">(")}}else t.push("(");let r=n.length;if(r){this.visitNode(n[0]);for(let i=1;i<r;++i)t.push(", "),this.visitNode(n[i])}t.push(")")}visitClassExpression(e){let n=e.declaration;this.visitClassDeclaration(n)}visitCommaExpression(e){let n=e.expressions,t=assert(n.length);this.visitNode(n[0]);let r=this.sb;for(let i=1;i<t;++i)r.push(","),this.visitNode(n[i])}visitElementAccessExpression(e){let n=this.sb;this.visitNode(e.expression),n.push("["),this.visitNode(e.elementExpression),n.push("]")}visitFunctionExpression(e){let n=e.declaration;n.arrowKind?assert(n.name.text.length==0):n.name.text.length?this.sb.push("function "):this.sb.push("function"),this.visitFunctionCommon(n)}visitLiteralExpression(e){switch(e.literalKind){case 0:{this.visitFloatLiteralExpression(e);break}case 1:{this.visitIntegerLiteralExpression(e);break}case 2:{this.visitStringLiteralExpression(e);break}case 3:{this.visitTemplateLiteralExpression(e);break}case 4:{this.visitRegexpLiteralExpression(e);break}case 5:{this.visitArrayLiteralExpression(e);break}case 6:{this.visitObjectLiteralExpression(e);break}default:{assert(!1);break}}}visitFloatLiteralExpression(e){this.sb.push(e.value.toString())}visitInstanceOfExpression(e){this.visitNode(e.expression),this.sb.push(" instanceof "),this.visitTypeNode(e.isType)}visitIntegerLiteralExpression(e){let n=e.range,t=n.source.text.startsWith("-",n.start);this.sb.push(i64_to_string(e.value,!t))}visitStringLiteral(e){let n=this.sb;n.push('"'),n.push(ke(e,34)),n.push('"')}visitStringLiteralExpression(e){this.visitStringLiteral(e.value)}visitTemplateLiteralExpression(e){let n=this.sb,t=e.tag,r=e.parts,i=e.expressions;t&&this.visitNode(t),n.push("`"),n.push(ke(r[0],96)),assert(r.length==i.length+1);for(let s=0,a=i.length;s<a;++s)n.push("${"),this.visitNode(i[s]),n.push("}"),n.push(ke(r[s+1],96));n.push("`")}visitRegexpLiteralExpression(e){let n=this.sb;n.push("/"),n.push(e.pattern),n.push("/"),n.push(e.patternFlags)}visitNewExpression(e){this.sb.push("new "),this.visitTypeName(e.typeName),this.visitArguments(e.typeArguments,e.args)}visitParenthesizedExpression(e){let n=this.sb;n.push("("),this.visitNode(e.expression),n.push(")")}visitPropertyAccessExpression(e){this.visitNode(e.expression),this.sb.push("."),this.visitIdentifierExpression(e.property)}visitTernaryExpression(e){let n=this.sb;this.visitNode(e.condition),n.push(" ? "),this.visitNode(e.ifThen),n.push(" : "),this.visitNode(e.ifElse)}visitUnaryExpression(e){switch(e.kind){case 27:{this.visitUnaryPostfixExpression(e);break}case 28:{this.visitUnaryPrefixExpression(e);break}default:assert(!1)}}visitUnaryPostfixExpression(e){this.visitNode(e.operand),this.sb.push(Ue(e.operator))}visitUnaryPrefixExpression(e){this.sb.push(Ue(e.operator)),this.visitNode(e.operand)}visitNodeAndTerminate(e){this.visitNode(e);let n=this.sb;if(!n.length||e.kind==47||e.kind==38)n.push(`;
`);else{let t=n[n.length-1],r=t.length-1;r>=0&&(t.charCodeAt(r)==125||t.charCodeAt(r)==59)?n.push(`
`):n.push(`;
`)}}visitBlockStatement(e){let n=this.sb,t=e.statements,r=t.length;if(r){n.push(`{
`);let i=++this.indentLevel;for(let s=0;s<r;++s)k(n,i),this.visitNodeAndTerminate(t[s]);k(n,--this.indentLevel),n.push("}")}else n.push("{}")}visitBreakStatement(e){let n=e.label;n?(this.sb.push("break "),this.visitIdentifierExpression(n)):this.sb.push("break")}visitContinueStatement(e){let n=e.label;n?(this.sb.push("continue "),this.visitIdentifierExpression(n)):this.sb.push("continue")}visitClassDeclaration(e,n=!1){let t=e.decorators;if(t)for(let f=0,p=t.length;f<p;++f)this.serializeDecorator(t[f]);let r=this.sb;n?r.push("export default "):this.serializeExternalModifiers(e),e.is(128)&&r.push("abstract "),e.name.text.length?(r.push("class "),this.visitIdentifierExpression(e.name)):r.push("class");let i=e.typeParameters;if(i!=null&&i.length>0){r.push("<"),this.visitTypeParameter(i[0]);for(let f=1,p=i.length;f<p;++f)r.push(", "),this.visitTypeParameter(i[f]);r.push(">")}let s=e.extendsType;s&&(r.push(" extends "),this.visitTypeNode(s));let a=e.implementsTypes;if(a){let f=a.length;if(f){r.push(" implements "),this.visitTypeNode(a[0]);for(let p=1;p<f;++p)r.push(", "),this.visitTypeNode(a[p])}}let o=e.indexSignature,u=e.members,c=u.length;if(o||c){r.push(` {
`);let f=++this.indentLevel;o&&(k(r,f),this.visitNodeAndTerminate(o));for(let p=0,d=u.length;p<d;++p){let m=u[p];(m.kind!=54||m.parameterIndex<0)&&(k(r,f),this.visitNodeAndTerminate(m))}k(r,--this.indentLevel),r.push("}")}else r.push(" {}")}visitDoStatement(e){let n=this.sb;n.push("do "),this.visitNode(e.body),e.body.kind==30?n.push(" while ("):(n.push(`;
`),k(n,this.indentLevel),n.push("while (")),this.visitNode(e.condition),n.push(")")}visitEmptyStatement(e){}visitEnumDeclaration(e,n=!1){let t=this.sb;n?t.push("export default "):this.serializeExternalModifiers(e),e.is(8)&&t.push("const "),t.push("enum "),this.visitIdentifierExpression(e.name);let r=e.values.length;if(r){t.push(` {
`);let i=++this.indentLevel;k(t,i),this.visitEnumValueDeclaration(e.values[0]);for(let s=1;s<r;++s)t.push(`,
`),k(t,i),this.visitEnumValueDeclaration(e.values[s]);t.push(`
`),k(t,--this.indentLevel),t.push("}")}else t.push(" {}")}visitEnumValueDeclaration(e){this.visitIdentifierExpression(e.name);let n=e.initializer;n&&(this.sb.push(" = "),this.visitNode(n))}visitExportImportStatement(e){let n=this.sb;n.push("export import "),this.visitIdentifierExpression(e.externalName),n.push(" = "),this.visitIdentifierExpression(e.name)}visitExportMember(e){this.visitIdentifierExpression(e.localName),e.exportedName.text!=e.localName.text&&(this.sb.push(" as "),this.visitIdentifierExpression(e.exportedName))}visitExportStatement(e){let n=this.sb;e.isDeclare&&n.push("declare ");let t=e.members;if(t==null)n.push("export *");else if(t.length>0){let i=t.length;n.push(`export {
`);let s=++this.indentLevel;k(n,s),this.visitExportMember(t[0]);for(let a=1;a<i;++a)n.push(`,
`),k(n,s),this.visitExportMember(t[a]);--this.indentLevel,n.push(`
}`)}else n.push("export {}");let r=e.path;r&&(n.push(" from "),this.visitStringLiteralExpression(r)),n.push(";")}visitExportDefaultStatement(e){let n=e.declaration;switch(n.kind){case 52:{this.visitEnumDeclaration(n,!0);break}case 55:{this.visitFunctionDeclaration(n,!0);break}case 51:{this.visitClassDeclaration(n,!0);break}case 57:{this.visitInterfaceDeclaration(n,!0);break}case 59:{this.visitNamespaceDeclaration(n,!0);break}default:assert(!1)}}visitExpressionStatement(e){this.visitNode(e.expression)}visitFieldDeclaration(e){let n=e.decorators;if(n)for(let s=0,a=n.length;s<a;++s)this.serializeDecorator(n[s]);this.serializeAccessModifiers(e),this.visitIdentifierExpression(e.name);let t=this.sb;e.flags&16384&&t.push("!");let r=e.type;r&&(t.push(": "),this.visitTypeNode(r));let i=e.initializer;i&&(t.push(" = "),this.visitNode(i))}visitForStatement(e){let n=this.sb;n.push("for (");let t=e.initializer;t&&this.visitNode(t);let r=e.condition;r?(n.push("; "),this.visitNode(r)):n.push(";");let i=e.incrementor;i?(n.push("; "),this.visitNode(i)):n.push(";"),n.push(") "),this.visitNode(e.body)}visitForOfStatement(e){let n=this.sb;n.push("for ("),this.visitNode(e.variable),n.push(" of "),this.visitNode(e.iterable),n.push(") "),this.visitNode(e.body)}visitFunctionDeclaration(e,n=!1){let t=this.sb,r=e.decorators;if(r)for(let i=0,s=r.length;i<s;++i)this.serializeDecorator(r[i]);n?t.push("export default "):(this.serializeExternalModifiers(e),this.serializeAccessModifiers(e)),e.name.text.length?t.push("function "):t.push("function"),this.visitFunctionCommon(e)}visitFunctionCommon(e){let n=this.sb;this.visitIdentifierExpression(e.name);let t=e.signature,r=e.typeParameters;if(r){let a=r.length;if(a){n.push("<"),this.visitTypeParameter(r[0]);for(let o=1;o<a;++o)n.push(", "),this.visitTypeParameter(r[o]);n.push(">")}}if(e.arrowKind==2){let a=t.parameters;assert(a.length==1),assert(!t.explicitThisType),this.serializeParameter(a[0])}else{n.push("(");let a=t.parameters,o=a.length,u=t.explicitThisType;if(u&&(n.push("this: "),this.visitTypeNode(u)),o){u&&n.push(", "),this.serializeParameter(a[0]);for(let c=1;c<o;++c)n.push(", "),this.serializeParameter(a[c])}}let i=e.body,s=t.returnType;e.arrowKind?i?(e.arrowKind==2?assert(Ve(s)):Ve(s)?n.push(")"):(n.push("): "),this.visitTypeNode(s)),n.push(" => "),this.visitNode(i)):(assert(!Ve(s)),n.push(" => "),this.visitTypeNode(s)):(!Ve(s)&&!e.isAny(528384)?(n.push("): "),this.visitTypeNode(s)):n.push(")"),i&&(n.push(" "),this.visitNode(i)))}visitIfStatement(e){let n=this.sb;n.push("if ("),this.visitNode(e.condition),n.push(") ");let t=e.ifTrue;this.visitNode(t),t.kind!=30&&n.push(`;
`);let r=e.ifFalse;r&&(t.kind==30?n.push(" else "):n.push("else "),this.visitNode(r))}visitImportDeclaration(e){let n=e.foreignName,t=e.name;this.visitIdentifierExpression(n),n.text!=t.text&&(this.sb.push(" as "),this.visitIdentifierExpression(t))}visitImportStatement(e){let n=this.sb;n.push("import ");let t=e.declarations,r=e.namespaceName;if(t){let i=t.length;if(i){n.push(`{
`);let s=++this.indentLevel;k(n,s),this.visitImportDeclaration(t[0]);for(let a=1;a<i;++a)n.push(`,
`),k(n,s),this.visitImportDeclaration(t[a]);--this.indentLevel,n.push(`
} from `)}else n.push("{} from ")}else r&&(n.push("* as "),this.visitIdentifierExpression(r),n.push(" from "));this.visitStringLiteralExpression(e.path)}visitIndexSignature(e){let n=this.sb;n.push("[key: "),this.visitTypeNode(e.keyType),n.push("]: "),this.visitTypeNode(e.valueType)}visitInterfaceDeclaration(e,n=!1){let t=e.decorators;if(t)for(let u=0,c=t.length;u<c;++u)this.serializeDecorator(t[u]);let r=this.sb;n?r.push("export default "):this.serializeExternalModifiers(e),r.push("interface "),this.visitIdentifierExpression(e.name);let i=e.typeParameters;if(i!=null&&i.length>0){r.push("<"),this.visitTypeParameter(i[0]);for(let u=1,c=i.length;u<c;++u)r.push(", "),this.visitTypeParameter(i[u]);r.push(">")}let s=e.extendsType;s&&(r.push(" extends "),this.visitTypeNode(s)),r.push(` {
`);let a=++this.indentLevel,o=e.members;for(let u=0,c=o.length;u<c;++u)k(r,a),this.visitNodeAndTerminate(o[u]);--this.indentLevel,r.push("}")}visitMethodDeclaration(e){let n=e.decorators;if(n)for(let t=0,r=n.length;t<r;++t)this.serializeDecorator(n[t]);this.serializeAccessModifiers(e),e.is(2048)?this.sb.push("get "):e.is(4096)&&this.sb.push("set "),this.visitFunctionCommon(e)}visitNamespaceDeclaration(e,n=!1){let t=e.decorators;if(t)for(let s=0,a=t.length;s<a;++s)this.serializeDecorator(t[s]);let r=this.sb;n?r.push("export default "):this.serializeExternalModifiers(e),r.push("namespace "),this.visitIdentifierExpression(e.name);let i=e.members;if(i.length){r.push(` {
`);let s=++this.indentLevel;for(let a=0,o=i.length;a<o;++a)k(r,s),this.visitNodeAndTerminate(i[a]);k(r,--this.indentLevel),r.push("}")}else r.push(" {}")}visitReturnStatement(e){let n=e.value;n?(this.sb.push("return "),this.visitNode(n)):this.sb.push("return")}visitSwitchCase(e){let n=this.sb,t=e.label;t?(n.push("case "),this.visitNode(t),n.push(`:
`)):n.push(`default:
`);let r=e.statements,i=r.length;if(i){let s=++this.indentLevel;k(n,s),this.visitNodeAndTerminate(r[0]);for(let a=1;a<i;++a)k(n,s),this.visitNodeAndTerminate(r[a]);--this.indentLevel}}visitSwitchStatement(e){let n=this.sb;n.push("switch ("),this.visitNode(e.condition),n.push(`) {
`);let t=++this.indentLevel,r=e.cases;for(let i=0,s=r.length;i<s;++i)k(n,t),this.visitSwitchCase(r[i]),n.push(`
`);--this.indentLevel,n.push("}")}visitThrowStatement(e){this.sb.push("throw "),this.visitNode(e.value)}visitTryStatement(e){let n=this.sb;n.push(`try {
`);let t=++this.indentLevel,r=e.bodyStatements;for(let a=0,o=r.length;a<o;++a)k(n,t),this.visitNodeAndTerminate(r[a]);let i=e.catchVariable;if(i){k(n,t-1),n.push("} catch ("),this.visitIdentifierExpression(i),n.push(`) {
`);let a=e.catchStatements;if(a)for(let o=0,u=a.length;o<u;++o)k(n,t),this.visitNodeAndTerminate(a[o])}let s=e.finallyStatements;if(s){k(n,t-1),n.push(`} finally {
`);for(let a=0,o=s.length;a<o;++a)k(n,t),this.visitNodeAndTerminate(s[a])}k(n,t-1),n.push("}")}visitTypeDeclaration(e){let n=e.decorators;if(n)for(let i=0,s=n.length;i<s;++i)this.serializeDecorator(n[i]);let t=this.sb;this.serializeExternalModifiers(e),t.push("type "),this.visitIdentifierExpression(e.name);let r=e.typeParameters;if(r){let i=r.length;if(i){t.push("<");for(let s=0;s<i;++s)this.visitTypeParameter(r[s]);t.push(">")}}t.push(" = "),this.visitTypeNode(e.type)}visitModuleDeclaration(e){let n=this.sb;e.flags&4&&n.push("declare "),n.push('module "'),n.push(ke(e.moduleName,34)),n.push('"')}visitVariableDeclaration(e){this.visitIdentifierExpression(e.name);let n=e.type,t=this.sb;e.flags&16384&&t.push("!"),n&&(t.push(": "),this.visitTypeNode(n));let r=e.initializer;r&&(t.push(" = "),this.visitNode(r))}visitVariableStatement(e){let n=e.decorators;if(n)for(let a=0,o=n.length;a<o;++a)this.serializeDecorator(n[a]);let t=this.sb,r=e.declarations,i=assert(r.length),s=r[0];this.serializeExternalModifiers(s),t.push(s.is(8)?"const ":s.is(16)?"let ":"var "),this.visitVariableDeclaration(e.declarations[0]);for(let a=1;a<i;++a)t.push(", "),this.visitVariableDeclaration(e.declarations[a])}visitWhileStatement(e){let n=this.sb;n.push("while ("),this.visitNode(e.condition);let t=e.body;t.isEmpty?n.push(")"):(n.push(") "),this.visitNode(t))}serializeDecorator(e){let n=this.sb;n.push("@"),this.visitNode(e.name);let t=e.args;if(t){n.push("(");let r=t.length;if(r){this.visitNode(t[0]);for(let i=1;i<r;++i)n.push(", "),this.visitNode(t[i])}n.push(`)
`)}else n.push(`
`);k(n,this.indentLevel)}serializeParameter(e){let n=this.sb,t=e.parameterKind,r=e.implicitFieldDeclaration;r&&this.serializeAccessModifiers(r),t==2&&n.push("..."),this.visitIdentifierExpression(e.name);let i=e.type,s=e.initializer;i&&(t==1&&!s&&n.push("?"),Ve(i)||(n.push(": "),this.visitTypeNode(i))),s&&(n.push(" = "),this.visitNode(s))}serializeExternalModifiers(e){let n=this.sb;e.is(2)?n.push("export "):e.is(1)?n.push("import "):e.is(4)&&n.push("declare ")}serializeAccessModifiers(e){let n=this.sb;e.is(4)&&n.push("declare "),e.is(256)?n.push("public "):e.is(512)?n.push("private "):e.is(1024)&&n.push("protected "),e.is(32)?n.push("static "):e.is(128)&&n.push("abstract "),e.is(64)&&n.push("readonly ")}finish(){let e=this.sb.join("");return this.sb=[],e}},$F=Yc;var M=ju,Wu=$e.argv.indexOf("--wasm");if(~Wu){let e=String($e.argv[Wu+1]);$e.argv.splice(Wu,2),M=await import(new URL(e,cr.pathToFileURL($e.cwd()+"/")))}var Hu=st.createRequire?st.createRequire(import.meta.url):{},Zu=$e.platform==="win32",Q=Zu?`\r
`:`
`,Xu=Zu?"\\":"/",te=".ts",YF=`.d${te}`,ti=new RegExp("\\"+te+"$"),ZF=new RegExp("^(?!.*\\.d\\"+te+"$).*\\"+te+"$");function I1(e){return e.replace(/-/g,"_").toUpperCase()}function JF(e){return typeof e=="string"&&e!==""}var $u=Cc,QF=Pn,an=wc,Dn=Ic,eA=kc,z1=3,N1=0;function Ju(e,n=[]){return Object.keys(e||{}).forEach(t=>{let r=e[t],i=Pn[t];i&&i.type==="b"?r&&n.push(`--${t}`):Array.isArray(r)?r.forEach(s=>{n.push(`--${t}`,String(s))}):n.push(`--${t}`,String(r))}),n}async function nA(e,n={}){typeof e=="string"&&(e={[`input${te}`]:e});let t=["--outFile","binary","--textFile","text"];Ju(n,t);let r={},i=await L1(t.concat(Object.keys(e)),{readFile:s=>Object.prototype.hasOwnProperty.call(e,s)?e[s]:null,writeFile:(s,a)=>{r[s]=a},listFiles:()=>[]});return Object.assign(i,r)}async function L1(e,n){Array.isArray(e)||(e=Ju(e)),n||(n={});let t=n.stats||new _s,r=t.begin(),i=0,s=0,a=0,o=($u||"").split(".");o.length===3&&(s=parseInt(o[0])|0,i=parseInt(o[1])|0,a=parseInt(o[2])|0);let u=n.stdout||Yu(),c=n.stderr||Yu(),f=n.readFile||rc,p=n.writeFile||ic,d=n.listFiles||sc,m=Tc(e,Pn,!1),g=m.options;e=m.arguments;let E=new at(u),y=new at(c);g.noColors&&(E.enabled=!1,y.enabled=!1);let b=m.unknown;b.length&&b.forEach(I=>{c.write(`${y.yellow("WARNING ")}Unknown option '${I}'${Q}`)});let T=m.trailing;T.length&&c.write(`${y.yellow("WARNING ")}Unsupported trailing arguments: ${T.join(" ")}${Q}`);let S=null,C=null,w=(I,N={})=>(I&&c.write(`${y.red("FAILURE ")}${I.stack.replace(/^ERROR: /i,"")}${Q}`),C&&C.dispose(),t.total||(t.total=t.end(r)),Object.assign({error:I,stdout:u,stderr:c,stats:t},N));if(g.version)return u.write(`Version ${$u}${Q}`),w(null);let B=J.normalize(g.baseDir||"."),D=ot(g.config||"asconfig.json",B),W=J.basename(D),P=J.dirname(D),j=await k1(W,P,f),ce=j!=null&&Array.isArray(j.entries)&&j.entries.length;if(g.help||!e.length&&!ce){let I=g.help?u:c,N=g.help?E:y;return I.write([N.white("SYNTAX"),"  "+N.cyan("asc")+" [entryFile ...] [options]","",N.white("EXAMPLES"),"  "+N.cyan("asc")+" hello"+te,"  "+N.cyan("asc")+" hello"+te+" -o hello.wasm -t hello.wat","  "+N.cyan("asc")+" hello1"+te+" hello2"+te+" -o -O > hello.wasm","  "+N.cyan("asc")+" --config asconfig.json --target release","",N.white("OPTIONS")].concat(Sc(Pn,24,Q)).join(Q)+Q),w(null)}if(!(bn.promises&&bn.promises.readFile)){if(f===rc)throw Error("'options.readFile' must be specified");if(p===ic)throw Error("'options.writeFile' must be specified");if(d===sc)throw Error("'options.listFiles' must be specified")}let le=new Set;le.add(D);let Ge=g.target||"release";for(;j;){if(j.targets){let N=j.targets[Ge];N&&(g=Is(Pn,g,N,P))}let I=j.options;if(I&&(g=Is(Pn,g,I,P)),j.entries)for(let N of j.entries)e.push(ot(N,P));if(j.extends){if(D=ot(j.extends,P,!0),W=J.basename(D),P=J.dirname(D),le.has(D))break;le.add(D),j=await k1(W,P,f)}else break}if(ks(Pn,g),g.showConfig)return c.write(JSON.stringify({options:g,entries:e},null,2)),w(null);function xe(I){return[...new Set(I)]}let ee,on,Z=M.newOptions();switch(g.runtime){case"stub":on=0;break;case"minimal":on=1;break;default:on=2;break}if(M.setTarget(Z,0),M.setDebugInfo(Z,!!g.debug),M.setRuntime(Z,on),M.setNoAssert(Z,g.noAssert),M.setExportMemory(Z,!g.noExportMemory),M.setImportMemory(Z,g.importMemory),M.setInitialMemory(Z,g.initialMemory>>>0),M.setMaximumMemory(Z,g.maximumMemory>>>0),M.setSharedMemory(Z,g.sharedMemory),M.setImportTable(Z,g.importTable),M.setExportTable(Z,g.exportTable),g.exportStart!=null&&M.setExportStart(Z,JF(g.exportStart)?g.exportStart:"_start"),M.setMemoryBase(Z,g.memoryBase>>>0),M.setTableBase(Z,g.tableBase>>>0),M.setSourceMap(Z,g.sourceMap!=null),M.setNoUnsafe(Z,g.noUnsafe),M.setPedantic(Z,g.pedantic),M.setLowMemoryLimit(Z,g.lowMemoryLimit>>>0),M.setExportRuntime(Z,g.exportRuntime),M.setBundleVersion(Z,s,i,a),!g.stackSize&&on===2&&(g.stackSize=M.DEFAULT_STACK_SIZE),M.setStackSize(Z,g.stackSize),M.setBindingsHint(Z,g.bindings&&g.bindings.length>0),g.use){let I=g.use;for(let N=0,L=I.length;N<L;++N){let O=I[N],ne=O.indexOf("=");if(ne<0)return w(Error(`Global alias '${O}' is invalid.`));let $=O.substring(0,ne).trim(),ie=O.substring(ne+1).trim();if(!$.length)return w(Error(`Global alias '${O}' is invalid.`));M.addGlobalAlias(Z,$,ie)}}let Le;if((Le=g.disable)!=null){typeof Le=="string"&&(Le=Le.split(","));for(let I=0,N=Le.length;I<N;++I){let L=Le[I].trim(),O=M[`FEATURE_${I1(L)}`];if(!O)return w(Error(`Feature '${L}' is unknown.`));M.disableFeature(Z,O)}}if((Le=g.enable)!=null){typeof Le=="string"&&(Le=Le.split(","));for(let I=0,N=Le.length;I<N;++I){let L=Le[I].trim(),O=M[`FEATURE_${I1(L)}`];if(!O)return w(Error(`Feature '${L}' is unknown.`));M.enableFeature(Z,O)}}let Je=0,_n=0;g.optimize&&(Je=z1,_n=N1),typeof g.optimizeLevel=="number"&&(Je=g.optimizeLevel),typeof g.shrinkLevel=="number"&&(_n=g.shrinkLevel),Je=Math.min(Math.max(Je,0),3),_n=Math.min(Math.max(_n,0),2),M.setOptimizeLevelHints(Z,Je,_n),ee=M.newProgram(Z);let Qe=[];if(Array.isArray(n.transforms)&&Qe.push(...n.transforms),g.transform){let I=xe(g.transform);for(let N=0,L=I.length;N<L;++N){let O=I[N].trim(),ne,$;if(Hu.resolve)try{ne=Hu.resolve(O,{paths:[$e.cwd(),B]}),$=await import(cr.pathToFileURL(ne)),$.default&&($=$.default)}catch(ie){try{$=Hu(ne)}catch{return w(ie)}}else try{$=await import(new URL(O,import.meta.url)),$.default&&($=$.default)}catch(ie){return w(ie)}if(!$||typeof $!="function"&&typeof $!="object")return w(Error("not a transform: "+I[N]));Qe.push($)}}try{Qe=Qe.map(I=>(typeof I=="function"&&(Object.assign(I.prototype,{program:ee,baseDir:B,stdout:u,stderr:c,log:console.error,readFile:f,writeFile:p,listFiles:d}),I=new I),I))}catch(I){return w(I)}async function sr(I,...N){for(let L=0,O=Qe.length;L<O;++L){let ne=Qe[L];if(typeof ne[I]=="function")try{let $=t.begin();t.transformCount++,await ne[I](...N),t.transformTime+=t.end($)}catch($){return $}}}Object.keys(Dn).forEach(I=>{if(I.includes("/"))return;let N=t.begin();t.parseCount++,M.parse(ee,Dn[I],an+I+te,!1),t.parseTime+=t.end(N)});let qe=[];if(g.lib){let I=g.lib;typeof I=="string"&&(I=I.split(",")),qe.push(...I.map(N=>N.trim())),qe=xe(qe);for(let N=0,L=qe.length;N<L;++N){let O=qe[N],ne;O.endsWith(te)?(ne=[J.basename(O)],O=J.dirname(O)):ne=await d(O,B)||[];for(let $ of ne){let ie=await f($,O);if(ie==null)return w(Error(`Library file '${$}' not found.`));Dn[$.replace(ti,"")]=ie;let Ce=t.begin();t.parseCount++,M.parse(ee,ie,an+$,!1),t.parseTime+=t.end(Ce)}}}g.path=g.path||[];let On=new Map;async function D1(I,N){let L=null,O=null;if(!I.startsWith(an))(L=await f(O=I+te,B))==null&&(L=await f(O=I+"/index"+te,B))==null&&(O=I+te,L=await f(I+YF,B));else{let ne=I.substring(an.length),$=`${ne}/index`;if(Object.prototype.hasOwnProperty.call(Dn,ne))L=Dn[ne],O=an+ne+te;else if(Object.prototype.hasOwnProperty.call(Dn,$))L=Dn[$],O=an+$+te;else{for(let ie of qe)if((L=await f(ne+te,ie))!=null){O=an+ne+te;break}else if((L=await f($+te,ie))!=null){O=an+$+te;break}if(L==null){let ie=I.match(/^~lib\/((?:@[^/]+\/)?[^/]+)(?:\/(.+))?/);if(ie){let Ce=ie[1],Rn=ie[2]||"index",si=On.has(N)?On.get(N):".",Ke=[],we=J.resolve(B,si).split(Xu);for(let he=we.length,De=Zu?1:0;he>=De;--he)we[he-1]!=="node_modules"&&Ke.push(`${we.slice(0,he).join(Xu)}${Xu}node_modules`);Ke.push(...g.path);for(let he of Ke.map(De=>J.relative(B,De))){let De=Rn;if((L=await f(J.join(he,Ce,De+te),B))!=null){O=`${an}${Ce}/${De}${te}`,On.set(O.replace(ti,""),J.join(he,Ce));break}let or=`${Rn}/index`;if((L=await f(J.join(he,Ce,or+te),B))!=null){O=`${an}${Ce}/${or}${te}`,On.set(O.replace(ti,""),J.join(he,Ce));break}}}}}}return L==null?null:{sourceText:L,sourcePath:O}}function O1(I=[]){do{let N=M.nextFile(ee);if(N==null)break;I.push(N)}while(!0);return I}async function ec(){let I;for(;(I=O1()).length;){let L=[];for(let O of I){let ne=M.getDependee(ee,O);L.push(D1(O,ne))}L=await Promise.all(L);for(let O=0,ne=I.length;O<ne;++O){let $=I[O],ie=L[O],Ce=t.begin();t.parseCount++,ie?M.parse(ee,ie.sourceText,ie.sourcePath,!1):M.parse(ee,null,$+te,!1),t.parseTime+=t.end(Ce)}}let N=ys(ee,c,g.disableWarning,n.reportDiagnostic,y.enabled);if(N){let L=Error(`${N} parse error(s)`);return L.stack=L.message,w(L)}}{let I=String(g.runtime),N=`rt/index-${I}`,L=Dn[N];if(L==null){if(N=I,L=await f(N+te,B),L==null)return w(Error(`Runtime '${J.resolve(B,N+te)}' is not found.`))}else N=`~lib/${N}`;let O=t.begin();t.parseCount++,M.parse(ee,L,N+te,!0),t.parseTime+=t.end(O)}for(let I=0,N=e.length;I<N;++I){let L=String(e[I]),O=J.isAbsolute(L)?J.relative(B,L):J.normalize(L);O=O.replace(/\\/g,"/").replace(ti,"").replace(/\/$/,"");let ne=await f(O+te,B);if(ne==null){let ie=`${O}/index${te}`;ne=await f(ie,B),ne!=null?O=ie:O+=te}else O+=te;let $=t.begin();t.parseCount++,M.parse(ee,ne,O,!0),t.parseTime+=t.end($)}{let I=await ec();if(I)return I}{let I=await sr("afterParse",ee.parser);if(I)return w(I)}{let I=await ec();if(I)return I}{let I=t.begin();t.initializeCount++;try{M.initializeProgram(ee)}catch(N){je("initialize",N)}t.initializeTime+=t.end(I)}{let I=await sr("afterInitialize",ee);if(I)return w(I)}{let I=t.begin();t.compileCount++;try{S=M.compile(ee)}catch(N){je("compile",N)}t.compileTime+=t.end(I)}C=Bs.wrapModule(typeof S=="number"||S instanceof Number?M.getBinaryenModuleRef(S):S.ref);let ar=ys(ee,c,g.disableWarning,n.reportDiagnostic,y.enabled);if(ar){let I=Error(`${ar} compile error(s)`);return I.stack=I.message,w(I)}{let I=await sr("afterCompile",C);if(I)return w(I)}if(ar=ys(ee,c,g.disableWarning,n.reportDiagnostic,y.enabled),ar){let I=Error(`${ar} afterCompile error(s)`);return I.stack=I.message,w(I)}if(!g.noValidate){let I=t.begin();t.validateCount++;let N=M.validate(S);if(t.validateTime+=t.end(I),!N)return w(Error("validate error"))}if(g.trapMode==="clamp"||g.trapMode==="js"){let I=t.begin();try{C.runPasses([`trap-mode-${g.trapMode}`])}catch(N){je("runPasses",N)}t.compileTime+=t.end(I)}else if(g.trapMode!=="allow")return w(Error("Unsupported trap mode"));let nc=g.debug,R1=g.converge,tc=g.importMemory?g.zeroFilledMemory:!1,ri=[];g.runPasses&&(typeof g.runPasses=="string"&&(g.runPasses=g.runPasses.split(",")),g.runPasses.length&&g.runPasses.forEach(I=>{ri.includes(I=I.trim())||ri.push(I)}));{let I=t.begin();try{t.optimizeCount++,M.optimize(S,Je,_n,nc,tc)}catch(N){je("optimize",N)}try{C.runPasses(ri)}catch(N){je("runPasses",N)}if(R1){let N;try{let L=t.begin();t.emitCount++,N=C.emitBinary(),t.emitTime+=t.end(L)}catch(L){je("emitBinary (converge)",L)}do{try{t.optimizeCount++,M.optimize(S,Je,_n,nc,tc)}catch(O){je("optimize (converge)",O)}try{C.runPasses(ri)}catch(O){je("runPasses (converge)",O)}let L;try{let O=t.begin();t.emitCount++,L=C.emitBinary(),t.emitTime+=t.end(O)}catch(O){je("emitBinary (converge)",O)}if(L.length>=N.length){L.length>N.length&&c.write(`Last converge was suboptimal.${Q}`);break}N=L}while(!0)}t.optimizeTime+=t.end(I)}let Dt=[];if(!g.noEmit){if(g.binaryFile)return w(Error("Usage of the --binaryFile compiler option is no longer supported. Use --outFile instead."));let I=g.bindings||[],N=!1,L=g.outFile!=null,O=g.textFile!=null,ne=L||O,$=L&&g.outFile.length>0||O&&g.textFile.length>0,ie=$?(g.outFile||g.textFile).replace(/\.\w+$/,""):null,Ce=$?J.basename(ie):"output";if(M.setBasenameHint(Z,Ce),g.outFile!=null){let Ke=g.sourceMap!=null?g.sourceMap.length?g.sourceMap:`./${Ce}.wasm.map`:null,we=t.begin();t.emitCount++;let he;try{he=C.emitBinary(Ke)}catch(De){je("emitBinary",De)}if(t.emitTime+=t.end(we),g.outFile.length?Dt.push(p(g.outFile,he.binary,B)):(N=!0,ii(he.binary)),he.sourceMap!="")if(g.outFile.length){let De=JSON.parse(he.sourceMap);De.sourceRoot=`./${Ce}`;let or=[];for(let ai=0,M1=De.sources.length;ai<M1;++ai){let ac=De.sources[ai],oc=M.getSource(ee,ac.replace(ti,""));if(oc==null)return w(Error(`Source of file '${ac}' not found.`));or[ai]=oc}De.sourcesContent=or,Dt.push(p(J.join(J.dirname(g.outFile),J.basename(Ke)).replace(/^\.\//,""),JSON.stringify(De),B))}else c.write(`Skipped source map (no output path)${Q}`)}if(g.textFile!=null||!ne){let Ke=t.begin();t.emitCount++;let we;try{we=g.textFile?.endsWith(".wast")?C.emitText():C.emitStackIR(!0)}catch(he){je("emitText",he)}t.emitTime+=t.end(Ke),g.textFile!=null&&g.textFile.length?Dt.push(p(g.textFile,we,B)):N||(N=!0,ii(we))}let Rn=I.includes("esm"),si=!Rn&&I.includes("raw");if(Rn||si)if(ie){let Ke=t.begin();t.emitCount++;let we;try{we=M.buildTSD(ee,Rn)}catch(he){je("buildTSD",he)}t.emitTime+=t.end(Ke),Dt.push(p(ie+".d.ts",we,B))}else c.write(`Skipped TypeScript binding (no output path)${Q}`);if(Rn||si)if(ie){let Ke=t.begin();t.emitCount++;let we;try{we=M.buildJS(ee,Rn)}catch(he){je("buildJS",he)}t.emitTime+=t.end(Ke),Dt.push(p(ie+".js",we,B))}else c.write(`Skipped JavaScript binding (no output path)${Q}`)}try{await Promise.all(Dt)}catch(I){return w(I)}return t.total=t.end(r),g.stats&&c.write(t.toString()),w(null);async function rc(I,N){let L=J.resolve(N,I);try{return t.readCount++,await bn.promises.readFile(L,"utf8")}catch{return null}}async function ic(I,N,L){try{t.writeCount++;let O=J.resolve(L,J.dirname(I)),ne=J.join(O,J.basename(I));return await bn.promises.mkdir(O,{recursive:!0}),await bn.promises.writeFile(ne,N),!0}catch{return!1}}async function sc(I,N){try{return t.readCount++,(await bn.promises.readdir(J.join(N,I))).filter(L=>ZF.test(L))}catch{return null}}function ii(I){ii.used||(ii.used=!0,t.writeCount++),u.write(I)}function je(I,N){let L=E.red("\u258C ");console.error([Q,L,"Whoops, the AssemblyScript compiler has crashed during ",I," :-(",Q,L,Q,(typeof N.stack=="string"?[L,"Here is the stack trace hinting at the problem, perhaps it's useful?",Q,L,Q,N.stack.replace(/^/mg,L),Q]:[L,"There is no stack trace. Perhaps a Binaryen exception above / in console?",Q,L,Q,L,"> "+N.stack,Q]).join(""),L,Q,L,"If you see where the error is, feel free to send us a pull request. If not,",Q,L,"please let us know: https://github.com/AssemblyScript/assemblyscript/issues",Q,L,Q,L,"Thank you!",Q].join("")),$e.exit(1)}}function Ku(e){return Object.prototype.toString.call(e)==="[object Object]"}async function k1(e,n,t){let r=await t(e,n),i=J.join(n,e);if(!r)return null;let s;try{s=JSON.parse(r)}catch{throw new Error(`Asconfig is not valid json: ${i}`)}if(s.options&&!Ku(s.options))throw new Error(`Asconfig.options is not an object: ${i}`);if(s.include&&!Array.isArray(s.include))throw new Error(`Asconfig.include is not an array: ${i}`);if(s.targets){if(!Ku(s.targets))throw new Error(`Asconfig.targets is not an object: ${i}`);let a=Object.keys(s.targets);for(let o=0;o<a.length;o++){let u=a[o];if(!Ku(s.targets[u]))throw new Error(`Asconfig.targets.${u} is not an object: ${i}`)}}if(s.extends&&typeof s.extends!="string")throw new Error(`Asconfig.extends is not a string: ${i}`);return s}function ys(e,n,t,r,i){typeof i>"u"&&n&&(i=n.isTTY);let s=0;do{let u=M.nextDiagnostic(e);if(!u)break;if(n){let c=f=>{if(t==null)return!1;if(!t.length)return!0;let p=M.getDiagnosticCode(f);return t.includes(p)};(M.isError(u)||!c(u))&&n.write(M.formatDiagnostic(u,i,!0)+Q+Q)}if(r){let c=function(p){return p&&{start:M.getRangeStart(p),end:M.getRangeEnd(p),source:f(M.getRangeSource(p))}||null},f=function(p){return p&&{normalizedPath:M.getSourceNormalizedPath(p)}||null};var a=c,o=f;r({message:M.getDiagnosticMessage(u),code:M.getDiagnosticCode(u),category:M.getDiagnosticCategory(u),range:c(M.getDiagnosticRange(u)),relatedRange:c(M.getDiagnosticRelatedRange(u))})}M.isError(u)&&++s}while(!0);return s}var _s=class{readCount=0;writeCount=0;parseTime=0;parseCount=0;initializeTime=0;initializeCount=0;compileTime=0;compileCount=0;emitTime=0;emitCount=0;validateTime=0;validateCount=0;optimizeTime=0;optimizeCount=0;transformTime=0;transformCount=0;begin(){return $e.hrtime()}end(n){let t=$e.hrtime(n);return t[0]*1e9+t[1]}toString(){let n=m=>m?`${(m/1e6).toFixed(3)} ms`:"n/a",t=Object.keys(this).filter(m=>m.endsWith("Time")).map(m=>m.substring(0,m.length-4)),r=t.map(m=>n(this[`${m}Time`])),i=t.map(m=>this[`${m}Count`].toString()),s=t.reduce((m,g)=>Math.max(g.length,m),0),a=r.reduce((m,g)=>Math.max(g.length,m),0),o=i.reduce((m,g)=>Math.max(g.length,m),0),u=s+a+o+6,c=[];c.push(`\u256D\u2500${"\u2500".repeat(u)}\u2500\u256E${Q}`);let f="Stats";c.push(`\u2502 ${f}${" ".repeat(u-f.length)} \u2502${Q}`),c.push(`\u255E\u2550${"\u2550".repeat(s)}\u2550\u2564\u2550${"\u2550".repeat(a)}\u2550\u2564\u2550${"\u2550".repeat(o)}\u2550\u2561${Q}`);for(let m=0,g=t.length;m<g;++m)c.push(`\u2502 ${t[m].padEnd(s)} \u2502 ${r[m].padStart(a)} \u2502 ${i[m].padStart(o)} \u2502${Q}`);c.push(`\u251C\u2500${"\u2500".repeat(s)}\u2500\u2534\u2500${"\u2500".repeat(a)}\u2500\u2534\u2500${"\u2500".repeat(o)}\u2500\u2524${Q}`);let p=`Took ${n(this.total)}`;c.push(`\u2502 ${p}${" ".repeat(u-p.length)} \u2502${Q}`);let d=`${this.readCount} reads, ${this.writeCount} writes`;return c.push(`\u2502 ${d}${" ".repeat(u-d.length)} \u2502${Q}`),c.push(`\u2570\u2500${"\u2500".repeat(u)}\u2500\u256F${Q}`),c.join("")}},B1=typeof global<"u"&&global.Buffer?global.Buffer.allocUnsafe||(e=>new global.Buffer(e)):e=>new Uint8Array(e);function Yu(e){let n=[];return n.write=function(t){if(e&&e(t),typeof t=="string"){let r=B1(ci.length(t));ci.write(t,r,0),t=r}this.push(t)},n.reset=function(){n.length=0},n.toBuffer=function(){let t=0,r=0,i=this.length;for(;r<i;)t+=this[r++].length;let s=B1(t);for(t=r=0;r<i;)s.set(this[r],t),t+=this[r].length,++r;return s},n.toString=function(){let t=this.toBuffer();return ci.read(t,0,t.length)},n}var tA={alwaysStrict:!0,strictNullChecks:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,noPropertyAccessFromIndexSignature:!0,experimentalDecorators:!0,target:"esnext",noLib:!0,types:[],allowJs:!1};export{_s as Stats,ys as checkDiagnostics,nA as compileString,Ju as configToArguments,Yu as createMemoryStream,Qu as default,z1 as defaultOptimizeLevel,N1 as defaultShrinkLevel,eA as definitionFiles,Dn as libraryFiles,an as libraryPrefix,L1 as main,QF as options,tA as tscOptions,$u as version};
//# sourceMappingURL=asc.js.map
